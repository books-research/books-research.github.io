<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Recursion - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<h3 id="definition-and-concepts"><a class="header" href="#definition-and-concepts">Definition and Concepts</a></h3>
<p>Recursion is a programming technique where a function solves a problem by calling itself with a smaller or simpler instance of the same problem. Each recursive call processes a subset of the input until a base case is reached, which provides a direct solution without further recursion. You can visualize recursion as a stack of nested function calls, where each call handles a smaller piece of the problem, and the stack unwinds as base cases are resolved. Recursion is a powerful approach for problems with a naturally hierarchical or repetitive structure, such as tree traversals or mathematical computations. In Java, recursion relies on the call stack to manage function calls and their local variables.</p>
<h3 id="why-use-it"><a class="header" href="#why-use-it">Why Use It?</a></h3>
<p>Recursion is used to simplify the solution to complex problems by breaking them into smaller, identical subproblems. It provides elegant and concise code for tasks like tree traversals, divide-and-conquer algorithms, and combinatorial problems. Recursion is particularly effective when a problem’s solution can be expressed in terms of itself, reducing the need for complex iterative loops. However, it requires careful design to avoid excessive memory usage or stack overflow errors.</p>
<h3 id="where-to-use-real-life-examples"><a class="header" href="#where-to-use-real-life-examples">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>File System Traversal</strong>: Operating systems use recursion to traverse directory structures, processing subdirectories and files hierarchically.</li>
<li><strong>Mathematical Computations</strong>: Recursion is used to compute factorials, Fibonacci numbers, or power functions in mathematical software.</li>
<li><strong>Tree and Graph Algorithms</strong>: Algorithms like depth-first search (DFS) or binary tree traversals (e.g., inorder, preorder) use recursion to explore nodes.</li>
<li><strong>Parsing Expressions</strong>: Compilers use recursion to parse nested expressions, such as evaluating <code>(2 + (3 * 4))</code>, by breaking them into sub-expressions.</li>
</ul>
<h3 id="svg-diagram"><a class="header" href="#svg-diagram">SVG Diagram</a></h3>
<p>The diagram for recursion would depict a stack of function calls for computing the factorial of 4 (e.g., <code>factorial(4)</code>). Each call would be a rectangular box labeled <code>factorial(n)</code>, with n decreasing from 4 to 0. Arrows would show the recursive calls downward (e.g., <code>factorial(4) -&gt; factorial(3) -&gt; factorial(2) -&gt; factorial(1) -&gt; factorial(0)</code>) and the return values upward (e.g., 1, 1, 2, 6, 24). The base case (<code>factorial(0) = 1</code>) would be highlighted. A caption would note: "Recursion breaks a problem into smaller subproblems, with each call stored on the call stack until the base case is reached."</p>
<h3 id="explain-operations"><a class="header" href="#explain-operations">Explain Operations</a></h3>
<ul>
<li><strong>Recursive Call</strong>: This operation involves a function calling itself with modified parameters to solve a smaller subproblem. The time complexity depends on the number of recursive calls and the work done per call.</li>
<li><strong>Base Case Check</strong>: This operation checks if the current input meets the base case condition, returning a direct result to terminate recursion. It has a time complexity of O(1).</li>
<li><strong>Parameter Modification</strong>: This operation adjusts the input parameters for the next recursive call to reduce the problem size. It typically has a time complexity of O(1).</li>
<li><strong>Stack Management</strong>: The Java call stack automatically manages recursive calls by storing each call’s state (parameters and local variables). The space complexity depends on the recursion depth.</li>
</ul>
<h3 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h3>
<p>The following Java code implements two common recursive algorithms: factorial and Fibonacci.</p>
<pre><code class="language-java">public class RecursionExamples {
    // Factorial: Computes n! recursively
    public int factorial(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        if (n == 0 || n == 1) { // Base case: 0! = 1, 1! = 1
            return 1;
        }
        return n * factorial(n - 1); // Recursive case: n! = n * (n-1)!
    }

    // Fibonacci: Computes the nth Fibonacci number recursively
    public int fibonacci(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Fibonacci is not defined for negative numbers.");
        }
        if (n == 0) { // Base case: F(0) = 0
            return 0;
        }
        if (n == 1) { // Base case: F(1) = 1
            return 1;
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case: F(n) = F(n-1) + F(n-2)
    }
}
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Factorial Implementation</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>If <code>n</code> is 0 or 1 (base case), it returns 1.</li>
<li>Otherwise, it recursively calls <code>factorial(n-1)</code> and multiplies the result by <code>n</code>.</li>
<li>For example, <code>factorial(4)</code> computes <code>4 * factorial(3)</code>, which computes <code>3 * factorial(2)</code>, and so on, until <code>factorial(0)</code> returns 1.</li>
</ul>
</li>
<li><strong>Fibonacci Implementation</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>If <code>n</code> is 0 (base case), it returns 0; if <code>n</code> is 1 (base case), it returns 1.</li>
<li>Otherwise, it recursively calls <code>fibonacci(n-1)</code> and <code>fibonacci(n-2)</code> and returns their sum.</li>
<li>For example, <code>fibonacci(5)</code> computes <code>fibonacci(4) + fibonacci(3)</code>, which further breaks down until base cases are reached.</li>
</ul>
</li>
<li><strong>Stack Management</strong>: Each recursive call is pushed onto the Java call stack with its parameters and local variables. When a base case is reached, the stack unwinds, combining results to produce the final answer.</li>
</ol>
<h3 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Factorial</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Fibonacci</td><td>O(2^n)</td><td>O(n)</td></tr>
<tr><td>Base Case Check</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Recursive Call</td><td>Varies</td><td>O(1) per call</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>Factorial has O(n) time complexity due to n recursive calls, each performing O(1) work.</li>
<li>Fibonacci has O(2^n) time complexity due to the exponential growth of recursive calls (two per level).</li>
<li>Space complexity for both is O(n) due to the maximum depth of the call stack.</li>
</ul>
<h3 id="key-differences--notes"><a class="header" href="#key-differences--notes">Key Differences / Notes</a></h3>
<ul>
<li><strong>Recursion vs. Iteration</strong>:
<ul>
<li>The implementation above uses recursion for simplicity and clarity. Iterative solutions (e.g., loops) can solve the same problems with O(1) space complexity but may be less intuitive for hierarchical problems.</li>
</ul>
</li>
<li><strong>Tail Recursion</strong>: Java does not optimize tail recursion, so recursive calls consume stack space. Tail-recursive algorithms (where the recursive call is the last operation) can be optimized in other languages but not in Java.</li>
<li><strong>Memoization</strong>: The Fibonacci implementation is inefficient due to redundant calculations. Memoization (caching results) can reduce its time complexity to O(n).</li>
<li><strong>Java’s Stack Limitations</strong>: Deep recursion can cause a <code>StackOverflowError</code>. Use iteration or increase the stack size for large inputs.</li>
</ul>
<h3 id="static-storage-allocation-in-recursion"><a class="header" href="#static-storage-allocation-in-recursion">Static Storage Allocation in Recursion</a></h3>
<p>Static storage allocation refers to memory allocation that is fixed at compile time and remains constant throughout a program’s execution. In the context of recursion, static storage allocation applies to variables declared as <code>static</code> in Java, which are shared across all calls to a recursive function. These variables are allocated once in the program’s data segment and persist for the program’s lifetime. For recursive algorithms, static variables can be used to store shared state across recursive calls, such as a counter or accumulator, but they are not typically used for local variables in recursion. In the provided <code>factorial</code> and <code>fibonacci</code> implementations, static storage allocation is not used, as each recursive call relies on local variables stored on the call stack. Static allocation is memory-efficient for shared data but can lead to issues in recursive functions if not managed carefully, as all recursive calls access the same variable, potentially causing unintended side effects.</p>
<h3 id="dynamic-storage-allocation"><a class="header" href="#dynamic-storage-allocation">Dynamic Storage Allocation</a></h3>
<p>Dynamic storage allocation refers to memory allocation that occurs at runtime, typically on the heap or call stack, and can vary in size during program execution. In recursion, dynamic storage allocation is critical because each recursive call allocates memory on the Java call stack for its local variables, parameters, and return address. In the provided <code>factorial</code> implementation, each call allocates space for the parameter <code>n</code> and temporary results. In the <code>fibonacci</code> implementation, each call allocates space for <code>n</code> and intermediate sums. This dynamic allocation enables recursion to handle varying problem sizes but increases space complexity, as the stack grows with each recursive call until the base case is reached. Excessive recursion depth can lead to a <code>StackOverflowError</code> if the stack size is exceeded. Dynamic allocation is essential for recursion but requires careful design to manage memory usage effectively</p>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursion for problems with a natural recursive structure, like tree traversals or divide-and-conquer algorithms. For efficiency, consider memoization or iteration for problems with overlapping subproblems, like Fibonacci.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious with deep recursion in Java, as it can lead to a <code>StackOverflowError</code> for large inputs due to dynamic allocation on the call stack. Always ensure base cases are reachable and consider iterative alternatives for performance-critical applications.</p>
</blockquote>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li><strong>Recursive Sum of Array</strong>: Write a Java program that uses recursion to compute the sum of elements in an array. Test it with arrays of different sizes.</li>
<li><strong>Reverse a String Recursively</strong>: Create a recursive method to reverse a string by breaking it into smaller substrings. Test with various strings, including empty and single-character cases.</li>
<li><strong>Binary Search Recursion</strong>: Implement a recursive binary search algorithm for a sorted array. Test it with arrays containing both existing and non-existing elements.</li>
<li><strong>Factorial with Memoization</strong>: Modify the factorial implementation to use memoization (e.g., with a HashMap) to cache results. Compare its performance with the original for large inputs.</li>
<li><strong>Tower of Hanoi</strong>: Write a recursive program to solve the Tower of Hanoi problem for n disks. Print the sequence of moves and test with different values of n.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01_10.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch02_01.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01_10.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch02_01.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
