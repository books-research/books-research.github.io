<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Merge Sort - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h2 id="merge-sort"><a class="header" href="#merge-sort">Merge Sort</a></h2>
<h3 id="definition-and-concepts"><a class="header" href="#definition-and-concepts">Definition and Concepts</a></h3>
<p>Merge Sort is a divide-and-conquer sorting algorithm that recursively divides an array into two halves, sorts each half, and then merges the sorted halves to produce a fully sorted array. The algorithm relies on the principle that it is easier to sort smaller subarrays and combine them efficiently. You can visualize Merge Sort as splitting a deck of cards into smaller stacks, sorting each stack, and then combining them in order. In Java, Merge Sort is typically implemented on arrays, using recursion to divide the array and an auxiliary array to merge the sorted subarrays. Merge Sort is a stable algorithm, preserving the relative order of equal elements, but it is not in-place, as it requires additional memory for merging.</p>
<h3 id="key-points"><a class="header" href="#key-points">Key Points:</a></h3>
<ul>
<li>Merge Sort divides the array into two equal halves until each subarray has one element (which is inherently sorted).</li>
<li>It merges sorted subarrays by comparing elements and placing them in the correct order.</li>
<li>The algorithm is efficient for large datasets due to its consistent O(n log n) time complexity.</li>
<li>It requires extra space for merging, unlike in-place algorithms like Bubble Sort or Insertion Sort.</li>
</ul>
<h3 id="why-use-it"><a class="header" href="#why-use-it">Why Use It?</a></h3>
<p>Merge Sort is used for its consistent and efficient O(n log n) time complexity, making it suitable for sorting large datasets where performance is critical. The algorithm is stable, ensuring that equal elements maintain their relative order, which is important in applications like database sorting. Merge Sort is particularly effective for linked lists, as it avoids random access, and for external sorting (sorting data too large to fit in memory). Its divide-and-conquer approach makes it easy to parallelize, improving performance on multi-core systems. However, its need for extra space makes it less suitable for memory-constrained environments.</p>
<h3 id="where-to-use-real-life-examples"><a class="header" href="#where-to-use-real-life-examples">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Database Sorting</strong>: Database systems use Merge Sort to sort large datasets, such as query results, due to its stability and efficiency.</li>
<li><strong>External Sorting</strong>: File systems use Merge Sort for sorting large files on disk, as it can handle data in chunks, minimizing memory usage.</li>
<li><strong>Linked List Sorting</strong>: Applications with linked list data structures use Merge Sort to sort elements efficiently without requiring random access.</li>
<li><strong>Parallel Processing</strong>: Parallel computing frameworks use Merge Sort in distributed systems, as its divide-and-conquer nature allows tasks to be split across processors.</li>
</ul>
<!-- ### Diagram
diagram for Merge Sort illustrating the process with the array [5, 3, 8, 1, 9].
<div style="text-align:center;">
    <img src="img/merge_sort_diagram.svg" alt="mSort" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations"><a class="header" href="#explain-operations">Explain Operations</a></h3>
<ul>
<li><strong>Divide</strong>: This operation splits the array into two halves recursively until each subarray has one element. It has a time complexity of O(1) per division.</li>
<li><strong>Merge</strong>: This operation combines two sorted subarrays into a single sorted array by comparing elements and placing them in order. It has a time complexity of O(n) for n elements in the subarrays.</li>
<li><strong>Recursive Sort</strong>: This operation recursively sorts the two halves of the array. It contributes to the overall O(n log n) time complexity due to log n levels of recursion.</li>
<li><strong>Full Algorithm</strong>: This operation combines division, recursive sorting, and merging to sort the entire array. It has a time complexity of O(n log n) in all cases.</li>
</ul>
<h3 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h3>
<p>The following Java code implements Merge Sort for an array of integers.</p>
<pre><code class="language-java">public class MergeSort {
    // Merge Sort: Sorts an array in ascending order
    public void mergeSort(int[] arr) {
        if (arr == null || arr.length &lt;= 1) {
            return; // No sorting needed for null or single-element arrays
        }
        int[] temp = new int[arr.length]; // Auxiliary array for merging
        mergeSortHelper(arr, 0, arr.length - 1, temp);
    }

    // Helper method: Recursively divides and sorts the array
    private void mergeSortHelper(int[] arr, int left, int right, int[] temp) {
        if (left &lt; right) { // Base case: subarray has more than one element
            int mid = left + (right - left) / 2; // Find midpoint
            mergeSortHelper(arr, left, mid, temp); // Sort left half
            mergeSortHelper(arr, mid + 1, right, temp); // Sort right half
            merge(arr, left, mid, right, temp); // Merge sorted halves
        }
    }

    // Merge: Combines two sorted subarrays into a single sorted array
    private void merge(int[] arr, int left, int mid, int right, int[] temp) {
        // Copy elements to temporary array
        for (int i = left; i &lt;= right; i++) {
            temp[i] = arr[i];
        }
        int i = left; // Index for left subarray
        int j = mid + 1; // Index for right subarray
        int k = left; // Index for merged array
        while (i &lt;= mid &amp;&amp; j &lt;= right) { // Compare and merge
            if (temp[i] &lt;= temp[j]) { // Use &lt;= for stability
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        while (i &lt;= mid) { // Copy remaining left subarray elements
            arr[k++] = temp[i++];
        }
        // No need to copy right subarray, as it’s already processed
    }
}
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>mergeSort</code> method checks if the input array is null or has one or fewer elements. If so, it returns immediately, as no sorting is needed.</li>
</ul>
</li>
<li><strong>Initialize Temporary Array</strong>:
<ul>
<li>An auxiliary array <code>temp</code> is created to assist with merging, with the same size as the input array.</li>
</ul>
</li>
<li><strong>Recursive Division (mergeSortHelper)</strong>:
<ul>
<li>The <code>mergeSortHelper</code> method recursively divides the array into two halves by calculating the midpoint (<code>mid = left + (right - left) / 2</code>).</li>
<li>It calls itself on the left half (<code>left</code> to <code>mid</code>) and right half (<code>mid + 1</code> to <code>right</code>).</li>
<li>For example, for <code>[5, 3, 8, 1, 9]</code>, it divides into <code>[5, 3]</code> and <code>[8, 1, 9]</code>, then further into <code>[5]</code>, <code>[3]</code>, <code>[8]</code>, <code>[1, 9]</code>.</li>
</ul>
</li>
<li><strong>Merge</strong>:
<ul>
<li>The <code>merge</code> method copies the subarray from <code>left</code> to <code>right</code> into <code>temp</code>, then merges the two sorted halves back into the original array.</li>
<li>It compares elements from the left subarray (<code>temp[i]</code>) and right subarray (<code>temp[j]</code>), placing the smaller (or equal, for stability) element into <code>arr[k]</code>.</li>
<li>For example, merging <code>[3, 5]</code> and <code>[1, 8, 9]</code> results in <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>After all recursive calls and merges, the array is sorted in ascending order. For example, <code>[5, 3, 8, 1, 9]</code> becomes <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Divide</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Merge</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Recursive Sort</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n log n) (all cases)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array.</li>
<li>Time complexity is O(n log n) in best, average, and worst cases, as the array is divided log n times, and each merge takes O(n) time.</li>
<li>Space complexity is O(n) due to the auxiliary array used for merging.</li>
</ul>
<h3 id="key-differences--notes"><a class="header" href="#key-differences--notes">Key Differences / Notes</a></h3>
<ul>
<li><strong>Merge Sort vs. Bubble/Selection/Insertion Sort</strong>:
<ul>
<li>Merge Sort has O(n log n) time complexity, making it more efficient than Bubble Sort, Selection Sort, and Insertion Sort (all O(n²)) for large datasets.</li>
<li>It is stable, like Insertion Sort, but unlike Selection Sort.</li>
<li>It requires O(n) extra space, unlike the in-place Bubble, Selection, and Insertion Sorts.</li>
</ul>
</li>
<li><strong>Merge Sort vs. Quick Sort</strong>:
<ul>
<li>Merge Sort is stable and has consistent O(n log n) time complexity, while Quick Sort is not stable and has O(n²) worst-case but O(n log n) average.</li>
<li>Quick Sort is in-place, while Merge Sort requires extra space.</li>
</ul>
</li>
<li><strong>Suitability for Data Structures</strong>:
<ul>
<li>Merge Sort is efficient for arrays and linked lists, as it avoids random access in the merge step, unlike Selection Sort.</li>
<li>It is particularly suited for external sorting and parallel processing due to its divide-and-conquer nature.</li>
</ul>
</li>
<li><strong>Stability</strong>:
<ul>
<li>The use of <code>&lt;=</code> in the merge step ensures stability, preserving the relative order of equal elements.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Merge Sort for large datasets or when stability is required, as its O(n log n) time complexity ensures consistent performance. For linked lists, Merge Sort is especially efficient, as it avoids random access.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be mindful of Merge Sort’s O(n) space complexity, which may be a limitation in memory-constrained environments. Always validate array bounds and ensure the auxiliary array is properly initialized to prevent errors.</p>
</blockquote>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li><strong>Basic Merge Sort</strong>: Implement Merge Sort for an array of integers and test it with various inputs (e.g., unsorted, sorted, reversed, duplicates). Verify the sorted output.</li>
<li><strong>Descending Order</strong>: Modify the Merge Sort implementation to sort an array in descending order by adjusting the merge comparison logic. Test with different array sizes.</li>
<li><strong>Performance Analysis</strong>: Write a program that measures the execution time of Merge Sort for arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare with Insertion Sort and Selection Sort.</li>
<li><strong>Object Sorting</strong>: Extend Merge Sort to sort an array of objects (e.g., <code>Student</code> objects with a <code>grade</code> field) based on a custom comparator. Test with a sample dataset.</li>
<li><strong>Space Optimization</strong>: Implement an in-place Merge Sort variant (if feasible) and compare its performance and space usage with the standard implementation. Test with various inputs.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04_03.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05_0.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04_03.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05_0.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
