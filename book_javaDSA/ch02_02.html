<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Recursion vs Iteration - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h2 id="recursion-vs-iteration"><a class="header" href="#recursion-vs-iteration">Recursion vs. Iteration</a></h2>
<h3 id="definition-and-concepts"><a class="header" href="#definition-and-concepts">Definition and Concepts</a></h3>
<p>Recursion and iteration are two fundamental programming techniques for solving repetitive problems. Recursion involves a function calling itself with a smaller or simpler instance of the same problem until a base case is reached, which provides a direct solution. Each recursive call is managed on the call stack, storing parameters and local variables. Iteration, in contrast, uses loops (e.g., for or while loops) to repeatedly execute a block of code until a condition is met, relying on variables to track state within a single function. You can visualize recursion as a stack of nested function calls that unwind, while iteration is a single loop cycling through updates. Both approaches can solve similar problems, but they differ in code structure, memory usage, and readability.</p>
<h3 id="why-use-it"><a class="header" href="#why-use-it">Why Use It?</a></h3>
<p>Recursion is used to simplify the solution to problems with a naturally hierarchical or self-referential structure, such as tree traversals or divide-and-conquer algorithms, offering concise and elegant code. Iteration is used when performance and memory efficiency are critical, as it avoids the overhead of multiple function calls and stack management. Choosing between recursion and iteration depends on the problem’s structure, performance requirements, and readability preferences. For example, recursion excels in problems like factorial computation for clarity, while iteration is preferred for large inputs to avoid stack overflow.</p>
<h3 id="where-to-use-real-life-examples"><a class="header" href="#where-to-use-real-life-examples">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Recursion in Tree Traversal</strong>: File systems use recursion to traverse directory trees, processing subdirectories hierarchically, as recursion naturally handles nested structures.</li>
<li><strong>Iteration in Data Processing</strong>: Data pipelines use iteration to process large datasets, such as summing values in a list, for efficiency and minimal memory usage.</li>
<li><strong>Recursion in Parsing</strong>: Compilers use recursion to parse nested expressions, like <code>(2 + (3 * 4))</code>, breaking them into sub-expressions.</li>
<li><strong>Iteration in Simulations</strong>: Game loops use iteration to update game states repeatedly, such as moving objects in a physics simulation, avoiding stack overhead.</li>
</ul>
<h3 id="svg-diagram"><a class="header" href="#svg-diagram">SVG Diagram</a></h3>
<p>The diagram would depict two side-by-side representations for computing factorial(4). On the left, recursion would show a stack of function calls (<code>factorial(4) -&gt; factorial(3) -&gt; factorial(2) -&gt; factorial(1)</code>), with arrows indicating recursive calls downward and return values (1, 2, 6, 24) upward. On the right, iteration would show a single loop with a variable <code>result</code> updating (1, 2, 6, 24) over iterations. A caption would note: "Recursion uses a call stack for nested calls, while iteration updates state in a loop, avoiding stack overhead."</p>
<h3 id="explain-operations"><a class="header" href="#explain-operations">Explain Operations</a></h3>
<ul>
<li><strong>Recursive Call (Recursion)</strong>: This operation involves a function calling itself with modified parameters to solve a smaller subproblem. It has a time complexity dependent on the number of calls and work per call.</li>
<li><strong>Base Case Check (Recursion)</strong>: This operation checks if the input meets a condition to terminate recursion, returning a direct result. It has a time complexity of O(1).</li>
<li><strong>Loop Execution (Iteration)</strong>: This operation repeatedly executes a block of code, updating variables until a condition is met. It has a time complexity dependent on the number of iterations.</li>
<li><strong>State Update (Iteration)</strong>: This operation modifies variables within a loop to track progress. It typically has a time complexity of O(1) per update.</li>
<li><strong>Stack Management (Recursion)</strong>: The Java call stack manages recursive calls, storing state for each call. It contributes to space complexity based on recursion depth.</li>
</ul>
<h3 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h3>
<p>The following Java code implements the factorial algorithm using both recursion and iteration for comparison.</p>
<pre><code class="language-java">public class RecursionVsIteration {
    // Recursive Factorial: Computes n! recursively
    public int factorialRecursive(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        if (n == 0 || n == 1) { // Base case: 0! = 1, 1! = 1
            return 1;
        }
        return n * factorialRecursive(n - 1); // Recursive case: n! = n * (n-1)!
    }

    // Iterative Factorial: Computes n! iteratively
    public int factorialIterative(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        int result = 1; // Initializes result for factorial
        for (int i = 1; i &lt;= n; i++) { // Loops from 1 to n
            result *= i; // Updates result by multiplying with i
        }
        return result; // Returns final result
    }
}
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Recursive Factorial</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>If <code>n</code> is 0 or 1 (base case), it returns 1.</li>
<li>Otherwise, it recursively calls <code>factorialRecursive(n-1)</code> and multiplies the result by <code>n</code>.</li>
<li>For example, <code>factorialRecursive(4)</code> computes <code>4 * factorialRecursive(3)</code>, which computes <code>3 * factorialRecursive(2)</code>, until <code>factorialRecursive(1)</code> returns 1, yielding 24.</li>
<li>Each call is pushed onto the call stack, consuming memory until the base case is reached.</li>
</ul>
</li>
<li><strong>Iterative Factorial</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>It initializes a <code>result</code> variable to 1 and uses a for loop to multiply <code>result</code> by each integer from 1 to <code>n</code>.</li>
<li>For example, <code>factorialIterative(4)</code> iterates with <code>result = 1 * 1 * 2 * 3 * 4</code>, yielding 24.</li>
<li>The loop uses a single function frame, avoiding additional stack memory.</li>
</ul>
</li>
<li><strong>Comparison</strong>: Recursion creates multiple stack frames, increasing space complexity, while iteration uses a single frame, making it more memory-efficient.</li>
</ol>
<h3 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Factorial</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iterative Factorial</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Base Case Check (Recursion)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Loop Execution (Iteration)</td><td>O(1) per iteration</td><td>O(1)</td></tr>
<tr><td>Stack Management (Recursion)</td><td>O(1) per call</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>Both recursive and iterative factorial have O(n) time complexity due to n multiplications.</li>
<li>Recursive factorial has O(n) space complexity due to n stack frames.</li>
<li>Iterative factorial has O(1) space complexity, as it uses only a few variables.</li>
</ul>
<h3 id="key-differences--notes"><a class="header" href="#key-differences--notes">Key Differences / Notes</a></h3>
<ul>
<li><strong>Code Readability</strong>:
<ul>
<li>Recursion offers concise, elegant code for problems with self-similar structures, like the recursive factorial, which mirrors the mathematical definition (n! = n * (n-1)!).</li>
<li>Iteration may require more lines of code but is often clearer for linear tasks, like the iterative factorial, avoiding stack management.</li>
</ul>
</li>
<li><strong>Performance</strong>:
<ul>
<li>Recursion incurs overhead from multiple function calls and stack management, which can lead to <code>StackOverflowError</code> for deep recursion in Java.</li>
<li>Iteration avoids this overhead, making it faster and more memory-efficient for large inputs.</li>
</ul>
</li>
<li><strong>Tail Recursion</strong>: Java does not optimize tail recursion, so recursive calls always consume stack space. Iterative solutions are preferred in Java for deep recursion.</li>
<li><strong>Use Cases</strong>:
<ul>
<li>Recursion is ideal for hierarchical problems (e.g., tree traversals, divide-and-conquer).</li>
<li>Iteration is better for linear or sequential tasks (e.g., summing arrays, simple loops).</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Choose recursion for problems with a natural recursive structure, like tree traversals or factorial, to improve readability. Use iteration for performance-critical tasks or large inputs to minimize memory usage and avoid stack overflow.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Deep recursion in Java can cause a <code>StackOverflowError</code> due to limited stack size. Always ensure recursive base cases are reachable and consider iterative alternatives for large-scale problems to optimize performance.</p>
</blockquote>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li><strong>Recursive vs. Iterative Sum</strong>: Write a Java program that computes the sum of an array using both recursive and iterative approaches. Compare their performance with large arrays.</li>
<li><strong>Reverse String Comparison</strong>: Implement string reversal using both recursion and iteration. Test with various strings and compare code readability and execution time.</li>
<li><strong>Power Function</strong>: Create recursive and iterative methods to compute x^n (x raised to the power n). Test with different inputs and analyze their space complexity.</li>
<li><strong>Fibonacci Optimization</strong>: Modify the recursive Fibonacci algorithm to use memoization, then compare it with an iterative Fibonacci implementation for performance on large inputs.</li>
<li><strong>Linked List Traversal</strong>: Using a singly linked list, implement recursive and iterative methods to traverse and print the list. Test both approaches and discuss their trade-offs.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02_01.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch02_03.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02_01.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch02_03.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
