<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Graphs - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h2 id="graph-data-structure"><a class="header" href="#graph-data-structure">Graph Data Structure</a></h2>
<h3 id="definition-and-concepts"><a class="header" href="#definition-and-concepts">Definition and Concepts</a></h3>
<p>A graph is a non-linear data structure consisting of nodes (also called vertices) connected by edges. Graphs can represent relationships between entities, where nodes represent entities and edges represent connections. Graphs can be directed (edges have direction, like one-way roads) or undirected (edges are bidirectional, like friendships). They can also be weighted (edges have values, like distances) or unweighted. A common representation is an adjacency list, where each node stores a list of its adjacent nodes. You can visualize a graph as a network of cities (nodes) connected by roads (edges). Graphs are versatile and used to model complex relationships in various applications.</p>
<h3 id="why-use-it"><a class="header" href="#why-use-it">Why Use It?</a></h3>
<p>Graphs are used to model and analyze relationships between entities, enabling solutions to problems like finding shortest paths, detecting cycles, or determining connectivity. They provide a flexible framework for representing networks, making them essential for applications in computer science, social networks, and logistics. Graphs support efficient algorithms for traversal, pathfinding, and optimization, with time complexities depending on the representation and algorithm used.</p>
<h3 id="where-to-use-real-life-examples"><a class="header" href="#where-to-use-real-life-examples">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Social Networks</strong>: Social media platforms use graphs to represent users (nodes) and friendships or follows (edges) to recommend connections or analyze communities.</li>
<li><strong>Navigation Systems</strong>: GPS applications use graphs to model road networks, with cities as nodes and roads as weighted edges, to compute shortest paths.</li>
<li><strong>Internet Routing</strong>: The internet uses graphs to represent routers and connections, enabling efficient data packet routing.</li>
<li><strong>Dependency Management</strong>: Build tools like Maven use graphs to manage dependencies between software modules, detecting cyclic dependencies.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a graph would depict an undirected graph with nodes (e.g., labeled A, B, C, D) connected by edges (lines). For example, node A connects to B and C, B connects to C and D, and so on. The adjacency list representation would be shown as a table, where each node lists its neighbors (e.g., A: [B, C], B: [A, C, D]). Arrows would illustrate a **depth-first search (DFS)** starting from node A, visiting B, then D, and a **breadth-first search (BFS)** visiting A, B, C, then D. A caption would note: "Graphs model relationships, with adjacency lists storing neighbors for each node." -->
<h3 id="explain-operations"><a class="header" href="#explain-operations">Explain Operations</a></h3>
<ul>
<li><strong>Add Vertex</strong>: This operation adds a new node to the graph. It has a time complexity of O(1) in an adjacency list.</li>
<li><strong>Add Edge</strong>: This operation adds a connection between two nodes. It has a time complexity of O(1) for an undirected graph using an adjacency list.</li>
<li><strong>Remove Vertex</strong>: This operation removes a node and all its edges. It has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges.</li>
<li><strong>Remove Edge</strong>: This operation removes a connection between two nodes. It has a time complexity of O(E) in the worst case for an adjacency list.</li>
<li><strong>Depth-First Search (DFS)</strong>: This operation traverses the graph by exploring as far as possible along each branch before backtracking. It has a time complexity of O(V + E).</li>
<li><strong>Breadth-First Search (BFS)</strong>: This operation traverses the graph level by level, visiting all neighbors of a node before moving to the next level. It has a time complexity of O(V + E).</li>
</ul>
<h3 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h3>
<p>The following Java code implements an undirected graph using an adjacency list, with basic operations and DFS/BFS traversals.</p>
<pre><code class="language-java">import java.util.*;

public class Graph {
    private Map&lt;Integer, List&lt;Integer&gt;&gt; adjList; // Adjacency list to store the graph
    private int vertexCount; // Number of vertices in the graph

    // Constructor to initialize an empty graph
    public Graph() {
        adjList = new HashMap&lt;&gt;();
        vertexCount = 0;
    }

    // Add Vertex: Adds a new vertex to the graph
    public void addVertex(int vertex) {
        if (!adjList.containsKey(vertex)) { // Checks if vertex doesn't already exist
            adjList.put(vertex, new ArrayList&lt;&gt;());
            vertexCount++;
        }
    }

    // Add Edge: Adds an undirected edge between two vertices
    public void addEdge(int vertex1, int vertex2) {
        if (!adjList.containsKey(vertex1) || !adjList.containsKey(vertex2)) {
            throw new IllegalArgumentException("Both vertices must exist in the graph.");
        }
        adjList.get(vertex1).add(vertex2); // Adds vertex2 to vertex1's list
        adjList.get(vertex2).add(vertex1); // Adds vertex1 to vertex2's list (undirected)
    }

    // Remove Vertex: Removes a vertex and all its edges
    public void removeVertex(int vertex) {
        if (!adjList.containsKey(vertex)) {
            throw new IllegalArgumentException("Vertex not found in the graph.");
        }
        List&lt;Integer&gt; neighbors = adjList.get(vertex);
        for (int neighbor : neighbors) { // Removes vertex from neighbors' lists
            adjList.get(neighbor).remove(Integer.valueOf(vertex));
        }
        adjList.remove(vertex); // Removes the vertex
        vertexCount--;
    }

    // Remove Edge: Removes an undirected edge between two vertices
    public void removeEdge(int vertex1, int vertex2) {
        if (!adjList.containsKey(vertex1) || !adjList.containsKey(vertex2)) {
            throw new IllegalArgumentException("Both vertices must exist in the graph.");
        }
        adjList.get(vertex1).remove(Integer.valueOf(vertex2)); // Removes vertex2 from vertex1's list
        adjList.get(vertex2).remove(Integer.valueOf(vertex1)); // Removes vertex1 from vertex2's list
    }

    // Depth-First Search: Traverses the graph starting from a vertex
    public List&lt;Integer&gt; dfs(int startVertex) {
        if (!adjList.containsKey(startVertex)) {
            throw new IllegalArgumentException("Start vertex not found in the graph.");
        }
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        dfsRec(startVertex, visited, result);
        return result;
    }

    private void dfsRec(int vertex, Set&lt;Integer&gt; visited, List&lt;Integer&gt; result) {
        visited.add(vertex); // Marks the vertex as visited
        result.add(vertex); // Adds vertex to result
        for (int neighbor : adjList.get(vertex)) { // Visits unvisited neighbors
            if (!visited.contains(neighbor)) {
                dfsRec(neighbor, visited, result);
            }
        }
    }

    // Breadth-First Search: Traverses the graph starting from a vertex
    public List&lt;Integer&gt; bfs(int startVertex) {
        if (!adjList.containsKey(startVertex)) {
            throw new IllegalArgumentException("Start vertex not found in the graph.");
        }
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        visited.add(startVertex);
        queue.offer(startVertex);
        while (!queue.isEmpty()) {
            int vertex = queue.poll(); // Dequeues a vertex
            result.add(vertex); // Adds vertex to result
            for (int neighbor : adjList.get(vertex)) { // Enqueues unvisited neighbors
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        return result;
    }

    // isEmpty: Checks if the graph is empty
    public boolean isEmpty() {
        return vertexCount == 0;
    }

    // Size: Returns the number of vertices in the graph
    public int size() {
        return vertexCount;
    }
}
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes an empty <code>HashMap</code> for the adjacency list and sets <code>vertexCount</code> to 0, indicating an empty graph.</li>
<li><strong>Add Vertex</strong>: The method adds a new vertex to the <code>adjList</code> with an empty list of neighbors if it doesn’t already exist, incrementing <code>vertexCount</code>.</li>
<li><strong>Add Edge</strong>: The method adds an undirected edge by appending each vertex to the other’s neighbor list in the <code>adjList</code>, ensuring both vertices exist.</li>
<li><strong>Remove Vertex</strong>: The method removes the vertex’s neighbor list and removes the vertex from all its neighbors’ lists, then removes the vertex from <code>adjList</code> and decrements <code>vertexCount</code>.</li>
<li><strong>Remove Edge</strong>: The method removes each vertex from the other’s neighbor list in the <code>adjList</code>, ensuring both vertices exist.</li>
<li><strong>Depth-First Search (DFS)</strong>: The method uses recursion to explore as far as possible along each branch, marking vertices as visited and adding them to the result list.</li>
<li><strong>Breadth-First Search (BFS)</strong>: The method uses a queue to explore nodes level by level, marking vertices as visited, adding them to the result, and enqueuing unvisited neighbors.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>vertexCount</code> equals 0, indicating an empty graph, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>vertexCount</code>, which represents the number of vertices in the graph.</li>
</ol>
<h3 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity (Adjacency List)</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Add Vertex</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Add Edge</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Remove Vertex</td><td>O(V + E)</td><td>O(1)</td></tr>
<tr><td>Remove Edge</td><td>O(E)</td><td>O(1)</td></tr>
<tr><td>DFS</td><td>O(V + E)</td><td>O(V)</td></tr>
<tr><td>BFS</td><td>O(V + E)</td><td>O(V)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: V is the number of vertices, and E is the number of edges. Time complexities assume an adjacency list representation.</p>
<h3 id="key-differences--notes"><a class="header" href="#key-differences--notes">Key Differences / Notes</a></h3>
<ul>
<li><strong>Adjacency List vs. Adjacency Matrix</strong>:
<ul>
<li>The implementation above uses an adjacency list, which is space-efficient (O(V + E)) and suitable for sparse graphs.</li>
<li>An adjacency matrix uses O(V²) space and is better for dense graphs or when checking edge existence is frequent.</li>
</ul>
</li>
<li><strong>Directed vs. Undirected Graphs</strong>:
<ul>
<li>The implementation is for an undirected graph. For a directed graph, only add the edge to the source vertex’s neighbor list.</li>
</ul>
</li>
<li><strong>Weighted Graphs</strong>: The implementation is unweighted. For weighted graphs, store edge weights in the adjacency list (e.g., as a <code>Map&lt;Integer, Integer&gt;</code> for weights).</li>
<li><strong>Thread Safety</strong>: The implementation is not thread-safe. For concurrent applications, use Java’s <code>ConcurrentHashMap</code> for the adjacency list or synchronize access.</li>
<li><strong>Java’s Built-in Support</strong>: Java does not provide a direct graph class, but libraries like JGraphT or Guava’s Graph can be used for advanced graph operations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use an adjacency list for sparse graphs to save memory, and an adjacency matrix for dense graphs to optimize edge lookups.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the graph is properly initialized with all vertices before adding edges, as missing vertices can cause errors in adjacency list operations.</p>
</blockquote>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li><strong>Graph Connectivity</strong>: Write a Java program that uses the graph implementation to check if a graph is connected (all vertices reachable from a starting vertex) using DFS or BFS.</li>
<li><strong>Cycle Detection</strong>: Extend the graph implementation to detect if the graph contains a cycle using DFS. Test it with cyclic and acyclic graphs.</li>
<li><strong>Shortest Path (Unweighted)</strong>: Implement a method to find the shortest path between two vertices in an unweighted graph using BFS. Return the path as a list of vertices.</li>
<li><strong>Weighted Graph Extension</strong>: Modify the graph implementation to support weighted edges (store weights in the adjacency list). Test it by adding and retrieving edge weights.</li>
<li><strong>Social Network Simulation</strong>: Create a program that simulates a social network using the graph. Allow users to add users (vertices), friendships (edges), and perform DFS to find mutual friends.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03_07.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04_0.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03_07.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04_0.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
