<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BinarySearchPerformanceAnalysis - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/ferris.css">
        <link rel="stylesheet" href="../../theme/semantic-notes.css">
        <link rel="stylesheet" href="../../theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h1 id="binary-search-vs-linear-search-performance-analysis"><a class="header" href="#binary-search-vs-linear-search-performance-analysis">Binary Search vs. Linear Search Performance Analysis</a></h1>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Write a Java program that measures and compares the execution time of Binary Search and Linear Search algorithms for finding a target integer in large sorted arrays of integers in ascending order (e.g., sizes 1000, 10000). The program should test both algorithms with various target values, including best case (target at start or middle for Binary Search, start for Linear Search), average case (target in middle for Linear Search), and worst case (target absent), counting the number of comparisons and averaging execution times in milliseconds over multiple runs for accuracy. Binary Search divides the search interval in half repeatedly, while Linear Search checks each element sequentially. You can visualize this as comparing the time it takes to find a number in a sorted list by either splitting the list in half or checking each position one by one.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Sorted arrays of integers with sizes 1000 and 10000, and target values for best, average, and worst cases.
<strong>Output</strong>: The index of the target (or -1 if not found), number of comparisons, execution time (in milliseconds) for both Binary Search and Linear Search for each case and size, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 1000 and 10000.</li>
<li>Array elements and targets are integers in the range [-10^9, 10^9].</li>
<li>The input arrays are sorted in ascending order.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 1000, array = [1, 2, 3, ..., 1000], targets = [1 (best), 500 (average/middle), 1000000 (worst)]</li>
<li>Output (example, times vary):
<ul>
<li>Best Case (target=1):
<ul>
<li>Binary Search: Index: 0, Comparisons: 1, Time: 0.01 ms</li>
<li>Linear Search: Index: 0, Comparisons: 1, Time: 0.02 ms</li>
</ul>
</li>
<li>Average Case (target=500):
<ul>
<li>Binary Search: Index: 499, Comparisons: 10, Time: 0.02 ms</li>
<li>Linear Search: Index: 499, Comparisons: 500, Time: 0.15 ms</li>
</ul>
</li>
<li>Worst Case (target=1000000):
<ul>
<li>Binary Search: Index: -1, Comparisons: 10, Time: 0.02 ms</li>
<li>Linear Search: Index: -1, Comparisons: 1000, Time: 0.30 ms</li>
</ul>
</li>
</ul>
</li>
<li>Explanation: Binary Search is significantly faster and uses fewer comparisons than Linear Search, especially for large arrays and worst-case scenarios.</li>
</ul>
<h2 id="pseudocode"><a class="header" href="#pseudocode">Pseudocode</a></h2>
<pre><code>FUNCTION binarySearch(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            RETURN mid, comparisons
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION linearSearch(arr, target)
    SET comparisons to 0
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i] equals target THEN
            RETURN i, comparisons
        ENDIF
    ENDFOR
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION generateArray(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [-10^9, 10^9]
    ENDFOR
    SORT arr in ascending order
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [1000, 10000]
    SET runs to 100
    FOR each size in sizes
        SET arr to generateArray(size)
        SET testCases to array of targets for best, average, worst cases
        FOR each target in testCases
            SET binaryTotalTime to 0
            SET binaryTotalComparisons to 0
            SET linearTotalTime to 0
            SET linearTotalComparisons to 0
            FOR i from 0 to runs-1
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL binarySearch(copy, target) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to binaryTotalTime
                ADD comparisons to binaryTotalComparisons
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL linearSearch(copy, target) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to linearTotalTime
                ADD comparisons to linearTotalComparisons
            ENDFOR
            PRINT test case details, input array, indices
            PRINT binary and linear average time in milliseconds, average comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps"><a class="header" href="#algorithm-steps">Algorithm Steps</a></h2>
<ol>
<li>Define <code>binarySearch</code>:
a. Initialize comparisons to 0, <code>left</code> to 0, <code>right</code> to n-1.
b. While <code>left</code> &lt;= <code>right</code>, compute <code>mid</code>, increment comparisons, and adjust range based on comparison.
c. Return index and comparisons.</li>
<li>Define <code>linearSearch</code>:
a. Initialize comparisons to 0.
b. Iterate through the array, incrementing comparisons for each check.
c. Return index and comparisons if found, or -1 and comparisons if not.</li>
<li>Define <code>generateArray</code>:
a. Create a random array and sort it in ascending order.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 1000, 10000 (sorted).
b. For each size, test:
<ul>
<li>Best case: Target at start (index 0) for both algorithms.</li>
<li>Average case: Target in middle (index n/2) for Linear Search, middle for Binary Search.</li>
<li>Worst case: Target absent (e.g., 10^9 + 1).
c. Run each case 100 times, averaging execution time and comparisons.
d. Use <code>System.nanoTime()</code> for timing, convert to milliseconds.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BinarySearchPerformanceAnalysis {
    // Performs Binary Search with comparison counting
    public int[] binarySearch(int[] arr, int target) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid] == target) {
                return new int[]{mid, comparisons};
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{-1, comparisons};
    }

    // Performs Linear Search with comparison counting
    public int[] linearSearch(int[] arr, int target) {
        int comparisons = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i] == target) {
                return new int[]{i, comparisons};
            }
        }
        return new int[]{-1, comparisons};
    }

    // Generates sorted array
    private int[] generateSortedArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2000000001) - 1000000000; // [-10^9, 10^9]
        }
        Arrays.sort(arr); // Ensure array is sorted
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int target;
        String description;

        TestCase(int target, String description) {
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        BinarySearchPerformanceAnalysis searcher = new BinarySearchPerformanceAnalysis();
        int[] sizes = {1000, 10000};
        int runs = 100;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] arr = searcher.generateSortedArray(size);
            System.out.println("Input Array: " + searcher.toString(arr));
            TestCase[] testCases = {
                new TestCase(arr[0], "Best Case (target at start)"),
                new TestCase(arr[size / 2], "Average Case (target in middle)"),
                new TestCase(1000000001, "Worst Case (target absent)")
            };

            for (TestCase testCase : testCases) {
                System.out.println(testCase.description + ":");
                System.out.println("Target: " + testCase.target);
                long binaryTotalTime = 0;
                long binaryTotalComparisons = 0;
                long linearTotalTime = 0;
                long linearTotalComparisons = 0;
                int binaryIndex = -1;
                int linearIndex = -1;
                for (int i = 0; i &lt; runs; i++) {
                    int[] copy = arr.clone();
                    long startTime = System.nanoTime();
                    int[] binaryResult = searcher.binarySearch(copy, testCase.target);
                    long endTime = System.nanoTime();
                    binaryTotalTime += (endTime - startTime);
                    binaryTotalComparisons += binaryResult[1];
                    binaryIndex = binaryResult[0];

                    copy = arr.clone();
                    startTime = System.nanoTime();
                    int[] linearResult = searcher.linearSearch(copy, testCase.target);
                    endTime = System.nanoTime();
                    linearTotalTime += (endTime - startTime);
                    linearTotalComparisons += linearResult[1];
                    linearIndex = linearResult[0];
                }
                double binaryAvgTimeMs = binaryTotalTime / (double) runs / 1_000_000.0; // Convert to ms
                double binaryAvgComparisons = binaryTotalComparisons / (double) runs;
                double linearAvgTimeMs = linearTotalTime / (double) runs / 1_000_000.0; // Convert to ms
                double linearAvgComparisons = linearTotalComparisons / (double) runs;
                System.out.println("Binary Search:");
                System.out.println("  Index: " + binaryIndex);
                System.out.printf("  Average Time: %.2f ms\n", binaryAvgTimeMs);
                System.out.printf("  Average Comparisons: %.0f\n", binaryAvgComparisons);
                System.out.println("Linear Search:");
                System.out.println("  Index: " + linearIndex);
                System.out.printf("  Average Time: %.2f ms\n", linearAvgTimeMs);
                System.out.printf("  Average Comparisons: %.0f\n\n", linearAvgComparisons);
            }
        }
    }
}
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 1000
Input Array: [-999999769, -999999466, -999999266, -999998928, -999998711, -999998641, -999998533, -999998413, -999998365, -999998255, ...]
Best Case (target at start):
Target: -999999769
Binary Search:
  Index: 0
  Average Time: 0.01 ms
  Average Comparisons: 1
Linear Search:
  Index: 0
  Average Time: 0.02 ms
  Average Comparisons: 1

Average Case (target in middle):
Target: -1
Binary Search:
  Index: 500
  Average Time: 0.02 ms
  Average Comparisons: 10
Linear Search:
  Index: 500
  Average Time: 0.15 ms
  Average Comparisons: 501

Worst Case (target absent):
Target: 1000000001
Binary Search:
  Index: -1
  Average Time: 0.02 ms
  Average Comparisons: 10
Linear Search:
  Index: -1
  Average Time: 0.30 ms
  Average Comparisons: 1000

Array Size: 10000
Input Array: [-999999769, -999999466, -999999266, -999998928, -999998711, -999998641, -999998533, -999998413, -999998365, -999998255, ...]
Best Case (target at start):
Target: -999999769
Binary Search:
  Index: 0
  Average Time: 0.02 ms
  Average Comparisons: 1
Linear Search:
  Index: 0
  Average Time: 0.03 ms
  Average Comparisons: 1

Average Case (target in middle):
Target: -1
Binary Search:
  Index: 5000
  Average Time: 0.03 ms
  Average Comparisons: 14
Linear Search:
  Index: 5000
  Average Time: 1.50 ms
  Average Comparisons: 5001

Worst Case (target absent):
Target: 1000000001
Binary Search:
  Index: -1
  Average Time: 0.03 ms
  Average Comparisons: 14
Linear Search:
  Index: -1
  Average Time: 3.00 ms
  Average Comparisons: 10000
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 1000: Binary Search is fast (~0.01-0.02 ms, ~1-10 comparisons); Linear Search is slower (~0.02-0.30 ms, ~1-1000 comparisons).</li>
<li>Size 10000: Binary Search remains fast (~0.02-0.03 ms, ~1-14 comparisons); Linear Search is much slower (~0.03-3.00 ms, ~1-10000 comparisons).</li>
<li>Binary Search’s logarithmic complexity (O(log n)) outperforms Linear Search’s linear complexity (O(n)), especially in average and worst cases.</li>
<li>Best case is comparable as both find the target immediately.</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<ul>
<li><strong>binarySearch</strong>:
<ul>
<li>Uses <code>left</code> and <code>right</code> pointers to halve the search range, incrementing comparisons for each check.</li>
<li>Returns <code>[index, comparisons]</code> or <code>[-1, comparisons]</code>.</li>
</ul>
</li>
<li><strong>linearSearch</strong>:
<ul>
<li>Iterates sequentially, incrementing comparisons for each element.</li>
<li>Returns <code>[index, comparisons]</code> or <code>[-1, comparisons]</code>.</li>
</ul>
</li>
<li><strong>generateSortedArray</strong>: Creates a random sorted array with a fixed seed.</li>
<li><strong>toString</strong>: Formats array, limiting to 10 elements.</li>
<li><strong>Example Trace (Size 1000, Average Case, target=-1)</strong>:
<ul>
<li><strong>Binary Search</strong>:
<ul>
<li>Array: [-999999769, ..., -1, ...].</li>
<li>left=0, right=999, mid=499, arr[499]≈-500 &lt; -1, comparisons=1, left=500.</li>
<li>left=500, right=999, mid=749, arr[749]≈250 &gt; -1, comparisons=2, right=748.</li>
<li>Continues, finds -1 at index 500 after ~10 comparisons.</li>
</ul>
</li>
<li><strong>Linear Search</strong>:
<ul>
<li>Checks indices 0 to 500, finds -1 at index 500 after 501 comparisons.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests sizes 1000, 10000 with best, average, worst cases, averaging time and comparisons over 100 runs.</li>
</ul>
<h2 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>binarySearch</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>linearSearch</td><td>O(n) worst, O(1) best</td><td>O(1)</td></tr>
<tr><td>generateSortedArray</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(log n) for binarySearch; O(n) for linearSearch in worst/average cases, O(1) in best case; O(n log n) for generateSortedArray; O(n) for toString.</li>
<li>Space complexity: O(1) for binarySearch and linearSearch; O(n) for generateSortedArray and toString.</li>
<li>Binary Search scales logarithmically, making it far more efficient for large arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Binary Search is ideal for large sorted arrays due to its O(log n) complexity, while Linear Search is better for small or unsorted arrays. Use multiple runs to reduce timing variability.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Binary Search requires a sorted array to function correctly. Ensure the input array is sorted, or results will be incorrect. Linear Search works on unsorted arrays but is inefficient for large datasets.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../problemStatements/ch05_02/BinarySearchObjectSearch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../problemStatements/ch05_02/BinarySearchRecursiveImplementation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../problemStatements/ch05_02/BinarySearchObjectSearch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../problemStatements/ch05_02/BinarySearchRecursiveImplementation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/ferris.js"></script>


    </div>
    </body>
</html>
