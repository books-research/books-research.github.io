<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>InsertAfterValueCircular - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/ferris.css">
        <link rel="stylesheet" href="../../theme/semantic-notes.css">
        <link rel="stylesheet" href="../../theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h1 id="insert-after-value-in-circular-linked-list"><a class="header" href="#insert-after-value-in-circular-linked-list">Insert After Value in Circular Linked List</a></h1>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Write a Java program that adds a method to insert a new node with a given value after the first occurrence of a specified target value in a circular linked list. A circular linked list is a singly linked list where the last node’s <code>next</code> pointer points to the head, forming a cycle. The method should insert the new node by updating the <code>next</code> pointers to maintain the circular structure and return true if the insertion is successful (target value found) or false if the target value is not found. Test the implementation with cases where the target value exists in the list and where it does not, including empty lists and single-node lists. You can visualize this as adding a new numbered card to a circular chain of cards, placing it right after the first card with a specific number.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A circular linked list of integers (e.g., 1→2→3→1, where 3→1 forms the cycle), a target value (e.g., 2), and a new value to insert (e.g., 4).
<strong>Output</strong>: A boolean indicating whether the insertion was successful, and the updated list printed as a string, listing nodes from the head until just before it cycles (e.g., "1 2 4 3").
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values and the new value are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty or not contain the target value.
<strong>Example</strong>:</li>
<li>Input: List = 1→2→3→1, target = 2, newValue = 4</li>
<li>Output: true, "1 2 4 3"</li>
<li>Explanation: Inserts 4 after the first 2, resulting in 1→2→4→3→1.</li>
<li>Input: List = 1→2→3→1, target = 5, newValue = 4</li>
<li>Output: false, "1 2 3"</li>
<li>Explanation: Target 5 not found, list unchanged.</li>
<li>Input: List = [], target = 1, newValue = 2</li>
<li>Output: false, "[]"</li>
<li>Explanation: Empty list, no insertion possible.</li>
</ul>
<h2 id="pseudocode"><a class="header" href="#pseudocode">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION insertAfterValue(head, target, newValue)
    IF head is null THEN
        RETURN false
    ENDIF
    SET current to head
    SET found to false
    REPEAT
        IF current.value equals target THEN
            SET found to true
            BREAK
        ENDIF
        SET current to current.next
    UNTIL current equals head
    IF not found THEN
        RETURN false
    ENDIF
    CREATE newNode as new Node(newValue)
    SET newNode.next to current.next
    SET current.next to newNode
    RETURN true
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    SET visited as new Set
    WHILE current is not null AND current not in visited
        ADD current to visited
        APPEND current.value to result
        IF current.next is not head THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of test cases (list values, target, newValue)
    FOR each testCase in testCases
        PRINT test case details
        CALL insertAfterValue(testCase.head, testCase.target, testCase.newValue)
        PRINT insertion result and updated list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps"><a class="header" href="#algorithm-steps">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>insertAfterValue</code>:
a. If the list is empty, return false.
b. Traverse the list starting from head until the target value is found or the traversal returns to head.
c. If target is not found, return false.
d. If target is found:
<ul>
<li>Create a new node with <code>newValue</code>.</li>
<li>Set <code>newNode.next</code> to <code>current.next</code>.</li>
<li>Set <code>current.next</code> to <code>newNode</code>.</li>
<li>Return true.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse from head, use a Set to avoid cycling, append values with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with cases where the target exists, does not exist, and edge cases like empty or single-node lists.</li>
</ol>
<h2 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class InsertAfterValueCircular {
    // Node class for the circular linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Inserts a new node after the first occurrence of target
    public boolean insertAfterValue(Node head, int target, int newValue) {
        if (head == null) {
            return false;
        }
        Node current = head;
        boolean found = false;
        do {
            if (current.value == target) {
                found = true;
                break;
            }
            current = current.next;
        } while (current != head);
        if (!found) {
            return false;
        }
        Node newNode = new Node(newValue);
        newNode.next = current.next;
        current.next = newNode;
        return true;
    }

    // Converts circular linked list to string
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
        while (current != null &amp;&amp; !visited.contains(current)) {
            visited.add(current);
            result.append(current.value);
            if (current.next != head) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;
        int target;
        int newValue;

        TestCase(int[] values, int target, int newValue) {
            this.target = target;
            this.newValue = newValue;
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
            // Make circular
            current.next = head;
        }
    }

    // Main method to test insert after value
    public static void main(String[] args) {
        InsertAfterValueCircular inserter = new InsertAfterValueCircular();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3}, 2, 4),      // Target exists
            new TestCase(new int[]{1, 2, 3}, 5, 4),      // Target does not exist
            new TestCase(new int[]{}, 1, 2),             // Empty list
            new TestCase(new int[]{5}, 5, 6),            // Single node, target exists
            new TestCase(new int[]{1, 1, 1}, 1, 2)       // Duplicates, insert after first
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + inserter.toString(test.head));
            System.out.println("Insert " + test.newValue + " after " + test.target);
            boolean result = inserter.insertAfterValue(test.head, test.target, test.newValue);
            System.out.println("Insertion successful: " + result);
            System.out.println("Updated list: " + inserter.toString(test.head) + "\n");
        }
    }
}
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3
Insert 4 after 2
Insertion successful: true
Updated list: 1 2 4 3

Test case 2:
Input list: 1 2 3
Insert 4 after 5
Insertion successful: false
Updated list: 1 2 3

Test case 3:
Input list: []
Insert 2 after 1
Insertion successful: false
Updated list: []

Test case 4:
Input list: 5
Insert 6 after 5
Insertion successful: true
Updated list: 5 6

Test case 5:
Input list: 1 1 1
Insert 2 after 1
Insertion successful: true
Updated list: 1 2 1 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Inserts 4 after first 2, resulting in 1→2→4→3→1.</li>
<li>Test case 2: Target 5 not found, list unchanged, returns false.</li>
<li>Test case 3: Empty list, no insertion, returns false.</li>
<li>Test case 4: Inserts 6 after 5 in single-node list, resulting in 5→6→5.</li>
<li>Test case 5: Inserts 2 after first 1 in 1→1→1→1, resulting in 1→2→1→1→1.</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a <code>next</code> pointer.</li>
<li><strong>insertAfterValue</strong>:
<ul>
<li>Returns false for empty lists.</li>
<li>Traverses the list in a loop, stopping at the first node with the target value or when returning to head.</li>
<li>If target is not found, returns false.</li>
<li>If found, inserts new node, updating <code>next</code> pointers, returns true.</li>
</ul>
</li>
<li><strong>toString</strong>: Traverses from head, uses a Set to prevent cycling, returns space-separated string or "[]".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→1, target=2, newValue=4.</li>
<li>current=1, no match, current=2, match.</li>
<li>newNode(4).next=3, 2.next=newNode.</li>
<li>Result: 1→2→4→3→1, return true.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests target exists, target does not exist, empty list, single node, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert After Value</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for insertAfterValue (traverse to find target); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for insertAfterValue (constant pointers); O(n) for toString (StringBuilder and Set).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a do-while loop to traverse the circular list and stop at the head to avoid infinite loops. Insert the new node by carefully updating <code>next</code> pointers to maintain the circular structure.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for the target value in one full cycle to handle cases where it doesn’t exist. Ensure proper handling of edge cases like empty or single-node lists to avoid null pointer issues.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../problemStatements/ch03_03_01/ReverseDoublyLinkedList.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../problemStatements/ch03_03_02/JosephusProblem.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../problemStatements/ch03_03_01/ReverseDoublyLinkedList.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../problemStatements/ch03_03_02/JosephusProblem.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/ferris.js"></script>


    </div>
    </body>
</html>
