<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MergeTwoSortedLists - Java Data Structures and Algorithms for Beginners</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/ferris.css">
        <link rel="stylesheet" href="../../theme/semantic-notes.css">
        <link rel="stylesheet" href="../../theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<h1 id="merge-two-sorted-lists"><a class="header" href="#merge-two-sorted-lists">Merge Two Sorted Lists</a></h1>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Write a Java program that merges two sorted singly linked lists into a single sorted linked list. Each linked list consists of nodes containing integer values in non-decreasing order. The program should merge the lists by comparing node values and constructing a new sorted list, preserving the sorted order. Test the implementation with different inputs, including empty lists, single-node lists, lists of varying lengths, and lists with duplicate values. You can visualize this as combining two sorted stacks of numbered cards into one sorted stack, picking the smaller card from the top of either stack each time.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Two sorted singly linked lists of integers (e.g., 1→3→5 and 2→4→6).
<strong>Output</strong>: A single sorted linked list as a string (e.g., "1 2 3 4 5 6").
<strong>Constraints</strong>:</li>
<li>The list sizes are between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>Both lists are sorted in non-decreasing order.</li>
<li>Either or both lists may be empty.
<strong>Example</strong>:</li>
<li>Input: list1 = 1→3→5, list2 = 2→4→6</li>
<li>Output: "1 2 3 4 5 6"</li>
<li>Explanation: Merges into a sorted list 1→2→3→4→5→6.</li>
<li>Input: list1 = [], list2 = []</li>
<li>Output: "[]"</li>
<li>Explanation: Merging two empty lists results in an empty list.</li>
<li>Input: list1 = 1→1, list2 = 1→2</li>
<li>Output: "1 1 1 2"</li>
<li>Explanation: Merges lists with duplicates into a sorted list.</li>
</ul>
<h2 id="pseudocode"><a class="header" href="#pseudocode">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION mergeTwoLists(list1, list2)
    CREATE dummy as new Node(0)
    SET tail to dummy
    SET current1 to list1
    SET current2 to list2
    WHILE current1 is not null AND current2 is not null
        IF current1.value &lt;= current2.value THEN
            SET tail.next to current1
            SET current1 to current1.next
        ELSE
            SET tail.next to current2
            SET current2 to current2.next
        ENDIF
        SET tail to tail.next
    ENDWHILE
    IF current1 is not null THEN
        SET tail.next to current1
    ELSE IF current2 is not null THEN
        SET tail.next to current2
    ENDIF
    RETURN dummy.next
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of pairs of linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL mergeTwoLists(testCase.list1, testCase.list2)
        PRINT merged list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps"><a class="header" href="#algorithm-steps">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>mergeTwoLists</code>:
a. Create a dummy node to simplify list construction.
b. Initialize <code>tail</code> to dummy, <code>current1</code> to list1, <code>current2</code> to list2.
c. While both lists have nodes:
<ul>
<li>Compare <code>current1.value</code> and <code>current2.value</code>.</li>
<li>Append smaller node to <code>tail.next</code>, advance corresponding pointer.</li>
<li>Move <code>tail</code> to appended node.
d. Append remaining nodes from list1 or list2, if any.
e. Return <code>dummy.next</code> as the merged list head.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse the list, append each value to a StringBuilder with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with non-empty lists, empty lists, single-node lists, and lists with duplicates.</li>
</ol>
<h2 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h2>
<pre><code class="language-java">public class MergeTwoSortedLists {
    // Node class for the linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Merges two sorted linked lists
    public Node mergeTwoLists(Node list1, Node list2) {
        Node dummy = new Node(0);
        Node tail = dummy;
        Node current1 = list1;
        Node current2 = list2;

        while (current1 != null &amp;&amp; current2 != null) {
            if (current1.value &lt;= current2.value) {
                tail.next = current1;
                current1 = current1.next;
            } else {
                tail.next = current2;
                current2 = current2.next;
            }
            tail = tail.next;
        }

        if (current1 != null) {
            tail.next = current1;
        } else if (current2 != null) {
            tail.next = current2;
        }

        return dummy.next;
    }

    // Converts linked list to string for output
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node list1;
        Node list2;

        TestCase(int[] values1, int[] values2) {
            // Create list1
            if (values1.length == 0) {
                list1 = null;
            } else {
                list1 = new Node(values1[0]);
                Node current = list1;
                for (int i = 1; i &lt; values1.length; i++) {
                    current.next = new Node(values1[i]);
                    current = current.next;
                }
            }
            // Create list2
            if (values2.length == 0) {
                list2 = null;
            } else {
                list2 = new Node(values2[0]);
                Node current = list2;
                for (int i = 1; i &lt; values2.length; i++) {
                    current.next = new Node(values2[i]);
                    current = current.next;
                }
            }
        }
    }

    // Main method to test merging sorted lists
    public static void main(String[] args) {
        MergeTwoSortedLists merger = new MergeTwoSortedLists();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 3, 5}, new int[]{2, 4, 6}), // Both non-empty
            new TestCase(new int[]{}, new int[]{}),              // Both empty
            new TestCase(new int[]{1}, new int[]{}),            // One empty
            new TestCase(new int[]{1, 1}, new int[]{1, 2}),     // Duplicates
            new TestCase(new int[]{1, 2, 3}, new int[]{4})      // Different lengths
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("List 1: " + merger.toString(test.list1));
            System.out.println("List 2: " + merger.toString(test.list2));
            Node merged = merger.mergeTwoLists(test.list1, test.list2);
            System.out.println("Merged list: " + merger.toString(merged) + "\n");
        }
    }
}
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
List 1: 1 3 5
List 2: 2 4 6
Merged list: 1 2 3 4 5 6

Test case 2:
List 1: []
List 2: []
Merged list: []

Test case 3:
List 1: 1
List 2: []
Merged list: 1

Test case 4:
List 1: 1 1
List 2: 1 2
Merged list: 1 1 1 2

Test case 5:
List 1: 1 2 3
List 2: 4
Merged list: 1 2 3 4
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Merges 1→3→5 and 2→4→6 into 1→2→3→4→5→6.</li>
<li>Test case 2: Both empty lists result in an empty list.</li>
<li>Test case 3: Merges 1 with empty list, resulting in 1.</li>
<li>Test case 4: Merges lists with duplicates 1→1 and 1→2 into 1→1→1→2.</li>
<li>Test case 5: Merges 1→2→3 and 4 into 1→2→3→4.</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a next pointer.</li>
<li><strong>mergeTwoLists</strong>:
<ul>
<li>Uses a dummy node to simplify list construction.</li>
<li>Compares nodes from both lists, appending the smaller to the result.</li>
<li>Advances the corresponding list’s pointer and moves the tail.</li>
<li>Appends any remaining nodes from either list.</li>
</ul>
</li>
<li><strong>toString</strong>: Converts the list to a space-separated string, returning "[]" for empty lists.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>list1: 1→3→5, list2: 2→4→6.</li>
<li>dummy→null, tail=dummy, current1=1, current2=2.</li>
<li>Step 1: 1≤2, dummy→1, current1=3, tail=1.</li>
<li>Step 2: 3&gt;2, dummy→1→2, current2=4, tail=2.</li>
<li>Step 3: 3≤4, dummy→1→2→3, current1=5, tail=3.</li>
<li>Step 4: 5&gt;4, dummy→1→2→3→4, current2=6, tail=4.</li>
<li>Step 5: 5≤6, dummy→1→2→3→4→5, current1=null, tail=5.</li>
<li>Step 6: Append 6, dummy→1→2→3→4→5→6.</li>
<li>Return: 1→2→3→4→5→6.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests non-empty lists, empty lists, one empty list, duplicates, and different lengths.</li>
</ul>
<h2 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Merge Two Lists</td><td>O(n + m)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n and m are the lengths of the two input lists.</li>
<li>Time complexity: O(n + m) for merging (single pass through both lists); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for merging (constant pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n + m) time, O(n + m) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a dummy node to simplify merging by avoiding special cases for the head. Compare values iteratively to maintain sorted order.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure pointers are updated correctly to avoid losing list segments. Handle empty list cases to prevent null pointer exceptions.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../problemStatements/ch03_03/CycleDetection.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../problemStatements/ch03_03/MiddleElementFinder.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../problemStatements/ch03_03/CycleDetection.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../problemStatements/ch03_03/MiddleElementFinder.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/ferris.js"></script>


    </div>
    </body>
</html>
