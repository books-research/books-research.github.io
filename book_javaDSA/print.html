<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Java Data Structures and Algorithms for Beginners</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Java Data Structures and Algorithms for Beginners</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
body {
  text-align: justify;
}
</style>
<p><strong>Book Title: Java Data Structures and Algorithms for Beginners</strong></p>
<p><strong>Author:</strong> Anirudha Anil Gaikwad</a></p>
<p><strong>Co-Author:</strong> Atit Anil Gaikwad</p>
<p><strong>Name of Publisher:</strong> Anirudha Anil Gaikwad</p>
<p><strong>ISBN Number:</strong> 978-93-343-8254-9</p>
<p><strong>Language:</strong> English<br />
<strong>Country of Publication:</strong> India</p>
<p><strong>Date of Publication:</strong> 30/08/2025</p>
<p><strong>Product Form:</strong> Digital online<br />
<strong>Product Composition:</strong> Single-component retail product</p>
<p>Copyright © 2025 Anirudha Anil Gaikwad<br />
All rights reserved by the author(s). No part of this digital publication may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, electronic or mechanical, including photocopy, recording, or any information storage and retrieval system, without prior written permission of the author(s).</p>
<p><strong>Design &amp; Layout:</strong> Anirudha Anil Gaikwad</p>
<p>Digital Edition | eBook | Published in India</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Welcome to <em>Java Data Structures and Algorithms for Beginners</em>, an introductory guide to one of the most important topics in computer science — <strong>data structures</strong> — using the Java programming language.</p>
<blockquote>
<p>This book, <strong>Java Data Structures and Algorithms for Beginners</strong>, is designed for students, new programmers, and anyone starting their journey into understanding how data structures work in Java. It aims to simplify concepts while providing practical examples you can run and explore.</p>
</blockquote>
<p>Data structures form the backbone of efficient software. They allow you to store, organize, and manipulate data in ways that make programs faster, more reliable, and easier to maintain. Whether you’re creating a simple to-do app or building a large-scale web service, understanding the right data structure for the job is essential.</p>
<p>Java provides a rich collection of <strong>built-in data structures</strong> in its standard library, from basic arrays to advanced collections like <code>HashMap</code> and <code>TreeSet</code>. This book will take you step-by-step from the very basics to slightly more advanced topics, with a strong focus on <strong>clear explanations and practical coding examples</strong>.</p>
<h3 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h3>
<p>This book is ideal for:</p>
<h3 id="students"><a class="header" href="#students">Students</a></h3>
<p>If you are learning Java or preparing for university/diploma-level programming courses, this book will give you a solid understanding of arrays, lists, stacks, queues, trees, graphs, and more.</p>
<h3 id="beginner-java-developers"><a class="header" href="#beginner-java-developers">Beginner Java Developers</a></h3>
<p>If you know the Java syntax but feel confused when it comes to selecting or implementing the right data structure, this book will help you build confidence.</p>
<h3 id="programming-enthusiasts"><a class="header" href="#programming-enthusiasts">Programming Enthusiasts</a></h3>
<p>Even if Java isn’t your main programming language, the concepts you learn here are transferable to many other languages like Python, C++, or Rust.</p>
<h3 id="job-seekers"><a class="header" href="#job-seekers">Job Seekers</a></h3>
<p>If you are preparing for interviews, this book will serve as a gentle starting point before diving into more challenging algorithmic problems.</p>
<h3 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h3>
<p>We recommend reading the chapters in sequence, as each chapter builds upon concepts introduced earlier. However, you can also jump to specific topics when needed.</p>
<p>You’ll find <strong>two types of chapters</strong> in this book:</p>
<ol>
<li><strong>Concept Chapters</strong> – Explain a data structure’s purpose, how it works internally, its operations, and time complexity.</li>
<li><strong>Practical Chapters</strong> – Show you how to implement the data structure in Java, with examples and small exercises.</li>
</ol>
<h3 id="chapter-overview"><a class="header" href="#chapter-overview">Chapter Overview</a></h3>
<p>This book is designed to guide beginners through <strong>Java Data Structures and Algorithms (DSA)</strong> step-by-step.<br />
Here’s a quick overview of what each chapter covers:</p>
<h3 id="1-getting-started-with-data-structures-algorithms-and-complexity"><a class="header" href="#1-getting-started-with-data-structures-algorithms-and-complexity">1️⃣ Getting Started with Data Structures, Algorithms, and Complexity</a></h3>
<p>Learn the basics of <strong>what DSA is</strong>, why it’s important, and how it affects the efficiency of your programs.<br />
We’ll also cover <strong>pseudocode</strong>, <strong>complexity analysis</strong>, and <strong>Big-O notation</strong> so you can evaluate algorithm performance.</p>
<h3 id="2-recursion"><a class="header" href="#2-recursion">2️⃣ Recursion</a></h3>
<p>Understand the concept of <strong>recursion</strong>, where a function calls itself to solve smaller subproblems.<br />
You’ll learn:</p>
<ul>
<li>How recursion works</li>
<li>Real-world examples like <strong>factorials</strong></li>
<li>Difference between <strong>recursion and iteration</strong></li>
<li><strong>Tail recursion</strong> and when to use it</li>
</ul>
<h3 id="3-core-data-structures"><a class="header" href="#3-core-data-structures">3️⃣ Core Data Structures</a></h3>
<p>Dive into the most important data structures:</p>
<ul>
<li><strong>Arrays</strong> – store data in a fixed-size list</li>
<li><strong>Strings</strong> – work with text</li>
<li><strong>Linked Lists</strong> – dynamic lists with connected nodes</li>
<li><strong>Stacks &amp; Queues</strong> – process data in LIFO/FIFO order</li>
<li><strong>Hashing</strong> – fast data lookup</li>
<li><strong>Trees &amp; Graphs</strong> – store and connect data in hierarchical and network structures</li>
</ul>
<h3 id="4-sorting-algorithms"><a class="header" href="#4-sorting-algorithms">4️⃣ Sorting Algorithms</a></h3>
<p>Learn how to arrange data efficiently:</p>
<ul>
<li><strong>Bubble Sort</strong> – simple but slow</li>
<li><strong>Selection Sort</strong> – select smallest/largest repeatedly</li>
<li><strong>Insertion Sort</strong> – build sorted lists step-by-step</li>
<li><strong>Merge Sort</strong> – efficient divide-and-conquer approach</li>
</ul>
<h3 id="5-searching-algorithms"><a class="header" href="#5-searching-algorithms">5️⃣ Searching Algorithms</a></h3>
<p>Discover how to find data in a collection:</p>
<ul>
<li><strong>Linear Search</strong> – check every element</li>
<li><strong>Binary Search</strong> – fast search in sorted lists</li>
</ul>
<h3 id="6-problem-solving-with-dsa"><a class="header" href="#6-problem-solving-with-dsa">6️⃣ Problem Solving with DSA</a></h3>
<p>Practice solving real coding challenges:</p>
<ul>
<li>Array problems</li>
<li>String problems</li>
<li>Linked list problems</li>
<li>Stack &amp; queue problems</li>
</ul>
<h3 id="-appendix"><a class="header" href="#-appendix">📎 Appendix</a></h3>
<p>Extra resources to help you:</p>
<ul>
<li><strong>Glossary of terms</strong></li>
<li><strong>Pseudocode symbols</strong></li>
<li><strong>Flowchart symbols</strong></li>
<li><strong>Java code templates</strong> for quick development</li>
</ul>
<h3 id="practice-oriented-learning"><a class="header" href="#practice-oriented-learning">Practice-Oriented Learning</a></h3>
<blockquote>
<p>This book takes a hands-on, practical approach to understanding data structure concepts for beginners. Rather than focusing only on theory, each chapter pairs clear explanations with step-by-step Java code examples, followed by small exercises you can try yourself. By actively implementing and experimenting with arrays, stacks, queues, and other structures, you’ll develop a stronger intuition for how they work and when to use them—turning abstract ideas into real programming skills.</p>
</blockquote>
<p>By the time you finish this book, you’ll not only know how each Java data structure works but also <strong>when and why to use it</strong> — a skill that will make your programs more efficient and your problem-solving sharper.</p>
<p>Let’s begin your journey into the world of Java Data Structures and Algorithms!</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="getting-started-with-data-structures-algorithms-and-complexity"><a class="header" href="#getting-started-with-data-structures-algorithms-and-complexity">Getting Started with Data Structures, Algorithms, and Complexity</a></h2>
<p>This chapter provides a <strong>beginner-friendly overview</strong> of what Data Structures and Algorithms (DSA) are, why they are important, and how they are measured in terms of efficiency.<br />
By the end of this chapter, you will have a <strong>clear understanding of the building blocks</strong> you’ll need before diving into each specific data structure or algorithm.</p>
<hr />
<h3 id="-what-youll-learn-in-this-chapter"><a class="header" href="#-what-youll-learn-in-this-chapter">📌 What You’ll Learn in This Chapter</a></h3>
<ul>
<li><strong>What is DSA?</strong> – Understanding the combination of Data Structures and Algorithms.</li>
<li><strong>What is an Algorithm?</strong> – Step-by-step instructions to solve a problem.</li>
<li><strong>Why Learn DSA?</strong> – Benefits in programming, efficiency, and career growth.</li>
<li><strong>Applications of DSA</strong> – Real-world areas where DSA is used.</li>
<li><strong>Impact of Using vs. Not Using DSA</strong> – How it affects program performance.</li>
<li><strong>Big-O Notation</strong> – Introduction to how we measure algorithm performance.</li>
<li><strong>Common Big-O Complexities</strong> – Examples like O(1), O(log n), O(n), O(n²).</li>
<li><strong>Algorithmic Complexity</strong> – Understanding time and space usage.</li>
<li><strong>Types of Complexity</strong> – Time Complexity vs. Space Complexity.</li>
</ul>
<hr />
<h3 id="-why-this-chapter-matters"><a class="header" href="#-why-this-chapter-matters">💡 Why This Chapter Matters</a></h3>
<p>Before you start coding, you need to understand <strong>why efficiency matters</strong>.<br />
Two solutions may solve the same problem, but one could take <strong>seconds</strong> while the other takes <strong>hours</strong>.<br />
By learning DSA fundamentals and complexity analysis, you’ll be able to:</p>
<ul>
<li>Choose the <strong>right approach</strong> for a problem.</li>
<li>Write programs that are <strong>faster</strong> and <strong>use less memory</strong>.</li>
<li>Develop skills that are highly valued in <strong>interviews and competitive programming</strong>.</li>
</ul>
<hr />
<h3 id="-next-steps"><a class="header" href="#-next-steps">🚀 Next Steps</a></h3>
<p>Start with <strong><a href="./ch01_01.html">What is DSA?</a></strong> and gradually work through each section.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="what-is-dsa"><a class="header" href="#what-is-dsa">What is DSA?</a></h2>
<p><strong>DSA</strong> stands for <strong>Data Structures and Algorithms</strong>. It refers to the study and implementation of data organization (data structures) and computational procedures (algorithms) to solve problems efficiently.</p>
<ul>
<li><strong>Data Structures</strong>: Ways to store and organize data in a computer so that it can be accessed and modified efficiently. Examples include arrays, linked lists, stacks, queues, trees, graphs, hash tables, etc.</li>
<li><strong>Algorithms</strong>: Step-by-step procedures or formulas for solving problems, such as sorting, searching, graph traversal, or dynamic programming.</li>
</ul>
<p>DSA is a cornerstone of efficient programming and problem-solving, applicable in virtually every area of software development and technology. Using DSA leads to faster, scalable, and cost-effective solutions, while neglecting it risks poor performance and limited career opportunities. Its scope spans from everyday apps to cutting-edge AI, making it an essential skill for developers and engineers.</p>
<p>▶ <strong>Next:</strong> <a href="./ch01_02.html">What is an Algorithm?</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="what-is-an-algorithm"><a class="header" href="#what-is-an-algorithm">What is an Algorithm?</a></h2>
<p>An <strong>algorithm</strong> is a <strong>step-by-step procedure</strong> or a <strong>set of instructions</strong> designed to perform a specific task or solve a problem.<br />
It is like a <strong>recipe</strong> in cooking — a list of steps you follow in a specific order to achieve the desired outcome.</p>
<h3 id="characteristics-of-a-good-algorithm"><a class="header" href="#characteristics-of-a-good-algorithm">Characteristics of a Good Algorithm</a></h3>
<ol>
<li><strong>Clear and Unambiguous</strong> – Each step is well-defined.</li>
<li><strong>Input</strong> – Takes zero or more inputs.</li>
<li><strong>Output</strong> – Produces at least one output.</li>
<li><strong>Finiteness</strong> – Completes after a finite number of steps.</li>
<li><strong>Effectiveness</strong> – Each step is basic enough to be performed exactly and in a reasonable time.</li>
</ol>
<h3 id="example-real-world"><a class="header" href="#example-real-world">Example (Real-World)</a></h3>
<p><strong>Making Tea Algorithm:</strong></p>
<ol>
<li>Boil water.</li>
<li>Add tea leaves.</li>
<li>Add sugar and milk.</li>
<li>Pour into a cup and serve.</li>
</ol>
<h3 id="here-each-step-is-clear-ordered-and-finite--just-like-in-programming"><a class="header" href="#here-each-step-is-clear-ordered-and-finite--just-like-in-programming">Here, each step is <strong>clear</strong>, <strong>ordered</strong>, and <strong>finite</strong> — just like in programming.</a></h3>
<hr />
<h3 id="example-of-an-algorithm--adding-two-numbers"><a class="header" href="#example-of-an-algorithm--adding-two-numbers">Example of an Algorithm – Adding Two Numbers</a></h3>
<p>Let’s take a very simple problem:</p>
<p><strong>Problem:</strong><br />
Write an algorithm to add two numbers and display the result.</p>
<h3 id="step-by-step-algorithm"><a class="header" href="#step-by-step-algorithm">Step-by-Step Algorithm</a></h3>
<ol>
<li><strong>Start</strong></li>
<li><strong>Input</strong> the first number.</li>
<li><strong>Input</strong> the second number.</li>
<li><strong>Add</strong> the two numbers.</li>
<li><strong>Output</strong> the result.</li>
<li><strong>End</strong></li>
</ol>
<h3 id="flowchart-representation"><a class="header" href="#flowchart-representation">Flowchart Representation</a></h3>
<p>Flowcharts are <strong>visual diagrams</strong> that show the steps of an algorithm using shapes and arrows.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>Easy to understand for beginners.</li>
<li>Shows the flow of logic visually.</li>
<li>Useful for planning before coding.</li>
</ul>
<h3 id="common-flowchart-symbols"><a class="header" href="#common-flowchart-symbols">Common Flowchart Symbols</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Symbol</th><th>Name</th><th>Purpose</th></tr></thead><tbody>
<tr><td>🔵 <strong>Oval</strong></td><td><strong>Start / End</strong></td><td>Indicates the start or end of the process</td></tr>
<tr><td>▭ <strong>Rectangle</strong></td><td><strong>Process</strong></td><td>Shows a task, step, or action to be performed</td></tr>
<tr><td>🔷 <strong>Diamond</strong></td><td><strong>Decision</strong></td><td>Represents a question or condition (Yes/No)</td></tr>
<tr><td>▱ <strong>Parallelogram</strong></td><td><strong>Input / Output</strong></td><td>Used for reading inputs or displaying outputs</td></tr>
<tr><td>➡ <strong>Arrow</strong></td><td><strong>Flow Line</strong></td><td>Shows the direction of process flow</td></tr>
<tr><td>🗂 <strong>Document Shape</strong></td><td><strong>Predefined Process</strong></td><td>Indicates a subroutine or pre-defined process</td></tr>
</tbody></table>
</div>
<hr />
<div style="text-align:center;">
    <img src="img/flowchart.svg" alt="flowchart" style="max-width:255px; height:auto;"/>
</div>
<h3 id="explanation-of-the-flowchart"><a class="header" href="#explanation-of-the-flowchart">Explanation of the Flowchart</a></h3>
<ul>
<li><strong>Start (A)</strong>: Represented by an oval, indicating the beginning of the algorithm.</li>
<li><strong>Input first number (B)</strong>: A parallelogram, showing the user inputs the first number.</li>
<li><strong>Input second number (C)</strong>: Another parallelogram, for inputting the second number.</li>
<li><strong>Add numbers (D)</strong>: A rectangle, representing the processing step where the two numbers are added.</li>
<li><strong>Display sum (E)</strong>: A parallelogram, indicating the output of the sum to the user.</li>
<li><strong>End (F)</strong>: An oval, marking the end of the algorithm.</li>
<li><strong>Arrows</strong>: Show the flow of execution from one step to the next.</li>
</ul>
<pre><code class="language-java">import java.util.Scanner;

public class AddTwoNumbers {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input
        System.out.print("Enter first number: ");
        int num1 = sc.nextInt();

        System.out.print("Enter second number: ");
        int num2 = sc.nextInt();

        // Processing
        int sum = num1 + num2;

        // Output
        System.out.println("Sum = " + sum);

        sc.close();
    }
}

</code></pre>
<hr />
<h3 id="-examples-of-algorithms-in-computer-science"><a class="header" href="#-examples-of-algorithms-in-computer-science">🔍 Examples of Algorithms in Computer Science</a></h3>
<ul>
<li><strong>Searching</strong>: Linear Search, Binary Search</li>
<li><strong>Sorting</strong>: Bubble Sort, Merge Sort</li>
<li><strong>Graph Traversal</strong>: BFS, DFS</li>
<li><strong>Dynamic Programming</strong>: Fibonacci, Knapsack</li>
</ul>
<hr />
<h3 id="-key-takeaway"><a class="header" href="#-key-takeaway">💡 Key Takeaway</a></h3>
<p>An algorithm is <strong>not code</strong> — it’s the <strong>logic and steps</strong> to solve a problem.<br />
You can write algorithms in <strong>plain language</strong>, <strong>pseudocode</strong>, or <strong>flowcharts</strong> before turning them into Java code.</p>
<hr />
<p>▶ <strong>Next:</strong> <a href="./ch01_03.html">What is Pseudocode and Flowchart?</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="what-is-pseudocode"><a class="header" href="#what-is-pseudocode">What is Pseudocode?</a></h2>
<p><strong>Pseudocode</strong> is a human-readable way to describe the steps of an algorithm without worrying about syntax of a specific programming language.<br />
It is written in plain English (or any natural language) but structured like code.</p>
<p><strong>Why use pseudocode?</strong></p>
<ul>
<li>Easy to understand for both technical and non-technical people.</li>
<li>Helps in planning before coding.</li>
<li>Reduces errors in implementation.</li>
</ul>
<h3 id="rules-for-writing-good-pseudocode"><a class="header" href="#rules-for-writing-good-pseudocode">Rules for Writing Good Pseudocode</a></h3>
<ol>
<li><strong>Use plain, simple language</strong> – avoid unnecessary jargon.</li>
<li><strong>Write one action per line</strong> – keep it clean.</li>
<li><strong>Use indentation</strong> – to represent loops or conditional blocks.</li>
<li><strong>Use standard keywords</strong> like:
<ul>
<li><code>START</code>, <code>END</code></li>
<li><code>IF</code>, <code>ELSE</code>, <code>ENDIF</code></li>
<li><code>FOR</code>, <code>WHILE</code>, <code>REPEAT</code></li>
<li><code>READ</code>, <code>PRINT</code>, <code>RETURN</code></li>
</ul>
</li>
<li><strong>Keep it language-independent</strong> – no need for Java, Python, or C++ syntax.</li>
<li><strong>Number your steps</strong> if sequence matters.</li>
</ol>
<h2 id="pseudocode-and-java-implementations"><a class="header" href="#pseudocode-and-java-implementations">Pseudocode and Java Implementations</a></h2>
<h3 id="example-1--find-if-a-number-is-even-or-odd"><a class="header" href="#example-1--find-if-a-number-is-even-or-odd">Example 1 – Find if a number is even or odd</a></h3>
<p><strong>Problem:</strong><br />
Write an algorithm to read a number and determine whether it is even or odd.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>1. START
2. READ number N
3. IF N mod 2 = 0 THEN
      PRINT "Even"
   ELSE
      PRINT "Odd"
4. END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class EvenOddCheck {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int N = sc.nextInt();

        if (N % 2 == 0) {
            System.out.println("Even");
        } else {
            System.out.println("Odd");
        }
    }
}
</code></pre>
<h3 id="example-2--sum-of-two-numbers"><a class="header" href="#example-2--sum-of-two-numbers">Example 2 – Sum of Two Numbers</a></h3>
<p><strong>Problem:</strong> Read two numbers and print their sum.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
READ A, B
SUM ← A + B
PRINT SUM
END

</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class SumOfTwoNumbers {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter first number: ");
        int A = sc.nextInt();
        System.out.print("Enter second number: ");
        int B = sc.nextInt();

        int SUM = A + B;
        System.out.println("Sum = " + SUM);
    }
}
</code></pre>
<h3 id="example-3--if-statement"><a class="header" href="#example-3--if-statement">Example 3 – IF Statement</a></h3>
<p><strong>Problem:</strong> Check if a number is positive.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
READ num
IF num &gt; 0 THEN
PRINT "Positive Number"
ENDIF
END

</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class PositiveCheck {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int num = sc.nextInt();

        if (num &gt; 0) {
            System.out.println("Positive Number");
        }
    }
}
</code></pre>
<h3 id="example-4--ifelse-statement"><a class="header" href="#example-4--ifelse-statement">Example 4 – IF...ELSE Statement</a></h3>
<p><strong>Problem:</strong> Check if a person is eligible to vote.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    READ age
    IF age &gt;= 18 THEN
        PRINT "Eligible to Vote"
    ELSE
        PRINT "Not Eligible to Vote"
    ENDIF
END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class VotingEligibility {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter your age: ");
        int age = sc.nextInt();

        if (age &gt;= 18) {
            System.out.println("Eligible to Vote");
        } else {
            System.out.println("Not Eligible to Vote");
        }
    }
}
</code></pre>
<h3 id="example-5--nested-if"><a class="header" href="#example-5--nested-if">Example 5 – Nested IF</a></h3>
<p><strong>Problem:</strong> Find the largest among three numbers.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    READ A, B, C
    IF A &gt; B THEN
        IF A &gt; C THEN
            PRINT "A is the largest"
        ELSE
            PRINT "C is the largest"
        ENDIF
    ELSE
        IF B &gt; C THEN
            PRINT "B is the largest"
        ELSE
            PRINT "C is the largest"
        ENDIF
    ENDIF
END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class LargestNumber {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter three numbers: ");
        int A = sc.nextInt();
        int B = sc.nextInt();
        int C = sc.nextInt();

        if (A &gt; B) {
            if (A &gt; C) {
                System.out.println("A is the largest");
            } else {
                System.out.println("C is the largest");
            }
        } else {
            if (B &gt; C) {
                System.out.println("B is the largest");
            } else {
                System.out.println("C is the largest");
            }
        }
    }
}
</code></pre>
<h3 id="example-6--nested-for-loop"><a class="header" href="#example-6--nested-for-loop">Example 6 – Nested FOR Loop</a></h3>
<p><strong>Problem:</strong> Print a multiplication table from 1 to 5.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    FOR i ← 1 TO 5 DO
        FOR j ← 1 TO 10 DO
            PRINT i × j
        ENDFOR
    ENDFOR
END
</code></pre>
<pre><code class="language-java">public class MultiplicationTable {
    public static void main(String[] args) {
        for (int i = 1; i &lt;= 5; i++) {
            for (int j = 1; j &lt;= 10; j++) {
                System.out.println(i + " x " + j + " = " + (i * j));
            }
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="example-7--while-loop"><a class="header" href="#example-7--while-loop">Example 7 – WHILE Loop</a></h3>
<p><strong>Problem:</strong> Print numbers from 1 to N.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    READ N
    i ← 1
    WHILE i &lt;= N DO
        PRINT i
        i ← i + 1
    ENDWHILE
END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class PrintNumbers {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter N: ");
        int N = sc.nextInt();

        int i = 1;
        while (i &lt;= N) {
            System.out.println(i);
            i++;
        }
    }
}
</code></pre>
<h3 id="example-8--repeat-until-loop-simulated-with-do-while-in-java"><a class="header" href="#example-8--repeat-until-loop-simulated-with-do-while-in-java">Example 8 – REPEAT UNTIL Loop (Simulated with do-while in Java)</a></h3>
<p><strong>Problem:</strong> Keep reading numbers until the user enters 0.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    REPEAT
        READ num
        PRINT num
    UNTIL num = 0
END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class RepeatUntilExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num;
        do {
            System.out.print("Enter a number (0 to stop): ");
            num = sc.nextInt();
            System.out.println("You entered: " + num);
        } while (num != 0);
    }
}
</code></pre>
<h3 id="example-9--if-with-andor-condition"><a class="header" href="#example-9--if-with-andor-condition">Example 9 – IF with AND/OR Condition</a></h3>
<p><strong>Problem:</strong> Check if a number is between 10 and 50.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    READ num
    IF num &gt;= 10 AND num &lt;= 50 THEN
        PRINT "Number is in range"
    ELSE
        PRINT "Number is out of range"
    ENDIF
END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class NumberRangeCheck {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int num = sc.nextInt();

        if (num &gt;= 10 &amp;&amp; num &lt;= 50) {
            System.out.println("Number is in range");
        } else {
            System.out.println("Number is out of range");
        }
    }
}
</code></pre>
<h3 id="example-10--combining-if-and-for"><a class="header" href="#example-10--combining-if-and-for">Example 10 – Combining IF and FOR</a></h3>
<p><strong>Problem:</strong> Print only even numbers between 1 and N.</p>
<p><strong>Pseudocode:</strong></p>
<pre><code>START
    READ N
    FOR i ← 1 TO N DO
        IF i MOD 2 = 0 THEN
            PRINT i
        ENDIF
    ENDFOR
END
</code></pre>
<pre><code class="language-java">import java.util.Scanner;

public class EvenNumbers {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter N: ");
        int N = sc.nextInt();

        for (int i = 1; i &lt;= N; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}
</code></pre>
<p>▶ <strong>Next:</strong> <a href="./ch01_04.html">Why Learn DSA?</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="why-learn-dsa"><a class="header" href="#why-learn-dsa">Why Learn DSA?</a></h2>
<p>DSA is fundamental in computer science and programming because it enables efficient problem-solving and resource management. Here’s why it’s important:</p>
<ol>
<li><strong>Efficiency</strong>: DSA optimizes the use of time and space resources. For example, choosing a hash table for quick lookups or a binary search tree for sorted data retrieval reduces computation time compared to less efficient structures like unsorted arrays.</li>
<li><strong>Scalability</strong>: Well-designed data structures and algorithms handle large datasets and complex computations effectively, critical for real-world applications like databases or machine learning models.</li>
<li><strong>Problem-Solving</strong>: DSA provides reusable frameworks to tackle recurring problems, such as finding the shortest path in a graph (e.g., Dijkstra’s algorithm) or sorting data (e.g., quicksort).</li>
<li><strong>Performance</strong>: Efficient algorithms reduce runtime and memory usage, which is vital for applications requiring real-time processing, like navigation systems or gaming.</li>
<li><strong>Career Advantage</strong>: Mastery of DSA is often a key requirement in technical interviews for software engineering roles at top companies, as it demonstrates problem-solving and analytical skills.</li>
</ol>
<p>▶ <strong>Next:</strong> <a href="./ch01_05.html">Applications of DSA (Where It’s Used)</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="applications-of-dsa-where-its-used"><a class="header" href="#applications-of-dsa-where-its-used">Applications of DSA (Where It’s Used)</a></h2>
<p>DSA is used across various domains in computer science and software development. Its scope includes:</p>
<ol>
<li>
<p><strong>Software Development</strong>:</p>
<ul>
<li><strong>Web Applications</strong>: Efficient data retrieval (e.g., databases using B-trees or hash indexes) and caching (e.g., LRU cache with hash maps and doubly linked lists).</li>
<li><strong>Mobile Apps</strong>: Optimizing battery and memory usage with compact data structures like arrays or efficient algorithms like greedy methods.</li>
<li><strong>Game Development</strong>: Pathfinding (A* algorithm), collision detection (spatial partitioning with quadtrees), and rendering optimizations.</li>
</ul>
</li>
<li>
<p><strong>System Design</strong>:</p>
<ul>
<li><strong>Databases</strong>: Indexing (B-trees, hash tables) and query optimization.</li>
<li><strong>Operating Systems</strong>: Process scheduling (priority queues), memory management (linked lists), and file systems (trees).</li>
<li><strong>Networking</strong>: Routing algorithms (Dijkstra’s, Bellman-Ford) and packet scheduling (queues).</li>
</ul>
</li>
<li>
<p><strong>Artificial Intelligence and Machine Learning</strong>:</p>
<ul>
<li><strong>AI</strong>: Graph algorithms for path planning in robotics or game AI (e.g., minimax with alpha-beta pruning).</li>
<li><strong>ML</strong>: Data preprocessing (sorting, hashing), clustering (k-d trees), and recommendation systems (matrix factorization, graphs).</li>
</ul>
</li>
<li>
<p><strong>Competitive Programming</strong>:</p>
<ul>
<li>DSA is the backbone of solving problems on platforms like LeetCode, Codeforces, or HackerRank, where efficiency is critical.</li>
</ul>
</li>
<li>
<p><strong>Big Data and Cloud Computing</strong>:</p>
<ul>
<li>Handling massive datasets with distributed algorithms (e.g., MapReduce) or optimized storage (e.g., Bloom filters for quick membership tests).</li>
</ul>
</li>
<li>
<p><strong>Embedded Systems and IoT</strong>:</p>
<ul>
<li>Resource-constrained environments rely on lightweight data structures (e.g., circular buffers) and algorithms to manage sensor data or communication.</li>
</ul>
</li>
<li>
<p><strong>Cybersecurity</strong>:</p>
<ul>
<li>Cryptographic algorithms (e.g., RSA, hash functions) and pattern matching for intrusion detection (e.g., KMP algorithm).</li>
</ul>
</li>
<li>
<p><strong>Everyday Tools</strong>:</p>
<ul>
<li>Search engines (inverted indexes, tries), GPS navigation (shortest path algorithms), and compression tools (Huffman coding).</li>
</ul>
</li>
</ol>
<h3 id="scope-in-practice"><a class="header" href="#scope-in-practice">Scope in Practice</a></h3>
<ul>
<li><strong>Tech Companies</strong>: FAANG (Google, Amazon, etc.) and startups emphasize DSA in interviews and product development for scalable systems.</li>
<li><strong>Open-Source Projects</strong>: Contributors use DSA to optimize codebases, e.g., in libraries like Apache Spark or TensorFlow.</li>
<li><strong>Research</strong>: DSA underpins advancements in fields like bioinformatics (sequence alignment with dynamic programming) or quantum computing.</li>
</ul>
<p>▶ <strong>Next:</strong> <a href="./ch01_06.html">Impact of Using vs. Not Using DSA</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="impact-of-using-vs-not-using-dsa"><a class="header" href="#impact-of-using-vs-not-using-dsa">Impact of Using vs. Not Using DSA</a></h2>
<h3 id="if-you-use-dsa"><a class="header" href="#if-you-use-dsa">If You Use DSA:</a></h3>
<ul>
<li><strong>Pros</strong>:
<ul>
<li>Faster execution: For example, using a binary search (O(log n)) instead of a linear search (O(n)) drastically reduces search time for large datasets.</li>
<li>Lower resource consumption: Efficient data structures like hash maps minimize memory usage compared to naive approaches.</li>
<li>Scalable solutions: Applications can handle increased data or user load without performance degradation.</li>
<li>Competitive edge: Strong DSA skills improve your ability to pass coding interviews and build robust software.</li>
</ul>
</li>
<li><strong>Example</strong>: In a social media app, using a graph data structure for friend recommendations (via BFS or DFS) is much faster than scanning all user data sequentially.</li>
</ul>
<h3 id="if-you-dont-use-dsa"><a class="header" href="#if-you-dont-use-dsa">If You Don’t Use DSA:</a></h3>
<ul>
<li><strong>Cons</strong>:
<ul>
<li>Poor performance: Inefficient solutions, like using nested loops for tasks that could be optimized with a hash table, lead to slow execution.</li>
<li>Scalability issues: Applications may crash or lag with large datasets due to unoptimized code.</li>
<li>Higher costs: Inefficient resource usage can increase server costs in cloud-based applications.</li>
<li>Limited career growth: Lack of DSA knowledge may hinder success in technical interviews or building high-performance systems.</li>
</ul>
</li>
<li><strong>Example</strong>: Without DSA, a search feature in an e-commerce app might scan every product linearly, causing delays for users, whereas a trie or inverted index could provide instant results.</li>
</ul>
<p>▶ <strong>Next:</strong> <a href="./ch01_07.html">Introduction to Big-O Notation</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="introduction-to-big-o-notation"><a class="header" href="#introduction-to-big-o-notation">Introduction to Big-O Notation</a></h2>
<p>Big O notation is a mathematical way to describe the performance or complexity of an algorithm, focusing on how it scales with input size ( n ). It provides an upper bound on the growth rate of an algorithm’s time or space requirements, typically in the worst-case scenario. It helps compare algorithms by abstracting away constants and lower-order terms to focus on the dominant behavior as ( n ) grows large.</p>
<p>By ignoring constants and less significant terms, Big-O focuses only on the dominant factor that affects performance when ( n ) becomes large.</p>
<h2 id="key-points"><a class="header" href="#key-points">Key Points:</a></h2>
<ul>
<li><strong>Purpose</strong>: Measures efficiency <strong>time complexity</strong> (execution time) or <strong>space complexity</strong> (memory usage) of algorithms.</li>
<li><strong>Focus</strong>: Describes worst-case performance unless specified otherwise.</li>
<li><strong>Notation</strong>: Expressed as ( O(f(n)) ), where ( f(n) ) is a function describing the upper bound.</li>
<li><strong>Why ignore constants?</strong>: Because as ( n ) grows, large-scale trends matter more than small-scale differences.</li>
</ul>
<h2 id="-example"><a class="header" href="#-example">📌 Example</a></h2>
<ul>
<li>A simple loop from ( 1 ) to ( n ) → <strong>O(n)</strong> (linear time).</li>
<li>Nested loops each running ( n ) times → <strong>O(n²)</strong> (quadratic time).</li>
</ul>
<p><strong>Key takeaway:</strong><br />
Big-O notation helps you <strong>predict scalability</strong>, not actual execution time. Two algorithms with different Big-O complexities might perform differently for small inputs, but the lower complexity will usually win for large ( n ).</p>
<p>▶ <strong>Next:</strong> <a href="./ch01_08.html">Common Big-O Complexities</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="common-big-o-complexities"><a class="header" href="#common-big-o-complexities">Common Big-O Complexities</a></h2>
<p>Big O notation categorizes algorithms based on their growth rates. Here are the most common types, ordered from fastest (most efficient) to slowest (least efficient):</p>
<ol>
<li>
<p><strong>O(1) - Constant Time</strong></p>
<ul>
<li>Execution time doesn’t depend on input size.</li>
<li>Example: Accessing an array element by index.</li>
<li>Graph: Flat line (no growth).</li>
</ul>
</li>
<li>
<p><strong>O(log n) - Logarithmic Time</strong></p>
<ul>
<li>Time grows logarithmically with input size.</li>
<li>Example: Binary search.</li>
<li>Graph: Very slow growth, flattens out.</li>
</ul>
</li>
<li>
<p><strong>O(n) - Linear Time</strong></p>
<ul>
<li>Time grows linearly with input size.</li>
<li>Example: Linear search through an array.</li>
<li>Graph: Straight line.</li>
</ul>
</li>
<li>
<p><strong>O(n log n) - Linearithmic Time</strong></p>
<ul>
<li>Time grows as ( n ) times the logarithm of ( n ).</li>
<li>Example: Efficient sorting algorithms like Merge Sort or Quick Sort.</li>
<li>Graph: Slightly steeper than linear.</li>
</ul>
</li>
<li>
<p><strong>O(n²) - Quadratic Time</strong></p>
<ul>
<li>Time grows quadratically with input size.</li>
<li>Example: Nested loops, like in Bubble Sort.</li>
<li>Graph: Parabolic curve.</li>
</ul>
</li>
<li>
<p><strong>O(n³) - Cubic Time</strong></p>
<ul>
<li>Time grows cubically with input size.</li>
<li>Example: Matrix multiplication with three nested loops.</li>
<li>Graph: Steep parabolic curve.</li>
</ul>
</li>
<li>
<p><strong>O(2ⁿ) - Exponential Time</strong></p>
<ul>
<li>Time doubles with each additional input.</li>
<li>Example: Solving the traveling salesman problem via brute force.</li>
<li>Graph: Extremely steep, quickly becomes impractical.</li>
</ul>
</li>
<li>
<p><strong>O(n!) - Factorial Time</strong></p>
<ul>
<li>Time grows factorially, extremely inefficient for large ( n ).</li>
<li>Example: Generating all permutations of a set.</li>
<li>Graph: Explosive growth, worst-case scenario.</li>
</ul>
</li>
</ol>
<h3 id="-frequently-used-big-o-complexities"><a class="header" href="#-frequently-used-big-o-complexities">📊 Frequently Used Big-O Complexities</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Notation</th><th>Name</th><th>Example Algorithm</th></tr></thead><tbody>
<tr><td><strong>O(1)</strong></td><td>Constant</td><td>Accessing an array element</td></tr>
<tr><td><strong>O(log n)</strong></td><td>Logarithmic</td><td>Binary search</td></tr>
<tr><td><strong>O(n)</strong></td><td>Linear</td><td>Iterating through a list</td></tr>
<tr><td><strong>O(n log n)</strong></td><td>Log-linear</td><td>Merge sort, Quick sort (average)</td></tr>
<tr><td><strong>O(n²)</strong></td><td>Quadratic</td><td>Bubble sort</td></tr>
<tr><td><strong>O(2ⁿ)</strong></td><td>Exponential</td><td>Recursive Fibonacci</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="-related-notations"><a class="header" href="#-related-notations">🔍 Related Notations</a></h3>
<p>While <strong>Big-O</strong> describes the <strong>upper bound</strong> of growth rate:</p>
<ul>
<li><strong>Big Theta (Θ)</strong> → <strong>Tight bound</strong> (exact growth rate).</li>
<li><strong>Big Omega (Ω)</strong> → <strong>Lower bound</strong> (best-case or minimum growth).</li>
</ul>
<p>These are less commonly used in casual discussions but provide more precise performance characterizations.</p>
<hr />
<h3 id="-practical-use"><a class="header" href="#-practical-use">💡 Practical Use</a></h3>
<ul>
<li><strong>Algorithm Selection</strong>: Big-O helps developers pick algorithms that <strong>scale well</strong> with large datasets.</li>
<li><strong>Space Complexity</strong>: Big-O also applies to <strong>memory usage</strong>, not just time.</li>
<li><strong>Focus on Trends</strong>: Ignore constants and small terms — large input size behavior is what matters most.</li>
</ul>
<p>▶ <strong>Next:</strong> <a href="./ch01_09.html">What is Complexity?</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<style>
body {
  text-align: justify;
}
</style>
<h2 id="what-is-complexity"><a class="header" href="#what-is-complexity">What is Complexity?</a></h2>
<p>Complexity in computer science refers to the measure of resources an algorithm requires to solve a problem. These resources are typically <strong>time</strong> (how long the algorithm takes to run) and <strong>space</strong> (how much memory the algorithm uses). Complexity analysis helps evaluate an algorithm's efficiency, especially as the input size grows, allowing developers to choose the most suitable algorithm for a task.</p>
<h3 id="what-is-time-complexity"><a class="header" href="#what-is-time-complexity">What is Time Complexity?</a></h3>
<p><strong>Time complexity</strong> describes the amount of time an algorithm takes to complete as a function of the input size ( n ). It focuses on the number of operations executed, ignoring constant factors and hardware-specific details. Time complexity is usually expressed using <strong>Big O notation</strong>, which provides an upper bound on the growth rate in the worst-case scenario.</p>
<ul>
<li><strong>Key Points</strong>:
<ul>
<li>Measures how the runtime scales with input size.</li>
<li>Expressed as ( O(f(n)) ), e.g., ( O(n) ), ( O(n^2) ), etc.</li>
<li>Common in analyzing loops, recursive calls, or operations like comparisons and assignments.</li>
<li><strong>Example</strong>: A linear search checking each element in an array has ( O(n) ) time complexity because it may need to inspect all ( n ) elements.</li>
</ul>
</li>
</ul>
<h3 id="what-is-space-complexity"><a class="header" href="#what-is-space-complexity">What is Space Complexity?</a></h3>
<p><strong>Space complexity</strong> measures the amount of memory or storage an algorithm uses as a function of the input size ( n ). It includes both the <strong>auxiliary space</strong> (extra memory allocated during execution, like temporary arrays or recursion stacks) and the <strong>input space</strong> (memory for the input data).</p>
<ul>
<li><strong>Key Points</strong>:
<ul>
<li>Focuses on memory usage, including variables, data structures, and recursion stacks.</li>
<li>Also expressed using Big O notation.</li>
<li>Does not include the input size in some analyses if the algorithm modifies the input in place.</li>
<li><strong>Example</strong>: A recursive algorithm like naive Fibonacci has ( O(n) ) space complexity due to the recursion stack, even though its time complexity is ( O(2^n) ).</li>
</ul>
</li>
</ul>
<h3 id="examples-with-java-code"><a class="header" href="#examples-with-java-code">Examples with Java Code</a></h3>
<p>Below are examples illustrating time and space complexity, with comments for clarity.</p>
<h3 id="1-linear-search-on-time-o1-space"><a class="header" href="#1-linear-search-on-time-o1-space">1. Linear Search (O(n) Time, O(1) Space)</a></h3>
<pre><code class="language-java">public class LinearSearchExample {
    public static int linearSearch(int[] array, int target) {
        // Loop through each element
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i] == target) {
                return i; // Return index if found
            }
        }
        return -1; // Not found
    }
    
    public static void main(String[] args) {
        int[] array = {10, 20, 30, 40, 50};
        int target = 30;
        
        // Time complexity: O(n) - may need to check all n elements
        // Space complexity: O(1) - uses only a few variables (i, target)
        int result = linearSearch(array, target);
        System.out.println("Index of " + target + ": " + result);
    }
}
</code></pre>
<ul>
<li><strong>Time Complexity</strong>: ( O(n) ), as it may iterate through all ( n ) elements.</li>
<li><strong>Space Complexity</strong>: ( O(1) ), as it uses only a constant amount of extra memory (variables <code>i</code> and <code>target</code>).</li>
</ul>
<h3 id="2-merge-sort-on-log-n-time-on-space"><a class="header" href="#2-merge-sort-on-log-n-time-on-space">2. Merge Sort (O(n log n) Time, O(n) Space)</a></h3>
<pre><code class="language-java">public class MergeSortExample {
    private static void merge(int[] array, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] leftArray = new int[n1]; // Temporary array
        int[] rightArray = new int[n2]; // Temporary array
        
        for (int i = 0; i &lt; n1; i++) leftArray[i] = array[left + i];
        for (int j = 0; j &lt; n2; j++) rightArray[j] = array[mid + 1 + j];
        
        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (leftArray[i] &lt;= rightArray[j]) {
                array[k++] = leftArray[i++];
            } else {
                array[k++] = rightArray[j++];
            }
        }
        while (i &lt; n1) array[k++] = leftArray[i++];
        while (j &lt; n2) array[k++] = rightArray[j++];
    }
    
    public static void mergeSort(int[] array, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            mergeSort(array, left, mid); // Recurse on left half
            mergeSort(array, mid + 1, right); // Recurse on right half
            merge(array, left, mid, right); // Merge results
        }
    }
    
    public static void main(String[] args) {
        int[] array = {12, 11, 13, 5, 6, 7};
        
        // Time complexity: O(n log n) - log n levels of recursion, each doing O(n) work
        // Space complexity: O(n) - temporary arrays for merging
        mergeSort(array, 0, array.length - 1);
        
        System.out.print("Sorted array: ");
        for (int num : array) System.out.print(num + " ");
    }
}
</code></pre>
<ul>
<li><strong>Time Complexity</strong>: ( O(n \log n) ), as the array is divided into ( \log n ) levels, and each level involves ( O(n) ) merging work.</li>
<li><strong>Space Complexity</strong>: ( O(n) ), due to the temporary arrays (<code>leftArray</code> and <code>rightArray</code>) used during merging.</li>
</ul>
<h3 id="key-differences-between-time-and-space-complexity"><a class="header" href="#key-differences-between-time-and-space-complexity">Key Differences Between Time and Space Complexity</a></h3>
<ul>
<li><strong>Time Complexity</strong>:
<ul>
<li>Concerns the number of operations or runtime.</li>
<li>Affected by loops, recursion, or function calls.</li>
<li>Example: A nested loop over ( n ) elements results in ( O(n^2) ) time.</li>
</ul>
</li>
<li><strong>Space Complexity</strong>:
<ul>
<li>Concerns memory usage.</li>
<li>Affected by variables, data structures, or recursion stacks.</li>
<li>Example: Creating a new array of size ( n ) results in ( O(n) ) space.</li>
</ul>
</li>
</ul>
<h3 id="why-analyze-complexity"><a class="header" href="#why-analyze-complexity">Why Analyze Complexity?</a></h3>
<ul>
<li><strong>Scalability</strong>: Predicts how an algorithm performs with large inputs.</li>
<li><strong>Trade-offs</strong>: Helps balance time vs. space (e.g., a faster algorithm might use more memory).</li>
<li><strong>Optimization</strong>: Guides developers to choose or design efficient algorithms.</li>
</ul>
<p>▶ <strong>Next:</strong> <a href="./ch01_10.html">Common Algorithmic Complexities with Examples</a></p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="common-algorithmic-complexities-with-examples"><a class="header" href="#common-algorithmic-complexities-with-examples">Common Algorithmic Complexities with Examples</a></h2>
<h3 id="1-o1---constant-time"><a class="header" href="#1-o1---constant-time">1. O(1) - Constant Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Accessing an element in an array by index.</li>
<li><strong>Time Complexity</strong>: O(1) - The operation takes a fixed amount of time regardless of the array size.</li>
<li><strong>Space Complexity</strong>: O(1) - No additional space is used beyond the input array.</li>
</ul>
<pre><code class="language-java">public class ConstantTimeExample {
    public static void main(String[] args) {
        int[] array = {10, 20, 30, 40, 50}; // Sample array
        int index = 2; // Index to access
        
        // Accessing the element at the given index
        // This operation is O(1) because it directly jumps to the memory location
        // without iterating or depending on the array size.
        int element = array[index];
        System.out.println("Element at index " + index + ": " + element);
    }
}
</code></pre>
<h3 id="2-olog-n---logarithmic-time"><a class="header" href="#2-olog-n---logarithmic-time">2. O(log n) - Logarithmic Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Binary search on a sorted array.</li>
<li><strong>Time Complexity</strong>: O(log n) - The search space is halved with each step.</li>
<li><strong>Space Complexity</strong>: O(1) - Only a few variables are used, no extra space proportional to input.</li>
</ul>
<pre><code class="language-java">public class LogarithmicTimeExample {
    public static int binarySearch(int[] sortedArray, int target) {
        int left = 0; // Start of the search range
        int right = sortedArray.length - 1; // End of the search range
        
        // Loop until the search range is exhausted
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Calculate middle index to avoid overflow
            
            // If target is found at mid, return the index
            if (sortedArray[mid] == target) {
                return mid;
            }
            // If target is larger, ignore left half
            else if (sortedArray[mid] &lt; target) {
                left = mid + 1;
            }
            // If target is smaller, ignore right half
            else {
                right = mid - 1;
            }
        }
        // Target not found
        return -1;
    }
    
    public static void main(String[] args) {
        int[] sortedArray = {2, 3, 4, 10, 40}; // Sorted array required for binary search
        int target = 10;
        
        // Binary search call
        // Time complexity is O(log n) because each step halves the search space,
        // e.g., for n=1024, it takes at most 10 comparisons.
        int result = binarySearch(sortedArray, target);
        System.out.println("Index of " + target + ": " + result);
    }
}
</code></pre>
<h3 id="3-on---linear-time"><a class="header" href="#3-on---linear-time">3. O(n) - Linear Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Linear search in an array.</li>
<li><strong>Time Complexity</strong>: O(n) - In the worst case, it checks every element.</li>
<li><strong>Space Complexity</strong>: O(1) - Only constant extra space for variables.</li>
</ul>
<pre><code class="language-java">public class LinearTimeExample {
    public static int linearSearch(int[] array, int target) {
        // Iterate through each element in the array
        for (int i = 0; i &lt; array.length; i++) {
            // Check if current element matches the target
            if (array[i] == target) {
                return i; // Return index if found
            }
        }
        return -1; // Return -1 if not found
    }
    
    public static void main(String[] args) {
        int[] array = {10, 20, 30, 40, 50}; // Sample array
        int target = 30;
        
        // Linear search call
        // Time complexity is O(n) because it may need to check all n elements
        // in the worst case (target not present or at the end).
        int result = linearSearch(array, target);
        System.out.println("Index of " + target + ": " + result);
    }
}
</code></pre>
<h3 id="4-on-log-n---linearithmic-time"><a class="header" href="#4-on-log-n---linearithmic-time">4. O(n log n) - Linearithmic Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Merge sort.</li>
<li><strong>Time Complexity</strong>: O(n log n) - Divides the array (log n levels) and merges (n work per level).</li>
<li><strong>Space Complexity</strong>: O(n) - Requires extra space for temporary arrays during merging.</li>
</ul>
<pre><code class="language-java">public class LinearithmicTimeExample {
    // Merge two sorted subarrays
    private static void merge(int[] array, int left, int mid, int right) {
        int n1 = mid - left + 1; // Size of left subarray
        int n2 = right - mid; // Size of right subarray
        
        int[] leftArray = new int[n1]; // Temporary array for left
        int[] rightArray = new int[n2]; // Temporary array for right
        
        // Copy data to temporary arrays
        for (int i = 0; i &lt; n1; i++) leftArray[i] = array[left + i];
        for (int j = 0; j &lt; n2; j++) rightArray[j] = array[mid + 1 + j];
        
        // Merge the temporary arrays back into the original
        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (leftArray[i] &lt;= rightArray[j]) {
                array[k++] = leftArray[i++];
            } else {
                array[k++] = rightArray[j++];
            }
        }
        // Copy remaining elements if any
        while (i &lt; n1) array[k++] = leftArray[i++];
        while (j &lt; n2) array[k++] = rightArray[j++];
    }
    
    // Recursive merge sort function
    public static void mergeSort(int[] array, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2; // Find midpoint
            
            // Recursively sort left and right halves
            mergeSort(array, left, mid);
            mergeSort(array, mid + 1, right);
            
            // Merge the sorted halves
            merge(array, left, mid, right);
        }
    }
    
    public static void main(String[] args) {
        int[] array = {12, 11, 13, 5, 6, 7}; // Sample unsorted array
        
        // Merge sort call
        // Time complexity is O(n log n): log n recursive levels, each doing O(n) work in merging.
        // Space is O(n) due to temporary arrays.
        mergeSort(array, 0, array.length - 1);
        
        System.out.print("Sorted array: ");
        for (int num : array) System.out.print(num + " ");
    }
}
</code></pre>
<h3 id="5-on²---quadratic-time"><a class="header" href="#5-on²---quadratic-time">5. O(n²) - Quadratic Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Bubble sort.</li>
<li><strong>Time Complexity</strong>: O(n²) - Two nested loops, each running up to n times.</li>
<li><strong>Space Complexity</strong>: O(1) - Sorts in place, no extra space needed.</li>
</ul>
<pre><code class="language-java">public class QuadraticTimeExample {
    public static void bubbleSort(int[] array) {
        int n = array.length;
        // Outer loop for each pass
        for (int i = 0; i &lt; n - 1; i++) {
            // Inner loop for comparing adjacent elements
            for (int j = 0; j &lt; n - i - 1; j++) {
                // Swap if current element is greater than next
                if (array[j] &gt; array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
    public static void main(String[] args) {
        int[] array = {64, 34, 25, 12, 22, 11, 90}; // Sample unsorted array
        
        // Bubble sort call
        // Time complexity is O(n²) due to nested loops: outer runs n-1 times,
        // inner runs up to n times per pass, leading to quadratic growth.
        bubbleSort(array);
        
        System.out.print("Sorted array: ");
        for (int num : array) System.out.print(num + " ");
    }
}
</code></pre>
<h3 id="6-on³---cubic-time"><a class="header" href="#6-on³---cubic-time">6. O(n³) - Cubic Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Naive matrix multiplication.</li>
<li><strong>Time Complexity</strong>: O(n³) - Three nested loops for n x n matrices.</li>
<li><strong>Space Complexity</strong>: O(n²) - Space for input and output matrices.</li>
</ul>
<pre><code class="language-java">public class CubicTimeExample {
    public static int[][] multiplyMatrices(int[][] A, int[][] B) {
        int n = A.length; // Assume square matrices
        int[][] result = new int[n][n]; // Output matrix
        
        // Three nested loops: i for rows of A, j for columns of B, k for dot product
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                for (int k = 0; k &lt; n; k++) {
                    result[i][j] += A[i][k] * B[k][j]; // Accumulate product
                }
            }
        }
        return result;
    }
    
    public static void main(String[] args) {
        int[][] A = {{1, 2}, {3, 4}}; // Sample matrix A
        int[][] B = {{5, 6}, {7, 8}}; // Sample matrix B
        
        // Matrix multiplication call
        // Time complexity is O(n³) because of three nested loops, each iterating n times.
        // Space is O(n²) for storing the result matrix.
        int[][] result = multiplyMatrices(A, B);
        
        System.out.println("Result matrix:");
        for (int[] row : result) {
            for (int val : row) System.out.print(val + " ");
            System.out.println();
        }
    }
}
</code></pre>
<h3 id="7-o2ⁿ---exponential-time"><a class="header" href="#7-o2ⁿ---exponential-time">7. O(2ⁿ) - Exponential Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Recursive Fibonacci (naive).</li>
<li><strong>Time Complexity</strong>: O(2ⁿ) - Each call branches into two more, leading to exponential calls.</li>
<li><strong>Space Complexity</strong>: O(n) - Due to recursion stack depth.</li>
</ul>
<pre><code class="language-java">public class ExponentialTimeExample {
    public static int fibonacci(int n) {
        // Base cases
        if (n &lt;= 1) return n;
        
        // Recursive calls: each branches into two
        // This leads to redundant computations and exponential time.
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    public static void main(String[] args) {
        int n = 10; // Small n to avoid long computation
        
        // Fibonacci call
        // Time complexity is O(2^n) because the recursion tree has about 2^n nodes.
        // Space is O(n) for the maximum recursion depth.
        int result = fibonacci(n);
        System.out.println("Fibonacci of " + n + ": " + result);
    }
}
</code></pre>
<h3 id="8-on---factorial-time"><a class="header" href="#8-on---factorial-time">8. O(n!) - Factorial Time</a></h3>
<ul>
<li><strong>Example Algorithm</strong>: Generating all permutations of an array (backtracking).</li>
<li><strong>Time Complexity</strong>: O(n!) - There are n! permutations, and each is generated in O(n) time.</li>
<li><strong>Space Complexity</strong>: O(n) - Recursion stack and temporary storage.</li>
</ul>
<pre><code class="language-java">import java.util.Arrays;

public class FactorialTimeExample {
    // Helper to swap elements
    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    // Recursive function to generate permutations
    public static void generatePermutations(int[] array, int start) {
        if (start == array.length - 1) {
            // Print permutation when base case is reached
            System.out.println(Arrays.toString(array));
            return;
        }
        
        // For each position, try swapping with all remaining elements
        for (int i = start; i &lt; array.length; i++) {
            swap(array, start, i); // Swap
            generatePermutations(array, start + 1); // Recurse
            swap(array, start, i); // Backtrack
        }
    }
    
    public static void main(String[] args) {
        int[] array = {1, 2, 3}; // Small array (n=3 has 6 permutations)
        
        // Permutations generation call
        // Time complexity is O(n!) because there are n! possible permutations,
        // and each is processed in O(n) time (printing/copying).
        // Space is O(n) for recursion depth.
        generatePermutations(array, 0);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<h3 id="definition-and-concepts"><a class="header" href="#definition-and-concepts">Definition and Concepts</a></h3>
<p>Recursion is a programming technique where a function solves a problem by calling itself with a smaller or simpler instance of the same problem. Each recursive call processes a subset of the input until a base case is reached, which provides a direct solution without further recursion. You can visualize recursion as a stack of nested function calls, where each call handles a smaller piece of the problem, and the stack unwinds as base cases are resolved. Recursion is a powerful approach for problems with a naturally hierarchical or repetitive structure, such as tree traversals or mathematical computations. In Java, recursion relies on the call stack to manage function calls and their local variables.</p>
<h3 id="why-use-it"><a class="header" href="#why-use-it">Why Use It?</a></h3>
<p>Recursion is used to simplify the solution to complex problems by breaking them into smaller, identical subproblems. It provides elegant and concise code for tasks like tree traversals, divide-and-conquer algorithms, and combinatorial problems. Recursion is particularly effective when a problem’s solution can be expressed in terms of itself, reducing the need for complex iterative loops. However, it requires careful design to avoid excessive memory usage or stack overflow errors.</p>
<h3 id="where-to-use-real-life-examples"><a class="header" href="#where-to-use-real-life-examples">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>File System Traversal</strong>: Operating systems use recursion to traverse directory structures, processing subdirectories and files hierarchically.</li>
<li><strong>Mathematical Computations</strong>: Recursion is used to compute factorials, Fibonacci numbers, or power functions in mathematical software.</li>
<li><strong>Tree and Graph Algorithms</strong>: Algorithms like depth-first search (DFS) or binary tree traversals (e.g., inorder, preorder) use recursion to explore nodes.</li>
<li><strong>Parsing Expressions</strong>: Compilers use recursion to parse nested expressions, such as evaluating <code>(2 + (3 * 4))</code>, by breaking them into sub-expressions.</li>
</ul>
<h3 id="svg-diagram"><a class="header" href="#svg-diagram">SVG Diagram</a></h3>
<p>The diagram for recursion would depict a stack of function calls for computing the factorial of 4 (e.g., <code>factorial(4)</code>). Each call would be a rectangular box labeled <code>factorial(n)</code>, with n decreasing from 4 to 0. Arrows would show the recursive calls downward (e.g., <code>factorial(4) -&gt; factorial(3) -&gt; factorial(2) -&gt; factorial(1) -&gt; factorial(0)</code>) and the return values upward (e.g., 1, 1, 2, 6, 24). The base case (<code>factorial(0) = 1</code>) would be highlighted. A caption would note: "Recursion breaks a problem into smaller subproblems, with each call stored on the call stack until the base case is reached."</p>
<h3 id="explain-operations"><a class="header" href="#explain-operations">Explain Operations</a></h3>
<ul>
<li><strong>Recursive Call</strong>: This operation involves a function calling itself with modified parameters to solve a smaller subproblem. The time complexity depends on the number of recursive calls and the work done per call.</li>
<li><strong>Base Case Check</strong>: This operation checks if the current input meets the base case condition, returning a direct result to terminate recursion. It has a time complexity of O(1).</li>
<li><strong>Parameter Modification</strong>: This operation adjusts the input parameters for the next recursive call to reduce the problem size. It typically has a time complexity of O(1).</li>
<li><strong>Stack Management</strong>: The Java call stack automatically manages recursive calls by storing each call’s state (parameters and local variables). The space complexity depends on the recursion depth.</li>
</ul>
<h3 id="java-implementation"><a class="header" href="#java-implementation">Java Implementation</a></h3>
<p>The following Java code implements two common recursive algorithms: factorial and Fibonacci.</p>
<pre><code class="language-java">public class RecursionExamples {
    // Factorial: Computes n! recursively
    public int factorial(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        if (n == 0 || n == 1) { // Base case: 0! = 1, 1! = 1
            return 1;
        }
        return n * factorial(n - 1); // Recursive case: n! = n * (n-1)!
    }

    // Fibonacci: Computes the nth Fibonacci number recursively
    public int fibonacci(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Fibonacci is not defined for negative numbers.");
        }
        if (n == 0) { // Base case: F(0) = 0
            return 0;
        }
        if (n == 1) { // Base case: F(1) = 1
            return 1;
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case: F(n) = F(n-1) + F(n-2)
    }
}
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Factorial Implementation</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>If <code>n</code> is 0 or 1 (base case), it returns 1.</li>
<li>Otherwise, it recursively calls <code>factorial(n-1)</code> and multiplies the result by <code>n</code>.</li>
<li>For example, <code>factorial(4)</code> computes <code>4 * factorial(3)</code>, which computes <code>3 * factorial(2)</code>, and so on, until <code>factorial(0)</code> returns 1.</li>
</ul>
</li>
<li><strong>Fibonacci Implementation</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>If <code>n</code> is 0 (base case), it returns 0; if <code>n</code> is 1 (base case), it returns 1.</li>
<li>Otherwise, it recursively calls <code>fibonacci(n-1)</code> and <code>fibonacci(n-2)</code> and returns their sum.</li>
<li>For example, <code>fibonacci(5)</code> computes <code>fibonacci(4) + fibonacci(3)</code>, which further breaks down until base cases are reached.</li>
</ul>
</li>
<li><strong>Stack Management</strong>: Each recursive call is pushed onto the Java call stack with its parameters and local variables. When a base case is reached, the stack unwinds, combining results to produce the final answer.</li>
</ol>
<h3 id="complexity-analysis-table"><a class="header" href="#complexity-analysis-table">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Factorial</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Fibonacci</td><td>O(2^n)</td><td>O(n)</td></tr>
<tr><td>Base Case Check</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Recursive Call</td><td>Varies</td><td>O(1) per call</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>Factorial has O(n) time complexity due to n recursive calls, each performing O(1) work.</li>
<li>Fibonacci has O(2^n) time complexity due to the exponential growth of recursive calls (two per level).</li>
<li>Space complexity for both is O(n) due to the maximum depth of the call stack.</li>
</ul>
<h3 id="key-differences--notes"><a class="header" href="#key-differences--notes">Key Differences / Notes</a></h3>
<ul>
<li><strong>Recursion vs. Iteration</strong>:
<ul>
<li>The implementation above uses recursion for simplicity and clarity. Iterative solutions (e.g., loops) can solve the same problems with O(1) space complexity but may be less intuitive for hierarchical problems.</li>
</ul>
</li>
<li><strong>Tail Recursion</strong>: Java does not optimize tail recursion, so recursive calls consume stack space. Tail-recursive algorithms (where the recursive call is the last operation) can be optimized in other languages but not in Java.</li>
<li><strong>Memoization</strong>: The Fibonacci implementation is inefficient due to redundant calculations. Memoization (caching results) can reduce its time complexity to O(n).</li>
<li><strong>Java’s Stack Limitations</strong>: Deep recursion can cause a <code>StackOverflowError</code>. Use iteration or increase the stack size for large inputs.</li>
</ul>
<h3 id="static-storage-allocation-in-recursion"><a class="header" href="#static-storage-allocation-in-recursion">Static Storage Allocation in Recursion</a></h3>
<p>Static storage allocation refers to memory allocation that is fixed at compile time and remains constant throughout a program’s execution. In the context of recursion, static storage allocation applies to variables declared as <code>static</code> in Java, which are shared across all calls to a recursive function. These variables are allocated once in the program’s data segment and persist for the program’s lifetime. For recursive algorithms, static variables can be used to store shared state across recursive calls, such as a counter or accumulator, but they are not typically used for local variables in recursion. In the provided <code>factorial</code> and <code>fibonacci</code> implementations, static storage allocation is not used, as each recursive call relies on local variables stored on the call stack. Static allocation is memory-efficient for shared data but can lead to issues in recursive functions if not managed carefully, as all recursive calls access the same variable, potentially causing unintended side effects.</p>
<h3 id="dynamic-storage-allocation"><a class="header" href="#dynamic-storage-allocation">Dynamic Storage Allocation</a></h3>
<p>Dynamic storage allocation refers to memory allocation that occurs at runtime, typically on the heap or call stack, and can vary in size during program execution. In recursion, dynamic storage allocation is critical because each recursive call allocates memory on the Java call stack for its local variables, parameters, and return address. In the provided <code>factorial</code> implementation, each call allocates space for the parameter <code>n</code> and temporary results. In the <code>fibonacci</code> implementation, each call allocates space for <code>n</code> and intermediate sums. This dynamic allocation enables recursion to handle varying problem sizes but increases space complexity, as the stack grows with each recursive call until the base case is reached. Excessive recursion depth can lead to a <code>StackOverflowError</code> if the stack size is exceeded. Dynamic allocation is essential for recursion but requires careful design to manage memory usage effectively</p>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursion for problems with a natural recursive structure, like tree traversals or divide-and-conquer algorithms. For efficiency, consider memoization or iteration for problems with overlapping subproblems, like Fibonacci.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious with deep recursion in Java, as it can lead to a <code>StackOverflowError</code> for large inputs due to dynamic allocation on the call stack. Always ensure base cases are reachable and consider iterative alternatives for performance-critical applications.</p>
</blockquote>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li><strong>Recursive Sum of Array</strong>: Write a Java program that uses recursion to compute the sum of elements in an array. Test it with arrays of different sizes.</li>
<li><strong>Reverse a String Recursively</strong>: Create a recursive method to reverse a string by breaking it into smaller substrings. Test with various strings, including empty and single-character cases.</li>
<li><strong>Binary Search Recursion</strong>: Implement a recursive binary search algorithm for a sorted array. Test it with arrays containing both existing and non-existing elements.</li>
<li><strong>Factorial with Memoization</strong>: Modify the factorial implementation to use memoization (e.g., with a HashMap) to cache results. Compare its performance with the original for large inputs.</li>
<li><strong>Tower of Hanoi</strong>: Write a recursive program to solve the Tower of Hanoi problem for n disks. Print the sequence of moves and test with different values of n.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="factorial-example-using-recursion"><a class="header" href="#factorial-example-using-recursion">Factorial Example using Recursion</a></h2>
<h3 id="what-is-factorial"><a class="header" href="#what-is-factorial">What is Factorial?</a></h3>
<p>The factorial of a number <code>n</code> (written as <code>n!</code>) is the product of all positive integers from <code>1</code> to <code>n</code>.<br />
Example: <code>5! = 5 × 4 × 3 × 2 × 1 = 120</code></p>
<h3 id="why-use-recursion-for-factorial"><a class="header" href="#why-use-recursion-for-factorial">Why use Recursion for Factorial?</a></h3>
<ul>
<li>Factorial definition is <strong>naturally recursive</strong>:<br />
<code>n! = n × (n-1)!</code></li>
<li>Short and clean code compared to iterative loops.</li>
</ul>
<h3 id="where-to-use-factorial-real-world-scenarios"><a class="header" href="#where-to-use-factorial-real-world-scenarios">Where to use Factorial (Real-world scenarios)</a></h3>
<ul>
<li>Probability &amp; statistics (e.g., permutations and combinations)</li>
<li>Scientific calculations</li>
<li>Combinatorics problems</li>
</ul>
<h3 id="java-example--recursive-factorial"><a class="header" href="#java-example--recursive-factorial">Java Example – Recursive Factorial</a></h3>
<pre><code class="language-java">public class FactorialRecursion {
    // Recursive function to find factorial
    static int factorial(int n) {
        if (n == 0) { // Base case: factorial of 0 is 1
            return 1;
        }
        return n * factorial(n - 1); // Recursive case
    }

    public static void main(String[] args) {
        int num = 5;
        System.out.println(num + "! = " + factorial(num));
    }
}
</code></pre>
<pre><code class="language-bash">5! = 120
</code></pre>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it works:</a></h3>
<ul>
<li>You call factorial(5) in main().</li>
<li>Since n is not 0, it does 5 × factorial(4).</li>
<li>To find factorial(4), it does 4 × factorial(3).</li>
<li>This keeps going until factorial(0) is called.</li>
<li>factorial(0) returns 1 (base case).</li>
<li>Now Java calculates:
factorial(1) → 1 × 1 = 1
factorial(2) → 2 × 1 = 2
factorial(3) → 3 × 2 = 6
factorial(4) → 4 × 6 = 24
factorial(5) → 5 × 24 = 120</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="recursion-vs-iteration"><a class="header" href="#recursion-vs-iteration">Recursion vs. Iteration</a></h2>
<h3 id="definition-and-concepts-1"><a class="header" href="#definition-and-concepts-1">Definition and Concepts</a></h3>
<p>Recursion and iteration are two fundamental programming techniques for solving repetitive problems. Recursion involves a function calling itself with a smaller or simpler instance of the same problem until a base case is reached, which provides a direct solution. Each recursive call is managed on the call stack, storing parameters and local variables. Iteration, in contrast, uses loops (e.g., for or while loops) to repeatedly execute a block of code until a condition is met, relying on variables to track state within a single function. You can visualize recursion as a stack of nested function calls that unwind, while iteration is a single loop cycling through updates. Both approaches can solve similar problems, but they differ in code structure, memory usage, and readability.</p>
<h3 id="why-use-it-1"><a class="header" href="#why-use-it-1">Why Use It?</a></h3>
<p>Recursion is used to simplify the solution to problems with a naturally hierarchical or self-referential structure, such as tree traversals or divide-and-conquer algorithms, offering concise and elegant code. Iteration is used when performance and memory efficiency are critical, as it avoids the overhead of multiple function calls and stack management. Choosing between recursion and iteration depends on the problem’s structure, performance requirements, and readability preferences. For example, recursion excels in problems like factorial computation for clarity, while iteration is preferred for large inputs to avoid stack overflow.</p>
<h3 id="where-to-use-real-life-examples-1"><a class="header" href="#where-to-use-real-life-examples-1">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Recursion in Tree Traversal</strong>: File systems use recursion to traverse directory trees, processing subdirectories hierarchically, as recursion naturally handles nested structures.</li>
<li><strong>Iteration in Data Processing</strong>: Data pipelines use iteration to process large datasets, such as summing values in a list, for efficiency and minimal memory usage.</li>
<li><strong>Recursion in Parsing</strong>: Compilers use recursion to parse nested expressions, like <code>(2 + (3 * 4))</code>, breaking them into sub-expressions.</li>
<li><strong>Iteration in Simulations</strong>: Game loops use iteration to update game states repeatedly, such as moving objects in a physics simulation, avoiding stack overhead.</li>
</ul>
<h3 id="svg-diagram-1"><a class="header" href="#svg-diagram-1">SVG Diagram</a></h3>
<p>The diagram would depict two side-by-side representations for computing factorial(4). On the left, recursion would show a stack of function calls (<code>factorial(4) -&gt; factorial(3) -&gt; factorial(2) -&gt; factorial(1)</code>), with arrows indicating recursive calls downward and return values (1, 2, 6, 24) upward. On the right, iteration would show a single loop with a variable <code>result</code> updating (1, 2, 6, 24) over iterations. A caption would note: "Recursion uses a call stack for nested calls, while iteration updates state in a loop, avoiding stack overhead."</p>
<h3 id="explain-operations-1"><a class="header" href="#explain-operations-1">Explain Operations</a></h3>
<ul>
<li><strong>Recursive Call (Recursion)</strong>: This operation involves a function calling itself with modified parameters to solve a smaller subproblem. It has a time complexity dependent on the number of calls and work per call.</li>
<li><strong>Base Case Check (Recursion)</strong>: This operation checks if the input meets a condition to terminate recursion, returning a direct result. It has a time complexity of O(1).</li>
<li><strong>Loop Execution (Iteration)</strong>: This operation repeatedly executes a block of code, updating variables until a condition is met. It has a time complexity dependent on the number of iterations.</li>
<li><strong>State Update (Iteration)</strong>: This operation modifies variables within a loop to track progress. It typically has a time complexity of O(1) per update.</li>
<li><strong>Stack Management (Recursion)</strong>: The Java call stack manages recursive calls, storing state for each call. It contributes to space complexity based on recursion depth.</li>
</ul>
<h3 id="java-implementation-1"><a class="header" href="#java-implementation-1">Java Implementation</a></h3>
<p>The following Java code implements the factorial algorithm using both recursion and iteration for comparison.</p>
<pre><code class="language-java">public class RecursionVsIteration {
    // Recursive Factorial: Computes n! recursively
    public int factorialRecursive(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        if (n == 0 || n == 1) { // Base case: 0! = 1, 1! = 1
            return 1;
        }
        return n * factorialRecursive(n - 1); // Recursive case: n! = n * (n-1)!
    }

    // Iterative Factorial: Computes n! iteratively
    public int factorialIterative(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        int result = 1; // Initializes result for factorial
        for (int i = 1; i &lt;= n; i++) { // Loops from 1 to n
            result *= i; // Updates result by multiplying with i
        }
        return result; // Returns final result
    }
}
</code></pre>
<h3 id="how-it-works-2"><a class="header" href="#how-it-works-2">How It Works</a></h3>
<ol>
<li><strong>Recursive Factorial</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>If <code>n</code> is 0 or 1 (base case), it returns 1.</li>
<li>Otherwise, it recursively calls <code>factorialRecursive(n-1)</code> and multiplies the result by <code>n</code>.</li>
<li>For example, <code>factorialRecursive(4)</code> computes <code>4 * factorialRecursive(3)</code>, which computes <code>3 * factorialRecursive(2)</code>, until <code>factorialRecursive(1)</code> returns 1, yielding 24.</li>
<li>Each call is pushed onto the call stack, consuming memory until the base case is reached.</li>
</ul>
</li>
<li><strong>Iterative Factorial</strong>:
<ul>
<li>The method checks if the input <code>n</code> is negative, throwing an exception if true.</li>
<li>It initializes a <code>result</code> variable to 1 and uses a for loop to multiply <code>result</code> by each integer from 1 to <code>n</code>.</li>
<li>For example, <code>factorialIterative(4)</code> iterates with <code>result = 1 * 1 * 2 * 3 * 4</code>, yielding 24.</li>
<li>The loop uses a single function frame, avoiding additional stack memory.</li>
</ul>
</li>
<li><strong>Comparison</strong>: Recursion creates multiple stack frames, increasing space complexity, while iteration uses a single frame, making it more memory-efficient.</li>
</ol>
<h3 id="complexity-analysis-table-1"><a class="header" href="#complexity-analysis-table-1">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Factorial</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iterative Factorial</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Base Case Check (Recursion)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Loop Execution (Iteration)</td><td>O(1) per iteration</td><td>O(1)</td></tr>
<tr><td>Stack Management (Recursion)</td><td>O(1) per call</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>Both recursive and iterative factorial have O(n) time complexity due to n multiplications.</li>
<li>Recursive factorial has O(n) space complexity due to n stack frames.</li>
<li>Iterative factorial has O(1) space complexity, as it uses only a few variables.</li>
</ul>
<h3 id="key-differences--notes-1"><a class="header" href="#key-differences--notes-1">Key Differences / Notes</a></h3>
<ul>
<li><strong>Code Readability</strong>:
<ul>
<li>Recursion offers concise, elegant code for problems with self-similar structures, like the recursive factorial, which mirrors the mathematical definition (n! = n * (n-1)!).</li>
<li>Iteration may require more lines of code but is often clearer for linear tasks, like the iterative factorial, avoiding stack management.</li>
</ul>
</li>
<li><strong>Performance</strong>:
<ul>
<li>Recursion incurs overhead from multiple function calls and stack management, which can lead to <code>StackOverflowError</code> for deep recursion in Java.</li>
<li>Iteration avoids this overhead, making it faster and more memory-efficient for large inputs.</li>
</ul>
</li>
<li><strong>Tail Recursion</strong>: Java does not optimize tail recursion, so recursive calls always consume stack space. Iterative solutions are preferred in Java for deep recursion.</li>
<li><strong>Use Cases</strong>:
<ul>
<li>Recursion is ideal for hierarchical problems (e.g., tree traversals, divide-and-conquer).</li>
<li>Iteration is better for linear or sequential tasks (e.g., summing arrays, simple loops).</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Choose recursion for problems with a natural recursive structure, like tree traversals or factorial, to improve readability. Use iteration for performance-critical tasks or large inputs to minimize memory usage and avoid stack overflow.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Deep recursion in Java can cause a <code>StackOverflowError</code> due to limited stack size. Always ensure recursive base cases are reachable and consider iterative alternatives for large-scale problems to optimize performance.</p>
</blockquote>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<ol>
<li><strong>Recursive vs. Iterative Sum</strong>: Write a Java program that computes the sum of an array using both recursive and iterative approaches. Compare their performance with large arrays.</li>
<li><strong>Reverse String Comparison</strong>: Implement string reversal using both recursion and iteration. Test with various strings and compare code readability and execution time.</li>
<li><strong>Power Function</strong>: Create recursive and iterative methods to compute x^n (x raised to the power n). Test with different inputs and analyze their space complexity.</li>
<li><strong>Fibonacci Optimization</strong>: Modify the recursive Fibonacci algorithm to use memoization, then compare it with an iterative Fibonacci implementation for performance on large inputs.</li>
<li><strong>Linked List Traversal</strong>: Using a singly linked list, implement recursive and iterative methods to traverse and print the list. Test both approaches and discuss their trade-offs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h2>
<h3 id="definition-and-concepts-2"><a class="header" href="#definition-and-concepts-2">Definition and Concepts</a></h3>
<p>Tail recursion is a special form of recursion where the recursive call is the last operation in the function, meaning no additional computation is performed after the recursive call returns. This allows certain programming languages to optimize tail-recursive calls by reusing the current function’s stack frame, avoiding the creation of new stack frames for each call. In a tail-recursive function, the result of the recursive call is directly returned, often with an accumulator parameter to track intermediate results. You can visualize tail recursion as a loop-like process where each recursive call updates the state and passes it to the next call until a base case is reached. In Java, however, tail recursion optimization is not supported, so tail-recursive functions still consume stack space, behaving like regular recursion.</p>
<h3 id="why-use-it-2"><a class="header" href="#why-use-it-2">Why Use It?</a></h3>
<p>Tail recursion is used to write recursive algorithms that can be optimized in languages that support tail call optimization (TCO), such as functional programming languages like Scala or Haskell, to prevent stack overflow and improve performance. It provides a clean, recursive approach to problems that might otherwise require iteration, maintaining readability while potentially achieving loop-like efficiency in TCO-supporting environments. In Java, tail recursion is less common due to the lack of TCO, but understanding it is valuable for designing recursive algorithms and preparing for languages or systems that optimize it. Tail recursion is particularly useful for problems with linear recursive structures, such as factorial or list traversal.</p>
<h3 id="where-to-use-real-life-examples-2"><a class="header" href="#where-to-use-real-life-examples-2">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Functional Programming</strong>: Languages like Scala use tail recursion to process large datasets, such as summing a list, to avoid stack overflow in recursive algorithms.</li>
<li><strong>Compiler Optimizations</strong>: Compilers for functional languages use tail recursion to optimize recursive parsing of expressions, like evaluating nested function calls.</li>
<li><strong>Event Loops in Simulations</strong>: Tail recursion can model event loops in simulations, such as cycling through states in a state machine, in TCO-supporting environments.</li>
<li><strong>Recursive Data Processing</strong>: Tail recursion is used in processing pipelines, like traversing a linked list to compute its length, in systems where TCO is available.</li>
</ul>
<h3 id="svg-diagram-2"><a class="header" href="#svg-diagram-2">SVG Diagram</a></h3>
<p>The diagram for tail recursion would depict a stack of function calls for computing the factorial of 4 using tail recursion (e.g., <code>factorialTail(4, 1)</code>). Each call would be a rectangular box labeled <code>factorialTail(n, acc)</code>, with <code>n</code> decreasing from 4 to 1 and <code>acc</code> (accumulator) updating (1, 4, 12, 24). Arrows would show recursive calls downward, with the base case (<code>n == 1</code>) returning the accumulator (24). A note would indicate that in TCO-supporting languages, the stack frame is reused, but in Java, new frames are created. A caption would note: "Tail recursion places the recursive call as the last operation, enabling stack frame reuse in TCO-supporting languages."</p>
<h3 id="explain-operations-2"><a class="header" href="#explain-operations-2">Explain Operations</a></h3>
<ul>
<li><strong>Tail-Recursive Call</strong>: This operation involves the function calling itself as its last action, passing updated parameters (often an accumulator) to the next call. The time complexity depends on the number of calls and work per call.</li>
<li><strong>Base Case Check</strong>: This operation checks if the input meets a condition to terminate recursion, returning the accumulator or result directly. It has a time complexity of O(1).</li>
<li><strong>Accumulator Update</strong>: This operation updates an accumulator parameter to track intermediate results, avoiding post-call computations. It typically has a time complexity of O(1).</li>
<li><strong>Stack Management</strong>: In TCO-supporting languages, the stack frame is reused for tail-recursive calls, resulting in O(1) space complexity. In Java, each call creates a new stack frame, leading to O(n) space complexity.</li>
</ul>
<h3 id="java-implementation-2"><a class="header" href="#java-implementation-2">Java Implementation</a></h3>
<p>The following Java code implements a tail-recursive factorial algorithm, using an accumulator to make it tail-recursive. A helper method is used to manage the accumulator.</p>
<pre><code class="language-java">public class TailRecursionExamples {
    // Factorial: Wrapper method for tail-recursive factorial
    public int factorial(int n) {
        if (n &lt; 0) { // Checks for invalid input
            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
        }
        return factorialTail(n, 1); // Calls tail-recursive helper with initial accumulator
    }

    // FactorialTail: Tail-recursive helper method for factorial
    private int factorialTail(int n, int acc) {
        if (n == 0 || n == 1) { // Base case: returns accumulator when n is 0 or 1
            return acc;
        }
        return factorialTail(n - 1, n * acc); // Tail-recursive call with updated accumulator
    }
}
</code></pre>
<h3 id="how-it-works-3"><a class="header" href="#how-it-works-3">How It Works</a></h3>
<ol>
<li><strong>Factorial Wrapper Method</strong>:
<ul>
<li>The <code>factorial</code> method validates the input <code>n</code>, throwing an exception if negative.</li>
<li>It calls the <code>factorialTail</code> helper method with <code>n</code> and an initial accumulator value of 1.</li>
</ul>
</li>
<li><strong>Tail-Recursive Factorial</strong>:
<ul>
<li>The <code>factorialTail</code> method checks if <code>n</code> is 0 or 1 (base case), returning the accumulator <code>acc</code> if true.</li>
<li>Otherwise, it makes a tail-recursive call to <code>factorialTail</code> with <code>n-1</code> and an updated accumulator <code>n * acc</code>.</li>
<li>For example, <code>factorialTail(4, 1)</code> calls <code>factorialTail(3, 4)</code>, then <code>factorialTail(2, 12)</code>, then <code>factorialTail(1, 24)</code>, which returns 24.</li>
<li>In Java, each call creates a new stack frame, unlike TCO-supporting languages where the stack frame would be reused.</li>
</ul>
</li>
<li><strong>Stack Management</strong>: In Java, the call stack grows with each recursive call, storing <code>n</code> and <code>acc</code> for each frame. When the base case is reached, the stack unwinds, returning the final accumulator value.</li>
</ol>
<h3 id="complexity-analysis-table-2"><a class="header" href="#complexity-analysis-table-2">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity (Java)</th><th>Space Complexity (TCO)</th></tr></thead><tbody>
<tr><td>Factorial (Tail)</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Base Case Check</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Accumulator Update</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Tail-Recursive Call</td><td>O(1) per call</td><td>O(1) per call</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>Time complexity is O(n) due to n recursive calls, each performing O(1) work.</li>
<li>In Java, space complexity is O(n) due to n stack frames.</li>
<li>In TCO-supporting languages, space complexity is O(1) due to stack frame reuse.</li>
</ul>
<h3 id="key-differences--notes-2"><a class="header" href="#key-differences--notes-2">Key Differences / Notes</a></h3>
<ul>
<li><strong>Tail Recursion vs. Regular Recursion</strong>:
<ul>
<li>The implementation above uses tail recursion, where the recursive call is the last operation, enabling potential optimization in TCO-supporting languages.</li>
<li>Regular recursion (e.g., <code>n * factorial(n-1)</code>) performs computations after the recursive call, requiring stack frames to store intermediate results.</li>
</ul>
</li>
<li><strong>Java’s Lack of TCO</strong>: Java does not optimize tail recursion, so tail-recursive functions consume O(n) stack space, similar to regular recursion. Use iteration in Java for deep recursion.</li>
<li><strong>TCO-Supporting Languages</strong>: Languages like Scala or Haskell optimize tail recursion, making it as efficient as iteration in terms of space complexity.</li>
<li><strong>Accumulator Usage</strong>: Tail recursion often uses an accumulator to pass intermediate results, avoiding post-call computations and simplifying the function’s structure.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use tail recursion when designing recursive algorithms for clarity, especially if targeting languages with tail call optimization. In Java, consider converting tail-recursive functions to iterative versions for better performance with large inputs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: In Java, tail recursion offers no performance benefit over regular recursion due to the lack of tail call optimization. Deep tail recursion can still cause a <code>StackOverflowError</code>, so use iteration for large-scale problems.</p>
</blockquote>
<h3 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h3>
<ol>
<li><strong>Tail-Recursive Sum</strong>: Write a Java program that computes the sum of an array using a tail-recursive function with an accumulator. Test it with arrays of different sizes.</li>
<li><strong>Tail-Recursive List Length</strong>: Implement a tail-recursive method to compute the length of a singly linked list. Compare it with an iterative version for readability and performance.</li>
<li><strong>Tail-Recursive Power</strong>: Create a tail-recursive method to compute x^n (x raised to the power n) using an accumulator. Test with various inputs and compare with an iterative approach.</li>
<li><strong>Reverse String Tail Recursion</strong>: Write a tail-recursive method to reverse a string using an accumulator to build the result. Test with different strings and discuss Java’s stack usage.</li>
<li><strong>Factorial Conversion</strong>: Convert the tail-recursive factorial implementation to an iterative version. Test both versions with large inputs and measure stack usage (e.g., by catching <code>StackOverflowError</code>).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h2>
<h3 id="what-are-core-data-structures"><a class="header" href="#what-are-core-data-structures">What are Core Data Structures?</a></h3>
<p>Core data structures are the basic ways of organizing and storing data so that it can be used efficiently.<br />
They are the <em>building blocks</em> of all programs — from a simple calculator app to large-scale social media platforms.</p>
<h3 id="why-learn-core-data-structures"><a class="header" href="#why-learn-core-data-structures">Why Learn Core Data Structures?</a></h3>
<ul>
<li><strong>Efficiency:</strong> Choosing the right data structure can make programs run much faster.</li>
<li><strong>Problem Solving:</strong> Many real-world problems map directly to these structures.</li>
<li><strong>Foundation for Advanced DSA:</strong> You can’t master algorithms without knowing how data is stored and accessed.</li>
<li><strong>Interview Readiness:</strong> Core data structures are a favorite topic in technical interviews.</li>
</ul>
<h3 id="-what-you-will-learn-in-this-chapter"><a class="header" href="#-what-you-will-learn-in-this-chapter">📖 What You Will Learn in This Chapter</a></h3>
<p>This chapter introduces you to the most commonly used data structures, their uses, advantages, disadvantages, and Java implementations.</p>
<h3 id="1-array"><a class="header" href="#1-array">1. <strong>Array</strong></a></h3>
<ul>
<li>What is an Array and how it works.</li>
<li>How to store and access elements using indexes.</li>
<li>Limitations of arrays.</li>
<li>Real-life example: Managing a list of student marks.</li>
</ul>
<h3 id="2-strings"><a class="header" href="#2-strings">2. <strong>Strings</strong></a></h3>
<ul>
<li>How strings store sequences of characters.</li>
<li>String manipulation in Java.</li>
<li>Common operations like concatenation, searching, and substring extraction.</li>
<li>Real-life example: Checking if a password contains a special character.</li>
</ul>
<h3 id="3-linked-lists"><a class="header" href="#3-linked-lists">3. <strong>Linked Lists</strong></a></h3>
<ul>
<li>How nodes are connected using references.</li>
<li>Singly vs Doubly linked lists.</li>
<li>Adding, deleting, and traversing nodes.</li>
<li>Real-life example: Music playlist navigation.</li>
</ul>
<h3 id="4-stacks"><a class="header" href="#4-stacks">4. <strong>Stacks</strong></a></h3>
<ul>
<li>Last In, First Out (LIFO) principle.</li>
<li>Push, Pop, Peek operations.</li>
<li>Real-life example: Undo/Redo feature in editors.</li>
</ul>
<h3 id="5-queues"><a class="header" href="#5-queues">5. <strong>Queues</strong></a></h3>
<ul>
<li>First In, First Out (FIFO) principle.</li>
<li>Enqueue and Dequeue operations.</li>
<li>Variations like Circular Queue and Priority Queue.</li>
<li>Real-life example: Ticket booking system.</li>
</ul>
<h3 id="6-hashing"><a class="header" href="#6-hashing">6. <strong>Hashing</strong></a></h3>
<ul>
<li>Storing and retrieving data using key–value pairs.</li>
<li>Hash functions and hash tables.</li>
<li>Handling collisions.</li>
<li>Real-life example: Fast dictionary lookup.</li>
</ul>
<h3 id="7-trees"><a class="header" href="#7-trees">7. <strong>Trees</strong></a></h3>
<ul>
<li>Hierarchical data representation.</li>
<li>Types of trees: Binary, Binary Search Tree (BST), etc.</li>
<li>Traversal methods (Inorder, Preorder, Postorder).</li>
<li>Real-life example: Folder structure in your computer.</li>
</ul>
<h3 id="8-graphs"><a class="header" href="#8-graphs">8. <strong>Graphs</strong></a></h3>
<ul>
<li>Nodes (vertices) and connections (edges).</li>
<li>Directed vs Undirected graphs.</li>
<li>Representations: Adjacency Matrix and Adjacency List.</li>
<li>Real-life example: Social network connections.</li>
</ul>
<h2 id="-how-we-will-learn"><a class="header" href="#-how-we-will-learn">🛠 How We Will Learn</a></h2>
<p>For each data structure, we will cover:</p>
<ol>
<li><strong>Definition</strong> – What it is.</li>
<li><strong>Why</strong> – Advantages and limitations.</li>
<li><strong>Where to Use</strong> – Real-life scenarios.</li>
<li><strong>Java Implementation</strong> – With step-by-step explanations.</li>
<li><strong>Complexity Analysis</strong> – Understanding performance.</li>
</ol>
<h3 id="key-takeaway"><a class="header" href="#key-takeaway">Key Takeaway</a></h3>
<p>By the end of this chapter, you will be able to:</p>
<ul>
<li>Identify the right data structure for a problem.</li>
<li>Implement it in Java.</li>
<li>Analyze its performance.</li>
<li>Use it in real-world applications.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="array"><a class="header" href="#array">Array</a></h2>
<h3 id="definition-and-concepts-3"><a class="header" href="#definition-and-concepts-3">Definition and Concepts</a></h3>
<p>An array in Java is a fixed-size, ordered collection of elements of the same data type, stored in contiguous memory locations. Each element is accessed using an index, starting from 0. Arrays are one of the simplest and most fundamental data structures, providing direct access to elements through their indices. You can visualize an array as a row of boxes, where each box holds a value and is labeled with an index. In Java, arrays are objects, created using the <code>new</code> keyword, and their size is set at initialization and cannot be changed. Arrays are versatile and used for storing lists of data, such as numbers or objects, when the size is known in advance.</p>
<h4 id="key-points-1"><a class="header" href="#key-points-1">Key Points:</a></h4>
<ul>
<li>Arrays store elements of a single data type (e.g., <code>int</code>, <code>String</code>).</li>
<li>Elements are accessed using an index (e.g., <code>arr[0]</code> for the first element).</li>
<li>Arrays are fixed-size, meaning their length cannot be modified after creation.</li>
<li>Declaration uses square brackets: <code>dataType[] arrayName;</code>.</li>
<li>Memory allocation uses <code>new</code>: <code>arrayName = new dataType[size];</code>.</li>
</ul>
<h3 id="why-use-it-3"><a class="header" href="#why-use-it-3">Why Use It?</a></h3>
<p>Arrays are used to store and manipulate a fixed number of elements efficiently, offering O(1) time complexity for accessing and modifying elements due to their contiguous memory layout. They are ideal for scenarios where the data size is known and constant, providing a simple and fast way to organize data. Arrays serve as the foundation for many algorithms and data structures, such as sorting, searching, and matrix operations, due to their straightforward indexing and predictable performance.</p>
<h3 id="where-to-use-real-life-examples-3"><a class="header" href="#where-to-use-real-life-examples-3">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Data Storage</strong>: Spreadsheets use arrays to store numerical data in cells, enabling quick calculations and lookups.</li>
<li><strong>Image Processing</strong>: Image processing applications use arrays to store pixel intensities for grayscale images, with each element representing a pixel value.</li>
<li><strong>Game Development</strong>: Games use arrays to store player scores, level data, or coordinates, allowing fast access during gameplay.</li>
<li><strong>Algorithm Implementation</strong>: Sorting and searching algorithms, like quicksort or binary search, use arrays to process ordered or unordered data efficiently.</li>
</ul>
<!-- ### SVG Diagram
The diagram for an array would depict a horizontal row of boxes, each labeled with an index (e.g., 0, 1, 2, 3, 4) and containing a value (e.g., 5, 3, 8, 1, 9). Arrows would illustrate an **access** operation (e.g., retrieving `arr[2] = 8`) and a **modification** operation (e.g., setting `arr[3] = 7`). A caption would note: "An array in Java is a fixed-size, indexed collection of elements, allowing O(1) access and modification using indices." -->
<h3 id="explain-operations-3"><a class="header" href="#explain-operations-3">Explain Operations</a></h3>
<ul>
<li><strong>Initialization</strong>: This operation allocates memory for an array of a specified size and data type. It has a time complexity of O(n), where n is the array size.</li>
<li><strong>Access Element</strong>: This operation retrieves an element at a specific index. It has a time complexity of O(1).</li>
<li><strong>Modify Element</strong>: This operation updates an element at a specific index. It has a time complexity of O(1).</li>
<li><strong>Traverse Array</strong>: This operation visits all elements in the array, typically using a loop. It has a time complexity of O(n).</li>
<li><strong>Get Length</strong>: This operation returns the size of the array. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-3"><a class="header" href="#java-implementation-3">Java Implementation</a></h3>
<p>The following Java code demonstrates common array operations, including initialization, access, modification, traversal, and getting the length.</p>
<pre><code class="language-java">public class ArrayExamples {
    // Initialize: Creates an array with a specified size
    public int[] initializeArray(int size) {
        if (size &lt;= 0) {
            throw new IllegalArgumentException("Array size must be positive.");
        }
        return new int[size]; // Allocates array of specified size
    }

    // Access Element: Retrieves an element at a given index
    public int accessElement(int[] array, int index) {
        if (array == null || index &lt; 0 || index &gt;= array.length) {
            throw new IllegalArgumentException("Invalid index.");
        }
        return array[index]; // Returns element at specified index
    }

    // Modify Element: Updates an element at a given index
    public void modifyElement(int[] array, int index, int value) {
        if (array == null || index &lt; 0 || index &gt;= array.length) {
            throw new IllegalArgumentException("Invalid index.");
        }
        array[index] = value; // Updates element at specified index
    }

    // Traverse Array: Visits all elements in the array
    public void traverseArray(int[] array) {
        if (array == null || array.length == 0) {
            throw new IllegalArgumentException("Array is null or empty.");
        }
        for (int i = 0; i &lt; array.length; i++) {
            System.out.print(array[i] + " "); // Prints each element
        }
        System.out.println(); // New line after traversal
    }

    // Get Length: Returns the size of the array
    public int getLength(int[] array) {
        if (array == null) {
            throw new IllegalArgumentException("Array is null.");
        }
        return array.length; // Returns the array length
    }
}
</code></pre>
<h3 id="how-it-works-4"><a class="header" href="#how-it-works-4">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>:
<ul>
<li>The <code>initializeArray</code> method allocates an array of the specified size using <code>new int[size]</code>. All elements are initialized to 0 for <code>int</code> arrays.</li>
<li>For example, <code>initializeArray(5)</code> creates an array <code>[0, 0, 0, 0, 0]</code>.</li>
</ul>
</li>
<li><strong>Access Element</strong>:
<ul>
<li>The <code>accessElement</code> method retrieves the value at <code>array[index]</code> after validating the index to prevent exceptions.</li>
<li>For example, <code>accessElement(array, 2)</code> returns the element at index 2.</li>
</ul>
</li>
<li><strong>Modify Element</strong>:
<ul>
<li>The <code>modifyElement</code> method updates <code>array[index]</code> with the given <code>value</code> after validating the index.</li>
<li>For example, <code>modifyElement(array, 2, 8)</code> sets the element at index 2 to 8.</li>
</ul>
</li>
<li><strong>Traverse Array</strong>:
<ul>
<li>The <code>traverseArray</code> method uses a loop to visit each element, printing them in sequence.</li>
<li>For example, traversing <code>[5, 3, 8, 1, 9]</code> prints "5 3 8 1 9".</li>
</ul>
</li>
<li><strong>Get Length</strong>:
<ul>
<li>The <code>getLength</code> method returns <code>array.length</code>, the size of the array.</li>
<li>For example, <code>getLength(array)</code> for an array of 5 elements returns 5.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-3"><a class="header" href="#complexity-analysis-table-3">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Initialization</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Access Element</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Modify Element</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Traverse Array</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Get Length</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array.</li>
<li>Space complexity for initialization accounts for the memory allocated for all elements.</li>
</ul>
<h3 id="key-differences--notes-3"><a class="header" href="#key-differences--notes-3">Key Differences / Notes</a></h3>
<ul>
<li><strong>Array vs. ArrayList</strong>:
<ul>
<li>Arrays are fixed-size, while <code>ArrayList</code> supports dynamic resizing, making it suitable for collections that grow or shrink.</li>
<li>Arrays offer O(1) access and modification, while <code>ArrayList</code> has similar performance but with additional overhead for resizing.</li>
</ul>
</li>
<li><strong>Array vs. Jagged/Multidimensional Arrays</strong>:
<ul>
<li>A simple array is one-dimensional, while multidimensional arrays (e.g., 2D, 3D) organize data in multiple dimensions, and jagged arrays allow rows of varying lengths.</li>
<li>Multidimensional arrays are used for grid-like data, while simple arrays are for linear lists.</li>
</ul>
</li>
<li><strong>Memory Allocation</strong>:
<ul>
<li>Arrays allocate contiguous memory, ensuring fast access but requiring a fixed size at creation.</li>
</ul>
</li>
<li><strong>Primitive vs. Reference Types</strong>:
<ul>
<li>Arrays can store primitive types (e.g., <code>int</code>, <code>double</code>) or reference types (e.g., <code>String</code>, objects), with null initialization for reference types.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use arrays when the size of the data is fixed and known in advance to leverage their O(1) access and modification times. For simple linear data, arrays are more efficient than dynamic structures like <code>ArrayList</code>.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Always validate array indices before accessing or modifying elements to prevent <code>ArrayIndexOutOfBoundsException</code>. Avoid using arrays for collections that require frequent resizing, as this requires creating a new array and copying elements.</p>
</blockquote>
<h3 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h3>
<ol>
<li><strong>Array Reversal</strong>: Write a Java program that reverses an array in-place (without using extra space). Test with arrays of different sizes.</li>
<li><strong>Maximum Element</strong>: Implement a method to find the maximum element in an array. Test with arrays containing positive and negative numbers.</li>
<li><strong>Array Rotation</strong>: Create a program that rotates an array by k positions to the left. Test with different values of k and array sizes.</li>
<li><strong>Duplicate Finder</strong>: Write a method to check if an array contains duplicate elements. Test with sorted and unsorted arrays.</li>
<li><strong>Array Sorting</strong>: Implement a simple sorting algorithm (e.g., bubble sort) to sort an array in ascending order. Test with various input arrays.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="multidimensional-array"><a class="header" href="#multidimensional-array">Multidimensional Array</a></h2>
<h3 id="definition-and-concepts-4"><a class="header" href="#definition-and-concepts-4">Definition and Concepts</a></h3>
<p>A multidimensional array in Java is an array of arrays. It allows storing data in a tabular (row-column) format or even higher dimensions. You can visualize a multidimensional array as a grid for two-dimensional (2D) arrays, where each cell is accessed by row and column indices, or as a cube for three-dimensional (3D) arrays, with additional depth indices. This structure is ideal for representing structured data, such as matrices, tensors, or multi-level datasets. In Java, multidimensional arrays are implemented as arrays of references to other arrays, with each dimension adding a level of nesting. They are fixed-size, meaning dimensions are set during initialization and cannot be resized dynamically.</p>
<h4 id="what-is-a-multidimensional-array"><a class="header" href="#what-is-a-multidimensional-array">What is a Multidimensional Array?</a></h4>
<p>A multidimensional array in Java is an array of arrays. It allows storing data in a tabular (row-column) format or even higher dimensions.</p>
<h4 id="key-points-2"><a class="header" href="#key-points-2">Key Points:</a></h4>
<ul>
<li>Two-dimensional (2D) arrays store data in a matrix format (rows and columns).</li>
<li>Three-dimensional (3D) arrays extend the concept further.</li>
<li>Each dimension is represented as an array of arrays.</li>
<li>Elements are accessed using multiple indices (e.g., <code>arr[row][col]</code> for 2D arrays).</li>
</ul>
<h4 id="declaration-and-initialization"><a class="header" href="#declaration-and-initialization">Declaration and Initialization</a></h4>
<p>A multidimensional array is declared using multiple square brackets <code>[ ]</code>.</p>
<pre><code class="language-java">dataType[][] arrayName; // 2D Array declaration
dataType[][][] arrayName; // 3D Array declaration
</code></pre>
<h4 id="memory-allocation-instantiation"><a class="header" href="#memory-allocation-instantiation">Memory Allocation (Instantiation)</a></h4>
<p>Once declared, memory needs to be allocated before usage.</p>
<pre><code class="language-java">arrayName = new dataType[rows][columns]; // 2D Array
arrayName = new dataType[depth][rows][columns]; // 3D Array
</code></pre>
<p>Multidimensional arrays provide efficient O(1) access to elements but require careful initialization to avoid null pointer exceptions. Higher-dimensional arrays (e.g., 3D or beyond) are less common but follow the same principle of nested arrays.</p>
<h3 id="why-use-it-4"><a class="header" href="#why-use-it-4">Why Use It?</a></h3>
<p>Multidimensional arrays are used to organize data in a structured, grid-like format for applications requiring tabular or hierarchical data representation, such as matrices or 3D models. They offer fast O(1) access and modification times due to contiguous memory allocation, making them suitable for performance-critical tasks. Multidimensional arrays are ideal when the data size is known in advance and does not require dynamic resizing, providing a simple and efficient way to handle multi-level data.</p>
<h3 id="where-to-use-real-life-examples-4"><a class="header" href="#where-to-use-real-life-examples-4">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Matrix Operations</strong>: Mathematical software uses multidimensional arrays to perform operations like matrix multiplication or determinant calculation in linear algebra.</li>
<li><strong>Image Processing</strong>: Image processing applications use 2D arrays to store pixel values, where each element represents a color or intensity at a specific row and column.</li>
<li><strong>Game Development</strong>: Board games or grid-based simulations use 2D arrays to represent game states, such as a chessboard or a grid-based maze.</li>
<li><strong>Scientific Simulations</strong>: Physics engines use 3D arrays to model spatial data, such as temperature distributions in a 3D space or voxel grids in simulations.</li>
</ul>
<!-- ### SVG Diagram

The diagram for a multidimensional array would depict a 2D array as a 3x3 grid of boxes, each labeled with an element (e.g., `arr[0][0] = 1`, `arr[0][1] = 2`, etc.). A 3D array would be shown as a stack of 2x2x2 cubes, with indices for depth, row, and column. Arrows would illustrate an **access** operation (e.g., retrieving `arr[1][2]` in a 2D array) and an **initialization** operation (e.g., allocating a 2x3 2D array). A caption would note: "Multidimensional arrays store data in a grid or higher-dimensional structure, accessed using multiple indices, such as `arr[row][col]` for 2D arrays." -->
<h3 id="explain-operations-4"><a class="header" href="#explain-operations-4">Explain Operations</a></h3>
<ul>
<li><strong>Initialization</strong>: This operation allocates memory for a multidimensional array by specifying the size of each dimension. It has a time complexity of O(n), where n is the total number of elements across all dimensions.</li>
<li><strong>Access Element</strong>: This operation retrieves an element at a specific set of indices (e.g., <code>arr[row][col]</code> for a 2D array). It has a time complexity of O(1).</li>
<li><strong>Modify Element</strong>: This operation updates an element at a specific set of indices. It has a time complexity of O(1).</li>
<li><strong>Traverse Array</strong>: This operation visits all elements in the multidimensional array using nested loops. It has a time complexity of O(n), where n is the total number of elements.</li>
<li><strong>Get Dimension Sizes</strong>: This operation returns the size of a specific dimension (e.g., number of rows or columns in a 2D array). It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-4"><a class="header" href="#java-implementation-4">Java Implementation</a></h3>
<p>The following Java code demonstrates common operations on a 2D multidimensional array, including initialization, access, modification, traversal, and getting dimension sizes.</p>
<pre><code class="language-java">public class MultidimensionalArrayExamples {
    // Initialize: Creates a 2D array with specified rows and columns
    public int[][] initialize2DArray(int rows, int cols) {
        if (rows &lt;= 0 || cols &lt;= 0) {
            throw new IllegalArgumentException("Rows and columns must be positive.");
        }
        int[][] array = new int[rows][cols]; // Allocates 2D array
        return array;
    }

    // Access Element: Retrieves an element at [row][col]
    public int accessElement(int[][] array, int row, int col) {
        if (array == null || row &lt; 0 || row &gt;= array.length || col &lt; 0 || col &gt;= array[0].length) {
            throw new IllegalArgumentException("Invalid row or column index.");
        }
        return array[row][col]; // Returns element at specified position
    }

    // Modify Element: Updates an element at [row][col]
    public void modifyElement(int[][] array, int row, int col, int value) {
        if (array == null || row &lt; 0 || row &gt;= array.length || col &lt; 0 || col &gt;= array[0].length) {
            throw new IllegalArgumentException("Invalid row or column index.");
        }
        array[row][col] = value; // Updates element at specified position
    }

    // Traverse Array: Visits all elements in the 2D array
    public void traverseArray(int[][] array) {
        if (array == null || array.length == 0) {
            throw new IllegalArgumentException("Array is null or empty.");
        }
        for (int i = 0; i &lt; array.length; i++) {
            for (int j = 0; j &lt; array[i].length; j++) {
                System.out.print(array[i][j] + " "); // Prints each element
            }
            System.out.println(); // New line after each row
        }
    }

    // Get Dimension Sizes: Returns the number of rows and columns
    public int[] getDimensionSizes(int[][] array) {
        if (array == null || array.length == 0) {
            throw new IllegalArgumentException("Array is null or empty.");
        }
        return new int[]{array.length, array[0].length}; // Returns [rows, cols]
    }
}
</code></pre>
<h3 id="how-it-works-5"><a class="header" href="#how-it-works-5">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>:
<ul>
<li>The <code>initialize2DArray</code> method allocates a 2D array with the specified number of rows and columns using <code>new int[rows][cols]</code>. All elements are initialized to 0 for <code>int</code> arrays.</li>
<li>For example, <code>initialize2DArray(3, 4)</code> creates a 3x4 matrix. For a 3D array, you would use <code>new int[depth][rows][cols]</code>.</li>
</ul>
</li>
<li><strong>Access Element</strong>:
<ul>
<li>The <code>accessElement</code> method retrieves the value at <code>array[row][col]</code> after validating the indices to prevent exceptions.</li>
<li>For example, <code>accessElement(array, 1, 2)</code> returns the element at row 1, column 2 in a 2D array.</li>
</ul>
</li>
<li><strong>Modify Element</strong>:
<ul>
<li>The <code>modifyElement</code> method updates <code>array[row][col]</code> with the given <code>value</code> after validating indices.</li>
<li>For example, <code>modifyElement(array, 1, 2, 5)</code> sets the element at row 1, column 2 to 5.</li>
</ul>
</li>
<li><strong>Traverse Array</strong>:
<ul>
<li>The <code>traverseArray</code> method uses nested loops to visit each element in the 2D array, printing them row by row. For a 3D array, an additional loop would iterate over the depth dimension.</li>
<li>For example, traversing a 2x3 array prints all elements in a grid format.</li>
</ul>
</li>
<li><strong>Get Dimension Sizes</strong>:
<ul>
<li>The <code>getDimensionSizes</code> method returns an array containing the number of rows (<code>array.length</code>) and columns (<code>array[0].length</code>) for a 2D array. For higher dimensions, additional lengths would be accessed (e.g., <code>array[0][0].length</code> for a 3D array).</li>
<li>For example, <code>getDimensionSizes(array)</code> for a 3x4 array returns <code>[3, 4]</code>.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-4"><a class="header" href="#complexity-analysis-table-4">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Initialization</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Access Element</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Modify Element</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Traverse Array</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Get Dimension Sizes</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the total number of elements in the array (e.g., rows * columns for 2D arrays, depth * rows * columns for 3D arrays).</li>
<li>Space complexity for initialization accounts for the memory allocated for all elements.</li>
</ul>
<h3 id="key-differences--notes-4"><a class="header" href="#key-differences--notes-4">Key Differences / Notes</a></h3>
<ul>
<li><strong>Multidimensional vs. Jagged Arrays</strong>:
<ul>
<li>Multidimensional arrays have fixed dimensions, with all rows having the same number of columns in a 2D array, ensuring a rectangular structure.</li>
</ul>
</li>
</ul>
<p>Jagged arrays allow rows of different lengths, offering memory efficiency for irregular data but requiring additional index validation.</p>
<ul>
<li><strong>Memory Allocation</strong>:
<ul>
<li>Multidimensional arrays allocate contiguous memory for all elements, providing predictable O(1) access but potentially wasting memory for sparse data.</li>
<li>In Java, a 2D array is an array of references to 1D arrays, and a 3D array adds another level of nesting, but the sub-arrays are typically uniform in size.</li>
</ul>
</li>
<li><strong>Higher Dimensions</strong>:
<ul>
<li>While 2D arrays are common for matrices, 3D or higher-dimensional arrays are used for complex data, such as 3D spatial models, but increase memory and complexity.</li>
</ul>
</li>
<li><strong>Dynamic Resizing</strong>:
<ul>
<li>Java arrays are fixed-size, so resizing a multidimensional array requires creating a new array and copying elements. Use <code>ArrayList</code> for dynamic sizing if needed.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use multidimensional arrays for structured data with fixed dimensions, such as matrices or 3D models, to leverage fast O(1) access and modification. Initialize all dimensions at creation to ensure proper memory allocation.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Always validate indices when accessing or modifying elements in a multidimensional array to prevent <code>ArrayIndexOutOfBoundsException</code>. Be cautious with higher-dimensional arrays, as their memory usage grows exponentially with each dimension, potentially impacting performance.</p>
</blockquote>
<h3 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h3>
<ol>
<li><strong>Matrix Multiplication</strong>: Write a Java program that multiplies two 2D arrays (matrices) and returns the result as a new 2D array. Test with matrices of different compatible sizes.</li>
<li><strong>Transpose Matrix</strong>: Implement a method to transpose a 2D array (swap rows and columns). Test with square and non-square matrices.</li>
<li><strong>3D Array Summation</strong>: Create a program that initializes a 3D array and computes the sum of all elements using nested loops. Test with different dimensions.</li>
<li><strong>Diagonal Elements</strong>: Write a method to extract the main diagonal elements of a square 2D array into a 1D array. Test with various square matrices.</li>
<li><strong>Wave Traversal</strong>: Implement a program that traverses a 2D array in a wave pattern (e.g., top-to-bottom for even columns, bottom-to-top for odd columns). Test with different matrix sizes.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="jagged-array"><a class="header" href="#jagged-array">Jagged Array</a></h2>
<h3 id="definition-and-concepts-5"><a class="header" href="#definition-and-concepts-5">Definition and Concepts</a></h3>
<p>A jagged array in Java is an array of arrays where each sub-array can have a different length, unlike a regular (rectangular) two-dimensional array where all rows have the same number of columns. Also known as a ragged array, it is a collection of one-dimensional arrays stored in a single array, where each element is itself an array of varying sizes. You can visualize a jagged array as a table where each row can have a different number of columns, providing flexibility in memory allocation. In Java, jagged arrays are implemented by creating an array of references to other arrays, allowing dynamic sizing for each row. This structure is useful when data sizes vary across rows, optimizing memory usage compared to fixed-size rectangular arrays.</p>
<h3 id="why-use-it-5"><a class="header" href="#why-use-it-5">Why Use It?</a></h3>
<p>Jagged arrays are used to efficiently store and manipulate data when the number of elements in each row varies, reducing memory waste compared to rectangular arrays. They provide flexibility in handling irregular datasets, such as matrices with uneven dimensions or collections of variable-length lists. Jagged arrays are ideal for applications where memory efficiency is critical, and the data structure naturally aligns with varying row lengths. They also simplify operations like adding or removing elements in specific rows without affecting others.</p>
<h3 id="where-to-use-real-life-examples-5"><a class="header" href="#where-to-use-real-life-examples-5">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Sparse Matrix Representation</strong>: Scientific computing applications use jagged arrays to store sparse matrices, where most elements are zero, to save memory by only storing non-zero elements per row.</li>
<li><strong>Graph Adjacency Lists</strong>: Graph algorithms use jagged arrays to represent adjacency lists, where each vertex has a list of neighbors with varying lengths.</li>
<li><strong>Text Processing</strong>: Natural language processing applications use jagged arrays to store sentences of different lengths from a document.</li>
<li><strong>Dynamic Data Storage</strong>: Database applications use jagged arrays to store query results with variable numbers of fields per record.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a jagged array would depict a structure with rows of different lengths. The main array would be shown as a vertical column of boxes, each pointing to a one-dimensional array of varying sizes (e.g., row 0: [1, 2], row 1: [3, 4, 5, 6], row 2: [7]). Arrows would illustrate an **access** operation (e.g., retrieving element `arr[1][2] = 5`) and an **initialization** operation for a row (e.g., allocating `arr[2] = new int[]{7}`). A caption would note: "A jagged array in Java consists of arrays of different lengths, allowing flexible memory allocation for irregular data." -->
<h3 id="explain-operations-5"><a class="header" href="#explain-operations-5">Explain Operations</a></h3>
<ul>
<li><strong>Initialization</strong>: This operation creates a jagged array by allocating the main array and then allocating each sub-array with a specific length. It has a time complexity of O(1) for the main array and O(n) for sub-arrays, where n is the total number of elements.</li>
<li><strong>Access Element</strong>: This operation retrieves an element at a specific row and column index. It has a time complexity of O(1).</li>
<li><strong>Modify Element</strong>: This operation updates an element at a specific row and column index. It has a time complexity of O(1).</li>
<li><strong>Add Row</strong>: This operation adds a new row by allocating a new sub-array and assigning it to the main array. It has a time complexity of O(n) for the sub-array allocation, where n is the row length.</li>
<li><strong>Get Row Length</strong>: This operation returns the length of a specific row. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-5"><a class="header" href="#java-implementation-5">Java Implementation</a></h3>
<p>The following Java code demonstrates common operations on a jagged array, including initialization, access, modification, adding a row, and getting row length.</p>
<pre><code class="language-java">public class JaggedArrayExamples {
    // Initialize: Creates a jagged array with specified row lengths
    public int[][] initializeJaggedArray(int[] rowLengths) {
        int[][] jaggedArray = new int[rowLengths.length][]; // Allocates main array
        for (int i = 0; i &lt; rowLengths.length; i++) {
            jaggedArray[i] = new int[rowLengths[i]]; // Allocates each sub-array
        }
        return jaggedArray;
    }

    // Access Element: Retrieves an element at [row][col]
    public int accessElement(int[][] jaggedArray, int row, int col) {
        if (row &lt; 0 || row &gt;= jaggedArray.length || col &lt; 0 || col &gt;= jaggedArray[row].length) {
            throw new IllegalArgumentException("Invalid row or column index.");
        }
        return jaggedArray[row][col]; // Returns element at specified position
    }

    // Modify Element: Updates an element at [row][col]
    public void modifyElement(int[][] jaggedArray, int row, int col, int value) {
        if (row &lt; 0 || row &gt;= jaggedArray.length || col &lt; 0 || col &gt;= jaggedArray[row].length) {
            throw new IllegalArgumentException("Invalid row or column index.");
        }
        jaggedArray[row][col] = value; // Updates element at specified position
    }

    // Add Row: Adds a new row to the jagged array
    public int[][] addRow(int[][] jaggedArray, int[] newRow) {
        int[][] newJaggedArray = new int[jaggedArray.length + 1][]; // Creates new main array
        for (int i = 0; i &lt; jaggedArray.length; i++) {
            newJaggedArray[i] = jaggedArray[i]; // Copies existing rows
        }
        newJaggedArray[jaggedArray.length] = newRow; // Adds new row
        return newJaggedArray;
    }

    // Get Row Length: Returns the length of a specific row
    public int getRowLength(int[][] jaggedArray, int row) {
        if (row &lt; 0 || row &gt;= jaggedArray.length) {
            throw new IllegalArgumentException("Invalid row index.");
        }
        return jaggedArray[row].length; // Returns length of specified row
    }
}
</code></pre>
<h3 id="how-it-works-6"><a class="header" href="#how-it-works-6">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>:
<ul>
<li>The <code>initializeJaggedArray</code> method creates a main array of size equal to <code>rowLengths.length</code> and allocates each sub-array with the length specified in <code>rowLengths</code>.</li>
<li>For example, <code>initializeJaggedArray(new int[]{2, 4, 1})</code> creates a jagged array with three rows of lengths 2, 4, and 1.</li>
</ul>
</li>
<li><strong>Access Element</strong>:
<ul>
<li>The <code>accessElement</code> method uses <code>jaggedArray[row][col]</code> to retrieve the element at the specified position after validating indices.</li>
<li>For example, <code>accessElement(jaggedArray, 1, 2)</code> returns the element at row 1, column 2.</li>
</ul>
</li>
<li><strong>Modify Element</strong>:
<ul>
<li>The <code>modifyElement</code> method updates <code>jaggedArray[row][col]</code> with the given <code>value</code> after validating indices.</li>
<li>For example, <code>modifyElement(jaggedArray, 1, 2, 5)</code> sets the element at row 1, column 2 to 5.</li>
</ul>
</li>
<li><strong>Add Row</strong>:
<ul>
<li>The <code>addRow</code> method creates a new main array with one additional slot, copies existing rows, and assigns the <code>newRow</code> to the last slot.</li>
<li>For example, <code>addRow(jaggedArray, new int[]{7, 8})</code> adds a new row <code>[7, 8]</code> to the jagged array.</li>
</ul>
</li>
<li><strong>Get Row Length</strong>:
<ul>
<li>The <code>getRowLength</code> method returns <code>jaggedArray[row].length</code> after validating the row index.</li>
<li>For example, <code>getRowLength(jaggedArray, 1)</code> returns the length of row 1.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-5"><a class="header" href="#complexity-analysis-table-5">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Initialization</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Access Element</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Modify Element</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Add Row</td><td>O(m)</td><td>O(m)</td></tr>
<tr><td>Get Row Length</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the total number of elements across all sub-arrays for initialization.</li>
<li>m is the number of rows in the jagged array for the add row operation.</li>
<li>Space complexity accounts for the memory allocated for the arrays.</li>
</ul>
<h3 id="key-differences--notes-5"><a class="header" href="#key-differences--notes-5">Key Differences / Notes</a></h3>
<ul>
<li><strong>Jagged Array vs. Rectangular Array</strong>:
<ul>
<li>Jagged arrays allow rows of different lengths, saving memory for irregular data, while rectangular arrays (<code>int[][]</code>) have fixed row and column sizes.</li>
<li>Jagged arrays are implemented as arrays of arrays, while rectangular arrays are contiguous 2D structures.</li>
</ul>
</li>
<li><strong>Memory Efficiency</strong>:
<ul>
<li>Jagged arrays are more memory-efficient for sparse or irregular data, as unused elements are not allocated, unlike rectangular arrays.</li>
</ul>
</li>
<li><strong>Dynamic Resizing</strong>:
<ul>
<li>Adding rows requires creating a new main array, as Java arrays are fixed-size. Use <code>ArrayList&lt;int[]&gt;</code> for dynamic resizing if needed.</li>
</ul>
</li>
<li><strong>Use in Algorithms</strong>:
<ul>
<li>Jagged arrays are commonly used in graph algorithms (e.g., adjacency lists) and dynamic programming with variable-sized rows.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use jagged arrays when dealing with irregular data, such as sparse matrices or adjacency lists, to optimize memory usage. Initialize row lengths based on the specific needs of each row to avoid unnecessary allocation.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious when accessing elements in a jagged array, as each row has a different length. Always validate column indices to avoid <code>ArrayIndexOutOfBoundsException</code>. Avoid frequent row additions, as they require creating a new main array, which is costly.</p>
</blockquote>
<h3 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h3>
<ol>
<li><strong>Sparse Matrix Sum</strong>: Write a Java program that uses a jagged array to represent a sparse matrix and computes the sum of all non-zero elements. Test with matrices of varying row lengths.</li>
<li><strong>Adjacency List Representation</strong>: Implement a graph using a jagged array as an adjacency list. Add edges and print the neighbors of each vertex. Test with a sample graph.</li>
<li><strong>Row Sorting</strong>: Create a program that sorts each row of a jagged array independently. Test with a jagged array containing rows of different lengths.</li>
<li><strong>Dynamic Row Addition</strong>: Write a program that allows users to add rows to a jagged array interactively, specifying row lengths and elements. Test with multiple additions.</li>
<li><strong>Jagged Array Transpose</strong>: Implement a program that transposes a jagged array (converting rows to columns) into another jagged array. Test with irregular input arrays.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="string-data-structure"><a class="header" href="#string-data-structure">String Data Structure</a></h2>
<h3 id="definition-and-concepts-6"><a class="header" href="#definition-and-concepts-6">Definition and Concepts</a></h3>
<p>A string is a sequence of characters used to represent text in programming. In Java, the <code>String</code> class is a fundamental data structure that is immutable, meaning its content cannot be changed after creation. Strings are stored as arrays of characters internally, but Java’s <code>String</code> class provides a high-level interface for manipulating text. You can visualize a string as a chain of characters, such as "Hello", where each character occupies a specific position (index) starting from 0. Strings support operations like concatenation, substring extraction, and searching, making them essential for text processing. Java also provides mutable alternatives like <code>StringBuilder</code> and <code>StringBuffer</code> for scenarios requiring frequent modifications.</p>
<h3 id="why-use-it-6"><a class="header" href="#why-use-it-6">Why Use It?</a></h3>
<p>Strings are used to handle and manipulate textual data in a wide range of applications, from user input processing to file parsing. Their immutability in Java ensures thread safety and consistency, making them ideal for constant or shared text data. Strings provide a rich set of methods for searching, modifying, and comparing text, simplifying complex text operations. For performance-critical applications, mutable classes like <code>StringBuilder</code> are used to reduce overhead from creating multiple string objects.</p>
<h3 id="where-to-use-real-life-examples-6"><a class="header" href="#where-to-use-real-life-examples-6">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Text Processing</strong>: Text editors use strings to store and manipulate document content, such as formatting or searching text.</li>
<li><strong>Web Development</strong>: Web applications use strings to process URLs, HTML content, and user input, such as form data.</li>
<li><strong>Data Parsing</strong>: CSV or JSON parsers use strings to extract fields and values from structured data files.</li>
<li><strong>Search and Validation</strong>: Search engines and form validators use strings to match patterns (e.g., email validation) or search for keywords.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a string would depict a sequence of boxes, each containing a character (e.g., "H", "e", "l", "l", "o") with indices (0 to 4). Arrows would illustrate a **substring** operation extracting "ell" (indices 1 to 3) and a **concatenation** operation appending " World" to form "Hello World". A caption would note: "Strings in Java are immutable sequences of characters, supporting operations like substring and concatenation." -->
<h3 id="explain-operations-6"><a class="header" href="#explain-operations-6">Explain Operations</a></h3>
<ul>
<li><strong>Concatenation</strong>: This operation combines two strings into a new string. It has a time complexity of O(n), where n is the total length of the resulting string.</li>
<li><strong>Substring Extraction</strong>: This operation extracts a portion of the string based on start and end indices. It has a time complexity of O(n) in Java due to string immutability.</li>
<li><strong>Search (Index Of)</strong>: This operation finds the index of a substring or character within the string. It has a time complexity of O(n*m) in the worst case, where n is the string length and m is the substring length.</li>
<li><strong>Length</strong>: This operation returns the number of characters in the string. It has a time complexity of O(1).</li>
<li><strong>Character Access</strong>: This operation retrieves the character at a specific index. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-6"><a class="header" href="#java-implementation-6">Java Implementation</a></h3>
<p>The following Java code demonstrates common string operations using the <code>String</code> class and introduces <code>StringBuilder</code> for mutable string manipulation.</p>
<pre><code class="language-java">public class StringExamples {
    // Concatenation: Combines two strings
    public String concatenate(String str1, String str2) {
        return str1 + str2; // Uses + operator for concatenation
    }

    // Substring: Extracts a portion of the string
    public String getSubstring(String str, int start, int end) {
        if (start &lt; 0 || end &gt; str.length() || start &gt; end) {
            throw new IllegalArgumentException("Invalid start or end index.");
        }
        return str.substring(start, end); // Returns substring from start to end-1
    }

    // Search: Finds the index of a substring
    public int findIndex(String str, String target) {
        return str.indexOf(target); // Returns index of first occurrence or -1 if not found
    }

    // Length: Returns the number of characters
    public int getLength(String str) {
        return str.length(); // Returns the string length
    }

    // Character Access: Gets character at index
    public char getCharAt(String str, int index) {
        if (index &lt; 0 || index &gt;= str.length()) {
            throw new IllegalArgumentException("Invalid index.");
        }
        return str.charAt(index); // Returns character at specified index
    }

    // StringBuilder Example: Demonstrates mutable string manipulation
    public String buildString(String[] parts) {
        StringBuilder builder = new StringBuilder();
        for (String part : parts) {
            builder.append(part); // Appends each part to the builder
        }
        return builder.toString(); // Converts StringBuilder to String
    }
}
</code></pre>
<h3 id="how-it-works-7"><a class="header" href="#how-it-works-7">How It Works</a></h3>
<ol>
<li><strong>Concatenation</strong>:
<ul>
<li>The <code>concatenate</code> method uses the <code>+</code> operator, which internally creates a new <code>String</code> object combining <code>str1</code> and <code>str2</code>.</li>
<li>For example, <code>concatenate("Hello", " World")</code> creates a new string "Hello World".</li>
</ul>
</li>
<li><strong>Substring Extraction</strong>:
<ul>
<li>The <code>getSubstring</code> method calls <code>str.substring(start, end)</code>, which creates a new string containing characters from index <code>start</code> to <code>end-1</code>.</li>
<li>For example, <code>getSubstring("Hello", 1, 4)</code> returns "ell".</li>
</ul>
</li>
<li><strong>Search (Index Of)</strong>:
<ul>
<li>The <code>findIndex</code> method uses <code>str.indexOf(target)</code> to return the starting index of <code>target</code> in <code>str</code> or -1 if not found.</li>
<li>For example, <code>findIndex("Hello", "ll")</code> returns 2.</li>
</ul>
</li>
<li><strong>Length</strong>:
<ul>
<li>The <code>getLength</code> method calls <code>str.length()</code> to return the number of characters.</li>
<li>For example, <code>getLength("Hello")</code> returns 5.</li>
</ul>
</li>
<li><strong>Character Access</strong>:
<ul>
<li>The <code>getCharAt</code> method uses <code>str.charAt(index)</code> to return the character at the specified index.</li>
<li>For example, <code>getCharAt("Hello", 1)</code> returns 'e'.</li>
</ul>
</li>
<li><strong>StringBuilder Example</strong>:
<ul>
<li>The <code>buildString</code> method uses <code>StringBuilder</code> to efficiently append multiple strings from an array, then converts the result to a <code>String</code>.</li>
<li>For example, <code>buildString(new String[]{"He", "llo"})</code> returns "Hello".</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-6"><a class="header" href="#complexity-analysis-table-6">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Concatenation</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Substring Extraction</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Search (Index Of)</td><td>O(n*m) worst case</td><td>O(1)</td></tr>
<tr><td>Length</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Character Access</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>StringBuilder Append</td><td>O(1) amortized</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the string (or total length for concatenation).</li>
<li>m is the length of the substring in <code>indexOf</code>.</li>
<li><code>StringBuilder</code> append is O(1) amortized due to dynamic resizing.</li>
</ul>
<h3 id="key-differences--notes-6"><a class="header" href="#key-differences--notes-6">Key Differences / Notes</a></h3>
<ul>
<li><strong>String Immutability</strong>:
<ul>
<li>Java’s <code>String</code> class is immutable, so operations like concatenation and substring create new strings, increasing space complexity.</li>
<li><code>StringBuilder</code> and <code>StringBuffer</code> are mutable, reducing overhead for frequent modifications.</li>
</ul>
</li>
<li><strong>String vs. StringBuilder/StringBuffer</strong>:
<ul>
<li>Use <code>String</code> for constant or infrequently modified text due to its immutability and thread safety.</li>
<li>Use <code>StringBuilder</code> for single-threaded, mutable string operations, or <code>StringBuffer</code> for thread-safe mutable operations.</li>
</ul>
</li>
<li><strong>Thread Safety</strong>:
<ul>
<li><code>String</code> and <code>StringBuilder</code> are not thread-safe for modifications (though <code>String</code> is immutable). <code>StringBuffer</code> is thread-safe but slower.</li>
</ul>
</li>
<li><strong>String Pool</strong>:
<ul>
<li>Java maintains a string pool, a special area in the heap (part of the constant pool in the PermGen or Metaspace, depending on the Java version), to store unique string literals and interned strings. When a string literal (e.g., <code>"Hello"</code>) is created, Java checks the string pool. If the string exists, the reference is reused; otherwise, a new string is added to the pool. This optimizes memory usage for repeated literals.</li>
<li>The <code>intern()</code> method can manually add a string to the pool, ensuring that identical strings share the same reference. For example, <code>new String("Hello").intern()</code> returns the pooled reference if <code>"Hello"</code> exists.</li>
<li>String pool usage reduces memory overhead but requires careful handling in performance-critical applications, as excessive interning can increase pool size and lookup time.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>StringBuilder</code> for concatenating strings in a loop to avoid the overhead of creating multiple <code>String</code> objects. For simple, one-time concatenations, the <code>+</code> operator is sufficient and readable. Use <code>String.intern()</code> to leverage the string pool for memory optimization when dealing with frequently reused strings.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid excessive string concatenation in loops using the <code>+</code> operator, as it creates multiple intermediate <code>String</code> objects, leading to O(n²) time complexity. Use <code>StringBuilder</code> for better performance. Be cautious with <code>String.intern()</code>, as overusing it can bloat the string pool and degrade performance.</p>
</blockquote>
<h3 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h3>
<ol>
<li><strong>Reverse a String</strong>: Write a Java program that reverses a string using both <code>String</code> methods and <code>StringBuilder</code>. Compare their performance for large strings.</li>
<li><strong>Palindrome Checker</strong>: Implement a method to check if a string is a palindrome (ignoring case and non-alphanumeric characters). Test with various inputs.</li>
<li><strong>String Compression</strong>: Create a program that compresses a string by replacing repeated characters with their count (e.g., "aabbb" becomes "a2b3"). Use <code>StringBuilder</code> for efficiency.</li>
<li><strong>Substring Frequency</strong>: Write a method to count the occurrences of a substring in a string using <code>indexOf</code>. Test with overlapping and non-overlapping cases.</li>
<li><strong>String Pool Experiment</strong>: Write a Java program that demonstrates the string pool by comparing string literals, <code>new String()</code> objects, and interned strings using <code>==</code> and <code>equals()</code>. Analyze memory usage and equality behavior.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="mutable-strings"><a class="header" href="#mutable-strings">Mutable Strings</a></h2>
<h3 id="definition-and-concepts-7"><a class="header" href="#definition-and-concepts-7">Definition and Concepts</a></h3>
<p>Mutable strings in Java refer to string-like data structures that can be modified after creation, unlike the immutable <code>String</code> class. Java provides two primary classes for mutable strings: <code>StringBuilder</code> and <code>StringBuffer</code>. Both classes allow operations like appending, inserting, or deleting characters without creating new objects, making them efficient for text manipulation. <code>StringBuilder</code> is designed for single-threaded environments, offering better performance, while <code>StringBuffer</code> is thread-safe, suitable for multi-threaded applications. You can visualize a mutable string as a dynamic sequence of characters that can be altered in place, such as changing "Hello" to "Hello World" by appending characters directly. Mutable strings are essential for performance-critical applications requiring frequent text modifications.</p>
<h3 id="why-use-it-7"><a class="header" href="#why-use-it-7">Why Use It?</a></h3>
<p>Mutable strings are used to efficiently manipulate text in scenarios where frequent modifications, such as appending or inserting characters, are needed. Unlike immutable <code>String</code> objects, which create new instances for each operation, <code>StringBuilder</code> and <code>StringBuffer</code> modify their internal character arrays, reducing memory overhead and improving performance. <code>StringBuilder</code> is preferred for single-threaded applications due to its speed, while <code>StringBuffer</code> is used when thread safety is required. These classes are ideal for building strings incrementally, such as in loops or dynamic text generation.</p>
<h3 id="where-to-use-real-life-examples-7"><a class="header" href="#where-to-use-real-life-examples-7">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Log Message Construction</strong>: Logging frameworks use <code>StringBuilder</code> to construct log messages by appending data, avoiding the overhead of multiple <code>String</code> concatenations.</li>
<li><strong>Text File Generation</strong>: Report generators use <code>StringBuilder</code> to build large text outputs, such as CSV or JSON files, by incrementally adding content.</li>
<li><strong>String Manipulation in Editors</strong>: Text editors use mutable strings to handle user edits, such as inserting or deleting text in a document, in real-time.</li>
<li><strong>Thread-Safe Text Processing</strong>: Multi-threaded server applications use <code>StringBuffer</code> to build responses concurrently, ensuring thread safety during string modifications.</li>
</ul>
<!-- ### SVG Diagram
The diagram for mutable strings would depict a `StringBuilder` object as a sequence of boxes containing characters (e.g., "H", "e", "l", "l", "o") with an arrow showing an **append** operation adding " World" to form "Hello World". A parallel depiction of `StringBuffer` would highlight its thread-safe nature with a lock icon. A caption would note: "Mutable strings (`StringBuilder` and `StringBuffer`) allow in-place modifications, such as appending characters, unlike immutable `String` objects." -->
<h3 id="explain-operations-7"><a class="header" href="#explain-operations-7">Explain Operations</a></h3>
<ul>
<li><strong>Append</strong>: This operation adds characters, strings, or other data types to the end of the mutable string. It has a time complexity of O(1) amortized.</li>
<li><strong>Insert</strong>: This operation inserts characters or strings at a specified index, shifting subsequent characters. It has a time complexity of O(n) due to shifting.</li>
<li><strong>Delete</strong>: This operation removes a range of characters from the mutable string, shifting remaining characters. It has a time complexity of O(n) due to shifting.</li>
<li><strong>Replace</strong>: This operation replaces a range of characters with a new string. It has a time complexity of O(n) due to shifting and copying.</li>
<li><strong>Length</strong>: This operation returns the number of characters in the mutable string. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-7"><a class="header" href="#java-implementation-7">Java Implementation</a></h3>
<p>The following Java code demonstrates common operations using <code>StringBuilder</code> and <code>StringBuffer</code>.</p>
<pre><code class="language-java">public class MutableStringExamples {
    // StringBuilder Append: Appends a string to a StringBuilder
    public StringBuilder appendStringBuilder(StringBuilder builder, String str) {
        return builder.append(str); // Appends str to the builder
    }

    // StringBuilder Insert: Inserts a string at a specified index
    public StringBuilder insertStringBuilder(StringBuilder builder, int index, String str) {
        if (index &lt; 0 || index &gt; builder.length()) {
            throw new IllegalArgumentException("Invalid index.");
        }
        return builder.insert(index, str); // Inserts str at the specified index
    }

    // StringBuilder Delete: Deletes a range of characters
    public StringBuilder deleteStringBuilder(StringBuilder builder, int start, int end) {
        if (start &lt; 0 || end &gt; builder.length() || start &gt; end) {
            throw new IllegalArgumentException("Invalid start or end index.");
        }
        return builder.delete(start, end); // Deletes characters from start to end-1
    }

    // StringBuilder Replace: Replaces a range of characters
    public StringBuilder replaceStringBuilder(StringBuilder builder, int start, int end, String str) {
        if (start &lt; 0 || end &gt; builder.length() || start &gt; end) {
            throw new IllegalArgumentException("Invalid start or end index.");
        }
        return builder.replace(start, end, str); // Replaces characters from start to end-1 with str
    }

    // StringBuilder Length: Returns the number of characters
    public int getLengthStringBuilder(StringBuilder builder) {
        return builder.length(); // Returns the current length
    }

    // StringBuffer Example: Demonstrates thread-safe append
    public StringBuffer appendStringBuffer(StringBuffer buffer, String str) {
        return buffer.append(str); // Appends str to the thread-safe buffer
    }
}
</code></pre>
<h3 id="how-it-works-8"><a class="header" href="#how-it-works-8">How It Works</a></h3>
<ol>
<li><strong>Append</strong>:
<ul>
<li>The <code>appendStringBuilder</code> method calls <code>builder.append(str)</code> to add <code>str</code> to the end of the <code>StringBuilder</code>’s internal character array.</li>
<li>For example, <code>appendStringBuilder(new StringBuilder("Hello"), " World")</code> results in "Hello World".</li>
<li>The <code>appendStringBuffer</code> method works similarly for <code>StringBuffer</code> with thread-safe synchronization.</li>
</ul>
</li>
<li><strong>Insert</strong>:
<ul>
<li>The <code>insertStringBuilder</code> method calls <code>builder.insert(index, str)</code> to insert <code>str</code> at the specified <code>index</code>, shifting subsequent characters.</li>
<li>For example, <code>insertStringBuilder(new StringBuilder("Hlo"), 1, "el")</code> results in "Hello".</li>
</ul>
</li>
<li><strong>Delete</strong>:
<ul>
<li>The <code>deleteStringBuilder</code> method calls <code>builder.delete(start, end)</code> to remove characters from <code>start</code> to <code>end-1</code>, shifting remaining characters.</li>
<li>For example, <code>deleteStringBuilder(new StringBuilder("Hello"), 1, 4)</code> results in "Ho".</li>
</ul>
</li>
<li><strong>Replace</strong>:
<ul>
<li>The <code>replaceStringBuilder</code> method calls <code>builder.replace(start, end, str)</code> to replace characters from <code>start</code> to <code>end-1</code> with <code>str</code>.</li>
<li>For example, <code>replaceStringBuilder(new StringBuilder("Halo"), 1, 3, "el")</code> results in "Hello".</li>
</ul>
</li>
<li><strong>Length</strong>:
<ul>
<li>The <code>getLengthStringBuilder</code> method calls <code>builder.length()</code> to return the number of characters.</li>
<li>For example, <code>getLengthStringBuilder(new StringBuilder("Hello"))</code> returns 5.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-7"><a class="header" href="#complexity-analysis-table-7">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Append</td><td>O(1) amortized</td><td>O(n)</td></tr>
<tr><td>Insert</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Delete</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Replace</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Length</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the mutable string or the resulting string after the operation.</li>
<li>Append is O(1) amortized due to occasional resizing of the internal array.</li>
<li>Space complexity accounts for the internal character array, which may resize dynamically.</li>
</ul>
<h3 id="key-differences--notes-7"><a class="header" href="#key-differences--notes-7">Key Differences / Notes</a></h3>
<ul>
<li><strong>StringBuilder vs. StringBuffer</strong>:
<ul>
<li><code>StringBuilder</code> is not thread-safe but faster, making it suitable for single-threaded applications.</li>
<li><code>StringBuffer</code> is thread-safe due to synchronized methods, making it slower but appropriate for multi-threaded environments.</li>
</ul>
</li>
<li><strong>Mutable vs. Immutable Strings</strong>:
<ul>
<li>Unlike the immutable <code>String</code> class, which creates new objects for modifications, <code>StringBuilder</code> and <code>StringBuffer</code> modify their internal arrays, reducing memory overhead.</li>
<li>Operations like concatenation with <code>String</code> have O(n) space complexity per operation, while <code>StringBuilder</code>/<code>StringBuffer</code> appends are more efficient.</li>
</ul>
</li>
<li><strong>Internal Array Resizing</strong>: Both classes use a dynamic array that doubles in size when capacity is exceeded, leading to O(1) amortized append time but occasional O(n) resizing.</li>
<li><strong>Java’s String Pool</strong>: Mutable strings (<code>StringBuilder</code>/<code>StringBuffer</code>) are not stored in the string pool, unlike <code>String</code> literals. Converting to <code>String</code> via <code>toString()</code> creates a new <code>String</code> that may be interned into the pool if needed.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>StringBuilder</code> for most mutable string operations in single-threaded applications to maximize performance. Reserve <code>StringBuffer</code> for scenarios requiring thread safety, such as concurrent server applications.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid using <code>StringBuilder</code> in multi-threaded environments without synchronization, as it can lead to data corruption. Use <code>StringBuffer</code> or explicit synchronization for thread-safe string manipulation.</p>
</blockquote>
<h3 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h3>
<ol>
<li><strong>String Reversal</strong>: Write a Java program that reverses a string using <code>StringBuilder</code> and <code>StringBuffer</code>. Compare their performance for large inputs.</li>
<li><strong>Dynamic Text Builder</strong>: Create a program that builds a formatted string (e.g., a CSV row) using <code>StringBuilder</code>, appending elements from an array. Test with varying array sizes.</li>
<li><strong>Thread-Safe Concatenation</strong>: Implement a multi-threaded program that uses <code>StringBuffer</code> to append strings concurrently from multiple threads. Verify thread safety with test cases.</li>
<li><strong>Insert and Delete Simulation</strong>: Write a program that simulates text editing using <code>StringBuilder</code>, performing a sequence of insert and delete operations. Test with different sequences.</li>
<li><strong>StringBuilder Capacity Management</strong>: Create a program that demonstrates <code>StringBuilder</code>’s capacity resizing by appending strings and monitoring capacity changes using <code>capacity()</code>. Analyze when resizing occurs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="stack-data-structure"><a class="header" href="#stack-data-structure">Stack Data Structure</a></h2>
<h3 id="definition-and-concepts-8"><a class="header" href="#definition-and-concepts-8">Definition and Concepts</a></h3>
<p>A stack is a linear data structure that operates on the <strong>Last In, First Out (LIFO)</strong> principle. This means that the last element added to the stack is the first one removed. You can visualize a stack as a stack of plates, where you add a plate to the top and remove the topmost plate first. The primary operations of a stack include <strong>push</strong>, which adds an element to the top, and <strong>pop</strong>, which removes the top element. Additional operations include <strong>peek</strong>, which views the top element without removing it, and <strong>isEmpty</strong>, which checks if the stack is empty. Stacks are simple to implement and are highly efficient for problems requiring reversal or backtracking.</p>
<h3 id="why-use-it-8"><a class="header" href="#why-use-it-8">Why Use It?</a></h3>
<p>A stack is useful when you need to process data in a Last In, First Out order. It provides an efficient way to manage data where the most recently added element is the first to be accessed or removed. Stacks are memory-efficient because they restrict operations to one end, known as the top, which simplifies data management and reduces operational complexity.</p>
<h3 id="where-to-use-real-life-examples-8"><a class="header" href="#where-to-use-real-life-examples-8">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Undo Functionality in Software</strong>: Text editors and graphic design tools use stacks to store user actions, such as typing or drawing, allowing the most recent action to be undone.</li>
<li><strong>Browser History Navigation</strong>: Web browsers employ stacks to manage back and forward navigation, where the most recently visited page is removed when you click the "back" button.</li>
<li><strong>Function Call Management</strong>: Programming languages utilize stacks to handle function calls, storing return addresses and local variables for each function.</li>
<li><strong>Expression Evaluation</strong>: Stacks are used to evaluate mathematical expressions, such as <code>3 + 4 * 2</code>, by managing operator precedence and parentheses.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a stack would depict a vertical arrangement of rectangular boxes, each labeled with a number to represent elements, such as 10, 20, and 30, ordered from bottom to top. An arrow would point to the topmost element, labeled "Top," indicating the position where elements are added or removed. Additional arrows would illustrate the **push** operation, showing a new element being added above the top, and the **pop** operation, showing the top element being removed. A caption would note the LIFO principle: "Last In, First Out." -->
<h3 id="explain-operations-8"><a class="header" href="#explain-operations-8">Explain Operations</a></h3>
<ul>
<li><strong>Push</strong>: This operation adds an element to the top of the stack. It has a time complexity of O(1).</li>
<li><strong>Pop</strong>: This operation removes and returns the top element from the stack. If the stack is empty, it may throw an exception or return null. It has a time complexity of O(1).</li>
<li><strong>Peek</strong>: This operation returns the top element without removing it. It has a time complexity of O(1).</li>
<li><strong>isEmpty</strong>: This operation checks whether the stack is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of elements currently in the stack. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-8"><a class="header" href="#java-implementation-8">Java Implementation</a></h3>
<p>The following Java code implements a stack using an array.</p>
<pre><code class="language-java">public class Stack {
    private int maxSize; // Represents the maximum size of the stack
    private int[] stackArray; // Array to store the stack elements
    private int top; // Index of the top element in the stack

    // Constructor to initialize the stack with a given size
    public Stack(int size) {
        maxSize = size;
        stackArray = new int[size];
        top = -1; // Indicates that the stack is initially empty
    }

    // Push: Adds an element to the top of the stack
    public void push(int value) {
        if (喧
        if (top &lt; maxSize - 1) { // Checks if the stack is not full
            stackArray[++top] = value; // Increments top and adds the value
        } else {
            throw new IllegalStateException("The stack is full.");
        }
    }

    // Pop: Removes and returns the top element
    public int pop() {
        if (isEmpty()) { // Checks if the stack is empty
            throw new IllegalStateException("The stack is empty.");
        }
        return stackArray[top--]; // Returns the top element and decrements top
    }

    // Peek: Returns the top element without removing it
    public int peek() {
        if (isEmpty()) { // Checks if the stack is empty
            throw new IllegalStateException("The stack is empty.");
        }
        return stackArray[top];
    }

    // isEmpty: Checks if the stack is empty
    public boolean isEmpty() {
        return (top == -1);
    }

    // Size: Returns the number of elements in the stack
    public int size() {
        return top + 1;
    }
}
</code></pre>
<h3 id="how-it-works-9"><a class="header" href="#how-it-works-9">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes an array of size <code>maxSize</code> and sets <code>top</code> to -1, indicating an empty stack.</li>
<li><strong>Push Operation</strong>:
<ul>
<li>The method checks if the stack is not full by comparing <code>top</code> to <code>maxSize - 1</code>.</li>
<li>If there is space, it increments <code>top</code> and stores the new value in <code>stackArray[top]</code>.</li>
<li>If the stack is full, it throws an exception.</li>
</ul>
</li>
<li><strong>Pop Operation</strong>:
<ul>
<li>The method verifies that the stack is not empty using <code>isEmpty()</code>.</li>
<li>It returns the element at <code>stackArray[top]</code> and decrements <code>top</code>.</li>
<li>If the stack is empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Peek Operation</strong>: The method returns the value at <code>stackArray[top]</code> without modifying <code>top</code>.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>top</code> equals -1, indicating an empty stack, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>top + 1</code>, which represents the current number of elements in the stack.</li>
</ol>
<h3 id="complexity-analysis-table-8"><a class="header" href="#complexity-analysis-table-8">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Push</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Pop</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Peek</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<h3 id="key-differences--notes-8"><a class="header" href="#key-differences--notes-8">Key Differences / Notes</a></h3>
<ul>
<li><strong>Array-Based vs. Linked List-Based Stack</strong>:
<ul>
<li>The array-based stack, as implemented above, has a fixed size and offers O(1) access but is limited by its maximum size.</li>
<li>A linked list-based stack supports dynamic sizing but may have slightly slower operations due to node creation and deletion.</li>
</ul>
</li>
<li><strong>Thread Safety</strong>: The provided implementation is not thread-safe. For concurrent applications, consider using Java’s <code>Stack</code> class or <code>ArrayDeque</code> with proper synchronization.</li>
<li><strong>Java’s Built-in Options</strong>: Java’s <code>java.util.Stack</code> class is available but is less efficient than <code>ArrayDeque</code>, which is recommended for stack implementations due to its performance.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Always check if the stack is empty before performing pop or peek operations to avoid exceptions. If you need a stack with dynamic sizing, consider using Java’s <code>ArrayDeque</code> or implementing a linked list-based stack.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: An array-based stack can overflow if you exceed its <code>maxSize</code>. Carefully estimate the required size for your application to prevent errors.</p>
</blockquote>
<h3 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h3>
<ol>
<li><strong>Reverse a String</strong>: Write a Java program that uses the stack implementation above to reverse a given string by pushing each character onto the stack and then popping them to form the reversed string.</li>
<li><strong>Parentheses Checker</strong>: Create a program that uses a stack to check if a string of parentheses (e.g., <code>"{[()]}"</code>) is balanced. Push opening brackets onto the stack and pop them when a matching closing bracket is found.</li>
<li><strong>Stack Min Function</strong>: Extend the stack implementation to include a <code>min()</code> function that returns the minimum element in the stack in O(1) time. Hint: Use an additional stack to track minimums.</li>
<li><strong>Infix to Postfix Conversion</strong>: Write a program that converts an infix expression (e.g., <code>A + B * C</code>) to postfix (e.g., <code>A B C * +</code>) using a stack. Test it with at least three different expressions.</li>
<li><strong>Real-World Simulation</strong>: Simulate a browser’s back button functionality using the stack. Allow users to input a list of URLs to push onto the stack and print the current page each time the back button (pop) is pressed.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="queue-data-structure"><a class="header" href="#queue-data-structure">Queue Data Structure</a></h2>
<h3 id="definition-and-concepts-9"><a class="header" href="#definition-and-concepts-9">Definition and Concepts</a></h3>
<p>A queue is a linear data structure that operates on the <strong>First In, First Out (FIFO)</strong> principle. This means that the first element added to the queue is the first one to be removed. You can visualize a queue as a line of people waiting at a ticket counter, where the person who arrives first is served first. The primary operations of a queue include <strong>enqueue</strong>, which adds an element to the rear of the queue, and <strong>dequeue</strong>, which removes and returns the element at the front. Additional operations include <strong>peek</strong>, which views the front element without removing it, and <strong>isEmpty</strong>, which checks if the queue is empty. Queues are essential for managing data in a sequential, order-preserving manner.</p>
<h3 id="why-use-it-9"><a class="header" href="#why-use-it-9">Why Use It?</a></h3>
<p>A queue is useful when you need to process data in the order it was received. It ensures fairness by maintaining the sequence of elements, making it ideal for tasks that require sequential processing or scheduling. Queues are efficient because they restrict operations to two ends: the front for removal and the rear for addition, simplifying data management.</p>
<h3 id="where-to-use-real-life-examples-9"><a class="header" href="#where-to-use-real-life-examples-9">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Task Scheduling in Operating Systems</strong>: Operating systems use queues to manage processes waiting for CPU time, ensuring each process is executed in the order it was submitted.</li>
<li><strong>Print Job Management</strong>: Printers use queues to handle multiple print jobs, processing them in the order they were received.</li>
<li><strong>Customer Service Systems</strong>: Call centers or ticket counters use queues to serve customers in the order of their arrival.</li>
<li><strong>Breadth-First Search (BFS) in Graphs</strong>: Queues are used in algorithms like BFS to explore nodes level by level in a graph or tree.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a queue would depict a horizontal sequence of rectangular boxes, each labeled with a number to represent elements, such as 10, 20, and 30, ordered from left (front) to right (rear). An arrow would point to the leftmost element, labeled "Front," where elements are dequeued, and another to the rightmost element, labeled "Rear," where elements are enqueued. Additional arrows would illustrate the **enqueue** operation, showing a new element added to the rear, and the **dequeue** operation, showing the front element being removed. A caption would note the FIFO principle: "First In, First Out." -->
<h3 id="explain-operations-9"><a class="header" href="#explain-operations-9">Explain Operations</a></h3>
<ul>
<li><strong>Enqueue</strong>: This operation adds an element to the rear of the queue. It has a time complexity of O(1).</li>
<li><strong>Dequeue</strong>: This operation removes and returns the front element of the queue. If the queue is empty, it may throw an exception or return null. It has a time complexity of O(1).</li>
<li><strong>Peek</strong>: This operation returns the front element without removing it. It has a time complexity of O(1).</li>
<li><strong>isEmpty</strong>: This operation checks whether the queue is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of elements currently in the queue. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-9"><a class="header" href="#java-implementation-9">Java Implementation</a></h3>
<p>The following Java code implements a queue using an array with a fixed size.</p>
<pre><code class="language-java">public class Queue {
    private int maxSize; // Represents the maximum size of the queue
    private int[] queueArray; // Array to store the queue elements
    private int front; // Index of the front element
    private int rear; // Index where the next element will be added
    private int currentSize; // Number of elements in the queue

    // Constructor to initialize the queue with a given size
    public Queue(int size) {
        maxSize = size;
        queueArray = new int[size];
        front = 0; // Front starts at index 0
        rear = -1; // Rear starts before the first element
        currentSize = 0; // Queue is initially empty
    }

    // Enqueue: Adds an element to the rear of the queue
    public void enqueue(int value) {
        if (currentSize &lt; maxSize) { // Checks if the queue is not full
            rear = (rear + 1) % maxSize; // Increments rear (circularly)
            queueArray[rear] = value; // Adds the value at rear
            currentSize++; // Increments the size
        } else {
            throw new IllegalStateException("The queue is full.");
        }
    }

    // Dequeue: Removes and returns the front element
    public int dequeue() {
        if (isEmpty()) { // Checks if the queue is empty
            throw new IllegalStateException("The queue is empty.");
        }
        int value = queueArray[front]; // Retrieves the front element
        front = (front + 1) % maxSize; // Moves front to the next element (circularly)
        currentSize--; // Decrements the size
        return value;
    }

    // Peek: Returns the front element without removing it
    public int peek() {
        if (isEmpty()) { // Checks if the queue is empty
            throw new IllegalStateException("The queue is empty.");
        }
        return queueArray[front];
    }

    // isEmpty: Checks if the queue is empty
    public boolean isEmpty() {
        return (currentSize == 0);
    }

    // Size: Returns the number of elements in the queue
    public int size() {
        return currentSize;
    }
}
</code></pre>
<h3 id="how-it-works-10"><a class="header" href="#how-it-works-10">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes an array of size <code>maxSize</code>, sets <code>front</code> to 0, <code>rear</code> to -1, and <code>currentSize</code> to 0, indicating an empty queue.</li>
<li><strong>Enqueue Operation</strong>:
<ul>
<li>The method checks if the queue is not full by comparing <code>currentSize</code> to <code>maxSize</code>.</li>
<li>It increments <code>rear</code> using modulo (<code>% maxSize</code>) to support a circular queue, adds the value to <code>queueArray[rear]</code>, and increments <code>currentSize</code>.</li>
<li>If the queue is full, it throws an exception.</li>
</ul>
</li>
<li><strong>Dequeue Operation</strong>:
<ul>
<li>The method verifies that the queue is not empty using <code>isEmpty()</code>.</li>
<li>It retrieves the value at <code>queueArray[front]</code>, moves <code>front</code> to the next position using modulo, decrements <code>currentSize</code>, and returns the value.</li>
<li>If the queue is empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Peek Operation</strong>: The method returns the value at <code>queueArray[front]</code> without modifying <code>front</code> or <code>currentSize</code>.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>currentSize</code> equals 0, indicating an empty queue, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>currentSize</code>, which represents the number of elements in the queue.</li>
</ol>
<h3 id="complexity-analysis-table-9"><a class="header" href="#complexity-analysis-table-9">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Dequeue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Peek</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<h3 id="key-differences--notes-9"><a class="header" href="#key-differences--notes-9">Key Differences / Notes</a></h3>
<ul>
<li><strong>Array-Based vs. Linked List-Based Queue</strong>:
<ul>
<li>The array-based queue, as implemented above, has a fixed size and offers O(1) access but is limited by its maximum size.</li>
<li>A linked list-based queue supports dynamic sizing but may involve additional overhead for node creation and deletion.</li>
</ul>
</li>
<li><strong>Circular Queue</strong>: The implementation above uses a circular queue to optimize space usage, allowing the array to wrap around when <code>rear</code> or <code>front</code> reaches the end.</li>
<li><strong>Thread Safety</strong>: The provided implementation is not thread-safe. For concurrent applications, consider using Java’s <code>ConcurrentLinkedQueue</code> or <code>ArrayBlockingQueue</code>.</li>
<li><strong>Java’s Built-in Options</strong>: Java provides <code>Queue</code> as an interface in <code>java.util</code>, with implementations like <code>LinkedList</code> and <code>ArrayDeque</code>. The <code>ArrayDeque</code> is recommended for better performance in most cases.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a circular queue, as shown in the implementation, to make efficient use of array space and avoid wasting memory when elements are dequeued.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: An array-based queue can overflow if you exceed its <code>maxSize</code>. Ensure the queue size is sufficient for your application, or consider a linked list-based queue for dynamic sizing.</p>
</blockquote>
<h3 id="exercises-9"><a class="header" href="#exercises-9">Exercises</a></h3>
<ol>
<li><strong>Print Job Simulator</strong>: Write a Java program that simulates a printer queue using the queue implementation above. Allow users to enqueue print jobs (represented as strings) and dequeue them in order, printing each job as it is processed.</li>
<li><strong>Queue Reversal</strong>: Create a program that reverses the elements of a queue using a stack. Enqueue a set of numbers, reverse them, and print the reversed queue.</li>
<li><strong>Circular Queue Test</strong>: Extend the queue implementation to handle edge cases, such as enqueueing and dequeuing in a loop, and test it with a sequence of operations to verify circular behavior.</li>
<li><strong>Queue-Based BFS</strong>: Implement a simple Breadth-First Search (BFS) algorithm for a graph using the queue. Represent the graph as an adjacency list and print the nodes visited in BFS order.</li>
<li><strong>Ticket Counter Simulation</strong>: Simulate a ticket counter system where customers (represented by names) join a queue and are served in order. Allow users to enqueue customers, dequeue them, and display the current queue size.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="priority-queue-data-structure"><a class="header" href="#priority-queue-data-structure">Priority Queue Data Structure</a></h2>
<h3 id="definition-and-concepts-10"><a class="header" href="#definition-and-concepts-10">Definition and Concepts</a></h3>
<p>A priority queue is an abstract data structure that operates similarly to a regular queue but assigns a priority to each element. Elements with higher priority are dequeued before those with lower priority, regardless of their order of insertion. You can visualize a priority queue as a hospital emergency room where patients with more severe conditions are treated first, even if they arrived later. The primary operations include <strong>enqueue</strong>, which adds an element with a specified priority, and <strong>dequeue</strong>, which removes and returns the element with the highest priority. Additional operations include <strong>peek</strong>, which views the highest-priority element without removing it, and <strong>isEmpty</strong>, which checks if the priority queue is empty. Priority queues are typically implemented using a heap (often a binary heap) to ensure efficient priority-based operations.</p>
<h3 id="why-use-it-10"><a class="header" href="#why-use-it-10">Why Use It?</a></h3>
<p>A priority queue is useful when you need to process elements based on their priority rather than their arrival order. It ensures that the most critical or highest-priority elements are handled first, making it ideal for scheduling, resource allocation, and optimization problems. Priority queues are efficient because they use a heap structure, which provides logarithmic time complexity for most operations.</p>
<h3 id="where-to-use-real-life-examples-10"><a class="header" href="#where-to-use-real-life-examples-10">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Task Scheduling in Operating Systems</strong>: Operating systems use priority queues to schedule processes based on their priority levels, ensuring critical tasks are executed first.</li>
<li><strong>Hospital Emergency Systems</strong>: Emergency rooms prioritize patients based on the severity of their condition, using a priority queue to manage treatment order.</li>
<li><strong>Dijkstra’s Algorithm</strong>: Priority queues are used in graph algorithms like Dijkstra’s to select the next node with the smallest distance.</li>
<li><strong>Huffman Coding</strong>: Priority queues are used to build optimal prefix codes for data compression by repeatedly selecting the two nodes with the smallest frequencies.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a priority queue would depict a binary min-heap as a tree structure. The root node would contain the smallest element (e.g., 5), with child nodes containing larger elements (e.g., 10, 15). Each node would be labeled with a value representing its priority. Arrows would show the **enqueue** operation, adding a new element (e.g., 8) and bubbling it up to maintain the heap property, and the **dequeue** operation, removing the root and reorganizing the heap. A caption would note: "Elements are ordered by priority, with the smallest at the root (min-heap)." -->
<h3 id="explain-operations-10"><a class="header" href="#explain-operations-10">Explain Operations</a></h3>
<ul>
<li><strong>Enqueue</strong>: This operation adds an element with a specified priority to the priority queue. The element is inserted into the heap, and the heap property is restored by bubbling up. It has a time complexity of O(log n).</li>
<li><strong>Dequeue</strong>: This operation removes and returns the element with the highest priority (the root in a min-heap). The last element is moved to the root, and the heap property is restored by bubbling down. It has a time complexity of O(log n).</li>
<li><strong>Peek</strong>: This operation returns the highest-priority element (the root) without removing it. It has a time complexity of O(1).</li>
<li><strong>isEmpty</strong>: This operation checks whether the priority queue is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of elements in the priority queue. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-10"><a class="header" href="#java-implementation-10">Java Implementation</a></h3>
<p>The following Java code implements a priority queue using a binary min-heap, where smaller values have higher priority.</p>
<pre><code class="language-java">public class PriorityQueue {
    private int[] heap; // Array to store the heap elements
    private int maxSize; // Maximum size of the priority queue
    private int size; // Current number of elements in the priority queue

    // Constructor to initialize the priority queue with a given size
    public PriorityQueue(int capacity) {
        maxSize = capacity;
        heap = new int[maxSize];
        size = 0; // Priority queue is initially empty
    }

    // Enqueue: Adds an element to the priority queue
    public void enqueue(int value) {
        if (size &gt;= maxSize) { // Checks if the priority queue is full
            throw new IllegalStateException("The priority queue is full.");
        }
        heap[size] = value; // Adds the new element at the end
        bubbleUp(size); // Restores heap property by bubbling up
        size++; // Increments the size
    }

    // Dequeue: Removes and returns the highest-priority element
    public int dequeue() {
        if (isEmpty()) { // Checks if the priority queue is empty
            throw new IllegalStateException("The priority queue is empty.");
        }
        int result = heap[0]; // Stores the root (highest-priority element)
        heap[0] = heap[size - 1]; // Moves the last element to the root
        size--; // Decrements the size
        if (size &gt; 0) { // Avoids bubbling down if the heap is empty
            bubbleDown(0); // Restores heap property by bubbling down
        }
        return result;
    }

    // Peek: Returns the highest-priority element without removing it
    public int peek() {
        if (isEmpty()) { // Checks if the priority queue is empty
            throw new IllegalStateException("The priority queue is empty.");
        }
        return heap[0]; // Returns the root element
    }

    // isEmpty: Checks if the priority queue is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Size: Returns the number of elements in the priority queue
    public int size() {
        return size;
    }

    // Helper method to bubble up an element to restore min-heap property
    private void bubbleUp(int index) {
        int parent = (index - 1) / 2; // Calculates parent index
        while (index &gt; 0 &amp;&amp; heap[index] &lt; heap[parent]) { // Compares with parent
            swap(index, parent); // Swaps if child is smaller
            index = parent; // Updates index to parent
            parent = (index - 1) / 2; // Recalculates parent
        }
    }

    // Helper method to bubble down an element to restore min-heap property
    private void bubbleDown(int index) {
        int minIndex = index; // Tracks the smallest element
        while (true) {
            int leftChild = 2 * index + 1; // Left child index
            int rightChild = 2 * index + 2; // Right child index
            if (leftChild &lt; size &amp;&amp; heap[leftChild] &lt; heap[minIndex]) {
                minIndex = leftChild; // Updates if left child is smaller
            }
            if (rightChild &lt; size &amp;&amp; heap[rightChild] &lt; heap[minIndex]) {
                minIndex = rightChild; // Updates if right child is smaller
            }
            if (minIndex == index) break; // Stops if no smaller child found
            swap(index, minIndex); // Swaps with the smaller child
            index = minIndex; // Updates index to continue bubbling down
        }
    }

    // Helper method to swap two elements in the heap
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
</code></pre>
<h3 id="how-it-works-11"><a class="header" href="#how-it-works-11">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes an array of size <code>maxSize</code> and sets <code>size</code> to 0, indicating an empty priority queue.</li>
<li><strong>Enqueue Operation</strong>:
<ul>
<li>The method checks if the priority queue is full by comparing <code>size</code> to <code>maxSize</code>.</li>
<li>It adds the new element at the end of the heap (<code>heap[size]</code>), calls <code>bubbleUp</code> to restore the min-heap property by moving the element up if it’s smaller than its parent, and increments <code>size</code>.</li>
<li>If the queue is full, it throws an exception.</li>
</ul>
</li>
<li><strong>Dequeue Operation</strong>:
<ul>
<li>The method verifies that the priority queue is not empty using <code>isEmpty()</code>.</li>
<li>It saves the root element (<code>heap[0]</code>), moves the last element (<code>heap[size-1]</code>) to the root, decrements <code>size</code>, and calls <code>bubbleDown</code> to restore the min-heap property by moving the root down if it’s larger than its children.</li>
<li>If the queue is empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Peek Operation</strong>: The method returns the root element (<code>heap[0]</code>) without modifying the heap.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>size</code> equals 0, indicating an empty priority queue, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>size</code>, which represents the number of elements in the priority queue.</li>
<li><strong>BubbleUp Helper</strong>: This method moves a newly added element up the heap by comparing it with its parent and swapping if it’s smaller, continuing until the heap property is restored.</li>
<li><strong>BubbleDown Helper</strong>: This method moves the root element down by comparing it with its children, swapping with the smaller child if necessary, and continuing until the heap property is restored.</li>
<li><strong>Swap Helper</strong>: This method exchanges two elements in the heap array.</li>
</ol>
<h3 id="complexity-analysis-table-10"><a class="header" href="#complexity-analysis-table-10">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Dequeue</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Peek</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<h3 id="key-differences--notes-10"><a class="header" href="#key-differences--notes-10">Key Differences / Notes</a></h3>
<ul>
<li><strong>Min-Heap vs. Max-Heap</strong>:
<ul>
<li>The implementation above uses a min-heap, where smaller values have higher priority. A max-heap can be implemented by reversing the comparison logic, where larger values have higher priority.</li>
</ul>
</li>
<li><strong>Array-Based vs. Other Implementations</strong>:
<ul>
<li>The array-based heap implementation is memory-efficient and provides O(log n) for enqueue and dequeue operations.</li>
<li>Other implementations, like a binary search tree or linked list, are less common due to higher complexity or overhead.</li>
</ul>
</li>
<li><strong>Thread Safety</strong>: The provided implementation is not thread-safe. For concurrent applications, use Java’s <code>PriorityBlockingQueue</code> or synchronize access.</li>
<li><strong>Java’s Built-in Priority Queue</strong>: Java provides <code>java.util.PriorityQueue</code>, which is a min-heap by default but can be customized for max-heap behavior using a comparator.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a min-heap for scenarios where the smallest element has the highest priority (e.g., shortest path algorithms) and a max-heap for scenarios where the largest element has priority (e.g., task prioritization).</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the priority queue’s capacity is sufficient for your use case to avoid overflow errors in the array-based implementation. For dynamic sizing, consider Java’s <code>PriorityQueue</code> class.</p>
</blockquote>
<h3 id="exercises-10"><a class="header" href="#exercises-10">Exercises</a></h3>
<ol>
<li><strong>Task Scheduler</strong>: Write a Java program that uses the priority queue implementation above to simulate a task scheduler. Enqueue tasks with priorities (represented as integers) and dequeue them in order of highest priority, printing each task as it’s processed.</li>
<li><strong>Kth Largest Element</strong>: Create a program that uses a priority queue to find the kth largest element in an array of integers. Test it with at least three different arrays and k values.</li>
<li><strong>Min-Heap to Max-Heap</strong>: Modify the priority queue implementation to support a max-heap (where larger values have higher priority). Test the modified version with enqueue and dequeue operations.</li>
<li><strong>Dijkstra’s Algorithm</strong>: Implement Dijkstra’s algorithm for a weighted graph using the priority queue. Represent the graph as an adjacency list and compute the shortest paths from a source node.</li>
<li><strong>Merge K Sorted Lists</strong>: Write a program that merges k sorted arrays into a single sorted array using a priority queue. Enqueue the first element of each array with its array index and value, and repeatedly dequeue and enqueue the next element from the same array.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="linked-list-data-structure"><a class="header" href="#linked-list-data-structure">Linked List Data Structure</a></h2>
<h3 id="definition-and-concepts-11"><a class="header" href="#definition-and-concepts-11">Definition and Concepts</a></h3>
<p>A linked list is a linear data structure consisting of a sequence of nodes, where each node contains data and a reference (or link) to the next node. Unlike arrays, linked lists do not store elements in contiguous memory locations, allowing dynamic memory allocation. In a singly linked list, each node points to the next node, with the last node pointing to null. You can visualize a linked list as a chain of boxes, where each box holds a value and an arrow pointing to the next box. Linked lists are flexible for insertions and deletions but require traversal to access elements, making them suitable for dynamic data.</p>
<h3 id="why-use-it-11"><a class="header" href="#why-use-it-11">Why Use It?</a></h3>
<p>Linked lists are used when you need a dynamic data structure that can grow or shrink efficiently without requiring contiguous memory. They allow fast insertions and deletions at known positions (e.g., head or tail) compared to arrays. Linked lists are ideal for applications where the size of the list is unknown or changes frequently, and they serve as a foundation for other data structures like stacks and queues.</p>
<h3 id="where-to-use-real-life-examples-11"><a class="header" href="#where-to-use-real-life-examples-11">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Dynamic Data Storage</strong>: Linked lists are used in applications like music playlists, where songs can be added or removed dynamically.</li>
<li><strong>Implementation of Stacks and Queues</strong>: Stacks and queues are often implemented using linked lists due to their flexibility in size.</li>
<li><strong>Browser History</strong>: Web browsers use linked lists to maintain a history of visited pages, allowing easy navigation forward and backward.</li>
<li><strong>Memory Management</strong>: Operating systems use linked lists to manage free memory blocks in dynamic memory allocation.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a singly linked list would depict a sequence of rectangular nodes, each containing a value (e.g., 10, 20, 30) and an arrow pointing to the next node, with the last node pointing to "null." The first node would be labeled "Head." Arrows would illustrate an **insert** operation adding a new node (e.g., 15) after the head and a **delete** operation removing a node (e.g., 20). A caption would note: "Each node in a linked list contains a value and a reference to the next node, with the last node pointing to null." -->
<h3 id="explain-operations-11"><a class="header" href="#explain-operations-11">Explain Operations</a></h3>
<ul>
<li><strong>Insert at Head</strong>: This operation adds a new node at the beginning of the list. It has a time complexity of O(1).</li>
<li><strong>Insert at Tail</strong>: This operation adds a new node at the end of the list. It has a time complexity of O(n) due to traversal.</li>
<li><strong>Delete at Head</strong>: This operation removes the first node. It has a time complexity of O(1).</li>
<li><strong>Delete by Value</strong>: This operation removes the first node with a given value. It has a time complexity of O(n) due to traversal.</li>
<li><strong>Search</strong>: This operation finds a node with a given value. It has a time complexity of O(n).</li>
<li><strong>isEmpty</strong>: This operation checks whether the linked list is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of nodes in the linked list. It has a time complexity of O(1) if maintained.</li>
</ul>
<h3 id="java-implementation-11"><a class="header" href="#java-implementation-11">Java Implementation</a></h3>
<p>The following Java code implements a singly linked list with basic operations.</p>
<pre><code class="language-java">public class LinkedList {
    private class Node {
        int value; // Value stored in the node
        Node next; // Reference to the next node

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    private Node head; // Head of the linked list
    private int size; // Number of nodes in the linked list

    // Constructor to initialize an empty linked list
    public LinkedList() {
        head = null;
        size = 0;
    }

    // Insert at Head: Adds a new node at the beginning
    public void insertAtHead(int value) {
        Node newNode = new Node(value); // Creates a new node
        newNode.next = head; // Points new node to current head
        head = newNode; // Updates head to new node
        size++; // Increments size
    }

    // Insert at Tail: Adds a new node at the end
    public void insertAtTail(int value) {
        Node newNode = new Node(value); // Creates a new node
        if (isEmpty()) { // If list is empty, sets head to new node
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) { // Traverses to the last node
                current = current.next;
            }
            current.next = newNode; // Adds new node at the end
        }
        size++; // Increments size
    }

    // Delete at Head: Removes the first node
    public void deleteAtHead() {
        if (isEmpty()) { // Checks if the list is empty
            throw new IllegalStateException("The linked list is empty.");
        }
        head = head.next; // Moves head to the next node
        size--; // Decrements size
    }

    // Delete by Value: Removes the first node with the given value
    public void deleteByValue(int value) {
        if (isEmpty()) { // Checks if the list is empty
            throw new IllegalStateException("The linked list is empty.");
        }
        if (head.value == value) { // If head has the value, removes head
            head = head.next;
            size--;
            return;
        }
        Node current = head;
        Node prev = null;
        while (current != null &amp;&amp; current.value != value) { // Traverses to find the value
            prev = current;
            current = current.next;
        }
        if (current == null) { // If value not found
            throw new IllegalArgumentException("Value not found in the linked list.");
        }
        prev.next = current.next; // Bypasses the node to delete
        size--; // Decrements size
    }

    // Search: Checks if a value exists in the linked list
    public boolean search(int value) {
        Node current = head;
        while (current != null) { // Traverses the list
            if (current.value == value) {
                return true; // Returns true if value is found
            }
            current = current.next;
        }
        return false; // Returns false if value is not found
    }

    // isEmpty: Checks if the linked list is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Size: Returns the number of nodes in the linked list
    public int size() {
        return size;
    }
}
</code></pre>
<h3 id="how-it-works-12"><a class="header" href="#how-it-works-12">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes <code>head</code> as null and <code>size</code> as 0, indicating an empty linked list.</li>
<li><strong>Insert at Head</strong>:
<ul>
<li>The method creates a new node with the given value, sets its <code>next</code> to the current <code>head</code>, updates <code>head</code> to the new node, and increments <code>size</code>.</li>
</ul>
</li>
<li><strong>Insert at Tail</strong>:
<ul>
<li>The method creates a new node. If the list is empty, it sets <code>head</code> to the new node. Otherwise, it traverses to the last node and sets its <code>next</code> to the new node, then increments <code>size</code>.</li>
</ul>
</li>
<li><strong>Delete at Head</strong>:
<ul>
<li>The method checks if the list is empty. If not, it moves <code>head</code> to the next node and decrements <code>size</code>. If empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Delete by Value</strong>:
<ul>
<li>The method checks if the list is empty or if the head node has the value. If the head is the target, it updates <code>head</code> and decrements <code>size</code>.</li>
<li>Otherwise, it traverses the list to find the value, keeping track of the previous node, and bypasses the target node by updating the previous node’s <code>next</code>. It decrements <code>size</code> or throws an exception if the value is not found.</li>
</ul>
</li>
<li><strong>Search Operation</strong>: The method traverses the list, returning true if the value is found and false if the end (null) is reached.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>size</code> equals 0, indicating an empty list, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>size</code>, which tracks the number of nodes.</li>
</ol>
<h3 id="complexity-analysis-table-11"><a class="header" href="#complexity-analysis-table-11">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert at Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Insert at Tail</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Delete at Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Delete by Value</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Search</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: n is the number of nodes in the linked list.</p>
<h3 id="key-differences--notes-11"><a class="header" href="#key-differences--notes-11">Key Differences / Notes</a></h3>
<ul>
<li><strong>Singly vs. Doubly Linked List</strong>:
<ul>
<li>The implementation above is a singly linked list, where each node points to the next. It is memory-efficient but slow for tail operations (O(n)).</li>
<li>A doubly linked list has nodes with pointers to both the next and previous nodes, enabling O(1) tail deletions but using more memory.</li>
</ul>
</li>
<li><strong>Linked List vs. Array</strong>:
<ul>
<li>Linked lists support dynamic sizing and efficient insertions/deletions at the head, but random access and tail operations are O(n).</li>
<li>Arrays offer O(1) random access but require contiguous memory and have O(n) insertions/deletions in the middle.</li>
</ul>
</li>
<li><strong>Thread Safety</strong>: The implementation is not thread-safe. For concurrent applications, use Java’s <code>ConcurrentLinkedDeque</code> or synchronize access.</li>
<li><strong>Java’s Built-in Linked List</strong>: Java provides <code>LinkedList</code> in <code>java.util</code>, which is a doubly linked list supporting both List and Deque interfaces.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a linked list when frequent insertions or deletions at the head are needed, or when the size of the list is unknown. For tail operations, consider a doubly linked list or maintain a tail pointer.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid using a singly linked list for applications requiring frequent access to the tail or random positions, as traversal is O(n). Use arrays or other structures for such cases.</p>
</blockquote>
<h3 id="exercises-11"><a class="header" href="#exercises-11">Exercises</a></h3>
<ol>
<li><strong>Reverse a Linked List</strong>: Write a Java program that reverses the linked list using the implementation above. Test it with lists of varying sizes.</li>
<li><strong>Cycle Detection</strong>: Extend the linked list implementation to detect if it contains a cycle (e.g., using Floyd’s Tortoise and Hare algorithm). Test with cyclic and acyclic lists.</li>
<li><strong>Merge Two Sorted Lists</strong>: Create a program that merges two sorted linked lists into a single sorted linked list. Use the implementation above and test with different inputs.</li>
<li><strong>Middle Element Finder</strong>: Implement a method to find the middle element of the linked list in a single pass. Use the fast-and-slow pointer technique and test it.</li>
<li><strong>Playlist Manager</strong>: Simulate a music playlist using the linked list. Allow users to add songs (insert at head or tail), remove songs (delete by value), and print the playlist.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="doubly-linked-list-data-structure"><a class="header" href="#doubly-linked-list-data-structure">Doubly Linked List Data Structure</a></h2>
<h3 id="definition-and-concepts-12"><a class="header" href="#definition-and-concepts-12">Definition and Concepts</a></h3>
<p>A doubly linked list is a linear data structure consisting of a sequence of nodes, where each node contains data, a reference to the next node, and a reference to the previous node. Unlike a singly linked list, which only allows traversal in one direction, a doubly linked list enables bidirectional traversal, making operations like deletion and insertion at both ends more efficient. The first node (head) has a null previous reference, and the last node (tail) has a null next reference. You can visualize a doubly linked list as a chain of boxes, where each box holds a value and arrows point to both the next and previous boxes. This structure is ideal for applications requiring frequent insertions, deletions, or reverse traversal.</p>
<h3 id="why-use-it-12"><a class="header" href="#why-use-it-12">Why Use It?</a></h3>
<p>A doubly linked list is used when you need a dynamic data structure that supports efficient insertions and deletions at both the head and tail, as well as bidirectional traversal. It provides more flexibility than a singly linked list by allowing navigation in both directions, which is useful for applications like undo/redo functionality or browsing history. Although it uses more memory due to the additional previous pointers, it offers O(1) time complexity for operations at the head and tail, making it suitable for dynamic datasets.</p>
<h3 id="where-to-use-real-life-examples-12"><a class="header" href="#where-to-use-real-life-examples-12">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Undo/Redo Functionality</strong>: Text editors use doubly linked lists to track actions, allowing users to move forward (redo) or backward (undo) through the action history.</li>
<li><strong>Browser Navigation</strong>: Web browsers use doubly linked lists to manage browsing history, enabling users to navigate back and forward between visited pages.</li>
<li><strong>Music or Video Playlists</strong>: Media players use doubly linked lists to manage playlists, allowing users to move to the next or previous song efficiently.</li>
<li><strong>Deque Implementation</strong>: Doubly linked lists are used to implement double-ended queues (deques), supporting insertions and deletions at both ends.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a doubly linked list would depict a sequence of rectangular nodes, each containing a value (e.g., 10, 20, 30) with arrows pointing to both the next and previous nodes. The first node would be labeled "Head" with a null previous arrow, and the last node would be labeled "Tail" with a null next arrow. Arrows would illustrate an **insert at tail** operation adding a new node (e.g., 40) and a **delete at head** operation removing the head node. A caption would note: "Each node in a doubly linked list contains a value, a next pointer, and a previous pointer, enabling bidirectional traversal." -->
<h3 id="explain-operations-12"><a class="header" href="#explain-operations-12">Explain Operations</a></h3>
<ul>
<li><strong>Insert at Head</strong>: This operation adds a new node at the beginning of the list. It has a time complexity of O(1).</li>
<li><strong>Insert at Tail</strong>: This operation adds a new node at the end of the list. It has a time complexity of O(1) if a tail pointer is maintained.</li>
<li><strong>Delete at Head</strong>: This operation removes the first node. It has a time complexity of O(1).</li>
<li><strong>Delete at Tail</strong>: This operation removes the last node. It has a time complexity of O(1) if a tail pointer is maintained.</li>
<li><strong>Search</strong>: This operation finds a node with a given value. It has a time complexity of O(n).</li>
<li><strong>isEmpty</strong>: This operation checks whether the doubly linked list is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of nodes in the doubly linked list. It has a time complexity of O(1) if maintained.</li>
</ul>
<h3 id="java-implementation-12"><a class="header" href="#java-implementation-12">Java Implementation</a></h3>
<p>The following Java code implements a doubly linked list with basic operations, maintaining both head and tail pointers for efficiency.</p>
<pre><code class="language-java">public class DoublyLinkedList {
    private class Node {
        int value; // Value stored in the node
        Node next; // Reference to the next node
        Node prev; // Reference to the previous node

        Node(int value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
    }

    private Node head; // Head of the doubly linked list
    private Node tail; // Tail of the doubly linked list
    private int size; // Number of nodes in the doubly linked list

    // Constructor to initialize an empty doubly linked list
    public DoublyLinkedList() {
        head = null;
        tail = null;
        size = 0;
    }

    // Insert at Head: Adds a new node at the beginning
    public void insertAtHead(int value) {
        Node newNode = new Node(value); // Creates a new node
        if (isEmpty()) { // If list is empty, sets both head and tail
            head = newNode;
            tail = newNode;
        } else {
            newNode.next = head; // Points new node to current head
            head.prev = newNode; // Points current head back to new node
            head = newNode; // Updates head to new node
        }
        size++; // Increments size
    }

    // Insert at Tail: Adds a new node at the end
    public void insertAtTail(int value) {
        Node newNode = new Node(value); // Creates a new node
        if (isEmpty()) { // If list is empty, sets both head and tail
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode; // Points current tail to new node
            newNode.prev = tail; // Points new node back to current tail
            tail = newNode; // Updates tail to new node
        }
        size++; // Increments size
    }

    // Delete at Head: Removes the first node
    public void deleteAtHead() {
        if (isEmpty()) { // Checks if the list is empty
            throw new IllegalStateException("The doubly linked list is empty.");
        }
        head = head.next; // Moves head to the next node
        if (head == null) { // If list becomes empty, updates tail
            tail = null;
        } else {
            head.prev = null; // Sets new head's previous to null
        }
        size--; // Decrements size
    }

    // Delete at Tail: Removes the last node
    public void deleteAtTail() {
        if (isEmpty()) { // Checks if the list is empty
            throw new IllegalStateException("The doubly linked list is empty.");
        }
        tail = tail.prev; // Moves tail to the previous node
        if (tail == null) { // If list becomes empty, updates head
            head = null;
        } else {
            tail.next = null; // Sets new tail's next to null
        }
        size--; // Decrements size
    }

    // Search: Checks if a value exists in the doubly linked list
    public boolean search(int value) {
        Node current = head;
        while (current != null) { // Traverses the list
            if (current.value == value) {
                return true; // Returns true if value is found
            }
            current = current.next;
        }
        return false; // Returns false if value is not found
    }

    // isEmpty: Checks if the doubly linked list is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Size: Returns the number of nodes in the doubly linked list
    public int size() {
        return size;
    }
}
</code></pre>
<h3 id="how-it-works-13"><a class="header" href="#how-it-works-13">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes <code>head</code> and <code>tail</code> as null and <code>size</code> as 0, indicating an empty doubly linked list.</li>
<li><strong>Insert at Head</strong>:
<ul>
<li>The method creates a new node with the given value.</li>
<li>If the list is empty, it sets both <code>head</code> and <code>tail</code> to the new node.</li>
<li>Otherwise, it links the new node to the current <code>head</code>, updates the <code>head</code>’s previous pointer, sets <code>head</code> to the new node, and increments <code>size</code>.</li>
</ul>
</li>
<li><strong>Insert at Tail</strong>:
<ul>
<li>The method creates a new node.</li>
<li>If the list is empty, it sets both <code>head</code> and <code>tail</code> to the new node.</li>
<li>Otherwise, it links the current <code>tail</code> to the new node, sets the new node’s previous pointer to the <code>tail</code>, updates <code>tail</code> to the new node, and increments <code>size</code>.</li>
</ul>
</li>
<li><strong>Delete at Head</strong>:
<ul>
<li>The method checks if the list is empty. If not, it moves <code>head</code> to the next node, sets the new <code>head</code>’s previous pointer to null (if not null), updates <code>tail</code> if the list becomes empty, and decrements <code>size</code>. If empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Delete at Tail</strong>:
<ul>
<li>The method checks if the list is empty. If not, it moves <code>tail</code> to the previous node, sets the new <code>tail</code>’s next pointer to null (if not null), updates <code>head</code> if the list becomes empty, and decrements <code>size</code>. If empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Search Operation</strong>: The method traverses the list from <code>head</code> to <code>tail</code>, returning true if the value is found and false if the end (null) is reached.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>size</code> equals 0, indicating an empty list, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>size</code>, which tracks the number of nodes.</li>
</ol>
<h3 id="complexity-analysis-table-12"><a class="header" href="#complexity-analysis-table-12">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert at Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Insert at Tail</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Delete at Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Delete at Tail</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Search</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: n is the number of nodes in the doubly linked list.</p>
<h3 id="key-differences--notes-12"><a class="header" href="#key-differences--notes-12">Key Differences / Notes</a></h3>
<ul>
<li><strong>Doubly vs. Singly Linked List</strong>:
<ul>
<li>The implementation above is a doubly linked list, which allows O(1) insertions and deletions at both head and tail due to the <code>tail</code> pointer and bidirectional links.</li>
<li>A singly linked list only has next pointers, making tail operations O(n) unless a tail pointer is maintained, but it uses less memory.</li>
</ul>
</li>
<li><strong>Doubly Linked List vs. Array</strong>:
<ul>
<li>Doubly linked lists support dynamic sizing and O(1) operations at both ends but have O(n) access and search times.</li>
<li>Arrays offer O(1) random access but require contiguous memory and have O(n) insertions/deletions in the middle.</li>
</ul>
</li>
<li><strong>Thread Safety</strong>: The implementation is not thread-safe. For concurrent applications, use Java’s <code>ConcurrentLinkedDeque</code> or synchronize access.</li>
<li><strong>Java’s Built-in Doubly Linked List</strong>: Java provides <code>LinkedList</code> in <code>java.util</code>, which is a doubly linked list implementing both List and Deque interfaces.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a doubly linked list when you need efficient insertions and deletions at both ends or bidirectional traversal, such as in navigation systems or deques.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Doubly linked lists use more memory than singly linked lists due to the additional previous pointers. Ensure memory constraints are considered for large datasets.</p>
</blockquote>
<h3 id="exercises-12"><a class="header" href="#exercises-12">Exercises</a></h3>
<ol>
<li><strong>Reverse a Doubly Linked List</strong>: Write a Java program that reverses the doubly linked list using the implementation above. Test it with lists of varying sizes.</li>
<li><strong>Bidirectional Traversal</strong>: Extend the implementation to include methods for printing the list in both forward (head to tail) and backward (tail to head) directions. Test with a sample list.</li>
<li><strong>Insert After Value</strong>: Add a method to insert a new node after the first occurrence of a given value. Test it with cases where the value exists and does not exist.</li>
<li><strong>Deque Implementation</strong>: Use the doubly linked list to implement a double-ended queue (deque) with methods for adding and removing elements at both ends. Test with a sequence of operations.</li>
<li><strong>Browser History Simulator</strong>: Create a program that simulates a browser’s navigation history using the doubly linked list. Allow users to add pages (insert at tail), navigate back (delete at tail), and navigate forward (re-insert).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="circular-linked-list-data-structure"><a class="header" href="#circular-linked-list-data-structure">Circular Linked List Data Structure</a></h2>
<h3 id="definition-and-concepts-13"><a class="header" href="#definition-and-concepts-13">Definition and Concepts</a></h3>
<p>A circular linked list is a linear data structure where nodes are arranged in a sequence, and the last node points back to the first node, forming a loop. In a singly circular linked list, each node contains data and a reference to the next node, with the last node’s next pointer linking to the head node instead of null. Unlike a standard singly linked list, which has a definite end, a circular linked list allows continuous traversal. You can visualize a circular linked list as a ring of boxes, where each box holds a value and an arrow points to the next box, with the last box pointing back to the first. This structure is ideal for applications requiring cyclic or round-robin processing.</p>
<h3 id="why-use-it-13"><a class="header" href="#why-use-it-13">Why Use It?</a></h3>
<p>A circular linked list is used when you need a data structure that supports continuous looping through elements, such as in round-robin scheduling or cyclic data processing. It eliminates the need to reset traversal to the beginning after reaching the end, making it efficient for repetitive tasks. The circular nature simplifies certain operations, like rotating the list, and it can be used as a foundation for structures like circular buffers.</p>
<h3 id="where-to-use-real-life-examples-13"><a class="header" href="#where-to-use-real-life-examples-13">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Round-Robin Scheduling</strong>: Operating systems use circular linked lists to manage processes in a round-robin fashion, cycling through tasks to allocate CPU time.</li>
<li><strong>Music Playlist Looping</strong>: Music players use circular linked lists to implement a looping playlist, where playback restarts from the first song after the last one.</li>
<li><strong>Circular Buffers</strong>: Network applications use circular linked lists to implement buffers for streaming data, reusing space in a fixed-size structure.</li>
<li><strong>Multiplayer Game Turns</strong>: Board games or turn-based applications use circular linked lists to cycle through players’ turns indefinitely.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a singly circular linked list would depict a sequence of rectangular nodes arranged in a circle, each containing a value (e.g., 10, 20, 30). Arrows would connect each node to the next, with the last node’s arrow pointing back to the first node, labeled "Head." The diagram would illustrate an **insert at tail** operation adding a new node (e.g., 40) and a **delete at head** operation removing the head node. A caption would note: "In a circular linked list, the last node points back to the head, forming a loop for continuous traversal." -->
<h3 id="explain-operations-13"><a class="header" href="#explain-operations-13">Explain Operations</a></h3>
<ul>
<li><strong>Insert at Head</strong>: This operation adds a new node at the beginning of the list, updating the last node’s pointer to the new head. It has a time complexity of O(1) if a tail pointer is maintained.</li>
<li><strong>Insert at Tail</strong>: This operation adds a new node at the end of the list, updating the last node’s pointer to the new node and linking it to the head. It has a time complexity of O(1) if a tail pointer is maintained.</li>
<li><strong>Delete at Head</strong>: This operation removes the first node, updating the last node’s pointer to the new head. It has a time complexity of O(1) if a tail pointer is maintained.</li>
<li><strong>Delete by Value</strong>: This operation removes the first node with a given value. It has a time complexity of O(n) due to traversal.</li>
<li><strong>Search</strong>: This operation finds a node with a given value. It has a time complexity of O(n).</li>
<li><strong>isEmpty</strong>: This operation checks whether the circular linked list is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of nodes in the circular linked list. It has a time complexity of O(1) if maintained.</li>
</ul>
<h3 id="java-implementation-13"><a class="header" href="#java-implementation-13">Java Implementation</a></h3>
<p>The following Java code implements a singly circular linked list with basic operations, maintaining a tail pointer for efficiency.</p>
<pre><code class="language-java">public class CircularLinkedList {
    private class Node {
        int value; // Value stored in the node
        Node next; // Reference to the next node

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    private Node tail; // Tail of the circular linked list
    private int size; // Number of nodes in the circular linked list

    // Constructor to initialize an empty circular linked list
    public CircularLinkedList() {
        tail = null;
        size = 0;
    }

    // Insert at Head: Adds a new node at the beginning
    public void insertAtHead(int value) {
        Node newNode = new Node(value); // Creates a new node
        if (isEmpty()) { // If list is empty, sets tail to new node and links to itself
            tail = newNode;
            newNode.next = newNode;
        } else {
            newNode.next = tail.next; // Points new node to current head
            tail.next = newNode; // Points tail to new node (new head)
        }
        size++; // Increments size
    }

    // Insert at Tail: Adds a new node at the end
    public void insertAtTail(int value) {
        Node newNode = new Node(value); // Creates a new node
        if (isEmpty()) { // If list is empty, sets tail to new node and links to itself
            tail = newNode;
            newNode.next = newNode;
        } else {
            newNode.next = tail.next; // Points new node to current head
            tail.next = newNode; // Points current tail to new node
            tail = newNode; // Updates tail to new node
        }
        size++; // Increments size
    }

    // Delete at Head: Removes the first node
    public void deleteAtHead() {
        if (isEmpty()) { // Checks if the list is empty
            throw new IllegalStateException("The circular linked list is empty.");
        }
        if (size == 1) { // If only one node, clears the list
            tail = null;
        } else {
            tail.next = tail.next.next; // Points tail to the second node (new head)
        }
        size--; // Decrements size
    }

    // Delete by Value: Removes the first node with the given value
    public void deleteByValue(int value) {
        if (isEmpty()) { // Checks if the list is empty
            throw new IllegalStateException("The circular linked list is empty.");
        }
        Node current = tail.next; // Starts at head
        Node prev = tail; // Previous node for deletion
        do {
            if (current.value == value) { // If value is found
                if (size == 1) { // If only one node, clears the list
                    tail = null;
                } else if (current == tail.next) { // If head node
                    tail.next = current.next;
                } else if (current == tail) { // If tail node
                    prev.next = tail.next;
                    tail = prev;
                } else { // If middle node
                    prev.next = current.next;
                }
                size--; // Decrements size
                return;
            }
            prev = current;
            current = current.next;
        } while (current != tail.next); // Loops until back to head
        throw new IllegalArgumentException("Value not found in the circular linked list.");
    }

    // Search: Checks if a value exists in the circular linked list
    public boolean search(int value) {
        if (isEmpty()) { // Checks if the list is empty
            return false;
        }
        Node current = tail.next; // Starts at head
        do {
            if (current.value == value) { // Returns true if value is found
                return true;
            }
            current = current.next;
        } while (current != tail.next); // Loops until back to head
        return false; // Returns false if value is not found
    }

    // isEmpty: Checks if the circular linked list is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Size: Returns the number of nodes in the circular linked list
    public int size() {
        return size;
    }
}
</code></pre>
<h3 id="how-it-works-14"><a class="header" href="#how-it-works-14">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes <code>tail</code> as null and <code>size</code> as 0, indicating an empty circular linked list.</li>
<li><strong>Insert at Head</strong>:
<ul>
<li>The method creates a new node with the given value.</li>
<li>If the list is empty, it sets <code>tail</code> to the new node and links it to itself.</li>
<li>Otherwise, it sets the new node’s <code>next</code> to the current head (<code>tail.next</code>), updates <code>tail.next</code> to the new node, and increments <code>size</code>.</li>
</ul>
</li>
<li><strong>Insert at Tail</strong>:
<ul>
<li>The method creates a new node.</li>
<li>If the list is empty, it sets <code>tail</code> to the new node and links it to itself.</li>
<li>Otherwise, it sets the new node’s <code>next</code> to the current head, updates <code>tail.next</code> to the new node, sets <code>tail</code> to the new node, and increments <code>size</code>.</li>
</ul>
</li>
<li><strong>Delete at Head</strong>:
<ul>
<li>The method checks if the list is empty. If not, it updates <code>tail.next</code> to the second node (new head) if multiple nodes exist, or sets <code>tail</code> to null if only one node, then decrements <code>size</code>. If empty, it throws an exception.</li>
</ul>
</li>
<li><strong>Delete by Value</strong>:
<ul>
<li>The method traverses from the head (<code>tail.next</code>) to find the value, keeping track of the previous node.</li>
<li>If found, it handles three cases: single node (clears the list), head node (updates <code>tail.next</code>), tail node (updates <code>tail</code> and <code>prev.next</code>), or middle node (updates <code>prev.next</code>). It decrements <code>size</code>.</li>
<li>If the value is not found after a full loop, it throws an exception.</li>
</ul>
</li>
<li><strong>Search Operation</strong>: The method traverses from the head, returning true if the value is found, or false after a full loop to the head.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>size</code> equals 0, indicating an empty list, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>size</code>, which tracks the number of nodes.</li>
</ol>
<h3 id="complexity-analysis-table-13"><a class="header" href="#complexity-analysis-table-13">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert at Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Insert at Tail</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Delete at Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Delete by Value</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Search</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: n is the number of nodes in the circular linked list. O(1) operations assume a tail pointer is maintained.</p>
<h3 id="key-differences--notes-13"><a class="header" href="#key-differences--notes-13">Key Differences / Notes</a></h3>
<ul>
<li><strong>Circular vs. Singly Linked List</strong>:
<ul>
<li>The implementation above is a singly circular linked list, where the last node points to the head, enabling continuous traversal. A singly linked list ends with a null pointer, requiring traversal to restart from the head.</li>
<li>Circular linked lists are more complex to manage due to the loop, but they simplify cyclic operations.</li>
</ul>
</li>
<li><strong>Circular vs. Doubly Circular Linked List</strong>:
<ul>
<li>A doubly circular linked list includes previous pointers, allowing bidirectional traversal, but uses more memory.</li>
<li>The singly circular linked list is simpler and more memory-efficient but only supports forward traversal.</li>
</ul>
</li>
<li><strong>Thread Safety</strong>: The implementation is not thread-safe. For concurrent applications, use Java’s <code>ConcurrentLinkedDeque</code> or synchronize access.</li>
<li><strong>Java’s Built-in Support</strong>: Java’s <code>LinkedList</code> can be adapted for circular behavior, but no direct circular linked list class is provided. Libraries like Apache Commons Collections offer circular list implementations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a circular linked list when your application requires continuous cycling through elements, such as in scheduling or looping playlists. Maintaining a tail pointer simplifies head and tail operations to O(1).</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious when traversing a circular linked list to avoid infinite loops. Always use a condition (e.g., checking for the head node) to terminate traversal.</p>
</blockquote>
<h3 id="exercises-13"><a class="header" href="#exercises-13">Exercises</a></h3>
<ol>
<li><strong>Rotate the List</strong>: Write a Java program that rotates the circular linked list by k positions (e.g., move the head k nodes forward). Test with different values of k and list sizes.</li>
<li><strong>Split Circular List</strong>: Implement a method to split a circular linked list into two circular linked lists of roughly equal size. Test with even and odd-sized lists.</li>
<li><strong>Josephus Problem</strong>: Solve the Josephus problem using the circular linked list, where every k-th person in a circle is eliminated until one remains. Test with different k values.</li>
<li><strong>Insert After Value</strong>: Add a method to insert a new node after the first occurrence of a given value in the circular linked list. Test with cases where the value exists and does not exist.</li>
<li><strong>Round-Robin Scheduler</strong>: Create a program that simulates a round-robin scheduler using the circular linked list. Allow users to add tasks (nodes), cycle through them, and remove completed tasks.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="hashing-data-structure"><a class="header" href="#hashing-data-structure">Hashing Data Structure</a></h2>
<h3 id="definition-and-concepts-14"><a class="header" href="#definition-and-concepts-14">Definition and Concepts</a></h3>
<p>Hashing is a technique used to map data of arbitrary size to fixed-size values, typically for efficient storage and retrieval in a data structure called a hash table. A hash table uses a hash function to compute an index (or hash code) for each key, which determines where the key-value pair is stored in an array. The goal is to enable fast access to data using keys, such as strings or numbers. You can visualize a hash table as a set of labeled drawers, where each label (key) quickly directs you to the corresponding drawer (value). Collisions, where multiple keys map to the same index, are resolved using techniques like separate chaining (using linked lists) or open addressing (using probing). Hashing is fundamental for applications requiring quick lookups, insertions, and deletions.</p>
<h3 id="why-use-it-14"><a class="header" href="#why-use-it-14">Why Use It?</a></h3>
<p>Hashing is used to achieve fast data retrieval, insertion, and deletion with an average time complexity of O(1). It is ideal for scenarios where you need to associate keys with values and access them efficiently without iterating through the entire dataset. Hash tables are versatile and widely used in databases, caches, and other systems requiring rapid data access.</p>
<h3 id="where-to-use-real-life-examples-14"><a class="header" href="#where-to-use-real-life-examples-14">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Database Indexing</strong>: Databases use hashing to index records, allowing quick retrieval of data based on keys like user IDs.</li>
<li><strong>Caches</strong>: Web browsers and content delivery networks use hash tables to cache web pages, mapping URLs to cached content for fast access.</li>
<li><strong>Symbol Tables in Compilers</strong>: Compilers use hash tables to store variable names and their attributes during code compilation.</li>
<li><strong>Password Storage</strong>: Systems store hashed passwords to verify user credentials quickly without storing plain text.</li>
</ul>
<!-- 
### SVG Diagram
The diagram for a hash table would depict an array of fixed size (e.g., 10 slots), with each slot representing a bucket. Some slots would contain linked lists (for separate chaining) to handle collisions, with nodes labeled as key-value pairs (e.g., "key1:value1"). Arrows would show a hash function mapping a key (e.g., "apple") to an index (e.g., 3) via a formula like `hash("apple") % 10`. The diagram would illustrate an **insert** operation adding a key-value pair and a **lookup** operation retrieving a value by key. A caption would note: "Hashing maps keys to indices for fast access, with collisions resolved by linked lists." -->
<h3 id="explain-operations-14"><a class="header" href="#explain-operations-14">Explain Operations</a></h3>
<ul>
<li><strong>Insert</strong>: This operation adds a key-value pair to the hash table. The hash function computes an index for the key, and the pair is stored at that index (or in a linked list if a collision occurs). It has an average time complexity of O(1).</li>
<li><strong>Lookup</strong>: This operation retrieves the value associated with a given key by computing its hash and checking the corresponding index. It has an average time complexity of O(1).</li>
<li><strong>Delete</strong>: This operation removes a key-value pair by finding the key’s index and removing it from the bucket (or linked list). It has an average time complexity of O(1).</li>
<li><strong>isEmpty</strong>: This operation checks whether the hash table is empty. It has a time complexity of O(1).</li>
<li><strong>Size</strong>: This operation returns the number of key-value pairs in the hash table. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-14"><a class="header" href="#java-implementation-14">Java Implementation</a></h3>
<p>The following Java code implements a hash table using separate chaining (linked lists for collision resolution).</p>
<pre><code class="language-java">public class HashTable {
    private static class Node {
        String key; // Key for the hash table entry
        int value; // Value associated with the key
        Node next; // Reference to the next node in case of collision

        Node(String key, int value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }

    private Node[] buckets; // Array of linked lists for storing key-value pairs
    private int capacity; // Size of the buckets array
    private int size; // Number of key-value pairs in the hash table

    // Constructor to initialize the hash table with a given capacity
    public HashTable(int capacity) {
        this.capacity = capacity;
        this.buckets = new Node[capacity];
        this.size = 0;
    }

    // Hash function to compute index for a key
    private int hash(String key) {
        return Math.abs(key.hashCode() % capacity); // Ensures non-negative index
    }

    // Insert: Adds a key-value pair to the hash table
    public void insert(String key, int value) {
        int index = hash(key); // Computes the index for the key
        if (buckets[index] == null) { // If bucket is empty, create new node
            buckets[index] = new Node(key, value);
            size++;
            return;
        }
        Node current = buckets[index];
        while (current != null) { // Traverses the linked list
            if (current.key.equals(key)) { // Updates value if key exists
                current.value = value;
                return;
            }
            if (current.next == null) break; // Reaches the end of the list
            current = current.next;
        }
        current.next = new Node(key, value); // Adds new node at the end
        size++;
    }

    // Lookup: Retrieves the value for a given key
    public int lookup(String key) {
        int index = hash(key); // Computes the index for the key
        Node current = buckets[index];
        while (current != null) { // Traverses the linked list
            if (current.key.equals(key)) {
                return current.value; // Returns value if key is found
            }
            current = current.next;
        }
        throw new IllegalArgumentException("Key not found in the hash table.");
    }

    // Delete: Removes a key-value pair from the hash table
    public void delete(String key) {
        int index = hash(key); // Computes the index for the key
        Node current = buckets[index];
        Node prev = null;
        while (current != null) { // Traverses the linked list
            if (current.key.equals(key)) {
                if (prev == null) { // If key is at the head
                    buckets[index] = current.next;
                } else {
                    prev.next = current.next; // Bypasses the node
                }
                size--;
                return;
            }
            prev = current;
            current = current.next;
        }
        throw new IllegalArgumentException("Key not found in the hash table.");
    }

    // isEmpty: Checks if the hash table is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Size: Returns the number of key-value pairs in the hash table
    public int size() {
        return size;
    }
}
</code></pre>
<h3 id="how-it-works-15"><a class="header" href="#how-it-works-15">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes an array of <code>Node</code> objects (<code>buckets</code>) with a given <code>capacity</code> and sets <code>size</code> to 0, indicating an empty hash table.</li>
<li><strong>Hash Function</strong>: The <code>hash</code> method computes an index by applying Java’s <code>hashCode</code> to the key and using modulo <code>capacity</code> to fit within the array bounds, ensuring a non-negative index.</li>
<li><strong>Insert Operation</strong>:
<ul>
<li>The method computes the index for the key using the hash function.</li>
<li>If the bucket at that index is empty, it creates a new <code>Node</code> with the key-value pair.</li>
<li>If the bucket contains a linked list, it traverses to check if the key exists (updating the value if found) or appends a new node at the end.</li>
<li>It increments <code>size</code> for new entries.</li>
</ul>
</li>
<li><strong>Lookup Operation</strong>:
<ul>
<li>The method computes the index for the key and traverses the linked list at that index.</li>
<li>If the key is found, it returns the associated value; otherwise, it throws an exception.</li>
</ul>
</li>
<li><strong>Delete Operation</strong>:
<ul>
<li>The method computes the index and traverses the linked list to find the key.</li>
<li>If found, it removes the node by updating pointers (either setting the bucket to the next node or bypassing the node) and decrements <code>size</code>.</li>
<li>If the key is not found, it throws an exception.</li>
</ul>
</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>size</code> equals 0, indicating an empty hash table, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>size</code>, which represents the number of key-value pairs.</li>
</ol>
<h3 id="complexity-analysis-table-14"><a class="header" href="#complexity-analysis-table-14">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Average Time Complexity</th><th>Worst-Case Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert</td><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Lookup</td><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Delete</td><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: Worst-case time complexity occurs when many keys hash to the same index, causing long linked lists.</p>
<h3 id="key-differences--notes-14"><a class="header" href="#key-differences--notes-14">Key Differences / Notes</a></h3>
<ul>
<li><strong>Separate Chaining vs. Open Addressing</strong>:
<ul>
<li>The implementation above uses separate chaining (linked lists) to handle collisions, which is simpler and handles high load factors well.</li>
<li>Open addressing resolves collisions by probing for the next available slot, which can be more memory-efficient but requires careful handling of deletions.</li>
</ul>
</li>
<li><strong>Load Factor</strong>: The load factor (size/capacity) affects performance. A high load factor increases collisions, slowing operations. Resizing the hash table (doubling capacity) can maintain efficiency.</li>
<li><strong>Thread Safety</strong>: The provided implementation is not thread-safe. For concurrent applications, use Java’s <code>ConcurrentHashMap</code> or synchronize access.</li>
<li><strong>Java’s Built-in Hash Table</strong>: Java provides <code>HashMap</code> and <code>Hashtable</code> in <code>java.util</code>. <code>HashMap</code> is preferred for non-thread-safe applications, while <code>ConcurrentHashMap</code> is used for thread safety.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Choose a good hash function to minimize collisions, as this directly impacts performance. Java’s <code>hashCode</code> is a reasonable default, but custom hash functions may be needed for specific key types.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: A poorly designed hash function or a small table size can lead to frequent collisions, degrading performance to O(n) in the worst case. Monitor the load factor and resize the table if necessary.</p>
</blockquote>
<h3 id="exercises-14"><a class="header" href="#exercises-14">Exercises</a></h3>
<ol>
<li><strong>Word Frequency Counter</strong>: Write a Java program that uses the hash table implementation above to count the frequency of words in a given text. Use words as keys and their counts as values, then print the results.</li>
<li><strong>Phone Book Application</strong>: Create a program that implements a phone book using the hash table. Allow users to insert, lookup, and delete contacts (name as key, phone number as value).</li>
<li><strong>Collision Analysis</strong>: Modify the hash table to track the number of collisions (multiple keys mapping to the same index). Test it with a set of keys and report the collision count.</li>
<li><strong>Two Sum Problem</strong>: Implement a solution to the Two Sum problem (find two numbers in an array that add up to a target sum) using the hash table. Return the indices of the two numbers.</li>
<li><strong>Custom Hash Function</strong>: Create a custom hash function for a specific key type (e.g., strings with a fixed format) and integrate it into the hash table implementation. Compare its performance with Java’s default <code>hashCode</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="tree-data-structure"><a class="header" href="#tree-data-structure">Tree Data Structure</a></h2>
<h3 id="definition-and-concepts-15"><a class="header" href="#definition-and-concepts-15">Definition and Concepts</a></h3>
<p>A tree is a hierarchical data structure consisting of nodes connected by edges, with a single root node at the top and no cycles. Each node can have zero or more child nodes, and every node except the root has exactly one parent. In a Binary Search Tree (BST), which is a common type of tree, each node has at most two children (left and right), and the left subtree contains values less than the node’s value, while the right subtree contains values greater. Trees are used to represent hierarchical relationships and enable efficient searching, insertion, and deletion. You can visualize a tree as a family tree, where each person (node) has descendants (children) and an ancestor (parent).</p>
<h3 id="why-use-it-15"><a class="header" href="#why-use-it-15">Why Use It?</a></h3>
<p>Trees are used to organize data hierarchically, enabling efficient operations like searching, insertion, and deletion with an average time complexity of O(log n) in a balanced BST. They are ideal for applications requiring ordered data, dynamic updates, or hierarchical structures. Trees provide a natural way to represent relationships, such as organizational charts or file systems, and are foundational for advanced data structures like heaps and tries.</p>
<h3 id="where-to-use-real-life-examples-15"><a class="header" href="#where-to-use-real-life-examples-15">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>File Systems</strong>: Operating systems use trees to represent directory structures, where folders are nodes and subfolders or files are children.</li>
<li><strong>Database Indexing</strong>: Databases use trees (e.g., B-trees or BSTs) to index data, enabling fast searches and range queries.</li>
<li><strong>Expression Parsing</strong>: Compilers use expression trees to represent mathematical expressions, such as <code>(2 + 3) * 4</code>, for evaluation.</li>
<li><strong>Autocomplete Systems</strong>: Search engines use trie (a type of tree) to store words for efficient prefix-based suggestions.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a Binary Search Tree would depict a tree with a root node (e.g., value 50) and branches to left and right children (e.g., 30 and 70). The left subtree would contain smaller values (e.g., 20, 40), and the right subtree would contain larger values (e.g., 60, 80). Arrows would show an **insert** operation adding a new node (e.g., 25) to the left subtree and a **search** operation tracing the path to find a value. A caption would note: "In a BST, left subtree values are less than the node, and right subtree values are greater." -->
<h3 id="explain-operations-15"><a class="header" href="#explain-operations-15">Explain Operations</a></h3>
<ul>
<li><strong>Insert</strong>: This operation adds a new node with a given value to the tree while maintaining the BST property. It has an average time complexity of O(log n) in a balanced tree.</li>
<li><strong>Search</strong>: This operation finds a node with a given value by traversing left or right based on comparisons. It has an average time complexity of O(log n).</li>
<li><strong>Delete</strong>: This operation removes a node with a given value, adjusting the tree to maintain the BST property. It has an average time complexity of O(log n).</li>
<li><strong>Inorder Traversal</strong>: This operation visits nodes in sorted order (left, root, right). It has a time complexity of O(n).</li>
<li><strong>isEmpty</strong>: This operation checks whether the tree is empty. It has a time complexity of O(1).</li>
</ul>
<h3 id="java-implementation-15"><a class="header" href="#java-implementation-15">Java Implementation</a></h3>
<p>The following Java code implements a Binary Search Tree with basic operations.</p>
<pre><code class="language-java">public class BinarySearchTree {
    private class Node {
        int value; // Value stored in the node
        Node left; // Reference to the left child
        Node right; // Reference to the right child

        Node(int value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }

    private Node root; // Root of the BST
    private int size; // Number of nodes in the tree

    // Constructor to initialize an empty BST
    public BinarySearchTree() {
        root = null;
        size = 0;
    }

    // Insert: Adds a new value to the BST
    public void insert(int value) {
        root = insertRec(root, value); // Recursively inserts the value
        size++; // Increments the size
    }

    private Node insertRec(Node root, int value) {
        if (root == null) { // If the subtree is empty, create a new node
            return new Node(value);
        }
        if (value &lt; root.value) { // Inserts into left subtree if value is smaller
            root.left = insertRec(root.left, value);
        } else if (value &gt; root.value) { // Inserts into right subtree if value is larger
            root.right = insertRec(root.right, value);
        }
        return root; // Returns unchanged root if value already exists
    }

    // Search: Checks if a value exists in the BST
    public boolean search(int value) {
        return searchRec(root, value); // Recursively searches for the value
    }

    private boolean searchRec(Node root, int value) {
        if (root == null || root.value == value) { // Returns true if found, false if null
            return root != null;
        }
        if (value &lt; root.value) { // Searches left subtree if value is smaller
            return searchRec(root.left, value);
        }
        return searchRec(root.right, value); // Searches right subtree if value is larger
    }

    // Delete: Removes a value from the BST
    public void delete(int value) {
        root = deleteRec(root, value); // Recursively deletes the value
        size--; // Decrements the size
    }

    private Node deleteRec(Node root, int value) {
        if (root == null) { // If value not found, return null
            return null;
        }
        if (value &lt; root.value) { // Deletes from left subtree if value is smaller
            root.left = deleteRec(root.left, value);
        } else if (value &gt; root.value) { // Deletes from right subtree if value is larger
            root.right = deleteRec(root.right, value);
        } else { // Node to delete found
            if (root.left == null) { // Case 1: No left child, return right child
                return root.right;
            } else if (root.right == null) { // Case 2: No right child, return left child
                return root.left;
            }
            // Case 3: Two children, replace with successor
            root.value = findMin(root.right).value; // Replaces with minimum in right subtree
            root.right = deleteRec(root.right, root.value); // Deletes the successor
        }
        return root;
    }

    // Helper method to find the minimum value node in a subtree
    private Node findMin(Node root) {
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }

    // Inorder Traversal: Prints nodes in sorted order
    public void inorder() {
        inorderRec(root); // Recursively traverses the tree
        System.out.println(); // Adds newline after traversal
    }

    private void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left); // Visits left subtree
            System.out.print(root.value + " "); // Visits current node
            inorderRec(root.right); // Visits right subtree
        }
    }

    // isEmpty: Checks if the BST is empty
    public boolean isEmpty() {
        return size == 0;
    }

    // Size: Returns the number of nodes in the BST
    public int size() {
        return size;
    }
}
</code></pre>
<h3 id="how-it-works-16"><a class="header" href="#how-it-works-16">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes the <code>root</code> as null and <code>size</code> as 0, indicating an empty Binary Search Tree.</li>
<li><strong>Insert Operation</strong>:
<ul>
<li>The method recursively traverses the tree based on the value: left if the value is smaller, right if larger.</li>
<li>If an empty spot is found (null node), it creates a new node with the value.</li>
<li>The <code>size</code> is incremented for each new node.</li>
</ul>
</li>
<li><strong>Search Operation</strong>:
<ul>
<li>The method recursively traverses the tree, comparing the target value with the current node’s value.</li>
<li>It returns true if the value is found or false if a null node is reached.</li>
</ul>
</li>
<li><strong>Delete Operation</strong>:
<ul>
<li>The method finds the node to delete by traversing left or right based on the value.</li>
<li>It handles three cases: no children (return null), one child (return the child), or two children (replace with the minimum value from the right subtree and delete that node).</li>
<li>The <code>size</code> is decremented after deletion.</li>
</ul>
</li>
<li><strong>Inorder Traversal</strong>: The method recursively visits the left subtree, the current node, and the right subtree, printing values in sorted order.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>size</code> equals 0, indicating an empty tree, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>size</code>, which represents the number of nodes in the tree.</li>
<li><strong>FindMin Helper</strong>: This method finds the smallest value in a subtree by traversing left until a null left child is reached.</li>
</ol>
<h3 id="complexity-analysis-table-15"><a class="header" href="#complexity-analysis-table-15">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Average Time Complexity</th><th>Worst-Case Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td></tr>
<tr><td>Search</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td></tr>
<tr><td>Delete</td><td>O(log n)</td><td>O(n)</td><td>O(log n)</td></tr>
<tr><td>Inorder Traversal</td><td>O(n)</td><td>O(n)</td><td>O(log n)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: Worst-case time complexity occurs in an unbalanced tree (e.g., a skewed tree resembling a linked list).</p>
<h3 id="key-differences--notes-15"><a class="header" href="#key-differences--notes-15">Key Differences / Notes</a></h3>
<ul>
<li><strong>Binary Search Tree vs. Other Trees</strong>:
<ul>
<li>The implementation above is a BST, where nodes are ordered for efficient searching. Other trees include binary trees (no ordering), AVL trees (self-balancing), and B-trees (for databases).</li>
<li>AVL and Red-Black trees maintain balance to ensure O(log n) operations, unlike a BST, which can degrade to O(n) if unbalanced.</li>
</ul>
</li>
<li><strong>Balancing</strong>: The provided BST is not self-balancing, which can lead to poor performance if insertions are not random. Use AVL or Red-Black trees for guaranteed balance.</li>
<li><strong>Thread Safety</strong>: The implementation is not thread-safe. For concurrent applications, use synchronized methods or Java’s <code>ConcurrentSkipListMap</code> for a tree-like structure.</li>
<li><strong>Java’s Built-in Trees</strong>: Java provides <code>TreeMap</code> and <code>TreeSet</code> in <code>java.util</code>, which are implemented as Red-Black trees for balanced performance.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a self-balancing tree like AVL or Red-Black for applications requiring consistent O(log n) performance, especially with frequent insertions or deletions.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: An unbalanced BST can degrade to O(n) performance if insertions occur in sorted order, resembling a linked list. Always consider input patterns when using a BST.</p>
</blockquote>
<h3 id="exercises-15"><a class="header" href="#exercises-15">Exercises</a></h3>
<ol>
<li><strong>BST Validator</strong>: Write a Java program that checks if a given tree is a valid Binary Search Tree by ensuring all nodes follow the BST property. Test it with at least three different trees.</li>
<li><strong>Height of BST</strong>: Extend the BST implementation to include a method that computes the height of the tree. Test it with balanced and unbalanced trees.</li>
<li><strong>Range Sum Query</strong>: Create a program that uses the BST to find the sum of all values within a given range (e.g., between 20 and 60). Use inorder traversal to collect values.</li>
<li><strong>Preorder and Postorder Traversals</strong>: Add methods to the BST implementation for preorder (root, left, right) and postorder (left, right, root) traversals. Print the results for a sample tree.</li>
<li><strong>Lowest Common Ancestor</strong>: Implement a method to find the lowest common ancestor of two nodes in the BST. Test it with different pairs of values.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="graph-data-structure"><a class="header" href="#graph-data-structure">Graph Data Structure</a></h2>
<h3 id="definition-and-concepts-16"><a class="header" href="#definition-and-concepts-16">Definition and Concepts</a></h3>
<p>A graph is a non-linear data structure consisting of nodes (also called vertices) connected by edges. Graphs can represent relationships between entities, where nodes represent entities and edges represent connections. Graphs can be directed (edges have direction, like one-way roads) or undirected (edges are bidirectional, like friendships). They can also be weighted (edges have values, like distances) or unweighted. A common representation is an adjacency list, where each node stores a list of its adjacent nodes. You can visualize a graph as a network of cities (nodes) connected by roads (edges). Graphs are versatile and used to model complex relationships in various applications.</p>
<h3 id="why-use-it-16"><a class="header" href="#why-use-it-16">Why Use It?</a></h3>
<p>Graphs are used to model and analyze relationships between entities, enabling solutions to problems like finding shortest paths, detecting cycles, or determining connectivity. They provide a flexible framework for representing networks, making them essential for applications in computer science, social networks, and logistics. Graphs support efficient algorithms for traversal, pathfinding, and optimization, with time complexities depending on the representation and algorithm used.</p>
<h3 id="where-to-use-real-life-examples-16"><a class="header" href="#where-to-use-real-life-examples-16">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Social Networks</strong>: Social media platforms use graphs to represent users (nodes) and friendships or follows (edges) to recommend connections or analyze communities.</li>
<li><strong>Navigation Systems</strong>: GPS applications use graphs to model road networks, with cities as nodes and roads as weighted edges, to compute shortest paths.</li>
<li><strong>Internet Routing</strong>: The internet uses graphs to represent routers and connections, enabling efficient data packet routing.</li>
<li><strong>Dependency Management</strong>: Build tools like Maven use graphs to manage dependencies between software modules, detecting cyclic dependencies.</li>
</ul>
<!-- ### SVG Diagram
The diagram for a graph would depict an undirected graph with nodes (e.g., labeled A, B, C, D) connected by edges (lines). For example, node A connects to B and C, B connects to C and D, and so on. The adjacency list representation would be shown as a table, where each node lists its neighbors (e.g., A: [B, C], B: [A, C, D]). Arrows would illustrate a **depth-first search (DFS)** starting from node A, visiting B, then D, and a **breadth-first search (BFS)** visiting A, B, C, then D. A caption would note: "Graphs model relationships, with adjacency lists storing neighbors for each node." -->
<h3 id="explain-operations-16"><a class="header" href="#explain-operations-16">Explain Operations</a></h3>
<ul>
<li><strong>Add Vertex</strong>: This operation adds a new node to the graph. It has a time complexity of O(1) in an adjacency list.</li>
<li><strong>Add Edge</strong>: This operation adds a connection between two nodes. It has a time complexity of O(1) for an undirected graph using an adjacency list.</li>
<li><strong>Remove Vertex</strong>: This operation removes a node and all its edges. It has a time complexity of O(V + E), where V is the number of vertices and E is the number of edges.</li>
<li><strong>Remove Edge</strong>: This operation removes a connection between two nodes. It has a time complexity of O(E) in the worst case for an adjacency list.</li>
<li><strong>Depth-First Search (DFS)</strong>: This operation traverses the graph by exploring as far as possible along each branch before backtracking. It has a time complexity of O(V + E).</li>
<li><strong>Breadth-First Search (BFS)</strong>: This operation traverses the graph level by level, visiting all neighbors of a node before moving to the next level. It has a time complexity of O(V + E).</li>
</ul>
<h3 id="java-implementation-16"><a class="header" href="#java-implementation-16">Java Implementation</a></h3>
<p>The following Java code implements an undirected graph using an adjacency list, with basic operations and DFS/BFS traversals.</p>
<pre><code class="language-java">import java.util.*;

public class Graph {
    private Map&lt;Integer, List&lt;Integer&gt;&gt; adjList; // Adjacency list to store the graph
    private int vertexCount; // Number of vertices in the graph

    // Constructor to initialize an empty graph
    public Graph() {
        adjList = new HashMap&lt;&gt;();
        vertexCount = 0;
    }

    // Add Vertex: Adds a new vertex to the graph
    public void addVertex(int vertex) {
        if (!adjList.containsKey(vertex)) { // Checks if vertex doesn't already exist
            adjList.put(vertex, new ArrayList&lt;&gt;());
            vertexCount++;
        }
    }

    // Add Edge: Adds an undirected edge between two vertices
    public void addEdge(int vertex1, int vertex2) {
        if (!adjList.containsKey(vertex1) || !adjList.containsKey(vertex2)) {
            throw new IllegalArgumentException("Both vertices must exist in the graph.");
        }
        adjList.get(vertex1).add(vertex2); // Adds vertex2 to vertex1's list
        adjList.get(vertex2).add(vertex1); // Adds vertex1 to vertex2's list (undirected)
    }

    // Remove Vertex: Removes a vertex and all its edges
    public void removeVertex(int vertex) {
        if (!adjList.containsKey(vertex)) {
            throw new IllegalArgumentException("Vertex not found in the graph.");
        }
        List&lt;Integer&gt; neighbors = adjList.get(vertex);
        for (int neighbor : neighbors) { // Removes vertex from neighbors' lists
            adjList.get(neighbor).remove(Integer.valueOf(vertex));
        }
        adjList.remove(vertex); // Removes the vertex
        vertexCount--;
    }

    // Remove Edge: Removes an undirected edge between two vertices
    public void removeEdge(int vertex1, int vertex2) {
        if (!adjList.containsKey(vertex1) || !adjList.containsKey(vertex2)) {
            throw new IllegalArgumentException("Both vertices must exist in the graph.");
        }
        adjList.get(vertex1).remove(Integer.valueOf(vertex2)); // Removes vertex2 from vertex1's list
        adjList.get(vertex2).remove(Integer.valueOf(vertex1)); // Removes vertex1 from vertex2's list
    }

    // Depth-First Search: Traverses the graph starting from a vertex
    public List&lt;Integer&gt; dfs(int startVertex) {
        if (!adjList.containsKey(startVertex)) {
            throw new IllegalArgumentException("Start vertex not found in the graph.");
        }
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        dfsRec(startVertex, visited, result);
        return result;
    }

    private void dfsRec(int vertex, Set&lt;Integer&gt; visited, List&lt;Integer&gt; result) {
        visited.add(vertex); // Marks the vertex as visited
        result.add(vertex); // Adds vertex to result
        for (int neighbor : adjList.get(vertex)) { // Visits unvisited neighbors
            if (!visited.contains(neighbor)) {
                dfsRec(neighbor, visited, result);
            }
        }
    }

    // Breadth-First Search: Traverses the graph starting from a vertex
    public List&lt;Integer&gt; bfs(int startVertex) {
        if (!adjList.containsKey(startVertex)) {
            throw new IllegalArgumentException("Start vertex not found in the graph.");
        }
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        visited.add(startVertex);
        queue.offer(startVertex);
        while (!queue.isEmpty()) {
            int vertex = queue.poll(); // Dequeues a vertex
            result.add(vertex); // Adds vertex to result
            for (int neighbor : adjList.get(vertex)) { // Enqueues unvisited neighbors
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
        return result;
    }

    // isEmpty: Checks if the graph is empty
    public boolean isEmpty() {
        return vertexCount == 0;
    }

    // Size: Returns the number of vertices in the graph
    public int size() {
        return vertexCount;
    }
}
</code></pre>
<h3 id="how-it-works-17"><a class="header" href="#how-it-works-17">How It Works</a></h3>
<ol>
<li><strong>Initialization</strong>: The constructor initializes an empty <code>HashMap</code> for the adjacency list and sets <code>vertexCount</code> to 0, indicating an empty graph.</li>
<li><strong>Add Vertex</strong>: The method adds a new vertex to the <code>adjList</code> with an empty list of neighbors if it doesn’t already exist, incrementing <code>vertexCount</code>.</li>
<li><strong>Add Edge</strong>: The method adds an undirected edge by appending each vertex to the other’s neighbor list in the <code>adjList</code>, ensuring both vertices exist.</li>
<li><strong>Remove Vertex</strong>: The method removes the vertex’s neighbor list and removes the vertex from all its neighbors’ lists, then removes the vertex from <code>adjList</code> and decrements <code>vertexCount</code>.</li>
<li><strong>Remove Edge</strong>: The method removes each vertex from the other’s neighbor list in the <code>adjList</code>, ensuring both vertices exist.</li>
<li><strong>Depth-First Search (DFS)</strong>: The method uses recursion to explore as far as possible along each branch, marking vertices as visited and adding them to the result list.</li>
<li><strong>Breadth-First Search (BFS)</strong>: The method uses a queue to explore nodes level by level, marking vertices as visited, adding them to the result, and enqueuing unvisited neighbors.</li>
<li><strong>isEmpty Operation</strong>: The method returns true if <code>vertexCount</code> equals 0, indicating an empty graph, and false otherwise.</li>
<li><strong>Size Operation</strong>: The method returns <code>vertexCount</code>, which represents the number of vertices in the graph.</li>
</ol>
<h3 id="complexity-analysis-table-16"><a class="header" href="#complexity-analysis-table-16">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity (Adjacency List)</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Add Vertex</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Add Edge</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Remove Vertex</td><td>O(V + E)</td><td>O(1)</td></tr>
<tr><td>Remove Edge</td><td>O(E)</td><td>O(1)</td></tr>
<tr><td>DFS</td><td>O(V + E)</td><td>O(V)</td></tr>
<tr><td>BFS</td><td>O(V + E)</td><td>O(V)</td></tr>
<tr><td>isEmpty</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>: V is the number of vertices, and E is the number of edges. Time complexities assume an adjacency list representation.</p>
<h3 id="key-differences--notes-16"><a class="header" href="#key-differences--notes-16">Key Differences / Notes</a></h3>
<ul>
<li><strong>Adjacency List vs. Adjacency Matrix</strong>:
<ul>
<li>The implementation above uses an adjacency list, which is space-efficient (O(V + E)) and suitable for sparse graphs.</li>
<li>An adjacency matrix uses O(V²) space and is better for dense graphs or when checking edge existence is frequent.</li>
</ul>
</li>
<li><strong>Directed vs. Undirected Graphs</strong>:
<ul>
<li>The implementation is for an undirected graph. For a directed graph, only add the edge to the source vertex’s neighbor list.</li>
</ul>
</li>
<li><strong>Weighted Graphs</strong>: The implementation is unweighted. For weighted graphs, store edge weights in the adjacency list (e.g., as a <code>Map&lt;Integer, Integer&gt;</code> for weights).</li>
<li><strong>Thread Safety</strong>: The implementation is not thread-safe. For concurrent applications, use Java’s <code>ConcurrentHashMap</code> for the adjacency list or synchronize access.</li>
<li><strong>Java’s Built-in Support</strong>: Java does not provide a direct graph class, but libraries like JGraphT or Guava’s Graph can be used for advanced graph operations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use an adjacency list for sparse graphs to save memory, and an adjacency matrix for dense graphs to optimize edge lookups.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the graph is properly initialized with all vertices before adding edges, as missing vertices can cause errors in adjacency list operations.</p>
</blockquote>
<h3 id="exercises-16"><a class="header" href="#exercises-16">Exercises</a></h3>
<ol>
<li><strong>Graph Connectivity</strong>: Write a Java program that uses the graph implementation to check if a graph is connected (all vertices reachable from a starting vertex) using DFS or BFS.</li>
<li><strong>Cycle Detection</strong>: Extend the graph implementation to detect if the graph contains a cycle using DFS. Test it with cyclic and acyclic graphs.</li>
<li><strong>Shortest Path (Unweighted)</strong>: Implement a method to find the shortest path between two vertices in an unweighted graph using BFS. Return the path as a list of vertices.</li>
<li><strong>Weighted Graph Extension</strong>: Modify the graph implementation to support weighted edges (store weights in the adjacency list). Test it by adding and retrieving edge weights.</li>
<li><strong>Social Network Simulation</strong>: Create a program that simulates a social network using the graph. Allow users to add users (vertices), friendships (edges), and perform DFS to find mutual friends.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="sorting-algorithms"><a class="header" href="#sorting-algorithms">Sorting Algorithms</a></h2>
<h3 id="what-are-sorting-algorithms"><a class="header" href="#what-are-sorting-algorithms">What are Sorting Algorithms?</a></h3>
<p>Sorting algorithms are methods for arranging elements of a list in a specific order, typically ascending or descending, to make data easier to search, process, or display. They are the <em>building blocks</em> of efficient data processing, used in everything from simple list sorting to complex database operations.</p>
<h3 id="why-learn-sorting-algorithms"><a class="header" href="#why-learn-sorting-algorithms">Why Learn Sorting Algorithms?</a></h3>
<ul>
<li><strong>Efficiency</strong>: Choosing the right sorting algorithm can significantly improve program performance.</li>
<li><strong>Problem Solving</strong>: Many real-world problems, like ranking or organizing data, rely on sorting.</li>
<li><strong>Foundation for Advanced Algorithms</strong>: Understanding sorting is essential for mastering more complex algorithms.</li>
<li><strong>Interview Readiness</strong>: Sorting algorithms are a common topic in technical interviews.</li>
</ul>
<h3 id="-what-you-will-learn-in-this-chapter-1"><a class="header" href="#-what-you-will-learn-in-this-chapter-1">📖 What You Will Learn in This Chapter</a></h3>
<p>This chapter introduces you to the most commonly used sorting algorithms, their uses, advantages, disadvantages, and Java implementations.</p>
<h3 id="1-bubble-sort"><a class="header" href="#1-bubble-sort">1. <strong>Bubble Sort</strong></a></h3>
<ul>
<li>What is Bubble Sort and how it works.</li>
<li>Comparing and swapping adjacent elements.</li>
<li>Limitations for large datasets.</li>
<li>Real-life example: Sorting a small list of exam scores.</li>
</ul>
<h3 id="2-selection-sort"><a class="header" href="#2-selection-sort">2. <strong>Selection Sort</strong></a></h3>
<ul>
<li>How Selection Sort selects the smallest element.</li>
<li>Building a sorted portion incrementally.</li>
<li>Minimizing swaps for efficiency.</li>
<li>Real-life example: Arranging books by height on a shelf.</li>
</ul>
<h3 id="3-insertion-sort"><a class="header" href="#3-insertion-sort">3. <strong>Insertion Sort</strong></a></h3>
<ul>
<li>How Insertion Sort builds a sorted portion by inserting elements.</li>
<li>Efficiency for nearly sorted data.</li>
<li>Common operations like shifting elements.</li>
<li>Real-life example: Sorting a hand of playing cards.</li>
</ul>
<h3 id="4-merge-sort"><a class="header" href="#4-merge-sort">4. <strong>Merge Sort</strong></a></h3>
<ul>
<li>How Merge Sort divides and conquers.</li>
<li>Merging sorted subarrays for efficiency.</li>
<li>Handling large datasets and stability.</li>
<li>Real-life example: Sorting large customer records in a database.</li>
</ul>
<h3 id="-how-we-will-learn-1"><a class="header" href="#-how-we-will-learn-1">🛠 How We Will Learn</a></h3>
<p>For each sorting algorithm, we will cover:</p>
<ol>
<li><strong>Definition</strong> – What it is and how it works.</li>
<li><strong>Why</strong> – Advantages and limitations of the algorithm.</li>
<li><strong>Where to Use</strong> – Real-life scenarios where the algorithm shines.</li>
<li><strong>Java Implementation</strong> – With step-by-step explanations.</li>
<li><strong>Complexity Analysis</strong> – Understanding performance trade-offs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble Sort</a></h2>
<h3 id="definition-and-concepts-17"><a class="header" href="#definition-and-concepts-17">Definition and Concepts</a></h3>
<p>Bubble Sort is a simple sorting algorithm that repeatedly iterates through a list, compares adjacent elements, and swaps them if they are in the wrong order, until the list is fully sorted. The algorithm gets its name because larger elements "bubble up" to the end of the list in each iteration, similar to bubbles rising in water. In Java, Bubble Sort is typically implemented on arrays due to their direct index-based access, which makes comparisons and swaps efficient. You can visualize Bubble Sort as a process where, in each pass, the largest unsorted element moves to its correct position at the end of the array. Bubble Sort is a stable sorting algorithm, meaning it preserves the relative order of equal elements, and it is in-place, requiring minimal extra memory.</p>
<h3 id="key-points-3"><a class="header" href="#key-points-3">Key Points:</a></h3>
<ul>
<li>Bubble Sort compares adjacent elements and swaps them if they are out of order (e.g., for ascending order, if the first element is larger than the second).</li>
<li>Each pass through the array places the next largest element in its final position.</li>
<li>The algorithm terminates early if no swaps are needed in a pass, indicating the list is sorted.</li>
<li>Bubble Sort is easy to implement but inefficient for large datasets due to its quadratic time complexity.</li>
</ul>
<h3 id="why-use-it-17"><a class="header" href="#why-use-it-17">Why Use It?</a></h3>
<p>Bubble Sort is used primarily for educational purposes because its logic is straightforward and easy for beginners to understand, making it an excellent introduction to sorting algorithms. It is suitable for small datasets or lists that are already nearly sorted, where its simplicity and minimal memory usage are advantageous. Bubble Sort requires only a constant amount of extra space, making it appropriate for environments with memory constraints. However, for large or complex datasets, more efficient algorithms like Quick Sort or Merge Sort are recommended.</p>
<h3 id="where-to-use-real-life-examples-17"><a class="header" href="#where-to-use-real-life-examples-17">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Educational Tools</strong>: Bubble Sort is used in teaching environments to demonstrate sorting concepts due to its simple comparison and swap mechanism.</li>
<li><strong>Small Data Sorting</strong>: Embedded systems with limited resources use Bubble Sort to sort small lists, such as a few sensor readings, where simplicity outweighs performance concerns.</li>
<li><strong>Nearly Sorted Data</strong>: Applications like real-time data feeds use Bubble Sort for nearly sorted lists, as it performs efficiently with few swaps in such cases.</li>
<li><strong>Prototyping</strong>: Developers use Bubble Sort in early-stage prototypes to quickly sort small datasets for testing, leveraging its ease of implementation.</li>
</ul>
<!-- ### Diagram
diagram for Bubble Sort illustrating the process with the array [5, 3, 8, 1, 9].
<div style="text-align:center;">
    <img src="img/bubble_sort_diagram.svg" alt="inSort" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations-17"><a class="header" href="#explain-operations-17">Explain Operations</a></h3>
<ul>
<li><strong>Comparison</strong>: This operation compares two adjacent elements to determine if they are in the correct order (e.g., for ascending order, the first element should be less than or equal to the second). It has a time complexity of O(1).</li>
<li><strong>Swap</strong>: This operation exchanges two adjacent elements if they are out of order. It has a time complexity of O(1).</li>
<li><strong>Pass</strong>: This operation involves one iteration through the unsorted portion of the array, performing comparisons and swaps as needed. It has a time complexity of O(n) for n elements in the worst case.</li>
<li><strong>Optimization Check</strong>: This operation uses a flag to track whether any swaps occurred in a pass. If no swaps are needed, the array is sorted, and the algorithm terminates early. It has a time complexity of O(1) per pass.</li>
</ul>
<h3 id="java-implementation-17"><a class="header" href="#java-implementation-17">Java Implementation</a></h3>
<p>The following Java code implements Bubble Sort for an array of integers, including an optimization to terminate early if the array is already sorted.</p>
<pre><code class="language-java">public class BubbleSort {
    // Bubble Sort: Sorts an array in ascending order
    public void bubbleSort(int[] arr) {
        if (arr == null || arr.length &lt;= 1) {
            return; // No sorting needed for null or single-element arrays
        }
        int n = arr.length;
        for (int i = 0; i &lt; n - 1; i++) { // Iterate n-1 times
            boolean swapped = false; // Tracks if swaps occurred in this pass
            for (int j = 0; j &lt; n - 1 - i; j++) { // Compare adjacent elements
                if (arr[j] &gt; arr[j + 1]) { // If out of order, swap
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            if (!swapped) { // If no swaps, array is sorted
                break;
            }
        }
    }
}
</code></pre>
<h3 id="how-it-works-18"><a class="header" href="#how-it-works-18">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>bubbleSort</code> method checks if the input array is null or has one or fewer elements. If so, it returns immediately, as no sorting is needed.</li>
</ul>
</li>
<li><strong>Outer Loop (Passes)</strong>:
<ul>
<li>The outer loop iterates <code>n-1</code> times, where <code>n</code> is the array length, as each pass places one element in its final position.</li>
<li>For example, in an array of 5 elements, 4 passes are sufficient to sort the array.</li>
</ul>
</li>
<li><strong>Inner Loop (Comparisons and Swaps)</strong>:
<ul>
<li>The inner loop iterates through the unsorted portion of the array (from index 0 to <code>n-1-i</code>), comparing adjacent elements (<code>arr[j]</code> and <code>arr[j+1]</code>).</li>
<li>If <code>arr[j] &gt; arr[j+1]</code>, the elements are swapped using a temporary variable.</li>
<li>For example, in the array <code>[5, 3, 8, 1, 9]</code>, the first pass compares and swaps 5 and 3, then 8 and 1, resulting in <code>[3, 5, 1, 8, 9]</code>.</li>
</ul>
</li>
<li><strong>Optimization Check</strong>:
<ul>
<li>A <code>swapped</code> flag tracks whether any swaps occurred in a pass. If no swaps are needed, the array is sorted, and the algorithm terminates early.</li>
<li>For example, if the array is already sorted like <code>[1, 3, 5, 8, 9]</code>, the algorithm stops after one pass with no swaps.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>After all passes, the array is sorted in ascending order. For example, <code>[5, 3, 8, 1, 9]</code> becomes <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-17"><a class="header" href="#complexity-analysis-table-17">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Swap</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Pass</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n) (best)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n²) (average/worst)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array.</li>
<li>Best case (O(n)) occurs when the array is already sorted, requiring one pass with no swaps.</li>
<li>Average and worst cases (O(n²)) involve up to n passes, each with up to n comparisons/swaps.</li>
<li>Space complexity is O(1) as Bubble Sort is in-place, using only a few variables.</li>
</ul>
<h3 id="key-differences--notes-17"><a class="header" href="#key-differences--notes-17">Key Differences / Notes</a></h3>
<ul>
<li><strong>Bubble Sort vs. Other Sorting Algorithms</strong>:
<ul>
<li>Bubble Sort is simpler but less efficient than Quick Sort (O(n log n) average) or Merge Sort (O(n log n)), which are preferred for large datasets.</li>
<li>It is stable, preserving the relative order of equal elements, unlike Quick Sort.</li>
<li>It is in-place, unlike Merge Sort, which requires O(n) extra space.</li>
</ul>
</li>
<li><strong>Optimization</strong>:
<ul>
<li>The <code>swapped</code> flag allows early termination for nearly sorted arrays, reducing the number of passes.</li>
</ul>
</li>
<li><strong>Suitability for Data Structures</strong>:
<ul>
<li>Bubble Sort is most efficient for arrays due to O(1) access and swap operations.</li>
<li>It is less practical for linked lists or other structures due to inefficient access patterns, which is why this implementation focuses on arrays.</li>
</ul>
</li>
<li><strong>Limitations</strong>:
<ul>
<li>Bubble Sort is rarely used in production code due to its O(n²) time complexity, but it is valuable for teaching and small-scale applications.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Bubble Sort for small arrays or nearly sorted data to take advantage of its simplicity and early termination optimization. Test your implementation with edge cases like empty, single-element, or already sorted arrays to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid using Bubble Sort for large datasets due to its O(n²) time complexity, which performs poorly compared to faster algorithms like Quick Sort or Merge Sort. Always validate array bounds to prevent <code>ArrayIndexOutOfBoundsException</code>.</p>
</blockquote>
<h3 id="exercises-17"><a class="header" href="#exercises-17">Exercises</a></h3>
<ol>
<li><strong>Basic Bubble Sort</strong>: Implement Bubble Sort for an array of integers and test it with various inputs (e.g., unsorted, sorted, reversed, duplicates). Count the number of swaps performed.</li>
<li><strong>Descending Order</strong>: Modify the Bubble Sort implementation to sort an array in descending order. Test with different array sizes and contents.</li>
<li><strong>Performance Analysis</strong>: Write a program that measures the execution time of Bubble Sort for arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare best, average, and worst cases.</li>
<li><strong>Flag Optimization</strong>: Implement Bubble Sort without the <code>swapped</code> flag and compare its performance with the optimized version for nearly sorted arrays.</li>
<li><strong>Edge Case Handling</strong>: Enhance the Bubble Sort implementation to handle arrays with negative numbers and floating-point numbers. Test with diverse inputs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="selection-sort"><a class="header" href="#selection-sort">Selection Sort</a></h2>
<h3 id="definition-and-concepts-18"><a class="header" href="#definition-and-concepts-18">Definition and Concepts</a></h3>
<p>Selection Sort is a simple, in-place sorting algorithm that divides an array into a sorted and an unsorted portion. In each iteration, the algorithm selects the smallest (or largest, for descending order) element from the unsorted portion and places it at the beginning of the sorted portion. You can visualize Selection Sort as repeatedly finding the smallest element in the remaining unsorted section of the array and swapping it with the first element of that section. In Java, Selection Sort is typically implemented on arrays due to their direct index-based access, which facilitates efficient comparisons and swaps. Selection Sort is not stable, meaning it may change the relative order of equal elements, but it is in-place, requiring minimal extra memory.</p>
<h3 id="key-points-4"><a class="header" href="#key-points-4">Key Points:</a></h3>
<ul>
<li>Selection Sort selects the minimum element from the unsorted portion and places it at the start of the sorted portion.</li>
<li>Each iteration reduces the size of the unsorted portion by one, growing the sorted portion.</li>
<li>The algorithm is simple to implement but inefficient for large datasets due to its quadratic time complexity.</li>
<li>It performs a fixed number of swaps, which can be advantageous in scenarios where swaps are costly.</li>
</ul>
<h3 id="why-use-it-18"><a class="header" href="#why-use-it-18">Why Use It?</a></h3>
<p>Selection Sort is used primarily for educational purposes because its logic is intuitive and easy for beginners to grasp, making it a good introduction to sorting algorithms alongside Bubble Sort. It is suitable for small datasets where simplicity is prioritized over performance. Selection Sort minimizes the number of swaps compared to other quadratic algorithms like Bubble Sort, making it useful when write operations are expensive (e.g., in certain memory systems). However, for large datasets, more efficient algorithms like Quick Sort or Merge Sort are preferred.</p>
<h3 id="where-to-use-real-life-examples-18"><a class="header" href="#where-to-use-real-life-examples-18">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Teaching Sorting</strong>: Selection Sort is used in classrooms to teach sorting concepts due to its straightforward mechanism of selecting the minimum element.</li>
<li><strong>Small Data Sorting</strong>: Embedded systems with limited resources use Selection Sort to sort small lists, such as configuration settings, where simplicity is key.</li>
<li><strong>Write-Constrained Environments</strong>: Applications with costly write operations, such as flash memory, use Selection Sort to minimize swaps.</li>
<li><strong>Prototyping</strong>: Developers use Selection Sort in prototypes to quickly sort small datasets for testing, leveraging its ease of implementation.</li>
</ul>
<!-- ### Diagram
diagram for Selection Sort illustrating the process with the array [5, 3, 8, 1, 9].
<div style="text-align:center;">
    <img src="img/selection_sort_diagram.svg" alt="seSort" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations-18"><a class="header" href="#explain-operations-18">Explain Operations</a></h3>
<ul>
<li><strong>Find Minimum</strong>: This operation scans the unsorted portion of the array to find the index of the smallest element. It has a time complexity of O(n) for n elements in the unsorted portion.</li>
<li><strong>Swap</strong>: This operation exchanges the minimum element with the first element of the unsorted portion. It has a time complexity of O(1).</li>
<li><strong>Iteration</strong>: This operation represents one pass through the array, finding the minimum and performing one swap. It has a time complexity of O(n) due to the minimum search.</li>
<li><strong>Full Algorithm</strong>: This operation runs n-1 iterations to sort the entire array, where n is the array length. It has a time complexity of O(n²).</li>
</ul>
<h3 id="java-implementation-18"><a class="header" href="#java-implementation-18">Java Implementation</a></h3>
<p>The following Java code implements Selection Sort for an array of integers, designed to be clear and beginner-friendly.</p>
<pre><code class="language-java">public class SelectionSort {
    // Selection Sort: Sorts an array in ascending order
    public void selectionSort(int[] arr) {
        if (arr == null || arr.length &lt;= 1) {
            return; // No sorting needed for null or single-element arrays
        }
        int n = arr.length;
        for (int i = 0; i &lt; n - 1; i++) { // Iterate over unsorted portion
            int minIndex = i; // Assume first element is minimum
            for (int j = i + 1; j &lt; n; j++) { // Search for minimum in unsorted portion
                if (arr[j] &lt; arr[minIndex]) {
                    minIndex = j; // Update minimum index
                }
            }
            if (minIndex != i) { // Swap if a smaller element was found
                int temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
    }
}
</code></pre>
<h3 id="how-it-works-19"><a class="header" href="#how-it-works-19">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>selectionSort</code> method checks if the input array is null or has one or fewer elements. If so, it returns immediately, as no sorting is needed.</li>
</ul>
</li>
<li><strong>Outer Loop (Iterations)</strong>:
<ul>
<li>The outer loop iterates <code>n-1</code> times, where <code>n</code> is the array length, as each iteration places one element in its final position, growing the sorted portion.</li>
<li>For example, in an array of 5 elements, 4 iterations are sufficient to sort the array.</li>
</ul>
</li>
<li><strong>Inner Loop (Find Minimum)</strong>:
<ul>
<li>The inner loop scans the unsorted portion (from index <code>i+1</code> to <code>n-1</code>) to find the index of the smallest element, updating <code>minIndex</code> when a smaller element is found.</li>
<li>For example, in the array <code>[5, 3, 8, 1, 9]</code>, the first iteration finds the minimum 1 at index 3.</li>
</ul>
</li>
<li><strong>Swap</strong>:
<ul>
<li>If the minimum element is not already at index <code>i</code>, the algorithm swaps the element at <code>minIndex</code> with the element at index <code>i</code> using a temporary variable.</li>
<li>For example, swapping 5 (at index 0) with 1 (at index 3) results in <code>[1, 3, 8, 5, 9]</code>.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>After all iterations, the array is sorted in ascending order. For example, <code>[5, 3, 8, 1, 9]</code> becomes <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-18"><a class="header" href="#complexity-analysis-table-18">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Find Minimum</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Swap</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n²) (best/average/worst)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array.</li>
<li>The time complexity is O(n²) for all cases (best, average, worst) because the algorithm always performs n-1 iterations, each scanning up to n elements to find the minimum.</li>
<li>Space complexity is O(1) as Selection Sort is in-place, using only a few variables for indexing and swapping.</li>
</ul>
<h3 id="key-differences--notes-18"><a class="header" href="#key-differences--notes-18">Key Differences / Notes</a></h3>
<ul>
<li><strong>Selection Sort vs. Bubble Sort</strong>:
<ul>
<li>Selection Sort minimizes swaps by performing one swap per iteration, while Bubble Sort may perform multiple swaps per pass.</li>
<li>Both have O(n²) time complexity, but Selection Sort is less adaptive to nearly sorted data, as it always scans the entire unsorted portion.</li>
</ul>
</li>
<li><strong>Selection Sort vs. Other Sorting Algorithms</strong>:
<ul>
<li>Selection Sort is less efficient than Quick Sort (O(n log n) average) or Merge Sort (O(n log n)), which are preferred for large datasets.</li>
<li>It is not stable, unlike Bubble Sort or Merge Sort, as it may swap equal elements out of order.</li>
</ul>
</li>
<li><strong>Suitability for Data Structures</strong>:
<ul>
<li>Selection Sort is most efficient for arrays due to O(1) access and swap operations.</li>
<li>It is less practical for linked lists or other structures due to inefficient access patterns, which is why this implementation focuses on arrays.</li>
</ul>
</li>
<li><strong>Fixed Swaps</strong>:
<ul>
<li>Selection Sort performs at most n-1 swaps, making it advantageous when swaps are more costly than comparisons.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Selection Sort for small arrays or when minimizing swaps is important, such as in systems where write operations are expensive. Test the implementation with edge cases like empty, single-element, or duplicate-filled arrays to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid using Selection Sort for large datasets due to its O(n²) time complexity, which is inefficient compared to algorithms like Quick Sort or Merge Sort. Always validate array bounds to prevent <code>ArrayIndexOutOfBoundsException</code>.</p>
</blockquote>
<h3 id="exercises-18"><a class="header" href="#exercises-18">Exercises</a></h3>
<ol>
<li><strong>Basic Selection Sort</strong>: Implement Selection Sort for an array of integers and test it with various inputs (e.g., unsorted, sorted, reversed, duplicates). Count the number of swaps performed.</li>
<li><strong>Descending Order</strong>: Modify the Selection Sort implementation to sort an array in descending order by selecting the maximum element instead. Test with different array sizes.</li>
<li><strong>Performance Analysis</strong>: Write a program that measures the execution time of Selection Sort for arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare performance across different input cases.</li>
<li><strong>String Array Sorting</strong>: Extend the Selection Sort implementation to sort an array of strings lexicographically. Test with strings of varying lengths and cases.</li>
<li><strong>Minimum Swap Count</strong>: Enhance the Selection Sort implementation to track and return the number of swaps performed. Test with nearly sorted and fully unsorted arrays.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="insertion-sort"><a class="header" href="#insertion-sort">Insertion Sort</a></h2>
<h3 id="definition-and-concepts-19"><a class="header" href="#definition-and-concepts-19">Definition and Concepts</a></h3>
<p>Insertion Sort is a simple sorting algorithm that builds a sorted array one element at a time by taking each element from the unsorted portion and inserting it into its correct position in the sorted portion. The algorithm maintains a sorted subarray at the beginning, which grows with each iteration as elements are inserted in their proper order. You can visualize Insertion Sort as sorting a hand of playing cards, where you pick one card at a time and place it in the correct position among the already-sorted cards. In Java, Insertion Sort is typically implemented on arrays due to their direct index-based access, which facilitates shifting elements during insertion. Insertion Sort is a stable algorithm, preserving the relative order of equal elements, and it is in-place, requiring minimal extra memory.</p>
<h5 id="key-points-5"><a class="header" href="#key-points-5">Key Points:</a></h5>
<ul>
<li>Insertion Sort divides the array into a sorted and an unsorted portion.</li>
<li>Each iteration takes an element from the unsorted portion and inserts it into the sorted portion.</li>
<li>The algorithm is efficient for small or nearly sorted datasets due to its adaptive nature.</li>
<li>It is easy to implement and understand, making it ideal for beginners.</li>
</ul>
<h3 id="why-use-it-19"><a class="header" href="#why-use-it-19">Why Use It?</a></h3>
<p>Insertion Sort is used for its simplicity and efficiency in sorting small datasets or nearly sorted arrays, where it performs well due to its adaptive nature. The algorithm requires minimal extra memory, as it sorts in-place, making it suitable for memory-constrained environments. Insertion Sort is particularly effective when the data is already partially sorted, as it can terminate early for each element once its position is found. It is also valuable for educational purposes, helping students understand sorting through its intuitive insertion process. For large datasets, however, more efficient algorithms like Quick Sort or Merge Sort are recommended.</p>
<h3 id="where-to-use-real-life-examples-19"><a class="header" href="#where-to-use-real-life-examples-19">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Teaching Sorting Algorithms</strong>: Insertion Sort is used in classrooms to teach sorting concepts due to its intuitive approach of building a sorted portion incrementally.</li>
<li><strong>Small Data Sorting</strong>: Embedded systems with limited resources use Insertion Sort to sort small lists, such as sensor data, where simplicity and low memory usage are critical.</li>
<li><strong>Nearly Sorted Data</strong>: Applications like online leaderboards use Insertion Sort to maintain nearly sorted lists, as it efficiently handles small updates with few shifts.</li>
<li><strong>Incremental Data Processing</strong>: Real-time systems processing incoming data streams use Insertion Sort to insert new elements into a sorted list, such as in event logging.</li>
</ul>
<!-- ### Diagram
diagram for Insertion Sort illustrating the process with the array [5, 3, 8, 1, 9].
<div style="text-align:center;">
    <img src="img/insertion_sort_diagram.svg" alt="inSort" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations-19"><a class="header" href="#explain-operations-19">Explain Operations</a></h3>
<ul>
<li><strong>Selection</strong>: This operation selects the next element from the unsorted portion to be inserted into the sorted portion. It has a time complexity of O(1).</li>
<li><strong>Comparison and Shift</strong>: This operation compares the selected element with elements in the sorted portion, shifting larger elements to the right until the correct position is found. It has a time complexity of O(n) in the worst case for n elements in the sorted portion.</li>
<li><strong>Insertion</strong>: This operation places the selected element in its correct position after shifting. It has a time complexity of O(1).</li>
<li><strong>Full Algorithm</strong>: This operation involves iterating through the array, performing selection, comparison, and insertion for each element. It has a time complexity of O(n²) in the worst and average cases.</li>
</ul>
<h3 id="java-implementation-19"><a class="header" href="#java-implementation-19">Java Implementation</a></h3>
<p>The following Java code implements Insertion Sort for an array of integers.</p>
<pre><code class="language-java">public class InsertionSort {
    // Insertion Sort: Sorts an array in ascending order
    public void insertionSort(int[] arr) {
        if (arr == null || arr.length &lt;= 1) {
            return; // No sorting needed for null or single-element arrays
        }
        int n = arr.length;
        for (int i = 1; i &lt; n; i++) { // Start from second element
            int key = arr[i]; // Select element to insert
            int j = i - 1; // Last index of sorted portion
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { // Shift larger elements
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key; // Insert key in correct position
        }
    }
}
</code></pre>
<h3 id="how-it-works-20"><a class="header" href="#how-it-works-20">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>insertionSort</code> method checks if the input array is null or has one or fewer elements. If so, it returns immediately, as no sorting is needed.</li>
</ul>
</li>
<li><strong>Outer Loop (Selection)</strong>:
<ul>
<li>The outer loop iterates from the second element (index 1) to the last element (index n-1), selecting each element (<code>key</code>) from the unsorted portion.</li>
<li>For example, in the array <code>[5, 3, 8, 1, 9]</code>, the first iteration selects <code>key = 3</code>.</li>
</ul>
</li>
<li><strong>Inner Loop (Comparison and Shift)</strong>:
<ul>
<li>The inner loop compares the <code>key</code> with elements in the sorted portion (from index <code>i-1</code> backward to 0), shifting larger elements one position to the right.</li>
<li>For example, when inserting <code>3</code>, the element <code>5</code> is shifted to index 1, resulting in <code>[5, 5, 8, 1, 9]</code>.</li>
</ul>
</li>
<li><strong>Insertion</strong>:
<ul>
<li>After the inner loop finds the correct position (when <code>arr[j] &lt;= key</code> or <code>j &lt; 0</code>), the <code>key</code> is placed at index <code>j+1</code>.</li>
<li>For example, <code>3</code> is inserted at index 0, resulting in <code>[3, 5, 8, 1, 9]</code>.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>After all iterations, the array is sorted in ascending order. For example, <code>[5, 3, 8, 1, 9]</code> becomes <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-19"><a class="header" href="#complexity-analysis-table-19">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Selection</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Comparison and Shift</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Insertion</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n) (best)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n²) (average/worst)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array.</li>
<li>Best case (O(n)) occurs when the array is already sorted, requiring minimal comparisons and no shifts.</li>
<li>Average and worst cases (O(n²)) involve up to n iterations, each with up to n comparisons and shifts.</li>
<li>Space complexity is O(1), as Insertion Sort is in-place, using only a few variables.</li>
</ul>
<h3 id="key-differences--notes-19"><a class="header" href="#key-differences--notes-19">Key Differences / Notes</a></h3>
<ul>
<li><strong>Insertion Sort vs. Bubble Sort</strong>:
<ul>
<li>Insertion Sort is more efficient for nearly sorted arrays, as it requires fewer shifts than Bubble Sort’s multiple swaps per pass.</li>
<li>Both have O(n²) worst-case time complexity, but Insertion Sort is adaptive, performing better on partially sorted data.</li>
</ul>
</li>
<li><strong>Insertion Sort vs. Selection Sort</strong>:
<ul>
<li>Insertion Sort is stable, preserving the order of equal elements, while Selection Sort is not.</li>
<li>Insertion Sort performs better for nearly sorted arrays, while Selection Sort performs a fixed number of comparisons regardless of input order.</li>
</ul>
</li>
<li><strong>Insertion Sort vs. Other Sorting Algorithms</strong>:
<ul>
<li>Insertion Sort is less efficient than Quick Sort (O(n log n) average) or Merge Sort (O(n log n)) for large datasets but excels in small or nearly sorted cases.</li>
<li>It is in-place, unlike Merge Sort, which requires O(n) extra space.</li>
</ul>
</li>
<li><strong>Suitability for Data Structures</strong>:
<ul>
<li>Insertion Sort is most efficient for arrays due to O(1) access and shift operations. It is less practical for linked lists (though feasible) due to traversal costs.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Insertion Sort for small arrays or nearly sorted data to leverage its adaptive nature and minimal memory usage. Test with edge cases like empty, single-element, or already sorted arrays to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid using Insertion Sort for large datasets due to its O(n²) time complexity in average and worst cases, which is inefficient compared to Quick Sort or Merge Sort. Always validate array bounds to prevent <code>ArrayIndexOutOfBoundsException</code>.</p>
</blockquote>
<h3 id="exercises-19"><a class="header" href="#exercises-19">Exercises</a></h3>
<ol>
<li><strong>Basic Insertion Sort</strong>: Implement Insertion Sort for an array of integers and test it with various inputs (e.g., unsorted, sorted, reversed, duplicates). Count the number of shifts performed.</li>
<li><strong>Descending Order</strong>: Modify the Insertion Sort implementation to sort an array in descending order by adjusting the comparison logic. Test with different array sizes.</li>
<li><strong>Performance Analysis</strong>: Write a program that measures the execution time of Insertion Sort for arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare with Bubble Sort and Selection Sort.</li>
<li><strong>Object Sorting</strong>: Extend Insertion Sort to sort an array of objects (e.g., <code>Student</code> objects with a <code>grade</code> field) based on a custom comparator. Test with a sample dataset.</li>
<li><strong>Nearly Sorted Arrays</strong>: Implement Insertion Sort and test its performance on nearly sorted arrays (e.g., one element out of place). Analyze the number of comparisons and shifts compared to unsorted inputs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="merge-sort"><a class="header" href="#merge-sort">Merge Sort</a></h2>
<h3 id="definition-and-concepts-20"><a class="header" href="#definition-and-concepts-20">Definition and Concepts</a></h3>
<p>Merge Sort is a divide-and-conquer sorting algorithm that recursively divides an array into two halves, sorts each half, and then merges the sorted halves to produce a fully sorted array. The algorithm relies on the principle that it is easier to sort smaller subarrays and combine them efficiently. You can visualize Merge Sort as splitting a deck of cards into smaller stacks, sorting each stack, and then combining them in order. In Java, Merge Sort is typically implemented on arrays, using recursion to divide the array and an auxiliary array to merge the sorted subarrays. Merge Sort is a stable algorithm, preserving the relative order of equal elements, but it is not in-place, as it requires additional memory for merging.</p>
<h3 id="key-points-6"><a class="header" href="#key-points-6">Key Points:</a></h3>
<ul>
<li>Merge Sort divides the array into two equal halves until each subarray has one element (which is inherently sorted).</li>
<li>It merges sorted subarrays by comparing elements and placing them in the correct order.</li>
<li>The algorithm is efficient for large datasets due to its consistent O(n log n) time complexity.</li>
<li>It requires extra space for merging, unlike in-place algorithms like Bubble Sort or Insertion Sort.</li>
</ul>
<h3 id="why-use-it-20"><a class="header" href="#why-use-it-20">Why Use It?</a></h3>
<p>Merge Sort is used for its consistent and efficient O(n log n) time complexity, making it suitable for sorting large datasets where performance is critical. The algorithm is stable, ensuring that equal elements maintain their relative order, which is important in applications like database sorting. Merge Sort is particularly effective for linked lists, as it avoids random access, and for external sorting (sorting data too large to fit in memory). Its divide-and-conquer approach makes it easy to parallelize, improving performance on multi-core systems. However, its need for extra space makes it less suitable for memory-constrained environments.</p>
<h3 id="where-to-use-real-life-examples-20"><a class="header" href="#where-to-use-real-life-examples-20">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Database Sorting</strong>: Database systems use Merge Sort to sort large datasets, such as query results, due to its stability and efficiency.</li>
<li><strong>External Sorting</strong>: File systems use Merge Sort for sorting large files on disk, as it can handle data in chunks, minimizing memory usage.</li>
<li><strong>Linked List Sorting</strong>: Applications with linked list data structures use Merge Sort to sort elements efficiently without requiring random access.</li>
<li><strong>Parallel Processing</strong>: Parallel computing frameworks use Merge Sort in distributed systems, as its divide-and-conquer nature allows tasks to be split across processors.</li>
</ul>
<!-- ### Diagram
diagram for Merge Sort illustrating the process with the array [5, 3, 8, 1, 9].
<div style="text-align:center;">
    <img src="img/merge_sort_diagram.svg" alt="mSort" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations-20"><a class="header" href="#explain-operations-20">Explain Operations</a></h3>
<ul>
<li><strong>Divide</strong>: This operation splits the array into two halves recursively until each subarray has one element. It has a time complexity of O(1) per division.</li>
<li><strong>Merge</strong>: This operation combines two sorted subarrays into a single sorted array by comparing elements and placing them in order. It has a time complexity of O(n) for n elements in the subarrays.</li>
<li><strong>Recursive Sort</strong>: This operation recursively sorts the two halves of the array. It contributes to the overall O(n log n) time complexity due to log n levels of recursion.</li>
<li><strong>Full Algorithm</strong>: This operation combines division, recursive sorting, and merging to sort the entire array. It has a time complexity of O(n log n) in all cases.</li>
</ul>
<h3 id="java-implementation-20"><a class="header" href="#java-implementation-20">Java Implementation</a></h3>
<p>The following Java code implements Merge Sort for an array of integers.</p>
<pre><code class="language-java">public class MergeSort {
    // Merge Sort: Sorts an array in ascending order
    public void mergeSort(int[] arr) {
        if (arr == null || arr.length &lt;= 1) {
            return; // No sorting needed for null or single-element arrays
        }
        int[] temp = new int[arr.length]; // Auxiliary array for merging
        mergeSortHelper(arr, 0, arr.length - 1, temp);
    }

    // Helper method: Recursively divides and sorts the array
    private void mergeSortHelper(int[] arr, int left, int right, int[] temp) {
        if (left &lt; right) { // Base case: subarray has more than one element
            int mid = left + (right - left) / 2; // Find midpoint
            mergeSortHelper(arr, left, mid, temp); // Sort left half
            mergeSortHelper(arr, mid + 1, right, temp); // Sort right half
            merge(arr, left, mid, right, temp); // Merge sorted halves
        }
    }

    // Merge: Combines two sorted subarrays into a single sorted array
    private void merge(int[] arr, int left, int mid, int right, int[] temp) {
        // Copy elements to temporary array
        for (int i = left; i &lt;= right; i++) {
            temp[i] = arr[i];
        }
        int i = left; // Index for left subarray
        int j = mid + 1; // Index for right subarray
        int k = left; // Index for merged array
        while (i &lt;= mid &amp;&amp; j &lt;= right) { // Compare and merge
            if (temp[i] &lt;= temp[j]) { // Use &lt;= for stability
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        while (i &lt;= mid) { // Copy remaining left subarray elements
            arr[k++] = temp[i++];
        }
        // No need to copy right subarray, as it’s already processed
    }
}
</code></pre>
<h3 id="how-it-works-21"><a class="header" href="#how-it-works-21">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>mergeSort</code> method checks if the input array is null or has one or fewer elements. If so, it returns immediately, as no sorting is needed.</li>
</ul>
</li>
<li><strong>Initialize Temporary Array</strong>:
<ul>
<li>An auxiliary array <code>temp</code> is created to assist with merging, with the same size as the input array.</li>
</ul>
</li>
<li><strong>Recursive Division (mergeSortHelper)</strong>:
<ul>
<li>The <code>mergeSortHelper</code> method recursively divides the array into two halves by calculating the midpoint (<code>mid = left + (right - left) / 2</code>).</li>
<li>It calls itself on the left half (<code>left</code> to <code>mid</code>) and right half (<code>mid + 1</code> to <code>right</code>).</li>
<li>For example, for <code>[5, 3, 8, 1, 9]</code>, it divides into <code>[5, 3]</code> and <code>[8, 1, 9]</code>, then further into <code>[5]</code>, <code>[3]</code>, <code>[8]</code>, <code>[1, 9]</code>.</li>
</ul>
</li>
<li><strong>Merge</strong>:
<ul>
<li>The <code>merge</code> method copies the subarray from <code>left</code> to <code>right</code> into <code>temp</code>, then merges the two sorted halves back into the original array.</li>
<li>It compares elements from the left subarray (<code>temp[i]</code>) and right subarray (<code>temp[j]</code>), placing the smaller (or equal, for stability) element into <code>arr[k]</code>.</li>
<li>For example, merging <code>[3, 5]</code> and <code>[1, 8, 9]</code> results in <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>After all recursive calls and merges, the array is sorted in ascending order. For example, <code>[5, 3, 8, 1, 9]</code> becomes <code>[1, 3, 5, 8, 9]</code>.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-20"><a class="header" href="#complexity-analysis-table-20">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Divide</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Merge</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Recursive Sort</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n log n) (all cases)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array.</li>
<li>Time complexity is O(n log n) in best, average, and worst cases, as the array is divided log n times, and each merge takes O(n) time.</li>
<li>Space complexity is O(n) due to the auxiliary array used for merging.</li>
</ul>
<h3 id="key-differences--notes-20"><a class="header" href="#key-differences--notes-20">Key Differences / Notes</a></h3>
<ul>
<li><strong>Merge Sort vs. Bubble/Selection/Insertion Sort</strong>:
<ul>
<li>Merge Sort has O(n log n) time complexity, making it more efficient than Bubble Sort, Selection Sort, and Insertion Sort (all O(n²)) for large datasets.</li>
<li>It is stable, like Insertion Sort, but unlike Selection Sort.</li>
<li>It requires O(n) extra space, unlike the in-place Bubble, Selection, and Insertion Sorts.</li>
</ul>
</li>
<li><strong>Merge Sort vs. Quick Sort</strong>:
<ul>
<li>Merge Sort is stable and has consistent O(n log n) time complexity, while Quick Sort is not stable and has O(n²) worst-case but O(n log n) average.</li>
<li>Quick Sort is in-place, while Merge Sort requires extra space.</li>
</ul>
</li>
<li><strong>Suitability for Data Structures</strong>:
<ul>
<li>Merge Sort is efficient for arrays and linked lists, as it avoids random access in the merge step, unlike Selection Sort.</li>
<li>It is particularly suited for external sorting and parallel processing due to its divide-and-conquer nature.</li>
</ul>
</li>
<li><strong>Stability</strong>:
<ul>
<li>The use of <code>&lt;=</code> in the merge step ensures stability, preserving the relative order of equal elements.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Merge Sort for large datasets or when stability is required, as its O(n log n) time complexity ensures consistent performance. For linked lists, Merge Sort is especially efficient, as it avoids random access.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be mindful of Merge Sort’s O(n) space complexity, which may be a limitation in memory-constrained environments. Always validate array bounds and ensure the auxiliary array is properly initialized to prevent errors.</p>
</blockquote>
<h3 id="exercises-20"><a class="header" href="#exercises-20">Exercises</a></h3>
<ol>
<li><strong>Basic Merge Sort</strong>: Implement Merge Sort for an array of integers and test it with various inputs (e.g., unsorted, sorted, reversed, duplicates). Verify the sorted output.</li>
<li><strong>Descending Order</strong>: Modify the Merge Sort implementation to sort an array in descending order by adjusting the merge comparison logic. Test with different array sizes.</li>
<li><strong>Performance Analysis</strong>: Write a program that measures the execution time of Merge Sort for arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare with Insertion Sort and Selection Sort.</li>
<li><strong>Object Sorting</strong>: Extend Merge Sort to sort an array of objects (e.g., <code>Student</code> objects with a <code>grade</code> field) based on a custom comparator. Test with a sample dataset.</li>
<li><strong>Space Optimization</strong>: Implement an in-place Merge Sort variant (if feasible) and compare its performance and space usage with the standard implementation. Test with various inputs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="searching-algorithms"><a class="header" href="#searching-algorithms">Searching Algorithms</a></h1>
<h3 id="what-are-searching-algorithms"><a class="header" href="#what-are-searching-algorithms">What are Searching Algorithms?</a></h3>
<p>Searching algorithms are methods for finding a specific element or its position within a data structure, such as an array or list. They are the <em>building blocks</em> of efficient data retrieval, used in applications from simple lookups to complex database queries. The algorithms covered in this chapter are Linear Search and Binary Search, each with distinct approaches to locating elements.</p>
<h3 id="why-learn-searching-algorithms"><a class="header" href="#why-learn-searching-algorithms">Why Learn Searching Algorithms?</a></h3>
<ul>
<li><strong>Efficiency</strong>: Choosing the right searching algorithm can drastically reduce the time needed to find data.</li>
<li><strong>Problem Solving</strong>: Many real-world tasks, like finding a contact or a record, rely on searching techniques.</li>
<li><strong>Foundation for Advanced Algorithms</strong>: Understanding searching is crucial for mastering more complex algorithms.</li>
<li><strong>Interview Readiness</strong>: Searching algorithms are a common topic in technical interviews.</li>
</ul>
<h3 id="-what-you-will-learn-in-this-chapter-2"><a class="header" href="#-what-you-will-learn-in-this-chapter-2">📖 What You Will Learn in This Chapter</a></h3>
<p>This chapter introduces you to the most commonly used searching algorithms, their uses, advantages, disadvantages, and Java implementations.</p>
<h3 id="1-linear-search"><a class="header" href="#1-linear-search">1. <strong>Linear Search</strong></a></h3>
<ul>
<li>What is Linear Search and how it works.</li>
<li>Checking elements one by one in sequence.</li>
<li>Applicability to unsorted data.</li>
<li>Real-life example: Finding a name in an unsorted list.</li>
</ul>
<h3 id="2-binary-search"><a class="header" href="#2-binary-search">2. <strong>Binary Search</strong></a></h3>
<ul>
<li>How Binary Search divides the search space.</li>
<li>Requiring sorted data for efficiency.</li>
<li>Iterative and recursive approaches.</li>
<li>Real-life example: Looking up a word in a dictionary.</li>
</ul>
<h3 id="-how-we-will-learn-2"><a class="header" href="#-how-we-will-learn-2">🛠 How We Will Learn</a></h3>
<p>For each searching algorithm, we will cover:</p>
<ol>
<li><strong>Definition</strong> – What it is and how it works.</li>
<li><strong>Why</strong> – Advantages and limitations of the algorithm.</li>
<li><strong>Where to Use</strong> – Real-life scenarios where the algorithm is effective.</li>
<li><strong>Java Implementation</strong> – With step-by-step explanations.</li>
<li><strong>Complexity Analysis</strong> – Understanding performance trade-offs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="linear-search"><a class="header" href="#linear-search">Linear Search</a></h2>
<h3 id="definition-and-concepts-21"><a class="header" href="#definition-and-concepts-21">Definition and Concepts</a></h3>
<p>Linear Search, also known as sequential search, is a simple searching algorithm that checks each element in a list sequentially until the target element is found or the list is exhausted. The algorithm does not require the data to be sorted, making it versatile but inefficient for large datasets. You can visualize Linear Search as looking through a stack of papers one by one to find a specific document. In Java, Linear Search is typically implemented on arrays due to their direct index-based access, returning the index of the target or -1 if not found.</p>
<h3 id="key-points-7"><a class="header" href="#key-points-7">Key Points:</a></h3>
<ul>
<li>Linear Search examines elements one at a time in order.</li>
<li>It works on both sorted and unsorted data.</li>
<li>The algorithm is simple to implement but has a linear time complexity.</li>
<li>It returns the first occurrence of the target element.</li>
</ul>
<h3 id="why-use-it-21"><a class="header" href="#why-use-it-21">Why Use It?</a></h3>
<p>Linear Search is used for its simplicity and applicability to small or unsorted datasets, where the overhead of sorting for other algorithms is unnecessary. It is ideal for beginners to understand searching concepts and is useful when the dataset is small or when searching for the first occurrence of a value. However, for large datasets, more efficient algorithms like Binary Search are preferred.</p>
<h3 id="where-to-use-real-life-examples-21"><a class="header" href="#where-to-use-real-life-examples-21">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Small List Search</strong>: Linear Search is used in applications like finding a contact in a short, unsorted phone list due to its simplicity.</li>
<li><strong>Unsorted Data</strong>: Inventory systems use Linear Search to locate items in unsorted lists, such as stock entries.</li>
<li><strong>Teaching Tool</strong>: Linear Search is used in classrooms to introduce searching concepts to beginners.</li>
<li><strong>First Occurrence</strong>: Applications like log analysis use Linear Search to find the first instance of an error in a sequence.</li>
</ul>
<!-- ### Diagram
diagram for Linear Search illustrating a sorted array [1, 3, 5, 8, 9], showing the sequential checking of elements for the target (5), stopping at index 2 where 5 is found.
<div style="text-align:center;">
    <img src="img/linear_search_diagram.svg" alt="LSearch" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations-21"><a class="header" href="#explain-operations-21">Explain Operations</a></h3>
<ul>
<li><strong>Comparison</strong>: Compares the current element with the target to check for a match, with a time complexity of O(1).</li>
<li><strong>Traversal</strong>: Moves to the next element in the array, incrementing the index, with a time complexity of O(n) for n elements in the worst case.</li>
<li><strong>Full Search</strong>: Executes the complete search, checking all elements until the target is found or the end is reached, with a time complexity of O(n).</li>
</ul>
<h3 id="java-implementation-21"><a class="header" href="#java-implementation-21">Java Implementation</a></h3>
<p>The following Java code implements Linear Search for an array of integers, designed to be clear and beginner-friendly.</p>
<pre><code class="language-java">public class LinearSearch {
    // Linear Search: Finds the target by checking each element
    public int linearSearch(int[] arr, int target) {
        if (arr == null) {
            return -1; // Return -1 for null array
        }
        for (int i = 0; i &lt; arr.length; i++) { // Check each element
            if (arr[i] == target) {
                return i; // Return index of target
            }
        }
        return -1; // Target not found
    }
}
</code></pre>
<h3 id="how-it-works-22"><a class="header" href="#how-it-works-22">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>linearSearch</code> method checks if the input array is null. If so, it returns -1, as no search is possible.</li>
</ul>
</li>
<li><strong>Traversal and Comparison</strong>:
<ul>
<li>The method iterates through the array from index 0 to the end, comparing each element with the target.</li>
<li>If a match is found, the method returns the index of the target.</li>
<li>For example, in <code>[1, 3, 5, 8, 9]</code> with target 5, it checks indices 0, 1, and 2, returning 2.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>If the target is not found after checking all elements, the method returns -1.</li>
<li>For example, searching for 7 in <code>[1, 3, 5, 8, 9]</code> returns -1.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-21"><a class="header" href="#complexity-analysis-table-21">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Traversal</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Search</td><td>O(1) (best)</td><td>O(1)</td></tr>
<tr><td>Full Search</td><td>O(n) (average/worst)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements.</li>
<li>Best case (O(1)) occurs when the target is at the first index.</li>
<li>Average and worst cases (O(n)) involve checking up to n elements.</li>
<li>Space complexity is O(1), as no extra space is used.</li>
</ul>
<h3 id="key-differences--notes-21"><a class="header" href="#key-differences--notes-21">Key Differences / Notes</a></h3>
<ul>
<li><strong>Linear Search vs. Binary Search</strong>:
<ul>
<li>Linear Search works on unsorted data, while Binary Search requires sorted data.</li>
<li>Linear Search has O(n) time complexity, while Binary Search is O(log n), making it faster for large datasets.</li>
</ul>
</li>
<li><strong>Simplicity</strong>:
<ul>
<li>Linear Search is easier to implement and understand than Binary Search, ideal for beginners.</li>
</ul>
</li>
<li><strong>Use Cases</strong>:
<ul>
<li>Linear Search is best for small or unsorted datasets or when finding the first occurrence is needed.</li>
</ul>
</li>
<li><strong>Limitations</strong>:
<ul>
<li>Linear Search is inefficient for large datasets due to its linear time complexity.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Linear Search for small or unsorted datasets due to its simplicity and lack of preprocessing requirements. Test with edge cases like empty arrays or missing targets to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid Linear Search for large datasets, as its O(n) time complexity can be slow compared to Binary Search’s O(log n). Always check for null arrays to prevent <code>NullPointerException</code>.</p>
</blockquote>
<h3 id="exercises-21"><a class="header" href="#exercises-21">Exercises</a></h3>
<ol>
<li><strong>Basic Linear Search</strong>: Implement Linear Search and test it with arrays of different sizes and targets (e.g., present, absent, first element). Count the number of comparisons.</li>
<li><strong>Last Occurrence</strong>: Modify Linear Search to find the last occurrence of a target in an array with duplicates. Test with <code>[1, 3, 3, 5, 8]</code> and target 3.</li>
<li><strong>Performance Analysis</strong>: Measure the execution time of Linear Search for arrays of increasing sizes (e.g., 10, 100, 1000 elements). Analyze best and worst cases.</li>
<li><strong>Object Search</strong>: Extend Linear Search to find an object in an array (e.g., <code>Student</code> with <code>id</code>). Test with a sample dataset.</li>
<li><strong>Multiple Targets</strong>: Implement Linear Search to return all indices where a target appears in an array. Test with duplicates like <code>[1, 3, 3, 5, 3]</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h2 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h2>
<h3 id="definition-and-concepts-22"><a class="header" href="#definition-and-concepts-22">Definition and Concepts</a></h3>
<p>Binary Search is an efficient searching algorithm that finds a target element in a sorted array by repeatedly dividing the search space in half. The algorithm compares the target with the middle element and eliminates half of the remaining elements based on the comparison, continuing until the target is found or the search space is empty. You can visualize Binary Search as looking up a word in a dictionary by opening to the middle and narrowing the search to one half. In Java, Binary Search is typically implemented on sorted arrays, returning the index of the target or -1 if not found.</p>
<h3 id="key-points-8"><a class="header" href="#key-points-8">Key Points:</a></h3>
<ul>
<li>Binary Search requires the input array to be sorted.</li>
<li>It divides the search space in half with each step, making it highly efficient.</li>
<li>The algorithm can be implemented iteratively or recursively.</li>
<li>It returns the index of the first occurrence of the target in case of duplicates.</li>
</ul>
<h3 id="why-use-it-22"><a class="header" href="#why-use-it-22">Why Use It?</a></h3>
<p>Binary Search is used for its efficiency, with an O(log n) time complexity, making it ideal for large, sorted datasets. It is suitable for applications where data is pre-sorted, such as database indexes or lookup tables, and is a key concept for students learning divide-and-conquer strategies. However, it requires sorted data, which may necessitate preprocessing, and is less versatile than Linear Search for unsorted data.</p>
<h3 id="where-to-use-real-life-examples-22"><a class="header" href="#where-to-use-real-life-examples-22">Where to Use? (Real-Life Examples)</a></h3>
<ul>
<li><strong>Database Indexes</strong>: Binary Search is used in databases to quickly locate records in sorted indexes, like customer IDs.</li>
<li><strong>Dictionary Lookups</strong>: Dictionary applications use Binary Search to find words in a sorted list efficiently.</li>
<li><strong>Sorted Data Search</strong>: Search engines use Binary Search to locate items in sorted datasets, such as ranked results.</li>
<li><strong>Algorithm Design</strong>: Binary Search is used in algorithms like finding the square root of a number by narrowing ranges.</li>
</ul>
<!-- ### Diagram
diagram for Binary Search illustrating a sorted array [1, 3, 5, 8, 9], highlighting the middle element (5) where the target (5) is found.
<div style="text-align:center;">
    <img src="img/binarySearch.svg" alt="bSearch" style="max-width:500px; height:auto;"/>
</div> -->
<h3 id="explain-operations-22"><a class="header" href="#explain-operations-22">Explain Operations</a></h3>
<ul>
<li><strong>Comparison</strong>: Compares the middle element with the target to determine the search direction, with a time complexity of O(1).</li>
<li><strong>Division</strong>: Updates the search boundaries (left or right) to half the current range, with a time complexity of O(1).</li>
<li><strong>Full Search</strong>: Executes the algorithm, halving the search space until the target is found or the space is empty, with a time complexity of O(log n).</li>
</ul>
<h3 id="java-implementation-22"><a class="header" href="#java-implementation-22">Java Implementation</a></h3>
<p>The following Java code implements Binary Search (iterative version) for an array of integers.</p>
<pre><code class="language-java">public class BinarySearch {
    // Binary Search: Finds the target in a sorted array
    public int binarySearch(int[] arr, int target) {
        if (arr == null) {
            return -1; // Return -1 for null array
        }
        int left = 0, right = arr.length - 1; // Initialize boundaries
        while (left &lt;= right) { // Continue until search space is valid
            int mid = left + (right - left) / 2; // Calculate midpoint
            if (arr[mid] == target) {
                return mid; // Return index of target
            } else if (arr[mid] &lt; target) {
                left = mid + 1; // Search right half
            } else {
                right = mid - 1; // Search left half
            }
        }
        return -1; // Target not found
    }
}
</code></pre>
<h3 id="how-it-works-23"><a class="header" href="#how-it-works-23">How It Works</a></h3>
<ol>
<li><strong>Check Input</strong>:
<ul>
<li>The <code>binarySearch</code> method checks if the input array is null. If so, it returns -1, as no search is possible.</li>
</ul>
</li>
<li><strong>Initialize Boundaries</strong>:
<ul>
<li>Sets <code>left</code> to 0 and <code>right</code> to the last index of the array, defining the initial search space.</li>
</ul>
</li>
<li><strong>Division and Comparison</strong>:
<ul>
<li>Calculates the midpoint (<code>mid</code>) and compares the element at <code>mid</code> with the target.</li>
<li>If equal, returns the index. If the target is greater, searches the right half (<code>left = mid + 1</code>). If smaller, searches the left half (<code>right = mid - 1</code>).</li>
<li>For example, in <code>[1, 3, 5, 8, 9]</code> with target 5, it checks index 2 (midpoint) and returns 2.</li>
</ul>
</li>
<li><strong>Result</strong>:
<ul>
<li>If the search space is empty (<code>left &gt; right</code>), returns -1, indicating the target is not found.</li>
<li>For example, searching for 7 returns -1.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis-table-22"><a class="header" href="#complexity-analysis-table-22">Complexity Analysis Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Division</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Search</td><td>O(1) (best)</td><td>O(1)</td></tr>
<tr><td>Full Search</td><td>O(log n) (average/worst)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements.</li>
<li>Best case (O(1)) occurs when the target is at the midpoint of the first check.</li>
<li>Average and worst cases (O(log n)) involve log n divisions.</li>
<li>Space complexity is O(1) for the iterative version, as no extra space is used.</li>
</ul>
<h3 id="key-differences--notes-22"><a class="header" href="#key-differences--notes-22">Key Differences / Notes</a></h3>
<ul>
<li><strong>Binary Search vs. Linear Search</strong>:
<ul>
<li>Binary Search is O(log n), much faster than Linear Search’s O(n) for large datasets, but requires sorted data.</li>
<li>Binary Search is more complex to implement due to its divide-and-conquer logic.</li>
</ul>
</li>
<li><strong>Iterative vs. Recursive</strong>:
<ul>
<li>The iterative version shown is more space-efficient (O(1)) than the recursive version (O(log n) due to call stack).</li>
</ul>
</li>
<li><strong>Use Cases</strong>:
<ul>
<li>Binary Search is ideal for large, sorted datasets, while Linear Search is better for unsorted or small data.</li>
</ul>
</li>
<li><strong>Limitations</strong>:
<ul>
<li>Binary Search fails on unsorted data, requiring preprocessing to sort the array.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Binary Search for large, sorted datasets to leverage its O(log n) efficiency. Test with sorted arrays and edge cases to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Binary Search requires sorted data; applying it to unsorted data produces incorrect results. Use <code>left + (right - left) / 2</code> for midpoint calculation to avoid integer overflow.</p>
</blockquote>
<h3 id="exercises-22"><a class="header" href="#exercises-22">Exercises</a></h3>
<ol>
<li><strong>Basic Binary Search</strong>: Implement Binary Search and test it with sorted arrays of different sizes and targets (e.g., present, absent, middle element).</li>
<li><strong>Recursive Implementation</strong>: Implement a recursive version of Binary Search and compare its performance with the iterative version.</li>
<li><strong>First and Last Occurrence</strong>: Modify Binary Search to find the first and last occurrences of a target in an array with duplicates (e.g., <code>[1, 3, 3, 3, 5]</code> for target 3).</li>
<li><strong>Performance Analysis</strong>: Measure the execution time of Binary Search vs. Linear Search for large sorted arrays (e.g., 1000, 10000 elements).</li>
<li><strong>Object Search</strong>: Extend Binary Search to find an object in a sorted array (e.g., <code>Student</code> with <code>id</code>). Test with a sample dataset.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion-problem-solving-with-dsa"><a class="header" href="#recursion-problem-solving-with-dsa">Recursion Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn"><a class="header" href="#-what-you-will-learn">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="binary-search-recursion"><a class="header" href="#binary-search-recursion">Binary Search Recursion</a></h1>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>Write a Java program that implements a recursive binary search algorithm to find the index of a target element in a sorted array of integers. The program should return the index of the target if found, or -1 if the target does not exist in the array. Test the program with arrays containing both existing and non-existing elements. You can visualize this as searching for a word in a dictionary by repeatedly opening to the middle page and narrowing the search to one half of the book.</p>
<p><strong>Input</strong>: A sorted array of integers and a target integer (e.g., <code>arr = [1, 3, 5, 8, 9], target = 5</code>).
<strong>Output</strong>: An integer representing the index of the target in the array, or -1 if the target is not found (e.g., 2 for target 5).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array is sorted in ascending order.</li>
<li>The target may or may not exist in the array.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 3, 5, 8, 9], target = 5</code></li>
<li>Output: 2</li>
<li>Explanation: The target 5 is found at index 2 in the sorted array.</li>
<li>Input: <code>arr = [1, 3, 5, 8, 9], target = 7</code></li>
<li>Output: -1</li>
<li>Explanation: The target 7 is not present in the array.</li>
</ul>
<h2 id="pseudocode"><a class="header" href="#pseudocode">Pseudocode</a></h2>
<pre><code>FUNCTION binarySearch(arr, target, left, right)
    IF arr is null OR left &gt; right THEN
        RETURN -1
    ENDIF
    SET mid to (left + right) / 2
    IF arr[mid] equals target THEN
        RETURN mid
    ELSE IF arr[mid] &lt; target THEN
        RETURN binarySearch(arr, target, mid + 1, right)
    ELSE
        RETURN binarySearch(arr, target, left, mid - 1)
    ENDIF
ENDFUNCTION

FUNCTION mainBinarySearch(arr, target)
    RETURN binarySearch(arr, target, 0, length of arr - 1)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps"><a class="header" href="#algorithm-steps">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or if the left index exceeds the right index, indicating an empty search space. If so, return -1.</li>
<li>Define a recursive helper function that takes the array, target, and left and right indices as parameters.</li>
<li>In the recursive function, calculate the middle index of the current search space.</li>
<li>Compare the element at the middle index with the target. If they are equal, return the middle index.</li>
<li>If the middle element is less than the target, recursively search the right half of the array (from mid + 1 to right).</li>
<li>If the middle element is greater than the target, recursively search the left half of the array (from left to mid - 1).</li>
<li>In the main function, initiate the recursion by calling the helper function with the initial left index as 0 and the right index as the array length minus 1.</li>
<li>Return the result from the recursive function, which is either the target’s index or -1 if not found.</li>
</ol>
<h2 id="java-implementation-23"><a class="header" href="#java-implementation-23">Java Implementation</a></h2>
<pre><code class="language-java">public class BinarySearchRecursion {
    // Main method to initiate recursive binary search
    public int binarySearch(int[] arr, int target) {
        // Check for null array
        if (arr == null) {
            return -1;
        }
        // Call recursive helper with initial boundaries
        return binarySearchHelper(arr, target, 0, arr.length - 1);
    }

    // Helper method for recursive binary search
    private int binarySearchHelper(int[] arr, int target, int left, int right) {
        // Base case: empty search space or invalid indices
        if (left &gt; right) {
            return -1;
        }
        // Calculate middle index
        int mid = left + (right - left) / 2;
        // If target found at mid, return index
        if (arr[mid] == target) {
            return mid;
        }
        // If target is greater, search right half
        else if (arr[mid] &lt; target) {
            return binarySearchHelper(arr, target, mid + 1, right);
        }
        // If target is smaller, search left half
        else {
            return binarySearchHelper(arr, target, left, mid - 1);
        }
    }
}
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<p>For the input <code>arr = [1, 3, 5, 8, 9], target = 5</code>, the program outputs:</p>
<pre><code>2
</code></pre>
<p>Explanation: The target 5 is found at index 2 in the sorted array.</p>
<p>For the input <code>arr = [1, 3, 5, 8, 9], target = 7</code>, the program outputs:</p>
<pre><code>-1
</code></pre>
<p>Explanation: The target 7 is not present in the array.</p>
<p>For an empty array <code>arr = []</code>, the program outputs:</p>
<pre><code>-1
</code></pre>
<p>Explanation: An empty array contains no elements, so the target cannot be found.</p>
<h2 id="how-it-works-24"><a class="header" href="#how-it-works-24">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>binarySearch</code> method checks if the array is null. For <code>[1, 3, 5, 8, 9]</code>, it is valid, so it calls the helper function with <code>left = 0</code> and <code>right = 4</code>.</li>
<li><strong>Step 2</strong>: In <code>binarySearchHelper</code>:
<ul>
<li>First call: <code>left = 0</code>, <code>right = 4</code>, <code>mid = 2</code>, <code>arr[2] = 5</code>. Since 5 equals the target, return 2.</li>
<li>For target 7: First call: <code>mid = 2</code>, <code>arr[2] = 5 &lt; 7</code>, recurse on <code>left = 3</code>, <code>right = 4</code>.</li>
<li>Second call: <code>mid = 3</code>, <code>arr[3] = 8 &gt; 7</code>, recurse on <code>left = 3</code>, <code>right = 2</code>.</li>
<li>Third call: <code>left &gt; right</code>, return -1.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[1, 3, 5, 8, 9]</code> with target 5:
<ul>
<li>Check <code>mid = 2</code>, <code>arr[2] = 5</code>, matches target, return 2.</li>
<li>For target 7: Check <code>mid = 2</code>, <code>arr[2] = 5 &lt; 7</code>, recurse on right half <code>[8, 9]</code>. Check <code>mid = 3</code>, <code>arr[3] = 8 &gt; 7</code>, recurse on left half (empty). Return -1.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-23"><a class="header" href="#complexity-analysis-table-23">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Recursive Call</td><td>O(log n)</td><td>O(log n)</td></tr>
<tr><td>Full Algorithm</td><td>O(log n)</td><td>O(log n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(log n), as the algorithm halves the search space with each recursive call.</li>
<li>Space complexity: O(log n) due to the recursive call stack, which grows logarithmically with the array size.</li>
<li>Best case: O(1) if the target is at the midpoint of the first call.</li>
<li>Average and worst cases: O(log n) for up to log n recursive calls.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursive binary search for sorted arrays to leverage its O(log n) efficiency, and test with both existing and non-existing targets to ensure correctness. Use the formula <code>left + (right - left) / 2</code> for midpoint calculation to avoid integer overflow.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Binary search requires a sorted array; applying it to an unsorted array will produce incorrect results. Ensure proper bounds checking to avoid infinite recursion or <code>ArrayIndexOutOfBoundsException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="factorial-with-memoization"><a class="header" href="#factorial-with-memoization">Factorial with Memoization</a></h1>
<h2 id="problem-statement-1"><a class="header" href="#problem-statement-1">Problem Statement</a></h2>
<p>Write a Java program that implements a recursive factorial function using memoization with a HashMap to cache previously computed results. The program should compute the factorial of a non-negative integer and compare its performance with a standard recursive factorial implementation for large inputs. Test the program with various inputs, including edge cases like 0 and 1. You can visualize this as calculating the number of ways to arrange books on a shelf, where memoization saves time by reusing previously calculated arrangements.</p>
<p><strong>Input</strong>: A non-negative integer <code>n</code> (e.g., <code>n = 5</code>).
<strong>Output</strong>: A long integer representing the factorial of <code>n</code> (e.g., 120 for <code>n = 5</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>0 ≤ n ≤ 20 (to avoid overflow with <code>long</code>).</li>
<li>The input is a non-negative integer.
<strong>Example</strong>:</li>
<li>Input: <code>n = 5</code></li>
<li>Output: 120</li>
<li>Explanation: The factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120.</li>
<li>Input: <code>n = 0</code></li>
<li>Output: 1</li>
<li>Explanation: The factorial of 0 is defined as 1.</li>
</ul>
<h2 id="pseudocode-1"><a class="header" href="#pseudocode-1">Pseudocode</a></h2>
<pre><code>FUNCTION factorialWithMemo(n, memo)
    IF n &lt; 0 THEN
        RETURN -1
    ENDIF
    IF n equals 0 OR n equals 1 THEN
        RETURN 1
    ENDIF
    IF n exists in memo THEN
        RETURN memo[n]
    ENDIF
    SET result to n * factorialWithMemo(n - 1, memo)
    SET memo[n] to result
    RETURN result
ENDFUNCTION

FUNCTION mainFactorial(n)
    CREATE empty HashMap memo
    RETURN factorialWithMemo(n, memo)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-1"><a class="header" href="#algorithm-steps-1">Algorithm Steps</a></h2>
<ol>
<li>Check if the input <code>n</code> is negative. If so, return -1, as factorial is undefined for negative numbers.</li>
<li>Define a recursive helper function that takes the input <code>n</code> and a HashMap for memoization as parameters.</li>
<li>In the recursive function, implement the base cases: if <code>n</code> is 0 or 1, return 1, as the factorial of 0 and 1 is 1.</li>
<li>Check if the factorial of <code>n</code> is already in the HashMap. If so, return the cached result.</li>
<li>For the recursive case, compute the factorial by multiplying <code>n</code> with the result of the recursive call for <code>n - 1</code>.</li>
<li>Store the computed result in the HashMap with <code>n</code> as the key.</li>
<li>In the main function, create an empty HashMap and call the helper function with <code>n</code> and the HashMap.</li>
<li>Return the final factorial result.</li>
</ol>
<h2 id="java-implementation-24"><a class="header" href="#java-implementation-24">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.HashMap;

public class FactorialWithMemoization {
    // Computes factorial of n using memoization with HashMap
    public long factorial(int n) {
        // Check for invalid input
        if (n &lt; 0) {
            return -1;
        }
        // Create HashMap for memoization
        HashMap&lt;Integer, Long&gt; memo = new HashMap&lt;&gt;();
        // Call recursive helper function
        return factorialHelper(n, memo);
    }

    // Helper function for recursive factorial with memoization
    private long factorialHelper(int n, HashMap&lt;Integer, Long&gt; memo) {
        // Base case: factorial of 0 or 1 is 1
        if (n == 0 || n == 1) {
            return 1;
        }
        // Check if result is in memo
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        // Recursive case: n * factorial(n-1)
        long result = n * factorialHelper(n - 1, memo);
        // Cache result in memo
        memo.put(n, result);
        return result;
    }

    // Standard recursive factorial for comparison
    public long standardFactorial(int n) {
        // Check for invalid input
        if (n &lt; 0) {
            return -1;
        }
        // Base case: factorial of 0 or 1 is 1
        if (n == 0 || n == 1) {
            return 1;
        }
        // Recursive case: n * factorial(n-1)
        return n * standardFactorial(n - 1);
    }
}
</code></pre>
<h2 id="output-1"><a class="header" href="#output-1">Output</a></h2>
<p>For the input <code>n = 5</code>, the <code>factorial</code> method outputs:</p>
<pre><code>120
</code></pre>
<p>Explanation: The factorial of 5 is computed as 5 * 4 * 3 * 2 * 1 = 120.</p>
<p>For the input <code>n = 0</code>, the <code>factorial</code> method outputs:</p>
<pre><code>1
</code></pre>
<p>Explanation: The factorial of 0 is defined as 1.</p>
<p>For the input <code>n = 15</code>, the <code>factorial</code> method outputs:</p>
<pre><code>1307674368000
</code></pre>
<p>Explanation: The factorial of 15 is computed as 15 * 14 * ... * 1 = 1307674368000.</p>
<h2 id="how-it-works-25"><a class="header" href="#how-it-works-25">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>factorial</code> method checks if <code>n</code> is negative. For <code>n = 5</code>, it is valid, so it creates a HashMap and calls <code>factorialHelper</code>.</li>
<li><strong>Step 2</strong>: In <code>factorialHelper</code>:
<ul>
<li>For <code>n = 5</code>: Not in memo, compute 5 * <code>factorialHelper(4)</code>.</li>
<li>For <code>n = 4</code>: Not in memo, compute 4 * <code>factorialHelper(3)</code>.</li>
<li>For <code>n = 3</code>: Not in memo, compute 3 * <code>factorialHelper(2)</code>.</li>
<li>For <code>n = 2</code>: Not in memo, compute 2 * <code>factorialHelper(1)</code>.</li>
<li>For <code>n = 1</code>: Base case, return 1.</li>
<li>Unwind: Store 2! = 2 in memo, 3! = 6 in memo, 4! = 24 in memo, 5! = 120 in memo, return 120.</li>
</ul>
</li>
<li><strong>Step 3</strong>: For subsequent calls with cached values (e.g., in a performance test), the memoized function retrieves results directly from the HashMap, reducing computation.</li>
<li><strong>Example Trace</strong>: For <code>n = 5</code>, the algorithm computes: 5 * (4 * (3 * (2 * (1)))) = 5 * 24 = 120, caching each intermediate result. For <code>n = 0</code>, it returns 1 immediately.</li>
<li><strong>Performance Comparison</strong>: The memoized version is faster for repeated calls or large <code>n</code> within the same HashMap, as it avoids recomputing factorials. For example, computing 15! takes O(n) time without memoization but O(1) for cached values with memoization.</li>
</ul>
<h2 id="complexity-analysis-table-24"><a class="header" href="#complexity-analysis-table-24">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>HashMap Operations</td><td>O(1) (average)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Memoized)</td><td>O(n) (first call)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Memoized)</td><td>O(1) (cached)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Standard)</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the input integer.</li>
<li>Time complexity (memoized): O(n) for the first call to compute and cache results up to n; O(1) for subsequent calls if cached.</li>
<li>Time complexity (standard): O(n) for all calls, as it recomputes each step.</li>
<li>Space complexity: O(n) for both, due to the recursive call stack and HashMap (for memoized version).</li>
<li>Best case (memoized): O(1) if the result is cached; worst case is O(n) for initial computation.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use memoization to optimize recursive functions like factorial for repeated calls or large inputs, and test with edge cases like 0, 1, and large values (within constraints) to verify correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious with inputs larger than 20, as factorial results may exceed the <code>long</code> data type’s capacity, causing overflow. Ensure the HashMap is properly initialized to avoid <code>NullPointerException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="recursive-sum-of-array"><a class="header" href="#recursive-sum-of-array">Recursive Sum of Array</a></h1>
<h2 id="problem-statement-2"><a class="header" href="#problem-statement-2">Problem Statement</a></h2>
<p>Write a Java program that uses recursion to compute the sum of all elements in an array of integers. The program should take an array as input and return the total sum of its elements. Test the program with arrays of different sizes, including empty arrays and single-element arrays. You can visualize this as calculating the total score of a student’s test results stored in a list, where you add each score one by one recursively.</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [1, 2, 3, 4, 5]</code>).
<strong>Output</strong>: An integer representing the sum of all elements in the array (e.g., 15 for <code>[1, 2, 3, 4, 5]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 2, 3, 4, 5]</code></li>
<li>Output: 15</li>
<li>Explanation: The sum is calculated as 1 + 2 + 3 + 4 + 5 = 15.</li>
</ul>
<h2 id="pseudocode-2"><a class="header" href="#pseudocode-2">Pseudocode</a></h2>
<pre><code>1. If the array is null or empty, return 0.
2. Define a recursive function sumArray(arr, index):
   a. Base case: If index equals array length, return 0.
   b. Recursive case: Return arr[index] + sumArray(arr, index + 1).
3. Call sumArray(arr, 0) to start recursion from the first element.
4. Return the result.
</code></pre>
<h2 id="algorithm-steps-2"><a class="header" href="#algorithm-steps-2">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or empty. If so, return 0, as the sum of no elements is zero.</li>
<li>Define a recursive helper function that takes the array and the current index as parameters.</li>
<li>In the recursive function, implement the base case: if the index equals the array length, return 0, as no more elements remain to sum.</li>
<li>For the recursive case, add the element at the current index to the result of the recursive call for the next index.</li>
<li>Initiate the recursion by calling the helper function with the initial index set to 0.</li>
<li>Return the final sum computed by the recursive function.</li>
</ol>
<h2 id="java-implementation-25"><a class="header" href="#java-implementation-25">Java Implementation</a></h2>
<pre><code class="language-java">public class RecursiveArraySum {
    // Computes the sum of array elements using recursion
    public int sumArray(int[] arr) {
        // Check for null or empty array
        if (arr == null || arr.length == 0) {
            return 0;
        }
        // Call recursive helper function starting at index 0
        return sumArrayHelper(arr, 0);
    }

    // Helper function for recursive sum
    private int sumArrayHelper(int[] arr, int index) {
        // Base case: if index reaches array length, return 0
        if (index == arr.length) {
            return 0;
        }
        // Recursive case: add current element to sum of remaining elements
        return arr[index] + sumArrayHelper(arr, index + 1);
    }
}
</code></pre>
<h2 id="output-2"><a class="header" href="#output-2">Output</a></h2>
<p>For the input array <code>[1, 2, 3, 4, 5]</code>, the program outputs:</p>
<pre><code>15
</code></pre>
<p>Explanation: The sum is computed as 1 + 2 + 3 + 4 + 5 = 15.</p>
<p>For an empty array <code>[]</code>, the program outputs:</p>
<pre><code>0
</code></pre>
<p>Explanation: The sum of an empty array is 0.</p>
<h2 id="how-it-works-26"><a class="header" href="#how-it-works-26">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>sumArray</code> method checks if the input array is null or empty. For <code>[1, 2, 3, 4, 5]</code>, it is valid, so it calls the helper function with index 0.</li>
<li><strong>Step 2</strong>: The <code>sumArrayHelper</code> method implements recursion:
<ul>
<li>At index 0: <code>arr[0] = 1</code>, recursive call for index 1.</li>
<li>At index 1: <code>arr[1] = 2</code>, recursive call for index 2.</li>
<li>At index 2: <code>arr[2] = 3</code>, recursive call for index 3.</li>
<li>At index 3: <code>arr[3] = 4</code>, recursive call for index 4.</li>
<li>At index 4: <code>arr[4] = 5</code>, recursive call for index 5.</li>
<li>At index 5: Base case reached (index equals length), return 0.</li>
</ul>
</li>
<li><strong>Step 3</strong>: The recursion unwinds: 5 + (4 + (3 + (2 + (1 + 0)))) = 15.</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 4, 5]</code>, the algorithm recursively adds: <code>1 + sum([2, 3, 4, 5]) = 1 + (2 + sum([3, 4, 5])) = 1 + 2 + (3 + sum([4, 5])) = 1 + 2 + 3 + (4 + sum([5])) = 1 + 2 + 3 + 4 + (5 + sum([])) = 1 + 2 + 3 + 4 + 5 + 0 = 15</code>.</li>
</ul>
<h2 id="complexity-analysis-table-25"><a class="header" href="#complexity-analysis-table-25">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n), as the algorithm makes one recursive call per element.</li>
<li>Space complexity: O(n) due to the recursive call stack, which grows linearly with the array size.</li>
<li>Best, average, and worst cases are all O(n), as every element is processed exactly once.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursion for problems like array summation when the logic is naturally recursive, and test with edge cases like empty arrays or single-element arrays to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious with large arrays, as the O(n) space complexity from the recursive call stack can lead to stack overflow errors. Consider iterative solutions for very large inputs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="reverse-a-string-recursively"><a class="header" href="#reverse-a-string-recursively">Reverse a String Recursively</a></h1>
<h2 id="problem-statement-3"><a class="header" href="#problem-statement-3">Problem Statement</a></h2>
<p>Write a Java program that uses recursion to reverse a string by breaking it into smaller substrings. The program should take a string as input and return the reversed string. Test the program with various strings, including empty strings and single-character strings. You can visualize this as rearranging the letters of a word written on a whiteboard, starting from the last letter and moving backward to the first, using smaller pieces of the word.</p>
<p><strong>Input</strong>: A string (e.g., <code>str = "hello"</code>).
<strong>Output</strong>: A string representing the reversed input (e.g., <code>"olleh"</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The string length is between 0 and 10^5.</li>
<li>The string contains printable ASCII characters.</li>
<li>The string may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>str = "hello"</code></li>
<li>Output: <code>"olleh"</code></li>
<li>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code> by rearranging its characters starting from the last one.</li>
</ul>
<h2 id="pseudocode-3"><a class="header" href="#pseudocode-3">Pseudocode</a></h2>
<pre><code>FUNCTION reverseString(str)
    IF str is null OR length of str &lt;= 1 THEN
        RETURN str
    ENDIF
    SET lastChar to character at index (length of str - 1)
    SET substring to str from index 0 to (length of str - 1)
    RETURN lastChar + reverseString(substring)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-3"><a class="header" href="#algorithm-steps-3">Algorithm Steps</a></h2>
<ol>
<li>Check if the input string is null, empty, or has one character. If so, return the string as is, since no reversal is needed.</li>
<li>Define a recursive function that takes the input string as a parameter.</li>
<li>In the recursive function, implement the base case: if the string is empty or has one character, return the string itself.</li>
<li>For the recursive case, extract the last character of the string and recursively call the function on the substring excluding the last character.</li>
<li>Combine the last character with the result of the recursive call to build the reversed string.</li>
<li>Return the final reversed string from the initial function call.</li>
</ol>
<h2 id="java-implementation-26"><a class="header" href="#java-implementation-26">Java Implementation</a></h2>
<pre><code class="language-java">public class ReverseStringRecursively {
    // Reverses a string using recursion
    public String reverseString(String str) {
        // Check for null, empty, or single-character string
        if (str == null || str.length() &lt;= 1) {
            return str;
        }
        // Recursive case: last character + reverse of remaining string
        return str.charAt(str.length() - 1) + reverseString(str.substring(0, str.length() - 1));
    }
}
</code></pre>
<h2 id="output-3"><a class="header" href="#output-3">Output</a></h2>
<p>For the input string <code>"hello"</code>, the program outputs:</p>
<pre><code>olleh
</code></pre>
<p>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code> by recursively rearranging characters.</p>
<p>For an empty string <code>""</code>, the program outputs:</p>
<pre><code>""
</code></pre>
<p>Explanation: An empty string remains empty after reversal.</p>
<p>For a single-character string <code>"a"</code>, the program outputs:</p>
<pre><code>a
</code></pre>
<p>Explanation: A single-character string is already reversed.</p>
<h2 id="how-it-works-27"><a class="header" href="#how-it-works-27">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>reverseString</code> method checks if the input string is null, empty, or has one character. For <code>"hello"</code>, it has length 5, so it proceeds to the recursive case.</li>
<li><strong>Step 2</strong>: In the recursive case:
<ul>
<li>For <code>"hello"</code>: Returns <code>'o'</code> + <code>reverseString("hell")</code>.</li>
<li>For <code>"hell"</code>: Returns <code>'l'</code> + <code>reverseString("hel")</code>.</li>
<li>For <code>"hel"</code>: Returns <code>'l'</code> + <code>reverseString("he")</code>.</li>
<li>For <code>"he"</code>: Returns <code>'e'</code> + <code>reverseString("h")</code>.</li>
<li>For <code>"h"</code>: Base case reached (length 1), returns <code>"h"</code>.</li>
</ul>
</li>
<li><strong>Step 3</strong>: The recursion unwinds: <code>'h'</code> + <code>'e'</code> + <code>'l'</code> + <code>'l'</code> + <code>'o'</code> = <code>"olleh"</code>.</li>
<li><strong>Example Trace</strong>: For <code>"hello"</code>, the algorithm recursively processes: <code>'o'</code> + <code>reverse("hell")</code> = <code>'o'</code> + (<code>'l'</code> + <code>reverse("hel")</code>) = <code>'o'</code> + <code>'l'</code> + (<code>'l'</code> + <code>reverse("he")</code>) = <code>'o'</code> + <code>'l'</code> + <code>'l'</code> + (<code>'e'</code> + <code>reverse("h")</code>) = <code>'o'</code> + <code>'l'</code> + <code>'l'</code> + <code>'e'</code> + <code>'h'</code> = <code>"olleh"</code>.</li>
</ul>
<h2 id="complexity-analysis-table-26"><a class="header" href="#complexity-analysis-table-26">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n), as the algorithm makes one recursive call per character.</li>
<li>Space complexity: O(n) due to the recursive call stack and the creation of substrings in Java, which involves new string objects.</li>
<li>Best, average, and worst cases are all O(n), as every character is processed exactly once.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursion for string reversal when the problem naturally breaks into smaller subproblems, and test with edge cases like empty strings, single characters, or long strings to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious with very long strings, as the O(n) space complexity from the recursive call stack and substring creation can lead to stack overflow or memory issues. Consider iterative solutions for large inputs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="tower-of-hanoi"><a class="header" href="#tower-of-hanoi">Tower of Hanoi</a></h1>
<h2 id="problem-statement-4"><a class="header" href="#problem-statement-4">Problem Statement</a></h2>
<p>Write a Java program that uses recursion to solve the Tower of Hanoi problem for <code>n</code> disks, printing the sequence of moves required to transfer all disks from a source rod to a destination rod using an auxiliary rod. The rules are: only one disk can be moved at a time, a larger disk cannot be placed on a smaller disk, and disks must be moved between the rods (source, auxiliary, destination). Test the program with different values of <code>n</code>, including edge cases like <code>n = 1</code>. You can visualize this as moving a stack of differently sized books from one table to another, using a third table as temporary storage, ensuring larger books are always below smaller ones.</p>
<p><strong>Input</strong>: A non-negative integer <code>n</code> representing the number of disks, and three rod names (e.g., <code>source = 'A'</code>, <code>auxiliary = 'B'</code>, <code>destination = 'C'</code>).
<strong>Output</strong>: A sequence of moves printed in the format "Move disk [number] from [source] to [destination]" (e.g., "Move disk 1 from A to C"), with each move on a new line.
<strong>Constraints</strong>:</p>
<ul>
<li>0 ≤ n ≤ 10 (to keep output manageable and avoid excessive recursion).</li>
<li>Rod names are single characters (e.g., 'A', 'B', 'C').
<strong>Example</strong>:</li>
<li>Input: <code>n = 2, source = 'A', auxiliary = 'B', destination = 'C'</code></li>
<li>Output:
<pre><code>Move disk 1 from A to B
Move disk 2 from A to C
Move disk 1 from B to C
</code></pre>
</li>
<li>Explanation: The two disks are moved from rod A to rod C using rod B as auxiliary, following the rules of the Tower of Hanoi.</li>
</ul>
<h2 id="pseudocode-4"><a class="header" href="#pseudocode-4">Pseudocode</a></h2>
<pre><code>FUNCTION towerOfHanoi(n, source, auxiliary, destination)
    IF n equals 0 THEN
        RETURN
    ENDIF
    IF n equals 1 THEN
        PRINT "Move disk 1 from source to destination"
        RETURN
    ENDIF
    CALL towerOfHanoi(n - 1, source, destination, auxiliary)
    PRINT "Move disk n from source to destination"
    CALL towerOfHanoi(n - 1, auxiliary, source, destination)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-4"><a class="header" href="#algorithm-steps-4">Algorithm Steps</a></h2>
<ol>
<li>Check if the number of disks <code>n</code> is 0. If so, return immediately, as no moves are needed.</li>
<li>Define a recursive function that takes the number of disks <code>n</code> and the names of the source, auxiliary, and destination rods as parameters.</li>
<li>In the recursive function, implement the base case: if <code>n</code> equals 1, print a move to transfer the single disk from the source to the destination rod and return.</li>
<li>For the recursive case, perform three steps:
a. Recursively move <code>n - 1</code> disks from the source rod to the auxiliary rod, using the destination rod as the auxiliary.
b. Print a move to transfer the nth disk from the source rod to the destination rod.
c. Recursively move <code>n - 1</code> disks from the auxiliary rod to the destination rod, using the source rod as the auxiliary.</li>
<li>In the main function, call the recursive function with the input <code>n</code> and rod names (e.g., 'A', 'B', 'C').</li>
<li>The function prints the sequence of moves to solve the Tower of Hanoi problem.</li>
</ol>
<h2 id="java-implementation-27"><a class="header" href="#java-implementation-27">Java Implementation</a></h2>
<pre><code class="language-java">public class TowerOfHanoi {
    // Solves Tower of Hanoi for n disks and prints moves
    public void towerOfHanoi(int n, char source, char auxiliary, char destination) {
        // Base case: no disks to move
        if (n == 0) {
            return;
        }
        // Base case: single disk, move directly
        if (n == 1) {
            System.out.println("Move disk 1 from " + source + " to " + destination);
            return;
        }
        // Recursive case: move n-1 disks to auxiliary rod
        towerOfHanoi(n - 1, source, destination, auxiliary);
        // Move nth disk to destination rod
        System.out.println("Move disk " + n + " from " + source + " to " + destination);
        // Move n-1 disks from auxiliary to destination rod
        towerOfHanoi(n - 1, auxiliary, source, destination);
    }
}
</code></pre>
<h2 id="output-4"><a class="header" href="#output-4">Output</a></h2>
<p>For the input <code>n = 2, source = 'A', auxiliary = 'B', destination = 'C'</code>, the program outputs:</p>
<pre><code>Move disk 1 from A to B
Move disk 2 from A to C
Move disk 1 from B to C
</code></pre>
<p>Explanation: The two disks are moved from rod A to rod C using rod B as auxiliary, following the Tower of Hanoi rules.</p>
<p>For the input <code>n = 1, source = 'A', auxiliary = 'B', destination = 'C'</code>, the program outputs:</p>
<pre><code>Move disk 1 from A to C
</code></pre>
<p>Explanation: A single disk is moved directly from rod A to rod C.</p>
<h2 id="how-it-works-28"><a class="header" href="#how-it-works-28">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>towerOfHanoi</code> method checks if <code>n</code> is 0. For <code>n = 2</code>, it proceeds to the recursive case.</li>
<li><strong>Step 2</strong>: For <code>n = 2</code>:
<ul>
<li>First recursive call: <code>towerOfHanoi(1, A, C, B)</code>:
<ul>
<li>Base case: <code>n = 1</code>, prints "Move disk 1 from A to B".</li>
</ul>
</li>
<li>Print: "Move disk 2 from A to C".</li>
<li>Second recursive call: <code>towerOfHanoi(1, B, A, C)</code>:
<ul>
<li>Base case: <code>n = 1</code>, prints "Move disk 1 from B to C".</li>
</ul>
</li>
</ul>
</li>
<li><strong>Step 3</strong>: The recursion generates the sequence of moves to transfer all disks from source to destination while respecting the rules.</li>
<li><strong>Example Trace</strong>: For <code>n = 2</code>:
<ul>
<li>Move disk 1 from A to B (move top disk to auxiliary).</li>
<li>Move disk 2 from A to C (move largest disk to destination).</li>
<li>Move disk 1 from B to C (move top disk to destination).</li>
</ul>
</li>
<li><strong>Testing with Different n</strong>: For <code>n = 1</code>, it prints one move. For <code>n = 3</code>, it generates 7 moves (2^3 - 1), following the same recursive pattern.</li>
</ul>
<h2 id="complexity-analysis-table-27"><a class="header" href="#complexity-analysis-table-27">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call</td><td>O(2^n)</td><td>O(n)</td></tr>
<tr><td>Print Operation</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(2^n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of disks.</li>
<li>Time complexity: O(2^n), as the algorithm makes 2^n - 1 moves, with each move involving a constant-time print operation.</li>
<li>Space complexity: O(n) due to the recursive call stack, which grows linearly with the number of disks.</li>
<li>Best, average, and worst cases are all O(2^n), as the number of moves is fixed for a given <code>n</code>.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the Tower of Hanoi to understand recursive problem-solving, and test with small values of <code>n</code> (e.g., 1, 2, 3) to visualize the move sequence. Count the number of moves to confirm it matches 2^n - 1.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid large values of <code>n</code> (e.g., &gt;10), as the O(2^n) time complexity leads to an exponential number of moves, causing significant delays. Ensure rod names are distinct to avoid confusion in output.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="fibonacci-optimization"><a class="header" href="#fibonacci-optimization">Fibonacci Optimization</a></h1>
<h2 id="problem-statement-5"><a class="header" href="#problem-statement-5">Problem Statement</a></h2>
<p>Write a Java program that computes the nth Fibonacci number using a recursive approach with memoization (using a HashMap to cache results) and an iterative approach. The program should return the nth Fibonacci number and compare the performance of both methods for large inputs. Test the program with various inputs, including edge cases like (n = 0) and (n = 1). You can visualize this as calculating the number of rabbits in a population after (n) months, where each month’s population depends on the previous two, with memoization or iteration to optimize the process.</p>
<p><strong>Input</strong>: A non-negative integer (n) (e.g., (n = 6)).
<strong>Output</strong>: A long integer representing the nth Fibonacci number (e.g., 8 for (n = 6)).
<strong>Constraints</strong>:</p>
<ul>
<li>(0 \leq n \leq 50) (to avoid overflow with <code>long</code>).</li>
<li>The input is a non-negative integer.
<strong>Example</strong>:</li>
<li>Input: (n = 6)</li>
<li>Output: 8</li>
<li>Explanation: The Fibonacci sequence is 0, 1, 1, 2, 3, 5, 8, ..., so the 6th Fibonacci number is 8.</li>
<li>Input: (n = 0)</li>
<li>Output: 0</li>
<li>Explanation: The 0th Fibonacci number is defined as 0.</li>
</ul>
<h2 id="pseudocode-5"><a class="header" href="#pseudocode-5">Pseudocode</a></h2>
<pre><code>FUNCTION fibonacciMemo(n, memo)
    IF n &lt; 0 THEN
        RETURN -1
    ENDIF
    IF n equals 0 THEN
        RETURN 0
    ENDIF
    IF n equals 1 THEN
        RETURN 1
    ENDIF
    IF n exists in memo THEN
        RETURN memo[n]
    ENDIF
    SET result to fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo)
    SET memo[n] to result
    RETURN result
ENDFUNCTION

FUNCTION fibonacciIterative(n)
    IF n &lt; 0 THEN
        RETURN -1
    ENDIF
    IF n equals 0 THEN
        RETURN 0
    ENDIF
    IF n equals 1 THEN
        RETURN 1
    ENDIF
    SET prev to 0
    SET current to 1
    FOR i from 2 to n
        SET next to prev + current
        SET prev to current
        SET current to next
    ENDFOR
    RETURN current
ENDFUNCTION

FUNCTION mainFibonacci(n)
    CREATE empty HashMap memo
    CALL fibonacciMemo(n, memo)
    CALL fibonacciIterative(n)
    RETURN results
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-5"><a class="header" href="#algorithm-steps-5">Algorithm Steps</a></h2>
<ol>
<li>For the recursive approach with memoization:
a. Check if (n) is negative. If so, return -1, as Fibonacci is undefined for negative numbers.
b. Define a recursive helper function that takes (n) and a HashMap for memoization as parameters.
c. Implement base cases: if (n = 0), return 0; if (n = 1), return 1.
d. Check if the Fibonacci number for (n) is in the HashMap. If so, return the cached result.
e. Compute the Fibonacci number as the sum of the results for (n - 1) and (n - 2) using recursive calls.
f. Store the result in the HashMap and return it.</li>
<li>For the iterative approach:
a. Check if (n) is negative. If so, return -1.
b. Implement base cases: if (n = 0), return 0; if (n = 1), return 1.
c. Initialize variables <code>prev</code> (F(0) = 0) and <code>current</code> (F(1) = 1).
d. Iterate from (i = 2) to (n), computing each Fibonacci number as <code>prev + current</code>, updating <code>prev</code> and <code>current</code> accordingly.
e. Return the final Fibonacci number.</li>
<li>In the main function, create a HashMap for memoization, call both methods, and compare their performance for large inputs.</li>
</ol>
<h2 id="java-implementation-28"><a class="header" href="#java-implementation-28">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.HashMap;

public class FibonacciOptimization {
    // Computes nth Fibonacci number using recursion with memoization
    public long fibonacciMemo(int n) {
        // Check for invalid input
        if (n &lt; 0) {
            return -1;
        }
        // Create HashMap for memoization
        HashMap&lt;Integer, Long&gt; memo = new HashMap&lt;&gt;();
        // Call recursive helper function
        return fibonacciMemoHelper(n, memo);
    }

    // Helper function for recursive Fibonacci with memoization
    private long fibonacciMemoHelper(int n, HashMap&lt;Integer, Long&gt; memo) {
        // Base case: F(0) = 0
        if (n == 0) {
            return 0;
        }
        // Base case: F(1) = 1
        if (n == 1) {
            return 1;
        }
        // Check if result is in memo
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        // Recursive case: F(n) = F(n-1) + F(n-2)
        long result = fibonacciMemoHelper(n - 1, memo) + fibonacciMemoHelper(n - 2, memo);
        // Cache result in memo
        memo.put(n, result);
        return result;
    }

    // Computes nth Fibonacci number using iteration
    public long fibonacciIterative(int n) {
        // Check for invalid input
        if (n &lt; 0) {
            return -1;
        }
        // Base case: F(0) = 0
        if (n == 0) {
            return 0;
        }
        // Base case: F(1) = 1
        if (n == 1) {
            return 1;
        }
        // Initialize variables for F(0) and F(1)
        long prev = 0;
        long current = 1;
        // Iterate to compute F(n)
        for (int i = 2; i &lt;= n; i++) {
            long next = prev + current;
            prev = current;
            current = next;
        }
        // Return nth Fibonacci number
        return current;
    }
}
</code></pre>
<h2 id="output-5"><a class="header" href="#output-5">Output</a></h2>
<p>For the input (n = 6), both methods output:</p>
<pre><code>8
</code></pre>
<p>Explanation: The Fibonacci sequence is 0, 1, 1, 2, 3, 5, 8, so the 6th Fibonacci number is 8.</p>
<p>For the input (n = 0), both methods output:</p>
<pre><code>0
</code></pre>
<p>Explanation: The 0th Fibonacci number is defined as 0.</p>
<p>For the input (n = 10), both methods output:</p>
<pre><code>55
</code></pre>
<p>Explanation: The 10th Fibonacci number is 55.</p>
<h2 id="how-it-works-29"><a class="header" href="#how-it-works-29">How It Works</a></h2>
<ul>
<li><strong>Recursive Approach with Memoization</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>fibonacciMemo</code> method checks if (n &lt; 0). For (n = 6), it creates a HashMap and calls <code>fibonacciMemoHelper</code>.</li>
<li><strong>Step 2</strong>: In <code>fibonacciMemoHelper</code>:
<ul>
<li>For (n = 6): Not in memo, compute F(5) + F(4).</li>
<li>For (n = 5): Not in memo, compute F(4) + F(3).</li>
<li>For (n = 4): Not in memo, compute F(3) + F(2).</li>
<li>For (n = 3): Not in memo, compute F(2) + F(1).</li>
<li>For (n = 2): Not in memo, compute F(1) + F(0) = 1 + 0 = 1.</li>
<li>For (n = 1): Base case, return 1.</li>
<li>For (n = 0): Base case, return 0.</li>
<li>Unwind: Cache F(2) = 1, F(3) = 2, F(4) = 3, F(5) = 5, F(6) = 8.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (n = 6), computes F(6) = F(5) + F(4) = 5 + 3 = 8, caching each result.</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>fibonacciIterative</code> method checks if (n &lt; 0). For (n = 6), initializes <code>prev = 0</code>, <code>current = 1</code>.</li>
<li><strong>Step 2</strong>: Iterates from (i = 2) to 6:
<ul>
<li>(i = 2): <code>next = 0 + 1 = 1</code>, <code>prev = 1</code>, <code>current = 1</code>.</li>
<li>(i = 3): <code>next = 1 + 1 = 2</code>, <code>prev = 1</code>, <code>current = 2</code>.</li>
<li>(i = 4): <code>next = 1 + 2 = 3</code>, <code>prev = 2</code>, <code>current = 3</code>.</li>
<li>(i = 5): <code>next = 2 + 3 = 5</code>, <code>prev = 3</code>, <code>current = 5</code>.</li>
<li>(i = 6): <code>next = 3 + 5 = 8</code>, <code>prev = 5</code>, <code>current = 8</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (n = 6), computes 0, 1, 1, 2, 3, 5, 8, returning 8.</li>
</ul>
</li>
<li><strong>Performance Comparison</strong>: Memoized recursive is O(n) time, much faster than O(2^n) for naive recursion, and comparable to iterative O(n) time. Iterative uses O(1) space, while memoized uses O(n) space for the HashMap and call stack, making iterative more efficient for very large (n).</li>
</ul>
<h2 id="complexity-analysis-table-28"><a class="header" href="#complexity-analysis-table-28">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call (Memoized)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Memoized)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the input integer.</li>
<li>Time complexity: O(n) for memoized recursive, as each Fibonacci number is computed once and cached; O(n) for iterative, as it performs n iterations.</li>
<li>Space complexity: O(n) for memoized recursive due to the HashMap and call stack; O(1) for iterative, using only a few variables.</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the iterative approach for large (n) to minimize space usage, or memoization for recursive solutions to avoid exponential time complexity. Test with large inputs (e.g., (n = 50)) to compare performance and verify results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Without memoization, recursive Fibonacci has O(2^n) time complexity, making it impractical for large (n). Ensure inputs are within constraints ((n \leq 50)) to avoid overflow with <code>long</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="linked-list-traversal"><a class="header" href="#linked-list-traversal">Linked List Traversal</a></h1>
<h2 id="problem-statement-6"><a class="header" href="#problem-statement-6">Problem Statement</a></h2>
<p>Write a Java program that implements both recursive and iterative methods to traverse and print the elements of a singly linked list. The program should take a singly linked list as input and print each element in order, from the head to the tail. Test both approaches with lists of varying sizes, including empty lists and single-node lists, and discuss their trade-offs in terms of readability, performance, and memory usage. You can visualize this as walking through a chain of boxes, each containing a number, and reading the numbers either by stepping through each box (iterative) or by recursively passing to the next box (recursive).</p>
<p><strong>Input</strong>: A singly linked list with integer nodes (e.g., <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>).
<strong>Output</strong>: The elements of the list printed in order, each on a new line (e.g., <code>1</code>, <code>2</code>, <code>3</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The list contains 0 to 10^5 nodes.</li>
<li>Node values are integers between -10^9 and 10^9.</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: Linked list <code>1 -&gt; 2 -&gt; 3 -&gt; null</code></li>
<li>Output:
<pre><code>1
2
3
</code></pre>
</li>
<li>Explanation: The elements 1, 2, and 3 are printed in order.</li>
<li>Input: Empty linked list <code>null</code></li>
<li>Output: (no output)</li>
<li>Explanation: An empty list has no elements to print.</li>
</ul>
<h2 id="pseudocode-6"><a class="header" href="#pseudocode-6">Pseudocode</a></h2>
<pre><code>FUNCTION recursivePrint(node)
    IF node is null THEN
        RETURN
    ENDIF
    PRINT node.value
    CALL recursivePrint(node.next)
ENDFUNCTION

FUNCTION iterativePrint(node)
    SET current to node
    WHILE current is not null
        PRINT current.value
        SET current to current.next
    ENDWHILE
ENDFUNCTION

FUNCTION mainPrint(head)
    CALL recursivePrint(head)
    CALL iterativePrint(head)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-6"><a class="header" href="#algorithm-steps-6">Algorithm Steps</a></h2>
<ol>
<li>For the recursive approach:
a. Check if the current node is null. If so, return, as there are no more elements to print.
b. Define a recursive function that takes the current node as a parameter.
c. Print the value of the current node.
d. Recursively call the function on the next node in the list.</li>
<li>For the iterative approach:
a. Initialize a pointer <code>current</code> to the head of the list.
b. While <code>current</code> is not null, print the value of <code>current</code> and move <code>current</code> to the next node.</li>
<li>In the main function, call both the recursive and iterative methods to print the list’s elements.</li>
<li>Discuss trade-offs: recursive is more concise but uses more memory due to the call stack; iterative is less readable but more space-efficient.</li>
</ol>
<h2 id="java-implementation-29"><a class="header" href="#java-implementation-29">Java Implementation</a></h2>
<pre><code class="language-java">public class LinkedListTraversal {
    // Node class for singly linked list
    class Node {
        int data;
        Node next;
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Prints linked list using recursion
    public void recursivePrint(Node head) {
        // Base case: if node is null, stop
        if (head == null) {
            return;
        }
        // Print current node's data
        System.out.println(head.data);
        // Recursive call for next node
        recursivePrint(head.next);
    }

    // Prints linked list using iteration
    public void iterativePrint(Node head) {
        // Start at head
        Node current = head;
        // Iterate until null
        while (current != null) {
            // Print current node's data
            System.out.println(current.data);
            // Move to next node
            current = current.next;
        }
    }
}
</code></pre>
<h2 id="output-6"><a class="header" href="#output-6">Output</a></h2>
<p>For the input linked list <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, both methods output:</p>
<pre><code>1
2
3
</code></pre>
<p>Explanation: The elements 1, 2, and 3 are printed in order from head to tail.</p>
<p>For an empty linked list <code>null</code>, both methods output:</p>
<pre><code>(nothing printed)
</code></pre>
<p>Explanation: An empty list has no elements to print.</p>
<p>For a single-node linked list <code>4 -&gt; null</code>, both methods output:</p>
<pre><code>4
</code></pre>
<p>Explanation: The single node’s value 4 is printed.</p>
<h2 id="how-it-works-30"><a class="header" href="#how-it-works-30">How It Works</a></h2>
<ul>
<li><strong>Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>recursivePrint</code> method checks if the head is null. For <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Recursion:
<ul>
<li>For node <code>1</code>: Print 1, recurse on node <code>2</code>.</li>
<li>For node <code>2</code>: Print 2, recurse on node <code>3</code>.</li>
<li>For node <code>3</code>: Print 3, recurse on <code>null</code>.</li>
<li>For <code>null</code>: Base case, return.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, prints 1, then 2, then 3.</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativePrint</code> method initializes <code>current</code> to the head (<code>1</code>).</li>
<li><strong>Step 2</strong>: Iterates:
<ul>
<li><code>current = 1</code>: Print 1, move to <code>2</code>.</li>
<li><code>current = 2</code>: Print 2, move to <code>3</code>.</li>
<li><code>current = 3</code>: Print 3, move to <code>null</code>.</li>
<li><code>current = null</code>: Stop.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, prints 1, 2, 3 in sequence.</li>
</ul>
</li>
<li><strong>Trade-offs</strong>:
<ul>
<li><strong>Readability</strong>: Recursive is more concise and elegant, mirroring the list’s structure, but may be harder for beginners to grasp.</li>
<li><strong>Performance</strong>: Both have O(n) time, but recursive uses O(n) space due to the call stack, while iterative uses O(1) space, making it more efficient for large lists.</li>
<li><strong>Memory</strong>: Recursive risks stack overflow for very large lists; iterative is safer.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-29"><a class="header" href="#complexity-analysis-table-29">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the linked list.</li>
<li>Time complexity: O(n) for both, as each node is visited exactly once.</li>
<li>Space complexity: O(n) for recursive due to the call stack; O(1) for iterative, using only a single pointer.</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the iterative approach for large linked lists to avoid stack overflow and minimize memory usage. Test with empty lists and long lists to verify correctness and compare performance.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The recursive approach may cause stack overflow for very large lists (e.g., 10^5 nodes) due to O(n) space complexity. Ensure the list is properly constructed to avoid null pointer exceptions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="power-function"><a class="header" href="#power-function">Power Function</a></h1>
<h2 id="problem-statement-7"><a class="header" href="#problem-statement-7">Problem Statement</a></h2>
<p>Write a Java program that implements both recursive and iterative methods to compute (x^n), where (x) is a double and (n) is a non-negative integer representing the power. The program should return the result of (x) raised to the power (n) and test the methods with different inputs, including edge cases like (n = 0) and (n = 1). Analyze the space complexity of both approaches. You can visualize this as calculating the total area of a square piece of land ((x)) that is scaled by itself (n) times, either by repeatedly multiplying (iterative) or by breaking it into smaller multiplications (recursive).</p>
<p><strong>Input</strong>: A double (x) and a non-negative integer (n) (e.g., (x = 2.0, n = 3)).
<strong>Output</strong>: A double representing (x^n) (e.g., 8.0 for (2.0^3)).
<strong>Constraints</strong>:</p>
<ul>
<li>(-100.0 \leq x \leq 100.0).</li>
<li>(0 \leq n \leq 10^3).</li>
<li>The result should fit within a double’s precision.
<strong>Example</strong>:</li>
<li>Input: (x = 2.0, n = 3)</li>
<li>Output: 8.0</li>
<li>Explanation: (2.0^3 = 2.0 * 2.0 * 2.0 = 8.0).</li>
<li>Input: (x = 5.0, n = 0)</li>
<li>Output: 1.0</li>
<li>Explanation: Any non-zero number raised to the power 0 is 1.</li>
</ul>
<h2 id="pseudocode-7"><a class="header" href="#pseudocode-7">Pseudocode</a></h2>
<pre><code>FUNCTION recursivePower(x, n)
    IF n equals 0 THEN
        RETURN 1.0
    ENDIF
    IF n equals 1 THEN
        RETURN x
    ENDIF
    RETURN x * recursivePower(x, n - 1)
ENDFUNCTION

FUNCTION iterativePower(x, n)
    IF n equals 0 THEN
        RETURN 1.0
    ENDIF
    SET result to 1.0
    FOR i from 1 to n
        SET result to result * x
    ENDFOR
    RETURN result
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-7"><a class="header" href="#algorithm-steps-7">Algorithm Steps</a></h2>
<ol>
<li>For the recursive approach:
a. Check if (n) is 0. If so, return 1.0, as any non-zero number raised to the power 0 is 1.
b. Check if (n) is 1. If so, return (x), as (x^1 = x).
c. Define a recursive function that multiplies (x) by the result of the recursive call for (n - 1).
d. Return the computed result.</li>
<li>For the iterative approach:
a. Check if (n) is 0. If so, return 1.0.
b. Initialize a variable <code>result</code> to 1.0.
c. Iterate (n) times, multiplying <code>result</code> by (x) in each iteration.
d. Return the final <code>result</code>.</li>
<li>Test both methods with various inputs (e.g., (n = 0, 1, 5)) and analyze space complexity.</li>
</ol>
<h2 id="java-implementation-30"><a class="header" href="#java-implementation-30">Java Implementation</a></h2>
<pre><code class="language-java">public class PowerFunction {
    // Computes x^n using recursion
    public double recursivePower(double x, int n) {
        // Base case: x^0 = 1
        if (n == 0) {
            return 1.0;
        }
        // Base case: x^1 = x
        if (n == 1) {
            return x;
        }
        // Recursive case: x * x^(n-1)
        return x * recursivePower(x, n - 1);
    }

    // Computes x^n using iteration
    public double iterativePower(double x, int n) {
        // Base case: x^0 = 1
        if (n == 0) {
            return 1.0;
        }
        // Initialize result
        double result = 1.0;
        // Multiply x by itself n times
        for (int i = 1; i &lt;= n; i++) {
            result *= x;
        }
        // Return final result
        return result;
    }
}
</code></pre>
<h2 id="output-7"><a class="header" href="#output-7">Output</a></h2>
<p>For the input (x = 2.0, n = 3), both methods output:</p>
<pre><code>8.0
</code></pre>
<p>Explanation: (2.0^3 = 2.0 * 2.0 * 2.0 = 8.0).</p>
<p>For the input (x = 5.0, n = 0), both methods output:</p>
<pre><code>1.0
</code></pre>
<p>Explanation: Any non-zero number raised to the power 0 is 1.</p>
<p>For the input (x = 3.0, n = 2), both methods output:</p>
<pre><code>9.0
</code></pre>
<p>Explanation: (3.0^2 = 3.0 * 3.0 = 9.0).</p>
<h2 id="how-it-works-31"><a class="header" href="#how-it-works-31">How It Works</a></h2>
<ul>
<li><strong>Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>recursivePower</code> method checks if (n = 0). For (x = 2.0, n = 3), it proceeds to recursion.</li>
<li><strong>Step 2</strong>: Recursion:
<ul>
<li>For (n = 3): Returns (2.0 * recursivePower(2.0, 2)).</li>
<li>For (n = 2): Returns (2.0 * recursivePower(2.0, 1)).</li>
<li>For (n = 1): Base case, returns 2.0.</li>
<li>Unwind: (2.0 * (2.0 * 2.0) = 2.0 * 4.0 = 8.0).</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (x = 2.0, n = 3), computes (2.0 * (2.0 * (2.0 * 1)) = 8.0).</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativePower</code> method checks if (n = 0). For (x = 2.0, n = 3), it initializes <code>result = 1.0</code>.</li>
<li><strong>Step 2</strong>: Iterates 3 times:
<ul>
<li>Iteration 1: <code>result = 1.0 * 2.0 = 2.0</code>.</li>
<li>Iteration 2: <code>result = 2.0 * 2.0 = 4.0</code>.</li>
<li>Iteration 3: <code>result = 4.0 * 2.0 = 8.0</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (x = 2.0, n = 3), multiplies (2.0 * 2.0 * 2.0 = 8.0).</li>
</ul>
</li>
<li><strong>Space Complexity Analysis</strong>:
<ul>
<li>Recursive: O(n) due to the call stack, which grows linearly with (n).</li>
<li>Iterative: O(1), as it uses only a single variable for the result.</li>
<li>The iterative approach is more space-efficient, especially for large (n), while both have similar time performance for this basic implementation.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-30"><a class="header" href="#complexity-analysis-table-30">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the exponent.</li>
<li>Time complexity: O(n) for both, as recursive makes n calls, and iterative performs n multiplications.</li>
<li>Space complexity: O(n) for recursive due to the call stack; O(1) for iterative, using only a single variable.</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the iterative approach for large (n) to avoid stack overflow and minimize space usage. Test with edge cases like (n = 0), (n = 1), and large (n) (e.g., 1000) to verify correctness and compare space efficiency.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The recursive approach may cause stack overflow for very large (n) due to O(n) space complexity. Be cautious with floating-point precision for large (x) or (n), as results may exceed double’s capacity.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="recursive-vs-iterative-sum"><a class="header" href="#recursive-vs-iterative-sum">Recursive vs. Iterative Sum</a></h1>
<h2 id="problem-statement-8"><a class="header" href="#problem-statement-8">Problem Statement</a></h2>
<p>Write a Java program that computes the sum of all elements in an array of integers using both recursive and iterative approaches. The program should return the total sum and allow performance comparison between the two methods for large arrays. Test the program with arrays of different sizes, including empty arrays and single-element arrays. You can visualize this as calculating the total cost of items in a shopping list, either by adding items one by one (iterative) or by breaking the list into smaller parts and combining their sums (recursive).</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [1, 2, 3, 4, 5]</code>).
<strong>Output</strong>: An integer representing the sum of all elements in the array (e.g., 15 for <code>[1, 2, 3, 4, 5]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 2, 3, 4, 5]</code></li>
<li>Output: 15</li>
<li>Explanation: The sum is calculated as 1 + 2 + 3 + 4 + 5 = 15.</li>
<li>Input: <code>arr = []</code></li>
<li>Output: 0</li>
<li>Explanation: The sum of an empty array is 0.</li>
</ul>
<h2 id="pseudocode-8"><a class="header" href="#pseudocode-8">Pseudocode</a></h2>
<pre><code>FUNCTION recursiveSum(arr, index)
    IF arr is null OR index equals length of arr THEN
        RETURN 0
    ENDIF
    RETURN arr[index] + recursiveSum(arr, index + 1)
ENDFUNCTION

FUNCTION iterativeSum(arr)
    IF arr is null OR length of arr equals 0 THEN
        RETURN 0
    ENDIF
    SET sum to 0
    FOR each index i from 0 to length of arr - 1
        SET sum to sum + arr[i]
    ENDFOR
    RETURN sum
ENDFUNCTION

FUNCTION mainSum(arr)
    CALL recursiveSum(arr, 0)
    CALL iterativeSum(arr)
    RETURN results
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-8"><a class="header" href="#algorithm-steps-8">Algorithm Steps</a></h2>
<ol>
<li>For the recursive approach:
a. Check if the array is null or the current index equals the array length. If so, return 0.
b. Define a recursive helper function that takes the array and the current index as parameters.
c. In the recursive function, add the element at the current index to the result of the recursive call for the next index.
d. Call the recursive function with the initial index set to 0.</li>
<li>For the iterative approach:
a. Check if the array is null or empty. If so, return 0.
b. Initialize a variable to store the sum.
c. Iterate through the array from index 0 to the last index, adding each element to the sum.
d. Return the final sum.</li>
<li>In the main function, call both the recursive and iterative methods to compute the sum.</li>
<li>Return the results for comparison, ideally measuring execution time for large arrays.</li>
</ol>
<h2 id="java-implementation-31"><a class="header" href="#java-implementation-31">Java Implementation</a></h2>
<pre><code class="language-java">public class RecursiveVsIterativeSum {
    // Computes sum of array elements using recursion
    public long recursiveSum(int[] arr) {
        // Check for null array
        if (arr == null) {
            return 0;
        }
        // Call recursive helper with initial index 0
        return recursiveSumHelper(arr, 0);
    }

    // Helper function for recursive sum
    private long recursiveSumHelper(int[] arr, int index) {
        // Base case: if index reaches array length, return 0
        if (index == arr.length) {
            return 0;
        }
        // Recursive case: add current element to sum of remaining elements
        return arr[index] + recursiveSumHelper(arr, index + 1);
    }

    // Computes sum of array elements using iteration
    public long iterativeSum(int[] arr) {
        // Check for null or empty array
        if (arr == null || arr.length == 0) {
            return 0;
        }
        // Initialize sum
        long sum = 0;
        // Iterate through array and add each element
        for (int i = 0; i &lt; arr.length; i++) {
            sum += arr[i];
        }
        // Return final sum
        return sum;
    }
}
</code></pre>
<h2 id="output-8"><a class="header" href="#output-8">Output</a></h2>
<p>For the input array <code>[1, 2, 3, 4, 5]</code>, both methods output:</p>
<pre><code>15
</code></pre>
<p>Explanation: The sum is computed as 1 + 2 + 3 + 4 + 5 = 15.</p>
<p>For an empty array <code>[]</code>, both methods output:</p>
<pre><code>0
</code></pre>
<p>Explanation: The sum of an empty array is 0.</p>
<p>For a single-element array <code>[7]</code>, both methods output:</p>
<pre><code>7
</code></pre>
<p>Explanation: The sum of a single-element array is the element itself.</p>
<h2 id="how-it-works-32"><a class="header" href="#how-it-works-32">How It Works</a></h2>
<ul>
<li><strong>Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>recursiveSum</code> method checks if the array is null. For <code>[1, 2, 3, 4, 5]</code>, it calls <code>recursiveSumHelper</code> with index 0.</li>
<li><strong>Step 2</strong>: In <code>recursiveSumHelper</code>:
<ul>
<li>Index 0: <code>arr[0] = 1</code>, recurse with index 1.</li>
<li>Index 1: <code>arr[1] = 2</code>, recurse with index 2.</li>
<li>Index 2: <code>arr[2] = 3</code>, recurse with index 3.</li>
<li>Index 3: <code>arr[3] = 4</code>, recurse with index 4.</li>
<li>Index 4: <code>arr[4] = 5</code>, recurse with index 5.</li>
<li>Index 5: Base case, return 0.</li>
<li>Unwind: 5 + (4 + (3 + (2 + (1 + 0)))) = 15.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 4, 5]</code>, computes 1 + (2 + (3 + (4 + (5 + 0)))) = 15.</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativeSum</code> method checks if the array is null or empty. For <code>[1, 2, 3, 4, 5]</code>, it initializes <code>sum = 0</code>.</li>
<li><strong>Step 2</strong>: Iterates: adds 1, 2, 3, 4, 5, resulting in <code>sum = 15</code>.</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 4, 5]</code>, adds 1 + 2 + 3 + 4 + 5 = 15.</li>
</ul>
</li>
<li><strong>Performance Comparison</strong>: For large arrays (e.g., 10^5 elements), the iterative approach is generally faster due to O(1) space complexity, while the recursive approach uses O(n) stack space, potentially causing stack overflow for very large arrays.</li>
</ul>
<h2 id="complexity-analysis-table-31"><a class="header" href="#complexity-analysis-table-31">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n) for both approaches, as each element is processed exactly once.</li>
<li>Space complexity: O(n) for recursive due to the call stack; O(1) for iterative, using only a single sum variable.</li>
<li>Best, average, and worst cases are O(n) for both, as all elements are summed.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the iterative approach for large arrays to avoid stack overflow and reduce memory usage. Test both methods with large arrays (e.g., 10^4, 10^5 elements) to compare execution times and verify identical results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The recursive approach may cause stack overflow for very large arrays due to O(n) space complexity. Ensure inputs are within reasonable bounds (e.g., n ≤ 10^5) to prevent performance issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="reverse-string-comparison"><a class="header" href="#reverse-string-comparison">Reverse String Comparison</a></h1>
<h2 id="problem-statement-9"><a class="header" href="#problem-statement-9">Problem Statement</a></h2>
<p>Write a Java program that implements string reversal using both recursive and iterative approaches. The program should take a string as input and return the reversed string. Test the program with various strings, including empty strings, single-character strings, and long strings, and compare the code readability and execution time of both approaches. You can visualize this as rearranging the letters of a word on a signboard, either by recursively breaking it into smaller parts or by iteratively swapping characters from the ends toward the center.</p>
<p><strong>Input</strong>: A string (e.g., <code>str = "hello"</code>).
<strong>Output</strong>: A string representing the reversed input (e.g., <code>"olleh"</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The string length is between 0 and 10^5.</li>
<li>The string contains printable ASCII characters.</li>
<li>The string may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>str = "hello"</code></li>
<li>Output: <code>"olleh"</code></li>
<li>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code> by rearranging its characters.</li>
<li>Input: <code>str = ""</code></li>
<li>Output: <code>""</code></li>
<li>Explanation: An empty string remains empty after reversal.</li>
</ul>
<h2 id="pseudocode-9"><a class="header" href="#pseudocode-9">Pseudocode</a></h2>
<pre><code>FUNCTION recursiveReverse(str)
    IF str is null OR length of str &lt;= 1 THEN
        RETURN str
    ENDIF
    SET lastChar to character at index (length of str - 1)
    SET substring to str from index 0 to (length of str - 1)
    RETURN lastChar + recursiveReverse(substring)
ENDFUNCTION

FUNCTION iterativeReverse(str)
    IF str is null OR length of str &lt;= 1 THEN
        RETURN str
    ENDIF
    CONVERT str to array of characters
    SET left to 0
    SET right to length of array - 1
    WHILE left &lt; right
        SWAP characters at left and right
        INCREMENT left
        DECREMENT right
    ENDWHILE
    RETURN array converted to string
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-9"><a class="header" href="#algorithm-steps-9">Algorithm Steps</a></h2>
<ol>
<li>For the recursive approach:
a. Check if the input string is null, empty, or has one character. If so, return the string as is.
b. Define a recursive function that takes the input string as a parameter.
c. Extract the last character of the string and recursively call the function on the substring excluding the last character.
d. Combine the last character with the result of the recursive call to build the reversed string.
e. Return the reversed string.</li>
<li>For the iterative approach:
a. Check if the input string is null, empty, or has one character. If so, return the string as is.
b. Convert the string to a character array for in-place manipulation.
c. Initialize two pointers: <code>left</code> at the start (index 0) and <code>right</code> at the end (index length - 1).
d. While <code>left</code> is less than <code>right</code>, swap the characters at <code>left</code> and <code>right</code>, increment <code>left</code>, and decrement <code>right</code>.
e. Convert the character array back to a string and return it.</li>
<li>Test both methods with various inputs and measure execution time for large strings to compare performance.</li>
</ol>
<h2 id="java-implementation-32"><a class="header" href="#java-implementation-32">Java Implementation</a></h2>
<pre><code class="language-java">public class ReverseStringComparison {
    // Reverses a string using recursion
    public String recursiveReverse(String str) {
        // Check for null, empty, or single-character string
        if (str == null || str.length() &lt;= 1) {
            return str;
        }
        // Recursive case: last character + reverse of remaining string
        return str.charAt(str.length() - 1) + recursiveReverse(str.substring(0, str.length() - 1));
    }

    // Reverses a string using iteration
    public String iterativeReverse(String str) {
        // Check for null, empty, or single-character string
        if (str == null || str.length() &lt;= 1) {
            return str;
        }
        // Convert string to char array
        char[] charArray = str.toCharArray();
        int left = 0;
        int right = charArray.length - 1;
        // Swap characters from ends toward center
        while (left &lt; right) {
            char temp = charArray[left];
            charArray[left] = charArray[right];
            charArray[right] = temp;
            left++;
            right--;
        }
        // Convert char array back to string
        return new String(charArray);
    }
}
</code></pre>
<h2 id="output-9"><a class="header" href="#output-9">Output</a></h2>
<p>For the input string <code>"hello"</code>, both methods output:</p>
<pre><code>olleh
</code></pre>
<p>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code> by rearranging its characters.</p>
<p>For an empty string <code>""</code>, both methods output:</p>
<pre><code>""
</code></pre>
<p>Explanation: An empty string remains empty after reversal.</p>
<p>For a single-character string <code>"a"</code>, both methods output:</p>
<pre><code>a
</code></pre>
<p>Explanation: A single-character string is already reversed.</p>
<h2 id="how-it-works-33"><a class="header" href="#how-it-works-33">How It Works</a></h2>
<ul>
<li><strong>Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>recursiveReverse</code> method checks if the string is null, empty, or has one character. For <code>"hello"</code>, it proceeds to recursion.</li>
<li><strong>Step 2</strong>: Recursion:
<ul>
<li>For <code>"hello"</code>: Returns <code>'o'</code> + <code>recursiveReverse("hell")</code>.</li>
<li>For <code>"hell"</code>: Returns <code>'l'</code> + <code>recursiveReverse("hel")</code>.</li>
<li>For <code>"hel"</code>: Returns <code>'l'</code> + <code>recursiveReverse("he")</code>.</li>
<li>For <code>"he"</code>: Returns <code>'e'</code> + <code>recursiveReverse("h")</code>.</li>
<li>For <code>"h"</code>: Base case, returns <code>"h"</code>.</li>
<li>Unwind: <code>'h'</code> + <code>'e'</code> + <code>'l'</code> + <code>'l'</code> + <code>'o'</code> = <code>"olleh"</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>"hello"</code>, computes <code>'o'</code> + (<code>'l'</code> + (<code>'l'</code> + (<code>'e'</code> + <code>'h'</code>))) = <code>"olleh"</code>.</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativeReverse</code> method checks if the string is null, empty, or has one character. For <code>"hello"</code>, it converts to <code>['h', 'e', 'l', 'l', 'o']</code>.</li>
<li><strong>Step 2</strong>: Initializes <code>left = 0</code>, <code>right = 4</code>. Swaps:
<ul>
<li>Swap <code>h</code> and <code>o</code>: <code>['o', 'e', 'l', 'l', 'h']</code>, <code>left = 1</code>, <code>right = 3</code>.</li>
<li>Swap <code>e</code> and <code>l</code>: <code>['o', 'l', 'l', 'e', 'h']</code>, <code>left = 2</code>, <code>right = 2</code>.</li>
<li>Stop as <code>left &gt;= right</code>.</li>
</ul>
</li>
<li><strong>Step 3</strong>: Converts array to <code>"olleh"</code>.</li>
<li><strong>Example Trace</strong>: For <code>"hello"</code>, swaps characters from ends: <code>h</code> ↔ <code>o</code>, <code>e</code> ↔ <code>l</code>, resulting in <code>"olleh"</code>.</li>
</ul>
</li>
<li><strong>Comparison</strong>:
<ul>
<li><strong>Readability</strong>: Iterative is more straightforward, using simple swaps, while recursive is more abstract but elegant for small inputs.</li>
<li><strong>Execution Time</strong>: Iterative is faster for large strings due to O(1) space complexity, while recursive uses O(n) space and creates substrings, increasing overhead.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-32"><a class="header" href="#complexity-analysis-table-32">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n) for both, as recursive processes each character once, and iterative performs n/2 swaps.</li>
<li>Space complexity: O(n) for recursive due to call stack and substring creation; O(n) for iterative due to the character array (though in-place swapping reduces overhead in practice).</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the iterative approach for large strings to avoid stack overflow and reduce memory usage due to substring creation in recursion. Test both methods with long strings (e.g., 10^4 characters) to compare execution times and assess readability.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The recursive approach may cause stack overflow for very large strings due to O(n) space complexity from the call stack and substring operations. Ensure inputs are within reasonable bounds to prevent performance issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="factorial-conversion"><a class="header" href="#factorial-conversion">Factorial Conversion</a></h1>
<h2 id="problem-statement-10"><a class="header" href="#problem-statement-10">Problem Statement</a></h2>
<p>Write a Java program that implements a tail-recursive method to compute the factorial of a non-negative integer (n) using an accumulator to track the running product, and convert this tail-recursive implementation to an iterative version. The program should return the factorial of (n) and test both methods with various inputs, including large values, while measuring stack usage by catching <code>StackOverflowError</code> for recursive calls. You can visualize this as calculating the number of ways to arrange (n) books on a shelf, either by recursively multiplying and passing the product forward or by iteratively accumulating the product.</p>
<p><strong>Input</strong>: A non-negative integer (n) (e.g., (n = 5)).
<strong>Output</strong>: A long integer representing the factorial of (n) (e.g., 120 for (n = 5)).
<strong>Constraints</strong>:</p>
<ul>
<li>(0 \leq n \leq 20) (to avoid overflow with <code>long</code>).</li>
<li>The input is a non-negative integer.
<strong>Example</strong>:</li>
<li>Input: (n = 5)</li>
<li>Output: 120</li>
<li>Explanation: The factorial of 5 is (5 * 4 * 3 * 2 * 1 = 120).</li>
<li>Input: (n = 0)</li>
<li>Output: 1</li>
<li>Explanation: The factorial of 0 is defined as 1.</li>
</ul>
<h2 id="pseudocode-10"><a class="header" href="#pseudocode-10">Pseudocode</a></h2>
<pre><code>FUNCTION tailRecursiveFactorial(n, accumulator)
    IF n &lt; 0 THEN
        RETURN -1
    ENDIF
    IF n equals 0 THEN
        RETURN accumulator
    ENDIF
    SET newAccumulator to accumulator * n
    RETURN tailRecursiveFactorial(n - 1, newAccumulator)
ENDFUNCTION

FUNCTION iterativeFactorial(n)
    IF n &lt; 0 THEN
        RETURN -1
    ENDIF
    IF n equals 0 THEN
        RETURN 1
    ENDIF
    SET result to 1
    FOR i from 1 to n
        SET result to result * i
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION mainFactorial(n)
    TRY
        CALL tailRecursiveFactorial(n, 1)
    CATCH StackOverflowError
        PRINT "Stack overflow occurred"
    ENDTRY
    CALL iterativeFactorial(n)
    RETURN results
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-10"><a class="header" href="#algorithm-steps-10">Algorithm Steps</a></h2>
<ol>
<li>For the tail-recursive approach:
a. Check if (n) is negative. If so, return -1, as factorial is undefined for negative numbers.
b. Define a tail-recursive helper function that takes (n) and an accumulator as parameters.
c. Implement the base case: if (n = 0), return the accumulator.
d. For the recursive case, multiply the accumulator by (n) and recursively call the function with (n - 1) and the updated accumulator.
e. Call the helper function with the initial accumulator set to 1.</li>
<li>For the iterative approach:
a. Check if (n) is negative. If so, return -1.
b. Check if (n = 0). If so, return 1.
c. Initialize a variable <code>result</code> to 1.
d. Iterate from 1 to (n), multiplying <code>result</code> by each integer.
e. Return the final <code>result</code>.</li>
<li>Test both methods with various inputs, including large values (e.g., (n = 20)), and wrap the tail-recursive call in a try-catch block to detect <code>StackOverflowError</code>.</li>
<li>Measure stack usage by observing whether <code>StackOverflowError</code> occurs for large inputs in the recursive method.</li>
</ol>
<h2 id="java-implementation-33"><a class="header" href="#java-implementation-33">Java Implementation</a></h2>
<pre><code class="language-java">public class FactorialConversion {
    // Computes factorial using tail recursion
    public long tailRecursiveFactorial(int n) {
        // Check for invalid input
        if (n &lt; 0) {
            return -1;
        }
        // Call tail-recursive helper with initial accumulator
        try {
            return tailRecursiveFactorialHelper(n, 1);
        } catch (StackOverflowError e) {
            System.out.println("Stack overflow occurred for n = " + n);
            return -1;
        }
    }

    // Helper function for tail-recursive factorial
    private long tailRecursiveFactorialHelper(int n, long accumulator) {
        // Base case: n = 0 returns accumulator
        if (n == 0) {
            return accumulator;
        }
        // Recursive case: multiply accumulator by n and recurse
        return tailRecursiveFactorialHelper(n - 1, accumulator * n);
    }

    // Computes factorial using iteration
    public long iterativeFactorial(int n) {
        // Check for invalid input
        if (n &lt; 0) {
            return -1;
        }
        // Base case: 0! = 1
        if (n == 0) {
            return 1;
        }
        // Initialize result
        long result = 1;
        // Multiply numbers from 1 to n
        for (int i = 1; i &lt;= n; i++) {
            result *= i;
        }
        // Return final result
        return result;
    }
}
</code></pre>
<h2 id="output-10"><a class="header" href="#output-10">Output</a></h2>
<p>For the input (n = 5), both methods output:</p>
<pre><code>120
</code></pre>
<p>Explanation: The factorial of 5 is (5 * 4 * 3 * 2 * 1 = 120).</p>
<p>For the input (n = 0), both methods output:</p>
<pre><code>1
</code></pre>
<p>Explanation: The factorial of 0 is defined as 1.</p>
<p>For a large input (n = 20), both methods output:</p>
<pre><code>2432902008176640000
</code></pre>
<p>Explanation: The factorial of 20 is computed correctly within the <code>long</code> range.</p>
<p>For a very large input (e.g., (n = 10000)), the tail-recursive method may output:</p>
<pre><code>Stack overflow occurred for n = 10000
-1
</code></pre>
<p>Explanation: Java’s lack of tail-call optimization causes a stack overflow, while the iterative method may overflow the <code>long</code> data type but avoids stack issues.</p>
<h2 id="how-it-works-34"><a class="header" href="#how-it-works-34">How It Works</a></h2>
<ul>
<li><strong>Tail-Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>tailRecursiveFactorial</code> method checks if (n &lt; 0). For (n = 5), it calls the helper with <code>accumulator = 1</code>.</li>
<li><strong>Step 2</strong>: In <code>tailRecursiveFactorialHelper</code>:
<ul>
<li>For (n = 5): <code>accumulator = 1 * 5 = 5</code>, recurse with (n = 4, accumulator = 5).</li>
<li>For (n = 4): <code>accumulator = 5 * 4 = 20</code>, recurse with (n = 3, accumulator = 20).</li>
<li>For (n = 3): <code>accumulator = 20 * 3 = 60</code>, recurse with (n = 2, accumulator = 60).</li>
<li>For (n = 2): <code>accumulator = 60 * 2 = 120</code>, recurse with (n = 1, accumulator = 120).</li>
<li>For (n = 1): <code>accumulator = 120 * 1 = 120</code>, recurse with (n = 0, accumulator = 120).</li>
<li>For (n = 0): Base case, return <code>accumulator = 120</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (n = 5), the accumulator builds: (1 \rightarrow 5 \rightarrow 20 \rightarrow 60 \rightarrow 120), returning 120.</li>
<li><strong>Stack Usage</strong>: The function is tail-recursive, but Java does not optimize tail recursion, so each call adds a stack frame, leading to O(n) stack usage and potential <code>StackOverflowError</code> for large (n).</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativeFactorial</code> method checks if (n &lt; 0) or (n = 0). For (n = 5), it initializes <code>result = 1</code>.</li>
<li><strong>Step 2</strong>: Iterates from 1 to 5:
<ul>
<li>(i = 1): <code>result = 1 * 1 = 1</code>.</li>
<li>(i = 2): <code>result = 1 * 2 = 2</code>.</li>
<li>(i = 3): <code>result = 2 * 3 = 6</code>.</li>
<li>(i = 4): <code>result = 6 * 4 = 24</code>.</li>
<li>(i = 5): <code>result = 24 * 5 = 120</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (n = 5), multiplies (1 * 2 * 3 * 4 * 5 = 120).</li>
<li><strong>Stack Usage</strong>: The iterative approach uses O(1) stack space, as it avoids recursive calls, making it immune to <code>StackOverflowError</code>.</li>
</ul>
</li>
<li><strong>Comparison</strong>: Both methods are O(n) time, but iterative is more space-efficient (O(1) vs. O(n)). For large inputs, the tail-recursive method may throw <code>StackOverflowError</code>, while the iterative method is limited only by <code>long</code> overflow.</li>
</ul>
<h2 id="complexity-analysis-table-33"><a class="header" href="#complexity-analysis-table-33">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call (Tail)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Tail-Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the input integer.</li>
<li>Time complexity: O(n) for both, as tail-recursive makes n calls, and iterative performs n multiplications.</li>
<li>Space complexity: O(n) for tail-recursive due to the call stack (Java does not optimize tail recursion); O(1) for iterative, using only a single variable.</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Convert tail-recursive functions to iterative versions to eliminate stack overflow risks in Java. Test with large inputs (e.g., (n = 1000)) to observe stack overflow in the recursive version and verify correctness in the iterative version.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Java does not optimize tail recursion, so the O(n) space complexity may cause <code>StackOverflowError</code> for large inputs. Be cautious with inputs larger than 20, as factorial results may exceed the <code>long</code> data type’s capacity, causing overflow.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="reverse-string-tail-recursion"><a class="header" href="#reverse-string-tail-recursion">Reverse String Tail Recursion</a></h1>
<h2 id="problem-statement-11"><a class="header" href="#problem-statement-11">Problem Statement</a></h2>
<p>Write a Java program that implements a tail-recursive method to reverse a string using an accumulator to build the result. The program should take a string as input and return the reversed string. Test the method with various strings, including empty strings, single-character strings, and long strings, and discuss Java’s stack usage for the tail-recursive approach. You can visualize this as rearranging the letters of a word on a signboard, building the reversed word step-by-step by passing the accumulated result to the next recursive call.</p>
<p><strong>Input</strong>: A string (e.g., <code>str = "hello"</code>).
<strong>Output</strong>: A string representing the reversed input (e.g., <code>"olleh"</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The string length is between 0 and 10^5.</li>
<li>The string contains printable ASCII characters.</li>
<li>The string may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>str = "hello"</code></li>
<li>Output: <code>"olleh"</code></li>
<li>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code> by rearranging its characters.</li>
<li>Input: <code>str = ""</code></li>
<li>Output: <code>""</code></li>
<li>Explanation: An empty string remains empty after reversal.</li>
</ul>
<h2 id="pseudocode-11"><a class="header" href="#pseudocode-11">Pseudocode</a></h2>
<pre><code>FUNCTION tailRecursiveReverse(str, index, accumulator)
    IF str is null OR index &lt; 0 THEN
        RETURN accumulator
    ENDIF
    SET newAccumulator to character at index in str + accumulator
    RETURN tailRecursiveReverse(str, index - 1, newAccumulator)
ENDFUNCTION

FUNCTION mainReverse(str)
    IF str is null OR length of str equals 0 THEN
        RETURN str
    ENDIF
    RETURN tailRecursiveReverse(str, length of str - 1, "")
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-11"><a class="header" href="#algorithm-steps-11">Algorithm Steps</a></h2>
<ol>
<li>Check if the input string is null or empty. If so, return the string as is.</li>
<li>Define a tail-recursive helper function that takes the string, the current index, and an accumulator as parameters.</li>
<li>In the helper function, implement the base case: if the index is less than 0, return the accumulator.</li>
<li>For the recursive case, prepend the character at the current index to the accumulator and recursively call the function with the previous index and the updated accumulator.</li>
<li>In the main function, call the tail-recursive function with the initial index set to the last index of the string (length - 1) and an empty string as the accumulator.</li>
<li>Return the reversed string computed by the tail-recursive function.</li>
</ol>
<h2 id="java-implementation-34"><a class="header" href="#java-implementation-34">Java Implementation</a></h2>
<pre><code class="language-java">public class ReverseStringTailRecursion {
    // Reverses a string using tail recursion
    public String reverse(String str) {
        // Check for null or empty string
        if (str == null || str.length() == 0) {
            return str;
        }
        // Call tail-recursive helper with initial index and accumulator
        return tailRecursiveReverse(str, str.length() - 1, "");
    }

    // Helper function for tail-recursive string reversal
    private String tailRecursiveReverse(String str, int index, String accumulator) {
        // Base case: if index &lt; 0, return accumulator
        if (index &lt; 0) {
            return accumulator;
        }
        // Recursive case: prepend current character to accumulator and recurse
        return tailRecursiveReverse(str, index - 1, str.charAt(index) + accumulator);
    }
}
</code></pre>
<h2 id="output-11"><a class="header" href="#output-11">Output</a></h2>
<p>For the input string <code>"hello"</code>, the program outputs:</p>
<pre><code>olleh
</code></pre>
<p>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code> by building the result in the accumulator.</p>
<p>For an empty string <code>""</code>, the program outputs:</p>
<pre><code>""
</code></pre>
<p>Explanation: An empty string remains empty after reversal.</p>
<p>For a single-character string <code>"a"</code>, the program outputs:</p>
<pre><code>a
</code></pre>
<p>Explanation: A single-character string is already reversed.</p>
<h2 id="how-it-works-35"><a class="header" href="#how-it-works-35">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>reverse</code> method checks if the string is null or empty. For <code>"hello"</code>, it calls <code>tailRecursiveReverse</code> with <code>index = 4</code> and <code>accumulator = ""</code>.</li>
<li><strong>Step 2</strong>: In <code>tailRecursiveReverse</code>:
<ul>
<li>Index 4: <code>accumulator = 'o' + "" = "o"</code>, recurse with <code>index = 3</code>, <code>accumulator = "o"</code>.</li>
<li>Index 3: <code>accumulator = 'l' + "o" = "lo"</code>, recurse with <code>index = 2</code>, <code>accumulator = "lo"</code>.</li>
<li>Index 2: <code>accumulator = 'l' + "lo" = "llo"</code>, recurse with <code>index = 1</code>, <code>accumulator = "llo"</code>.</li>
<li>Index 1: <code>accumulator = 'e' + "llo" = "ello"</code>, recurse with <code>index = 0</code>, <code>accumulator = "ello"</code>.</li>
<li>Index 0: <code>accumulator = 'h' + "ello" = "hello"</code>, recurse with <code>index = -1</code>, <code>accumulator = "hello"</code>.</li>
<li>Index -1: Base case, return <code>accumulator = "hello"</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>"hello"</code>, the accumulator builds: <code>"" → "o" → "lo" → "llo" → "ello" → "hello"</code>, returning <code>"olleh"</code>.</li>
<li><strong>Java Stack Usage</strong>: The function is tail-recursive because the recursive call is the last operation. However, Java does not optimize tail recursion, so each recursive call adds a frame to the call stack, leading to O(n) space complexity. This can cause stack overflow for very large strings (e.g., 10^5 characters). An iterative approach would use O(1) space (excluding the output string).</li>
</ul>
<h2 id="complexity-analysis-table-34"><a class="header" href="#complexity-analysis-table-34">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call (Tail)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n), as the function processes each character exactly once.</li>
<li>Space complexity: O(n) due to the recursive call stack (Java does not optimize tail recursion) and the accumulator string, which grows with each call.</li>
<li>Best, average, and worst cases are O(n).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use tail recursion to write elegant recursive solutions for problems like string reversal, but consider iterative methods for better space efficiency in Java. Test with long strings (e.g., 10^4 characters) and edge cases like empty or single-character strings to verify correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Java does not optimize tail recursion, so the O(n) space complexity may cause stack overflow for very large strings. Additionally, string concatenation in the accumulator can be inefficient; consider using <code>StringBuilder</code> in an iterative approach for better performance.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="tail-recursive-list-length"><a class="header" href="#tail-recursive-list-length">Tail-Recursive List Length</a></h1>
<h2 id="problem-statement-12"><a class="header" href="#problem-statement-12">Problem Statement</a></h2>
<p>Write a Java program that computes the length of a singly linked list using a tail-recursive method with an accumulator to track the count of nodes. The program should also implement an iterative method to compute the length for comparison. Test both approaches with lists of varying sizes, including empty lists and single-node lists, and compare their readability and performance. You can visualize this as counting the number of links in a chain, either by recursively passing the count to the next link (tail-recursive) or by iteratively stepping through each link (iterative).</p>
<p><strong>Input</strong>: A singly linked list with integer nodes (e.g., <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>).
<strong>Output</strong>: An integer representing the number of nodes in the list (e.g., 3 for <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The list contains 0 to 10^5 nodes.</li>
<li>Node values are integers between -10^9 and 10^9.</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: Linked list <code>1 -&gt; 2 -&gt; 3 -&gt; null</code></li>
<li>Output: 3</li>
<li>Explanation: The list has 3 nodes.</li>
<li>Input: Empty linked list <code>null</code></li>
<li>Output: 0</li>
<li>Explanation: An empty list has no nodes.</li>
</ul>
<h2 id="pseudocode-12"><a class="header" href="#pseudocode-12">Pseudocode</a></h2>
<pre><code>FUNCTION tailRecursiveLength(node, accumulator)
    IF node is null THEN
        RETURN accumulator
    ENDIF
    SET newAccumulator to accumulator + 1
    RETURN tailRecursiveLength(node.next, newAccumulator)
ENDFUNCTION

FUNCTION iterativeLength(node)
    SET count to 0
    SET current to node
    WHILE current is not null
        INCREMENT count
        SET current to current.next
    ENDWHILE
    RETURN count
ENDFUNCTION

FUNCTION mainLength(head)
    CALL tailRecursiveLength(head, 0)
    CALL iterativeLength(head)
    RETURN results
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-12"><a class="header" href="#algorithm-steps-12">Algorithm Steps</a></h2>
<ol>
<li>For the tail-recursive approach:
a. Define a tail-recursive helper function that takes the current node and an accumulator as parameters.
b. Implement the base case: if the node is null, return the accumulator.
c. For the recursive case, increment the accumulator by 1 and recursively call the function with the next node and the updated accumulator.
d. Call the helper function with the head node and an initial accumulator of 0.</li>
<li>For the iterative approach:
a. Initialize a counter to 0 and a pointer <code>current</code> to the head of the list.
b. While <code>current</code> is not null, increment the counter and move <code>current</code> to the next node.
c. Return the counter as the list length.</li>
<li>In the main function, call both the tail-recursive and iterative methods to compute the list length.</li>
<li>Compare readability (recursive is more concise but abstract; iterative is more explicit) and performance (iterative is more space-efficient).</li>
</ol>
<h2 id="java-implementation-35"><a class="header" href="#java-implementation-35">Java Implementation</a></h2>
<pre><code class="language-java">public class TailRecursiveListLength {
    // Node class for singly linked list
    class Node {
        int data;
        Node next;
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // Computes list length using tail recursion
    public int tailRecursiveLength(Node head) {
        // Call tail-recursive helper with initial accumulator
        return tailRecursiveLengthHelper(head, 0);
    }

    // Helper function for tail-recursive length
    private int tailRecursiveLengthHelper(Node node, int accumulator) {
        // Base case: if node is null, return accumulator
        if (node == null) {
            return accumulator;
        }
        // Recursive case: increment accumulator and recurse
        return tailRecursiveLengthHelper(node.next, accumulator + 1);
    }

    // Computes list length using iteration
    public int iterativeLength(Node head) {
        // Initialize counter and current pointer
        int count = 0;
        Node current = head;
        // Iterate until null
        while (current != null) {
            count++;
            current = current.next;
        }
        // Return final count
        return count;
    }
}
</code></pre>
<h2 id="output-12"><a class="header" href="#output-12">Output</a></h2>
<p>For the input linked list <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, both methods output:</p>
<pre><code>3
</code></pre>
<p>Explanation: The list has 3 nodes.</p>
<p>For an empty linked list <code>null</code>, both methods output:</p>
<pre><code>0
</code></pre>
<p>Explanation: An empty list has no nodes.</p>
<p>For a single-node linked list <code>4 -&gt; null</code>, both methods output:</p>
<pre><code>1
</code></pre>
<p>Explanation: The list has 1 node.</p>
<h2 id="how-it-works-36"><a class="header" href="#how-it-works-36">How It Works</a></h2>
<ul>
<li><strong>Tail-Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>tailRecursiveLength</code> method calls the helper with <code>head</code> and <code>accumulator = 0</code>.</li>
<li><strong>Step 2</strong>: In <code>tailRecursiveLengthHelper</code>:
<ul>
<li>For node <code>1</code>: <code>accumulator = 0 + 1 = 1</code>, recurse with <code>node = 2</code>, <code>accumulator = 1</code>.</li>
<li>For node <code>2</code>: <code>accumulator = 1 + 1 = 2</code>, recurse with <code>node = 3</code>, <code>accumulator = 2</code>.</li>
<li>For node <code>3</code>: <code>accumulator = 2 + 1 = 3</code>, recurse with <code>node = null</code>, <code>accumulator = 3</code>.</li>
<li>For <code>null</code>: Base case, return <code>accumulator = 3</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, the accumulator builds: 0 → 1 → 2 → 3, returning 3.</li>
<li><strong>Tail Recursion Note</strong>: The function is tail-recursive because the recursive call is the last operation, though Java does not optimize tail recursion.</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativeLength</code> method initializes <code>count = 0</code>, <code>current = head</code>.</li>
<li><strong>Step 2</strong>: Iterates:
<ul>
<li><code>current = 1</code>: <code>count = 1</code>, move to <code>2</code>.</li>
<li><code>current = 2</code>: <code>count = 2</code>, move to <code>3</code>.</li>
<li><code>current = 3</code>: <code>count = 3</code>, move to <code>null</code>.</li>
<li><code>current = null</code>: Return <code>count = 3</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>1 -&gt; 2 -&gt; 3 -&gt; null</code>, counts nodes: 1 → 2 → 3, returning 3.</li>
</ul>
</li>
<li><strong>Comparison</strong>:
<ul>
<li><strong>Readability</strong>: Tail-recursive is concise and elegant but may be less intuitive for beginners; iterative is straightforward and explicit.</li>
<li><strong>Performance</strong>: Both are O(n) time, but iterative uses O(1) space, while tail-recursive uses O(n) space due to the call stack in Java.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-35"><a class="header" href="#complexity-analysis-table-35">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call (Tail)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Tail-Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the linked list.</li>
<li>Time complexity: O(n) for both, as each node is visited exactly once.</li>
<li>Space complexity: O(n) for tail-recursive due to the call stack (Java does not optimize tail recursion); O(1) for iterative, using only a counter and pointer.</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use tail recursion for elegant solutions to problems like list length, but prefer the iterative approach for large lists to save memory. Test with empty lists and long lists (e.g., 10^4 nodes) to compare performance and readability.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Java does not optimize tail recursion, so the O(n) space complexity may cause stack overflow for very large lists. Ensure the list is properly constructed to avoid null pointer exceptions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="tail-recursive-power"><a class="header" href="#tail-recursive-power">Tail-Recursive Power</a></h1>
<h2 id="problem-statement-13"><a class="header" href="#problem-statement-13">Problem Statement</a></h2>
<p>Write a Java program that implements a tail-recursive method to compute (x^n) (x raised to the power n) using an accumulator to track the running product. The program should also include an iterative method for comparison. Test both methods with various inputs, including edge cases like (n = 0) and (n = 1), and compare their performance and readability. You can visualize this as calculating the total growth of an investment ((x)) compounded (n) times, either by iteratively multiplying or by recursively passing the accumulated product to the next step.</p>
<p><strong>Input</strong>: A double (x) and a non-negative integer (n) (e.g., (x = 2.0, n = 3)).
<strong>Output</strong>: A double representing (x^n) (e.g., 8.0 for (2.0^3)).
<strong>Constraints</strong>:</p>
<ul>
<li>(-100.0 \leq x \leq 100.0).</li>
<li>(0 \leq n \leq 10^3).</li>
<li>The result should fit within a double’s precision.
<strong>Example</strong>:</li>
<li>Input: (x = 2.0, n = 3)</li>
<li>Output: 8.0</li>
<li>Explanation: (2.0^3 = 2.0 * 2.0 * 2.0 = 8.0).</li>
<li>Input: (x = 5.0, n = 0)</li>
<li>Output: 1.0</li>
<li>Explanation: Any non-zero number raised to the power 0 is 1.</li>
</ul>
<h2 id="pseudocode-13"><a class="header" href="#pseudocode-13">Pseudocode</a></h2>
<pre><code>FUNCTION tailRecursivePower(x, n, accumulator)
    IF n equals 0 THEN
        RETURN accumulator
    ENDIF
    SET newAccumulator to accumulator * x
    RETURN tailRecursivePower(x, n - 1, newAccumulator)
ENDFUNCTION

FUNCTION iterativePower(x, n)
    IF n equals 0 THEN
        RETURN 1.0
    ENDIF
    SET result to 1.0
    FOR i from 1 to n
        SET result to result * x
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION mainPower(x, n)
    CALL tailRecursivePower(x, n, 1.0)
    CALL iterativePower(x, n)
    RETURN results
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-13"><a class="header" href="#algorithm-steps-13">Algorithm Steps</a></h2>
<ol>
<li>For the tail-recursive approach:
a. Define a tail-recursive helper function that takes (x), (n), and an accumulator as parameters.
b. Implement the base case: if (n = 0), return the accumulator.
c. For the recursive case, multiply the accumulator by (x) and recursively call the function with (n - 1) and the updated accumulator.
d. Call the helper function with the initial accumulator set to 1.0.</li>
<li>For the iterative approach:
a. Check if (n = 0). If so, return 1.0.
b. Initialize a variable <code>result</code> to 1.0.
c. Iterate (n) times, multiplying <code>result</code> by (x) in each iteration.
d. Return the final <code>result</code>.</li>
<li>Test both methods with various inputs (e.g., (n = 0, 1, 5)) and compare performance and readability.</li>
</ol>
<h2 id="java-implementation-36"><a class="header" href="#java-implementation-36">Java Implementation</a></h2>
<pre><code class="language-java">public class TailRecursivePower {
    // Computes x^n using tail recursion
    public double tailRecursivePower(double x, int n) {
        // Call tail-recursive helper with initial accumulator
        return tailRecursivePowerHelper(x, n, 1.0);
    }

    // Helper function for tail-recursive power
    private double tailRecursivePowerHelper(double x, int n, double accumulator) {
        // Base case: x^0 = accumulator
        if (n == 0) {
            return accumulator;
        }
        // Recursive case: multiply accumulator by x and recurse
        return tailRecursivePowerHelper(x, n - 1, accumulator * x);
    }

    // Computes x^n using iteration
    public double iterativePower(double x, int n) {
        // Base case: x^0 = 1
        if (n == 0) {
            return 1.0;
        }
        // Initialize result
        double result = 1.0;
        // Multiply x by itself n times
        for (int i = 1; i &lt;= n; i++) {
            result *= x;
        }
        // Return final result
        return result;
    }
}
</code></pre>
<h2 id="output-13"><a class="header" href="#output-13">Output</a></h2>
<p>For the input (x = 2.0, n = 3), both methods output:</p>
<pre><code>8.0
</code></pre>
<p>Explanation: (2.0^3 = 2.0 * 2.0 * 2.0 = 8.0).</p>
<p>For the input (x = 5.0, n = 0), both methods output:</p>
<pre><code>1.0
</code></pre>
<p>Explanation: Any non-zero number raised to the power 0 is 1.</p>
<p>For the input (x = 3.0, n = 2), both methods output:</p>
<pre><code>9.0
</code></pre>
<p>Explanation: (3.0^2 = 3.0 * 3.0 = 9.0).</p>
<h2 id="how-it-works-37"><a class="header" href="#how-it-works-37">How It Works</a></h2>
<ul>
<li><strong>Tail-Recursive Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>tailRecursivePower</code> method calls the helper with (x = 2.0, n = 3, accumulator = 1.0).</li>
<li><strong>Step 2</strong>: In <code>tailRecursivePowerHelper</code>:
<ul>
<li>For (n = 3): <code>accumulator = 1.0 * 2.0 = 2.0</code>, recurse with (n = 2, accumulator = 2.0).</li>
<li>For (n = 2): <code>accumulator = 2.0 * 2.0 = 4.0</code>, recurse with (n = 1, accumulator = 4.0).</li>
<li>For (n = 1): <code>accumulator = 4.0 * 2.0 = 8.0</code>, recurse with (n = 0, accumulator = 8.0).</li>
<li>For (n = 0): Base case, return <code>accumulator = 8.0</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (x = 2.0, n = 3), the accumulator builds: (1.0 \rightarrow 2.0 \rightarrow 4.0 \rightarrow 8.0), returning 8.0.</li>
<li><strong>Tail Recursion Note</strong>: The function is tail-recursive because the recursive call is the last operation, though Java does not optimize tail recursion.</li>
</ul>
</li>
<li><strong>Iterative Approach</strong>:
<ul>
<li><strong>Step 1</strong>: The <code>iterativePower</code> method checks if (n = 0). For (x = 2.0, n = 3), it initializes <code>result = 1.0</code>.</li>
<li><strong>Step 2</strong>: Iterates 3 times:
<ul>
<li>Iteration 1: <code>result = 1.0 * 2.0 = 2.0</code>.</li>
<li>Iteration 2: <code>result = 2.0 * 2.0 = 4.0</code>.</li>
<li>Iteration 3: <code>result = 4.0 * 2.0 = 8.0</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For (x = 2.0, n = 3), multiplies (2.0 * 2.0 * 2.0 = 8.0).</li>
</ul>
</li>
<li><strong>Comparison</strong>:
<ul>
<li><strong>Readability</strong>: Tail-recursive is concise and intuitive for recursive thinking but abstract; iterative is straightforward and explicit.</li>
<li><strong>Performance</strong>: Both are O(n) time, but iterative uses O(1) space, while tail-recursive uses O(n) space due to the call stack in Java.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-36"><a class="header" href="#complexity-analysis-table-36">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call (Tail)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm (Tail-Recursive)</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm (Iterative)</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the exponent.</li>
<li>Time complexity: O(n) for both, as tail-recursive makes n calls, and iterative performs n multiplications.</li>
<li>Space complexity: O(n) for tail-recursive due to the call stack (Java does not optimize tail recursion); O(1) for iterative, using only a single variable.</li>
<li>Best, average, and worst cases are O(n) for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use tail recursion for elegant recursive solutions, but prefer the iterative approach for large (n) to minimize memory usage. Test with edge cases like (n = 0, 1) and large (n) (e.g., 1000) to verify correctness and compare performance.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Java does not optimize tail recursion, so the O(n) space complexity may cause stack overflow for very large (n). Be cautious with floating-point precision for large (x) or (n), as results may exceed double’s capacity.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="tail-recursive-sum"><a class="header" href="#tail-recursive-sum">Tail-Recursive Sum</a></h1>
<h2 id="problem-statement-14"><a class="header" href="#problem-statement-14">Problem Statement</a></h2>
<p>Write a Java program that computes the sum of all elements in an array of integers using a tail-recursive function with an accumulator to track the running sum. The program should return the total sum and test the function with arrays of different sizes, including empty arrays and single-element arrays. You can visualize this as tallying the total score of a series of games, where each game’s score is added to a running total, passing the updated total to the next step recursively until all scores are processed.</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [1, 2, 3, 4, 5]</code>).
<strong>Output</strong>: A long integer representing the sum of all elements in the array (e.g., 15 for <code>[1, 2, 3, 4, 5]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 2, 3, 4, 5]</code></li>
<li>Output: 15</li>
<li>Explanation: The sum is calculated as 1 + 2 + 3 + 4 + 5 = 15.</li>
<li>Input: <code>arr = []</code></li>
<li>Output: 0</li>
<li>Explanation: The sum of an empty array is 0.</li>
</ul>
<h2 id="pseudocode-14"><a class="header" href="#pseudocode-14">Pseudocode</a></h2>
<pre><code>FUNCTION tailRecursiveSum(arr, index, accumulator)
    IF arr is null OR index equals length of arr THEN
        RETURN accumulator
    ENDIF
    SET newAccumulator to accumulator + arr[index]
    RETURN tailRecursiveSum(arr, index + 1, newAccumulator)
ENDFUNCTION

FUNCTION mainSum(arr)
    IF arr is null THEN
        RETURN 0
    ENDIF
    RETURN tailRecursiveSum(arr, 0, 0)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-14"><a class="header" href="#algorithm-steps-14">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null. If so, return 0.</li>
<li>Define a tail-recursive helper function that takes the array, the current index, and an accumulator as parameters.</li>
<li>In the helper function, implement the base case: if the index equals the array length, return the accumulator.</li>
<li>For the recursive case, add the current element to the accumulator and recursively call the function with the next index and the updated accumulator.</li>
<li>In the main function, call the tail-recursive function with the initial index set to 0 and the accumulator set to 0.</li>
<li>Return the final sum computed by the tail-recursive function.</li>
</ol>
<h2 id="java-implementation-37"><a class="header" href="#java-implementation-37">Java Implementation</a></h2>
<pre><code class="language-java">public class TailRecursiveSum {
    // Computes sum of array elements using tail recursion
    public long sum(int[] arr) {
        // Check for null array
        if (arr == null) {
            return 0;
        }
        // Call tail-recursive helper with initial index and accumulator
        return tailRecursiveSum(arr, 0, 0);
    }

    // Helper function for tail-recursive sum
    private long tailRecursiveSum(int[] arr, int index, long accumulator) {
        // Base case: if index reaches array length, return accumulator
        if (index == arr.length) {
            return accumulator;
        }
        // Recursive case: update accumulator and recurse
        return tailRecursiveSum(arr, index + 1, accumulator + arr[index]);
    }
}
</code></pre>
<h2 id="output-14"><a class="header" href="#output-14">Output</a></h2>
<p>For the input array <code>[1, 2, 3, 4, 5]</code>, the program outputs:</p>
<pre><code>15
</code></pre>
<p>Explanation: The sum is computed as 1 + 2 + 3 + 4 + 5 = 15.</p>
<p>For an empty array <code>[]</code>, the program outputs:</p>
<pre><code>0
</code></pre>
<p>Explanation: The sum of an empty array is 0.</p>
<p>For a single-element array <code>[7]</code>, the program outputs:</p>
<pre><code>7
</code></pre>
<p>Explanation: The sum of a single-element array is the element itself.</p>
<h2 id="how-it-works-38"><a class="header" href="#how-it-works-38">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>sum</code> method checks if the array is null. For <code>[1, 2, 3, 4, 5]</code>, it calls <code>tailRecursiveSum</code> with <code>index = 0</code> and <code>accumulator = 0</code>.</li>
<li><strong>Step 2</strong>: In <code>tailRecursiveSum</code>:
<ul>
<li>Index 0: <code>accumulator = 0 + 1 = 1</code>, recurse with <code>index = 1</code>, <code>accumulator = 1</code>.</li>
<li>Index 1: <code>accumulator = 1 + 2 = 3</code>, recurse with <code>index = 2</code>, <code>accumulator = 3</code>.</li>
<li>Index 2: <code>accumulator = 3 + 3 = 6</code>, recurse with <code>index = 3</code>, <code>accumulator = 6</code>.</li>
<li>Index 3: <code>accumulator = 6 + 4 = 10</code>, recurse with <code>index = 4</code>, <code>accumulator = 10</code>.</li>
<li>Index 4: <code>accumulator = 10 + 5 = 15</code>, recurse with <code>index = 5</code>, <code>accumulator = 15</code>.</li>
<li>Index 5: Base case, return <code>accumulator = 15</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 4, 5]</code>, the accumulator builds: 0 → 1 → 3 → 6 → 10 → 15, returning 15.</li>
<li><strong>Tail Recursion Note</strong>: The function is tail-recursive because the recursive call is the last operation, allowing potential optimization in languages that support tail-call optimization (though Java does not natively optimize tail recursion).</li>
</ul>
<h2 id="complexity-analysis-table-37"><a class="header" href="#complexity-analysis-table-37">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Recursive Call</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n), as the function processes each element exactly once.</li>
<li>Space complexity: O(n) due to the recursive call stack, as Java does not optimize tail recursion.</li>
<li>Best, average, and worst cases are O(n), as all elements are processed.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use tail recursion with an accumulator to make recursive functions more intuitive by tracking state explicitly. Test with large arrays (e.g., 10^4 elements) and edge cases like empty or single-element arrays to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Java does not optimize tail recursion, so the O(n) space complexity may lead to stack overflow for very large arrays. Consider iterative solutions for better space efficiency in such cases.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="array-problem-solving-with-dsa"><a class="header" href="#array-problem-solving-with-dsa">Array Problem Solving with DSA</a></h2>
<h3 id="-what-you-will-learn-1"><a class="header" href="#-what-you-will-learn-1">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="array-reversal"><a class="header" href="#array-reversal">Array Reversal</a></h1>
<h2 id="problem-statement-15"><a class="header" href="#problem-statement-15">Problem Statement</a></h2>
<p>Write a Java program that reverses an array of integers in-place, meaning without using additional array storage beyond a few variables. The program should modify the input array such that the elements are arranged in reverse order and test the implementation with arrays of different sizes, including empty arrays and single-element arrays. You can visualize this as rearranging a row of numbered cards on a table by swapping pairs from the ends toward the center, without needing extra space to store a new row.</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [1, 2, 3, 4, 5]</code>).
<strong>Output</strong>: The same array modified in-place to contain the elements in reverse order (e.g., <code>[5, 4, 3, 2, 1]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 2, 3, 4, 5]</code></li>
<li>Output: <code>[5, 4, 3, 2, 1]</code></li>
<li>Explanation: The array is reversed in-place by swapping elements from the ends toward the center.</li>
<li>Input: <code>arr = []</code></li>
<li>Output: <code>[]</code></li>
<li>Explanation: An empty array remains unchanged.</li>
</ul>
<h2 id="pseudocode-15"><a class="header" href="#pseudocode-15">Pseudocode</a></h2>
<pre><code>FUNCTION reverseArray(arr)
    IF arr is null OR length of arr &lt;= 1 THEN
        RETURN
    ENDIF
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt; right
        SET temp to arr[left]
        SET arr[left] to arr[right]
        SET arr[right] to temp
        INCREMENT left
        DECREMENT right
    ENDWHILE
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-15"><a class="header" href="#algorithm-steps-15">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or has 0 or 1 element. If so, return, as no reversal is needed.</li>
<li>Initialize two pointers: <code>left</code> at the start of the array (index 0) and <code>right</code> at the end of the array (index length - 1).</li>
<li>While <code>left</code> is less than <code>right</code>:
a. Swap the elements at indices <code>left</code> and <code>right</code> using a temporary variable.
b. Increment <code>left</code> and decrement <code>right</code> to move the pointers inward.</li>
<li>Continue until <code>left</code> meets or exceeds <code>right</code>, at which point the array is fully reversed.</li>
<li>Test the method with arrays of different sizes to verify correctness.</li>
</ol>
<h2 id="java-implementation-38"><a class="header" href="#java-implementation-38">Java Implementation</a></h2>
<pre><code class="language-java">public class ArrayReversal {
    // Reverses an array in-place
    public void reverseArray(int[] arr) {
        // Check for null or single-element/empty array
        if (arr == null || arr.length &lt;= 1) {
            return;
        }
        // Initialize pointers
        int left = 0;
        int right = arr.length - 1;
        // Swap elements from ends toward center
        while (left &lt; right) {
            // Swap using temporary variable
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            // Move pointers
            left++;
            right--;
        }
    }
}
</code></pre>
<h2 id="output-15"><a class="header" href="#output-15">Output</a></h2>
<p>For the input array <code>[1, 2, 3, 4, 5]</code>, the program modifies it to:</p>
<pre><code>[5, 4, 3, 2, 1]
</code></pre>
<p>Explanation: The array is reversed in-place by swapping elements: (1 ↔ 5), (2 ↔ 4), leaving the middle element 3 in place.</p>
<p>For an empty array <code>[]</code>, the program outputs:</p>
<pre><code>[]
</code></pre>
<p>Explanation: An empty array remains unchanged.</p>
<p>For a single-element array <code>[7]</code>, the program outputs:</p>
<pre><code>[7]
</code></pre>
<p>Explanation: A single-element array is already reversed.</p>
<h2 id="how-it-works-39"><a class="header" href="#how-it-works-39">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>reverseArray</code> method checks if the array is null or has 0 or 1 element. For <code>[1, 2, 3, 4, 5]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Initialize <code>left = 0</code>, <code>right = 4</code>.</li>
<li><strong>Step 3</strong>: Iterate while <code>left &lt; right</code>:
<ul>
<li>First iteration: Swap <code>arr[0] = 1</code> and <code>arr[4] = 5</code>, resulting in <code>[5, 2, 3, 4, 1]</code>. Set <code>left = 1</code>, <code>right = 3</code>.</li>
<li>Second iteration: Swap <code>arr[1] = 2</code> and <code>arr[3] = 4</code>, resulting in <code>[5, 4, 3, 2, 1]</code>. Set <code>left = 2</code>, <code>right = 2</code>.</li>
<li>Stop: <code>left = 2 &gt;= right = 2</code>, so the loop ends.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 4, 5]</code>, swaps (1 ↔ 5), (2 ↔ 4), resulting in <code>[5, 4, 3, 2, 1]</code>.</li>
<li><strong>In-Place Property</strong>: The algorithm uses only a single temporary variable, ensuring O(1) extra space regardless of array size.</li>
</ul>
<h2 id="complexity-analysis-table-38"><a class="header" href="#complexity-analysis-table-38">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Swapping</td><td>O(n/2) = O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n), as the algorithm performs n/2 swaps, each taking constant time.</li>
<li>Space complexity: O(1), as only a single temporary variable is used for swapping.</li>
<li>Best, average, and worst cases are O(n), as all elements are processed up to the midpoint.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use two pointers to reverse arrays in-place for optimal space efficiency. Test with large arrays (e.g., 10^4 elements) and edge cases like empty or single-element arrays to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input array is not null to avoid <code>NullPointerException</code>. Be cautious with very large arrays, as accessing invalid indices could occur if pointers are mismanaged.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="array-rotation"><a class="header" href="#array-rotation">Array Rotation</a></h1>
<h2 id="problem-statement-16"><a class="header" href="#problem-statement-16">Problem Statement</a></h2>
<p>Write a Java program that rotates an array of integers by k positions to the left. The rotation should shift each element k positions left, with elements at the beginning wrapping around to the end of the array. The program should modify the array in-place and test the implementation with different values of k and array sizes, including edge cases like empty arrays, single-element arrays, and k larger than the array length. You can visualize this as rotating a circular table of numbered plates k positions counterclockwise, so the first k plates move to the end while the rest shift forward.</p>
<p><strong>Input</strong>: An array of integers and a non-negative integer k (e.g., <code>arr = [1, 2, 3, 4, 5], k = 2</code>).
<strong>Output</strong>: The array modified in-place to reflect the left rotation by k positions (e.g., <code>[3, 4, 5, 1, 2]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>k is a non-negative integer (0 ≤ k ≤ 10^9).</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 2, 3, 4, 5], k = 2</code></li>
<li>Output: <code>[3, 4, 5, 1, 2]</code></li>
<li>Explanation: Rotating [1, 2, 3, 4, 5] left by 2 positions moves 1 and 2 to the end.</li>
<li>Input: <code>arr = [1, 2, 3], k = 4</code></li>
<li>Output: <code>[3, 1, 2]</code></li>
<li>Explanation: Rotating by k = 4 is equivalent to k = 1 (since 4 % 3 = 1).</li>
</ul>
<h2 id="pseudocode-16"><a class="header" href="#pseudocode-16">Pseudocode</a></h2>
<pre><code>FUNCTION rotateArray(arr, k)
    IF arr is null OR length of arr &lt;= 1 THEN
        RETURN
    ENDIF
    SET n to length of arr
    SET k to k modulo n
    IF k equals 0 THEN
        RETURN
    ENDIF
    CALL reverseArray(arr, 0, k - 1)
    CALL reverseArray(arr, k, n - 1)
    CALL reverseArray(arr, 0, n - 1)
ENDFUNCTION

FUNCTION reverseArray(arr, start, end)
    WHILE start &lt; end
        SET temp to arr[start]
        SET arr[start] to arr[end]
        SET arr[end] to temp
        INCREMENT start
        DECREMENT end
    ENDWHILE
ENDFUNCTION

FUNCTION main()
    SET testCases to array of tuples (arr, k)
    FOR each (arr, k) in testCases
        CALL rotateArray(arr, k)
        PRINT arr
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-16"><a class="header" href="#algorithm-steps-16">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or has 0 or 1 element. If so, return, as no rotation is needed.</li>
<li>Compute the effective rotation value: <code>k = k % n</code>, where <code>n</code> is the array length, to handle cases where k exceeds n.</li>
<li>If k equals 0 after modulo, return, as no rotation is needed.</li>
<li>Use the reversal algorithm to rotate the array in-place:
a. Reverse the first k elements (indices 0 to k-1).
b. Reverse the remaining elements (indices k to n-1).
c. Reverse the entire array (indices 0 to n-1).</li>
<li>The <code>reverseArray</code> helper function swaps elements from <code>start</code> to <code>end</code> using a temporary variable.</li>
<li>In the <code>main</code> method, create test cases with different array sizes and k values, call <code>rotateArray</code>, and print the results.</li>
</ol>
<h2 id="java-implementation-39"><a class="header" href="#java-implementation-39">Java Implementation</a></h2>
<pre><code class="language-java">public class ArrayRotation {
    // Rotates array left by k positions in-place
    public void rotateArray(int[] arr, int k) {
        // Check for null or single-element/empty array
        if (arr == null || arr.length &lt;= 1) {
            return;
        }
        // Normalize k to handle cases where k &gt; array length
        int n = arr.length;
        k = k % n;
        if (k == 0) {
            return;
        }
        // Perform three reversals
        reverseArray(arr, 0, k - 1);
        reverseArray(arr, k, n - 1);
        reverseArray(arr, 0, n - 1);
    }

    // Helper function to reverse array segment from start to end
    private void reverseArray(int[] arr, int start, int end) {
        while (start &lt; end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }

    // Main method to test rotateArray with various inputs
    public static void main(String[] args) {
        ArrayRotation rotator = new ArrayRotation();

        // Test case 1: Normal array, k = 2
        int[] arr1 = {1, 2, 3, 4, 5};
        System.out.print("Test case 1 before: ");
        printArray(arr1);
        rotator.rotateArray(arr1, 2);
        System.out.print("Test case 1 after: ");
        printArray(arr1);

        // Test case 2: k &gt; array length
        int[] arr2 = {1, 2, 3};
        System.out.print("Test case 2 before: ");
        printArray(arr2);
        rotator.rotateArray(arr2, 4);
        System.out.print("Test case 2 after: ");
        printArray(arr2);

        // Test case 3: Empty array
        int[] arr3 = {};
        System.out.print("Test case 3 before: ");
        printArray(arr3);
        rotator.rotateArray(arr3, 3);
        System.out.print("Test case 3 after: ");
        printArray(arr3);

        // Test case 4: Single-element array
        int[] arr4 = {7};
        System.out.print("Test case 4 before: ");
        printArray(arr4);
        rotator.rotateArray(arr4, 2);
        System.out.print("Test case 4 after: ");
        printArray(arr4);

        // Test case 5: k = 0
        int[] arr5 = {1, 2, 3, 4};
        System.out.print("Test case 5 before: ");
        printArray(arr5);
        rotator.rotateArray(arr5, 0);
        System.out.print("Test case 5 after: ");
        printArray(arr5);
    }

    // Helper method to print array
    private static void printArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            System.out.println("[]");
            return;
        }
        System.out.print("[");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]);
            if (i &lt; arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-16"><a class="header" href="#output-16">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1 before: [1, 2, 3, 4, 5]
Test case 1 after: [3, 4, 5, 1, 2]
Test case 2 before: [1, 2, 3]
Test case 2 after: [3, 1, 2]
Test case 3 before: []
Test case 3 after: []
Test case 4 before: [7]
Test case 4 after: [7]
Test case 5 before: [1, 2, 3, 4]
Test case 5 after: [1, 2, 3, 4]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Rotates <code>[1, 2, 3, 4, 5]</code> left by 2, resulting in <code>[3, 4, 5, 1, 2]</code>.</li>
<li>Test case 2: Rotates <code>[1, 2, 3]</code> by k = 4, equivalent to k = 1 (4 % 3), resulting in <code>[3, 1, 2]</code>.</li>
<li>Test case 3: Empty array remains <code>[]</code>.</li>
<li>Test case 4: Single-element array <code>[7]</code> remains unchanged.</li>
<li>Test case 5: k = 0 leaves <code>[1, 2, 3, 4]</code> unchanged.</li>
</ul>
<h2 id="how-it-works-40"><a class="header" href="#how-it-works-40">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>rotateArray</code> method checks if the array is null or has 0 or 1 element. For <code>[1, 2, 3, 4, 5], k = 2</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Normalize k: <code>n = 5</code>, <code>k = 2 % 5 = 2</code>.</li>
<li><strong>Step 3</strong>: Perform three reversals:
<ul>
<li>Reverse indices 0 to 1: <code>[2, 1, 3, 4, 5]</code>.</li>
<li>Reverse indices 2 to 4: <code>[2, 1, 5, 4, 3]</code>.</li>
<li>Reverse entire array: <code>[3, 4, 5, 1, 2]</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 4, 5], k = 2</code>, reverses [1, 2] to [2, 1], [3, 4, 5] to [5, 4, 3], then [2, 1, 5, 4, 3] to [3, 4, 5, 1, 2].</li>
<li><strong>Main Method</strong>: Tests the method with various cases: normal rotation, k &gt; n, empty array, single-element array, and k = 0.</li>
<li><strong>In-Place Property</strong>: The algorithm uses O(1) extra space by performing swaps via the <code>reverseArray</code> helper.</li>
</ul>
<h2 id="complexity-analysis-table-39"><a class="header" href="#complexity-analysis-table-39">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Reverse</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n), as the algorithm performs three reversals, each taking O(n/2), O(n-k), and O(n) respectively, totaling O(n).</li>
<li>Space complexity: O(1), as only a few temporary variables are used for swapping.</li>
<li>Best, average, and worst cases are O(n).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Normalize k using modulo to handle large k values efficiently. Test with edge cases like k = 0, k &gt; n, and empty arrays to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input array is not null to avoid <code>NullPointerException</code>. Verify index bounds in the reverse function to prevent <code>ArrayIndexOutOfBoundsException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="array-sorting"><a class="header" href="#array-sorting">Array Sorting</a></h1>
<h2 id="problem-statement-17"><a class="header" href="#problem-statement-17">Problem Statement</a></h2>
<p>Write a Java program that implements the bubble sort algorithm to sort an array of integers in ascending order. The program should modify the input array in-place to arrange its elements from smallest to largest and test the implementation with various input arrays, including empty arrays, single-element arrays, and arrays with duplicate or negative numbers. You can visualize this as organizing a row of books on a shelf by repeatedly comparing and swapping adjacent books to ensure they are in order by size.</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [64, 34, 25, 12, 22]</code>).
<strong>Output</strong>: The array modified in-place to be sorted in ascending order (e.g., <code>[12, 22, 25, 34, 64]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [64, 34, 25, 12, 22]</code></li>
<li>Output: <code>[12, 22, 25, 34, 64]</code></li>
<li>Explanation: The array is sorted in ascending order using bubble sort.</li>
<li>Input: <code>arr = [1, 1, 1]</code></li>
<li>Output: <code>[1, 1, 1]</code></li>
<li>Explanation: The array with duplicate elements remains sorted.</li>
</ul>
<h2 id="pseudocode-17"><a class="header" href="#pseudocode-17">Pseudocode</a></h2>
<pre><code>FUNCTION bubbleSort(arr)
    IF arr is null OR length of arr &lt;= 1 THEN
        RETURN
    ENDIF
    SET n to length of arr
    FOR i from 0 to n - 1
        FOR j from 0 to n - i - 2
            IF arr[j] &gt; arr[j + 1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j + 1]
                SET arr[j + 1] to temp
            ENDIF
        ENDFOR
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testArrays to arrays of integers
    FOR each array in testArrays
        CALL bubbleSort(array)
        PRINT array
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-17"><a class="header" href="#algorithm-steps-17">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or has 0 or 1 element. If so, return, as no sorting is needed.</li>
<li>Initialize <code>n</code> as the length of the array.</li>
<li>For each index <code>i</code> from 0 to <code>n - 1</code>:
a. Iterate through indices <code>j</code> from 0 to <code>n - i - 2</code>.
b. If <code>arr[j] &gt; arr[j + 1]</code>, swap the elements at indices <code>j</code> and <code>j + 1</code> using a temporary variable.</li>
<li>Repeat until no more swaps are needed, indicating the array is sorted.</li>
<li>In the <code>main</code> method, create test arrays with various cases (e.g., unsorted, sorted, duplicates, negative numbers) and call <code>bubbleSort</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-40"><a class="header" href="#java-implementation-40">Java Implementation</a></h2>
<pre><code class="language-java">public class ArraySorting {
    // Sorts array in ascending order using bubble sort
    public void bubbleSort(int[] arr) {
        // Check for null or single-element/empty array
        if (arr == null || arr.length &lt;= 1) {
            return;
        }
        // Get array length
        int n = arr.length;
        // Outer loop for passes
        for (int i = 0; i &lt; n; i++) {
            // Inner loop for comparisons and swaps
            for (int j = 0; j &lt; n - i - 1; j++) {
                // Compare adjacent elements
                if (arr[j] &gt; arr[j + 1]) {
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    // Main method to test bubbleSort with various arrays
    public static void main(String[] args) {
        ArraySorting sorter = new ArraySorting();

        // Test case 1: Unsorted array
        int[] arr1 = {64, 34, 25, 12, 22};
        System.out.print("Test case 1 before: ");
        printArray(arr1);
        sorter.bubbleSort(arr1);
        System.out.print("Test case 1 after: ");
        printArray(arr1);

        // Test case 2: Already sorted array
        int[] arr2 = {1, 2, 3, 4, 5};
        System.out.print("Test case 2 before: ");
        printArray(arr2);
        sorter.bubbleSort(arr2);
        System.out.print("Test case 2 after: ");
        printArray(arr2);

        // Test case 3: Array with duplicates
        int[] arr3 = {3, 1, 3, 2, 1};
        System.out.print("Test case 3 before: ");
        printArray(arr3);
        sorter.bubbleSort(arr3);
        System.out.print("Test case 3 after: ");
        printArray(arr3);

        // Test case 4: Array with negative numbers
        int[] arr4 = {-5, 0, -2, 3, -1};
        System.out.print("Test case 4 before: ");
        printArray(arr4);
        sorter.bubbleSort(arr4);
        System.out.print("Test case 4 after: ");
        printArray(arr4);

        // Test case 5: Empty array
        int[] arr5 = {};
        System.out.print("Test case 5 before: ");
        printArray(arr5);
        sorter.bubbleSort(arr5);
        System.out.print("Test case 5 after: ");
        printArray(arr5);

        // Test case 6: Single-element array
        int[] arr6 = {42};
        System.out.print("Test case 6 before: ");
        printArray(arr6);
        sorter.bubbleSort(arr6);
        System.out.print("Test case 6 after: ");
        printArray(arr6);
    }

    // Helper method to print array
    private static void printArray(int[] arr) {
        if (arr == null || arr.length == 0) {
            System.out.println("[]");
            return;
        }
        System.out.print("[");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]);
            if (i &lt; arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-17"><a class="header" href="#output-17">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1 before: [64, 34, 25, 12, 22]
Test case 1 after: [12, 22, 25, 34, 64]
Test case 2 before: [1, 2, 3, 4, 5]
Test case 2 after: [1, 2, 3, 4, 5]
Test case 3 before: [3, 1, 3, 2, 1]
Test case 3 after: [1, 1, 2, 3, 3]
Test case 4 before: [-5, 0, -2, 3, -1]
Test case 4 after: [-5, -2, -1, 0, 3]
Test case 5 before: []
Test case 5 after: []
Test case 6 before: [42]
Test case 6 after: [42]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Sorts <code>[64, 34, 25, 12, 22]</code> to <code>[12, 22, 25, 34, 64]</code>.</li>
<li>Test case 2: Already sorted <code>[1, 2, 3, 4, 5]</code> remains unchanged.</li>
<li>Test case 3: Sorts <code>[3, 1, 3, 2, 1]</code> to <code>[1, 1, 2, 3, 3]</code>, handling duplicates.</li>
<li>Test case 4: Sorts <code>[-5, 0, -2, 3, -1]</code> to <code>[-5, -2, -1, 0, 3]</code>, handling negatives.</li>
<li>Test case 5: Empty array <code>[]</code> remains unchanged.</li>
<li>Test case 6: Single-element array <code>[42]</code> remains unchanged.</li>
</ul>
<h2 id="how-it-works-41"><a class="header" href="#how-it-works-41">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>bubbleSort</code> method checks if the array is null or has 0 or 1 element. For <code>[64, 34, 25, 12, 22]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: For <code>n = 5</code>, perform 5 passes:
<ul>
<li>Pass 1: Compare and swap adjacent elements: <code>[64, 34] → [34, 64]</code>, <code>[64, 25] → [25, 64]</code>, <code>[64, 12] → [12, 64]</code>, <code>[64, 22] → [22, 64]</code>. Result: <code>[34, 25, 12, 22, 64]</code>.</li>
<li>Pass 2: <code>[34, 25] → [25, 34]</code>, <code>[34, 12] → [12, 34]</code>, <code>[34, 22] → [22, 34]</code>. Result: <code>[25, 12, 22, 34, 64]</code>.</li>
<li>Pass 3: <code>[25, 12] → [12, 25]</code>, <code>[25, 22] → [22, 25]</code>. Result: <code>[12, 22, 25, 34, 64]</code>.</li>
<li>Pass 4: No swaps needed, array is sorted.</li>
<li>Pass 5: No swaps needed, done.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[64, 34, 25, 12, 22]</code>, sorts to <code>[12, 22, 25, 34, 64]</code> by bubbling larger elements to the end.</li>
<li><strong>Main Method</strong>: Tests the method with unsorted, sorted, duplicate, negative, empty, and single-element arrays, printing results.</li>
<li><strong>In-Place Property</strong>: Bubble sort modifies the array in-place, using only a temporary variable for swaps.</li>
</ul>
<h2 id="complexity-analysis-table-40"><a class="header" href="#complexity-analysis-table-40">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Sorting</td><td>O(n^2)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n^2)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n^2) in the worst and average cases, as the algorithm performs up to n passes, each with up to n-1 comparisons. Best case is O(n) when the array is already sorted (no swaps).</li>
<li>Space complexity: O(1), as only a temporary variable is used for swapping.</li>
<li>Worst case: O(n^2) for reverse-sorted arrays. Best case: O(n) for sorted arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Bubble sort is simple but inefficient for large arrays. Consider adding a flag to detect if no swaps occur in a pass to optimize for nearly sorted arrays. Test with various cases to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input array is not null to avoid <code>NullPointerException</code>. Be cautious with very large arrays, as O(n^2) time complexity can lead to slow performance.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="duplicate-finder"><a class="header" href="#duplicate-finder">Duplicate Finder</a></h1>
<h2 id="problem-statement-18"><a class="header" href="#problem-statement-18">Problem Statement</a></h2>
<p>Write a Java program that implements a method to check if an array of integers contains any duplicate elements. The method should return true if there are duplicates and false otherwise. Test the method with both sorted and unsorted arrays, including edge cases like empty arrays, single-element arrays, and arrays with multiple duplicates. You can visualize this as checking a list of student IDs to determine if any ID appears more than once, whether the list is sorted or unsorted.</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [1, 2, 3, 1]</code> or <code>arr = [1, 1, 2, 3]</code>).
<strong>Output</strong>: A boolean indicating whether the array contains duplicate elements (e.g., true for <code>[1, 2, 3, 1]</code>, false for <code>[1, 2, 3, 4]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 0 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array may be empty.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [1, 2, 3, 1]</code></li>
<li>Output: true</li>
<li>Explanation: The element 1 appears twice, so the array contains duplicates.</li>
<li>Input: <code>arr = [1, 2, 3, 4]</code></li>
<li>Output: false</li>
<li>Explanation: All elements are unique.</li>
</ul>
<h2 id="pseudocode-18"><a class="header" href="#pseudocode-18">Pseudocode</a></h2>
<pre><code>FUNCTION hasDuplicates(arr)
    IF arr is null OR length of arr &lt;= 1 THEN
        RETURN false
    ENDIF
    CREATE empty HashSet seen
    FOR each element in arr
        IF element exists in seen THEN
            RETURN true
        ELSE
            ADD element to seen
        ENDIF
    ENDFOR
    RETURN false
ENDFUNCTION

FUNCTION main()
    SET testArrays to arrays of integers
    FOR each array in testArrays
        CALL hasDuplicates(array)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-18"><a class="header" href="#algorithm-steps-18">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or has 0 or 1 element. If so, return false, as duplicates are not possible.</li>
<li>Create an empty HashSet to store seen elements.</li>
<li>Iterate through the array:
a. For each element, check if it exists in the HashSet.
b. If the element is in the HashSet, return true, as a duplicate has been found.
c. Otherwise, add the element to the HashSet.</li>
<li>If the loop completes without finding duplicates, return false.</li>
<li>In the <code>main</code> method, create test arrays (sorted and unsorted) with various cases and call the <code>hasDuplicates</code> method to verify correctness.</li>
</ol>
<h2 id="java-implementation-41"><a class="header" href="#java-implementation-41">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.HashSet;

public class DuplicateFinder {
    // Checks if array contains duplicate elements
    public boolean hasDuplicates(int[] arr) {
        // Check for null or single-element/empty array
        if (arr == null || arr.length &lt;= 1) {
            return false;
        }
        // Use HashSet to track seen elements
        HashSet&lt;Integer&gt; seen = new HashSet&lt;&gt;();
        // Iterate through array
        for (int num : arr) {
            // If element is already in set, duplicate found
            if (seen.contains(num)) {
                return true;
            }
            // Add element to set
            seen.add(num);
        }
        // No duplicates found
        return false;
    }

    // Main method to test hasDuplicates with various arrays
    public static void main(String[] args) {
        DuplicateFinder finder = new DuplicateFinder();

        // Test case 1: Unsorted array with duplicates
        int[] arr1 = {1, 2, 3, 1};
        System.out.println("Test case 1 (unsorted with duplicates): " + finder.hasDuplicates(arr1));

        // Test case 2: Sorted array with duplicates
        int[] arr2 = {1, 1, 2, 3};
        System.out.println("Test case 2 (sorted with duplicates): " + finder.hasDuplicates(arr2));

        // Test case 3: Unsorted array without duplicates
        int[] arr3 = {1, 2, 3, 4};
        System.out.println("Test case 3 (unsorted without duplicates): " + finder.hasDuplicates(arr3));

        // Test case 4: Empty array
        int[] arr4 = {};
        System.out.println("Test case 4 (empty): " + finder.hasDuplicates(arr4));

        // Test case 5: Single-element array
        int[] arr5 = {5};
        System.out.println("Test case 5 (single element): " + finder.hasDuplicates(arr5));

        // Test case 6: Array with negative numbers and duplicates
        int[] arr6 = {-1, 2, -1, 3};
        System.out.println("Test case 6 (negative numbers with duplicates): " + finder.hasDuplicates(arr6));
    }
}
</code></pre>
<h2 id="output-18"><a class="header" href="#output-18">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1 (unsorted with duplicates): true
Test case 2 (sorted with duplicates): true
Test case 3 (unsorted without duplicates): false
Test case 4 (empty): false
Test case 5 (single element): false
Test case 6 (negative numbers with duplicates): true
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>[1, 2, 3, 1]</code> returns true (duplicate 1).</li>
<li>Test case 2: <code>[1, 1, 2, 3]</code> returns true (duplicate 1).</li>
<li>Test case 3: <code>[1, 2, 3, 4]</code> returns false (no duplicates).</li>
<li>Test case 4: <code>[]</code> returns false (empty array).</li>
<li>Test case 5: <code>[5]</code> returns false (single element).</li>
<li>Test case 6: <code>[-1, 2, -1, 3]</code> returns true (duplicate -1).</li>
</ul>
<h2 id="how-it-works-42"><a class="header" href="#how-it-works-42">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>hasDuplicates</code> method checks if the array is null or has 0 or 1 element. For <code>[1, 2, 3, 1]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Initialize an empty HashSet <code>seen</code>.</li>
<li><strong>Step 3</strong>: Iterate through <code>[1, 2, 3, 1]</code>:
<ul>
<li>Element 1: Not in <code>seen</code>, add 1 to <code>seen</code>.</li>
<li>Element 2: Not in <code>seen</code>, add 2 to <code>seen</code>.</li>
<li>Element 3: Not in <code>seen</code>, add 3 to <code>seen</code>.</li>
<li>Element 1: In <code>seen</code>, return true.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[1, 2, 3, 1]</code>, <code>seen</code> grows: <code>{1} → {1, 2} → {1, 2, 3}</code>, then detects duplicate 1, returning true.</li>
<li><strong>Main Method</strong>: Tests the method with sorted and unsorted arrays, including duplicates, no duplicates, empty, single-element, and negative numbers.</li>
<li><strong>HashSet Efficiency</strong>: The HashSet provides O(1) average-time lookups and insertions, making the algorithm efficient for both sorted and unsorted arrays.</li>
</ul>
<h2 id="complexity-analysis-table-41"><a class="header" href="#complexity-analysis-table-41">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Iteration</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n), as the algorithm iterates through the array once, with O(1) average-time HashSet operations.</li>
<li>Space complexity: O(n), as the HashSet may store up to n elements in the worst case.</li>
<li>Best, average, and worst cases are O(n) for time; space depends on the number of unique elements.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a HashSet for efficient duplicate detection in both sorted and unsorted arrays. Test with edge cases like empty arrays, single-element arrays, and arrays with negative numbers to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input array is not null to avoid <code>NullPointerException</code>. Be mindful of memory usage for very large arrays, as the HashSet requires O(n) space.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="maximum-element"><a class="header" href="#maximum-element">Maximum Element</a></h1>
<h2 id="problem-statement-19"><a class="header" href="#problem-statement-19">Problem Statement</a></h2>
<p>Write a Java program that implements a method to find the maximum element in an array of integers. The program should return the largest element in the array and test the method with arrays containing positive and negative numbers, including edge cases like single-element arrays and arrays with duplicate maximum values. You can visualize this as searching through a list of exam scores to find the highest score, ensuring the method works whether the scores are positive, negative, or a mix of both.</p>
<p><strong>Input</strong>: An array of integers (e.g., <code>arr = [3, -1, 5, 2, -7]</code>).
<strong>Output</strong>: An integer representing the maximum element in the array (e.g., 5 for <code>[3, -1, 5, 2, -7]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The array length is between 1 and 10^5.</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The array is guaranteed to have at least one element.
<strong>Example</strong>:</li>
<li>Input: <code>arr = [3, -1, 5, 2, -7]</code></li>
<li>Output: 5</li>
<li>Explanation: The maximum element in the array is 5.</li>
<li>Input: <code>arr = [-2, -5, -1, -8]</code></li>
<li>Output: -1</li>
<li>Explanation: The maximum element in the array is -1.</li>
</ul>
<h2 id="pseudocode-19"><a class="header" href="#pseudocode-19">Pseudocode</a></h2>
<pre><code>FUNCTION findMax(arr)
    IF arr is null OR length of arr equals 0 THEN
        RETURN null
    ENDIF
    SET max to arr[0]
    FOR i from 1 to length of arr - 1
        IF arr[i] &gt; max THEN
            SET max to arr[i]
        ENDIF
    ENDFOR
    RETURN max
ENDFUNCTION

FUNCTION main()
    SET testArrays to arrays of integers
    FOR each array in testArrays
        CALL findMax(array)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-19"><a class="header" href="#algorithm-steps-19">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null or empty. If so, return null (or throw an exception, depending on requirements).</li>
<li>Initialize a variable <code>max</code> to the first element of the array.</li>
<li>Iterate through the array from index 1 to the last index.</li>
<li>For each element, compare it with <code>max</code>. If the element is greater than <code>max</code>, update <code>max</code> to the element’s value.</li>
<li>After the loop, return <code>max</code> as the maximum element.</li>
<li>In the <code>main</code> method, create test arrays with positive and negative numbers and call the <code>findMax</code> method to verify correctness.</li>
</ol>
<h2 id="java-implementation-42"><a class="header" href="#java-implementation-42">Java Implementation</a></h2>
<pre><code class="language-java">public class MaximumElement {
    // Finds the maximum element in an array
    public Integer findMax(int[] arr) {
        // Check for null or empty array
        if (arr == null || arr.length == 0) {
            return null;
        }
        // Initialize max to first element
        int max = arr[0];
        // Iterate through array to find maximum
        for (int i = 1; i &lt; arr.length; i++) {
            if (arr[i] &gt; max) {
                max = arr[i];
            }
        }
        return max;
    }

    // Main method to test findMax with various arrays
    public static void main(String[] args) {
        MaximumElement maxElement = new MaximumElement();
        
        // Test case 1: Mixed positive and negative numbers
        int[] arr1 = {3, -1, 5, 2, -7};
        System.out.println("Maximum element in arr1: " + maxElement.findMax(arr1));
        
        // Test case 2: All negative numbers
        int[] arr2 = {-2, -5, -1, -8};
        System.out.println("Maximum element in arr2: " + maxElement.findMax(arr2));
        
        // Test case 3: Single element
        int[] arr3 = {42};
        System.out.println("Maximum element in arr3: " + maxElement.findMax(arr3));
        
        // Test case 4: Duplicate maximum values
        int[] arr4 = {4, 4, 3, 4, 2};
        System.out.println("Maximum element in arr4: " + maxElement.findMax(arr4));
        
        // Test case 5: Null array
        int[] arr5 = null;
        System.out.println("Maximum element in arr5: " + maxElement.findMax(arr5));
    }
}
</code></pre>
<h2 id="output-19"><a class="header" href="#output-19">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Maximum element in arr1: 5
Maximum element in arr2: -1
Maximum element in arr3: 42
Maximum element in arr4: 4
Maximum element in arr5: null
</code></pre>
<p>Explanation:</p>
<ul>
<li>For <code>arr1 = [3, -1, 5, 2, -7]</code>, the maximum is 5.</li>
<li>For <code>arr2 = [-2, -5, -1, -8]</code>, the maximum is -1 (largest among negatives).</li>
<li>For <code>arr3 = [42]</code>, the maximum is 42 (single element).</li>
<li>For <code>arr4 = [4, 4, 3, 4, 2]</code>, the maximum is 4 (handles duplicates).</li>
<li>For <code>arr5 = null</code>, the method returns null.</li>
</ul>
<h2 id="how-it-works-43"><a class="header" href="#how-it-works-43">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>findMax</code> method checks if the array is null or empty. For <code>[3, -1, 5, 2, -7]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Initialize <code>max = arr[0] = 3</code>.</li>
<li><strong>Step 3</strong>: Iterate from index 1 to 4:
<ul>
<li>Index 1: <code>arr[1] = -1</code>, <code>-1 &lt; 3</code>, so <code>max</code> remains 3.</li>
<li>Index 2: <code>arr[2] = 5</code>, <code>5 &gt; 3</code>, so <code>max = 5</code>.</li>
<li>Index 3: <code>arr[3] = 2</code>, <code>2 &lt; 5</code>, so <code>max</code> remains 5.</li>
<li>Index 4: <code>arr[4] = -7</code>, <code>-7 &lt; 5</code>, so <code>max</code> remains 5.</li>
</ul>
</li>
<li><strong>Step 4</strong>: Return <code>max = 5</code>.</li>
<li><strong>Example Trace</strong>: For <code>[3, -1, 5, 2, -7]</code>, <code>max</code> updates: <code>3 → 5</code>, returning 5.</li>
<li><strong>Main Method</strong>: The <code>main</code> method tests the <code>findMax</code> method with various arrays, including mixed numbers, all negatives, single-element, duplicates, and null, printing the results.</li>
</ul>
<h2 id="complexity-analysis-table-42"><a class="header" href="#complexity-analysis-table-42">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Iteration</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the input array.</li>
<li>Time complexity: O(n), as the algorithm iterates through the array once, comparing each element.</li>
<li>Space complexity: O(1), as only a single variable (<code>max</code>) is used, regardless of array size.</li>
<li>Best, average, and worst cases are O(n), as all elements are processed.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Initialize the maximum to the first element to handle arrays with negative numbers efficiently. Test with edge cases like single-element arrays, all-negative arrays, and arrays with duplicates to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input array is not null or empty to avoid <code>NullPointerException</code> or unexpected behavior. For very large arrays, ensure elements are within the integer range to avoid overflow issues in comparisons.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="3d-array-summation"><a class="header" href="#3d-array-summation">3D Array Summation</a></h1>
<h2 id="problem-statement-20"><a class="header" href="#problem-statement-20">Problem Statement</a></h2>
<p>Write a Java program that initializes a 3D array of integers and computes the sum of all elements using nested loops. The program should return the total sum and test the implementation with 3D arrays of different dimensions, including edge cases like single-element arrays and arrays with varying sizes for each dimension. You can visualize this as calculating the total value of items stored in a 3D grid, such as boxes stacked in a warehouse with layers, rows, and columns, by adding up every item’s value.</p>
<p><strong>Input</strong>: A 3D array of integers with dimensions d × r × c (e.g., <code>array = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}</code>).
<strong>Output</strong>: A long integer representing the sum of all elements in the 3D array (e.g., 36 for the example above).
<strong>Constraints</strong>:</p>
<ul>
<li>1 ≤ d, r, c ≤ 100 (where d is depth, r is rows, c is columns).</li>
<li>Elements are integers between -10^4 and 10^4.</li>
<li>The array is guaranteed to be non-empty and well-formed (all sub-arrays have consistent dimensions).
<strong>Example</strong>:</li>
<li>Input: <code>array = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}</code></li>
<li>Output: 36</li>
<li>Explanation: Sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36.</li>
<li>Input: <code>array = {{{1}}}</code></li>
<li>Output: 1</li>
<li>Explanation: The single-element 3D array has sum 1.</li>
</ul>
<h2 id="pseudocode-20"><a class="header" href="#pseudocode-20">Pseudocode</a></h2>
<pre><code>FUNCTION sum3DArray(array)
    IF array is null OR array is empty OR array[0] is empty OR array[0][0] is empty THEN
        RETURN 0
    ENDIF
    SET depth to number of layers in array
    SET rows to number of rows in array[0]
    SET cols to number of columns in array[0][0]
    SET sum to 0
    FOR i from 0 to depth - 1
        FOR j from 0 to rows - 1
            FOR k from 0 to cols - 1
                SET sum to sum + array[i][j][k]
            ENDFOR
        ENDFOR
    ENDFOR
    RETURN sum
ENDFUNCTION

FUNCTION main()
    SET testArrays to 3D arrays with different dimensions
    FOR each array in testArrays
        CALL sum3DArray(array)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-20"><a class="header" href="#algorithm-steps-20">Algorithm Steps</a></h2>
<ol>
<li>Check if the input 3D array is null, empty, or has empty sub-arrays. If so, return 0.</li>
<li>Determine the dimensions: <code>depth</code> (d), <code>rows</code> (r), and <code>columns</code> (c) of the 3D array.</li>
<li>Initialize a variable <code>sum</code> to 0.</li>
<li>Use three nested loops to iterate through each element <code>array[i][j][k]</code>:
a. Add the element to <code>sum</code>.</li>
<li>Return the final <code>sum</code>.</li>
<li>In the <code>main</code> method, create test 3D arrays with different dimensions and call <code>sum3DArray</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-43"><a class="header" href="#java-implementation-43">Java Implementation</a></h2>
<pre><code class="language-java">public class ThreeDArraySummation {
    // Computes the sum of all elements in a 3D array
    public long sum3DArray(int[][][] array) {
        // Check for null or empty array
        if (array == null || array.length == 0 || array[0].length == 0 || array[0][0].length == 0) {
            return 0;
        }
        // Get dimensions
        int depth = array.length;
        int rows = array[0].length;
        int cols = array[0][0].length;
        // Initialize sum
        long sum = 0;
        // Iterate through all elements
        for (int i = 0; i &lt; depth; i++) {
            for (int j = 0; j &lt; rows; j++) {
                for (int k = 0; k &lt; cols; k++) {
                    sum += array[i][j][k];
                }
            }
        }
        return sum;
    }

    // Main method to test sum3DArray with various inputs
    public static void main(String[] args) {
        ThreeDArraySummation summer = new ThreeDArraySummation();

        // Test case 1: 2x2x2 3D array
        int[][][] array1 = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};
        System.out.println("Test case 1:");
        System.out.println("Array:");
        print3DArray(array1);
        System.out.println("Sum: " + summer.sum3DArray(array1));

        // Test case 2: 1x1x1 single-element array
        int[][][] array2 = {{{1}}};
        System.out.println("Test case 2:");
        System.out.println("Array:");
        print3DArray(array2);
        System.out.println("Sum: " + summer.sum3DArray(array2));

        // Test case 3: 2x3x2 non-uniform dimensions
        int[][][] array3 = {{{1, 2}, {3, 4}, {5, 6}}, {{7, 8}, {9, 10}, {11, 12}}};
        System.out.println("Test case 3:");
        System.out.println("Array:");
        print3DArray(array3);
        System.out.println("Sum: " + summer.sum3DArray(array3));

        // Test case 4: 1x2x3 array with negative numbers
        int[][][] array4 = {{{-1, -2, -3}, {-4, -5, -6}}};
        System.out.println("Test case 4:");
        System.out.println("Array:");
        print3DArray(array4);
        System.out.println("Sum: " + summer.sum3DArray(array4));

        // Test case 5: Empty array
        int[][][] array5 = {};
        System.out.println("Test case 5:");
        System.out.println("Array:");
        print3DArray(array5);
        System.out.println("Sum: " + summer.sum3DArray(array5));
    }

    // Helper method to print 3D array
    private static void print3DArray(int[][][] array) {
        if (array == null || array.length == 0) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; array.length; i++) {
            System.out.println("  [");
            for (int j = 0; j &lt; array[i].length; j++) {
                System.out.print("    [");
                for (int k = 0; k &lt; array[i][j].length; k++) {
                    System.out.print(array[i][j][k]);
                    if (k &lt; array[i][j].length - 1) {
                        System.out.print(", ");
                    }
                }
                System.out.println("]");
            }
            System.out.println("  ]");
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-20"><a class="header" href="#output-20">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Array:
[
  [
    [1, 2]
    [3, 4]
  ]
  [
    [5, 6]
    [7, 8]
  ]
]
Sum: 36
Test case 2:
Array:
[
  [
    [1]
  ]
]
Sum: 1
Test case 3:
Array:
[
  [
    [1, 2]
    [3, 4]
    [5, 6]
  ]
  [
    [7, 8]
    [9, 10]
    [11, 12]
  ]
]
Sum: 78
Test case 4:
Array:
[
  [
    [-1, -2, -3]
    [-4, -5, -6]
  ]
]
Sum: -21
Test case 5:
Array:
null
Sum: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Sums a 2×2×2 array: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36.</li>
<li>Test case 2: Sums a 1×1×1 array: 1 = 1.</li>
<li>Test case 3: Sums a 2×3×2 array: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 = 78.</li>
<li>Test case 4: Sums a 1×2×3 array with negatives: -1 + (-2) + (-3) + (-4) + (-5) + (-6) = -21.</li>
<li>Test case 5: Returns 0 for an empty array.</li>
</ul>
<h2 id="how-it-works-44"><a class="header" href="#how-it-works-44">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>sum3DArray</code> method checks for null or empty arrays. For <code>{{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}}</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Get dimensions: <code>depth = 2</code>, <code>rows = 2</code>, <code>cols = 2</code>.</li>
<li><strong>Step 3</strong>: Initialize <code>sum = 0</code>.</li>
<li><strong>Step 4</strong>: Iterate through all elements:
<ul>
<li>Layer 0: <code>[1, 2]</code> → sum = 0 + 1 + 2 = 3; <code>[3, 4]</code> → sum = 3 + 3 + 4 = 10.</li>
<li>Layer 1: <code>[5, 6]</code> → sum = 10 + 5 + 6 = 21; <code>[7, 8]</code> → sum = 21 + 7 + 8 = 36.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, accumulates: 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36.</li>
<li><strong>Main Method</strong>: Tests with different dimensions (2×2×2, 1×1×1, 2×3×2, 1×2×3) and an empty array, printing inputs and sums.</li>
<li><strong>Summation Property</strong>: Uses nested loops to access each element, ensuring all are included in the sum.</li>
</ul>
<h2 id="complexity-analysis-table-43"><a class="header" href="#complexity-analysis-table-43">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Summation</td><td>O(d<em>r</em>c)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(d<em>r</em>c)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>d is the depth, r is the number of rows, c is the number of columns.</li>
<li>Time complexity: O(d<em>r</em>c), as the algorithm iterates through each element once.</li>
<li>Space complexity: O(1), as only a single <code>sum</code> variable is used (excluding input/output).</li>
<li>Best, average, and worst cases are O(d<em>r</em>c).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use nested loops for straightforward 3D array traversal. Test with varying dimensions and negative numbers to ensure correctness, especially for edge cases like single-element arrays.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the 3D array is well-formed (consistent dimensions across layers, rows, and columns) to avoid <code>NullPointerException</code> or <code>ArrayIndexOutOfBoundsException</code>. Use a <code>long</code> for the sum to handle large arrays within the given constraints.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="diagonal-elements"><a class="header" href="#diagonal-elements">Diagonal Elements</a></h1>
<h2 id="problem-statement-21"><a class="header" href="#problem-statement-21">Problem Statement</a></h2>
<p>Write a Java program that implements a method to extract the main diagonal elements of a square 2D array (matrix) into a 1D array. The main diagonal consists of elements where the row index equals the column index (i.e., matrix[i][i]). The program should return a 1D array containing these elements and test the implementation with various square matrices, including edge cases like 1×1 matrices and matrices with negative numbers. You can visualize this as collecting the numbers along the top-left to bottom-right diagonal of a square grid, like picking out the main diagonal pieces on a chessboard.</p>
<p><strong>Input</strong>: A square 2D array (matrix) of integers with dimensions n × n (e.g., <code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code>).
<strong>Output</strong>: A 1D array containing the main diagonal elements (e.g., <code>[1, 5, 9]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>1 ≤ n ≤ 100 (where n is the number of rows and columns).</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The matrix is guaranteed to be square (number of rows equals number of columns) and non-empty.
<strong>Example</strong>:</li>
<li>Input: <code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code></li>
<li>Output: <code>[1, 5, 9]</code></li>
<li>Explanation: The main diagonal elements are matrix[0][0] = 1, matrix[1][1] = 5, matrix[2][2] = 9.</li>
<li>Input: <code>matrix = [[5]]</code></li>
<li>Output: <code>[5]</code></li>
<li>Explanation: The 1×1 matrix has a single diagonal element, 5.</li>
</ul>
<h2 id="pseudocode-21"><a class="header" href="#pseudocode-21">Pseudocode</a></h2>
<pre><code>FUNCTION getMainDiagonal(matrix)
    IF matrix is null OR matrix is empty OR matrix[0] is empty OR rows not equal to columns THEN
        RETURN null
    ENDIF
    SET n to number of rows in matrix
    CREATE result array of size n
    FOR i from 0 to n - 1
        SET result[i] to matrix[i][i]
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION main()
    SET testMatrices to square 2D arrays
    FOR each matrix in testMatrices
        CALL getMainDiagonal(matrix)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-21"><a class="header" href="#algorithm-steps-21">Algorithm Steps</a></h2>
<ol>
<li>Check if the input matrix is null, empty, or not square (rows ≠ columns). If so, return null.</li>
<li>Get the size of the matrix: <code>n</code> (number of rows, equal to columns since square).</li>
<li>Create a 1D result array of size n.</li>
<li>Iterate through indices i from 0 to n-1:
a. Set <code>result[i]</code> to <code>matrix[i][i]</code> (the main diagonal element).</li>
<li>Return the result array.</li>
<li>In the <code>main</code> method, create test square matrices of different sizes and call <code>getMainDiagonal</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-44"><a class="header" href="#java-implementation-44">Java Implementation</a></h2>
<pre><code class="language-java">public class DiagonalElements {
    // Extracts main diagonal elements into a 1D array
    public int[] getMainDiagonal(int[][] matrix) {
        // Check for null, empty, or non-square matrix
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0 || matrix.length != matrix[0].length) {
            return null;
        }
        // Get matrix size
        int n = matrix.length;
        // Create result array
        int[] result = new int[n];
        // Extract diagonal elements
        for (int i = 0; i &lt; n; i++) {
            result[i] = matrix[i][i];
        }
        return result;
    }

    // Main method to test getMainDiagonal with various inputs
    public static void main(String[] args) {
        DiagonalElements diagonal = new DiagonalElements();

        // Test case 1: 3x3 matrix
        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        System.out.println("Test case 1:");
        System.out.println("Matrix:");
        printMatrix(matrix1);
        System.out.print("Main diagonal: ");
        printArray(diagonal.getMainDiagonal(matrix1));

        // Test case 2: 1x1 matrix
        int[][] matrix2 = {{5}};
        System.out.println("Test case 2:");
        System.out.println("Matrix:");
        printMatrix(matrix2);
        System.out.print("Main diagonal: ");
        printArray(diagonal.getMainDiagonal(matrix2));

        // Test case 3: 2x2 matrix with negative numbers
        int[][] matrix3 = {{-1, -2}, {-3, -4}};
        System.out.println("Test case 3:");
        System.out.println("Matrix:");
        printMatrix(matrix3);
        System.out.print("Main diagonal: ");
        printArray(diagonal.getMainDiagonal(matrix3));

        // Test case 4: 4x4 matrix
        int[][] matrix4 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};
        System.out.println("Test case 4:");
        System.out.println("Matrix:");
        printMatrix(matrix4);
        System.out.print("Main diagonal: ");
        printArray(diagonal.getMainDiagonal(matrix4));

        // Test case 5: Null matrix
        int[][] matrix5 = null;
        System.out.println("Test case 5:");
        System.out.println("Matrix:");
        printMatrix(matrix5);
        System.out.print("Main diagonal: ");
        printArray(diagonal.getMainDiagonal(matrix5));
    }

    // Helper method to print matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            for (int j = 0; j &lt; matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
                if (j &lt; matrix[i].length - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        }
        System.out.println("]");
    }

    // Helper method to print 1D array
    private static void printArray(int[] arr) {
        if (arr == null) {
            System.out.println("null");
            return;
        }
        System.out.print("[");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]);
            if (i &lt; arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-21"><a class="header" href="#output-21">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Matrix:
[
  [1, 2, 3]
  [4, 5, 6]
  [7, 8, 9]
]
Main diagonal: [1, 5, 9]
Test case 2:
Matrix:
[
  [5]
]
Main diagonal: [5]
Test case 3:
Matrix:
[
  [-1, -2]
  [-3, -4]
]
Main diagonal: [-1, -4]
Test case 4:
Matrix:
[
  [1, 2, 3, 4]
  [5, 6, 7, 8]
  [9, 10, 11, 12]
  [13, 14, 15, 16]
]
Main diagonal: [1, 6, 11, 16]
Test case 5:
Matrix:
null
Main diagonal: null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Extracts diagonal <code>[1, 5, 9]</code> from a 3×3 matrix.</li>
<li>Test case 2: Extracts <code>[5]</code> from a 1×1 matrix.</li>
<li>Test case 3: Extracts <code>[-1, -4]</code> from a 2×2 matrix with negative numbers.</li>
<li>Test case 4: Extracts <code>[1, 6, 11, 16]</code> from a 4×4 matrix.</li>
<li>Test case 5: Returns null for a null matrix.</li>
</ul>
<h2 id="how-it-works-45"><a class="header" href="#how-it-works-45">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>getMainDiagonal</code> method checks if the matrix is null, empty, or not square. For <code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Get size: <code>n = 3</code>.</li>
<li><strong>Step 3</strong>: Create a result array of size 3.</li>
<li><strong>Step 4</strong>: Iterate for i = 0 to 2:
<ul>
<li>i = 0: <code>result[0] = matrix[0][0] = 1</code></li>
<li>i = 1: <code>result[1] = matrix[1][1] = 5</code></li>
<li>i = 2: <code>result[2] = matrix[2][2] = 9</code></li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, builds <code>[1, 5, 9]</code> by collecting <code>matrix[i][i]</code>.</li>
<li><strong>Main Method</strong>: Tests with square matrices (3×3, 1×1, 2×2, 4×4) and a null matrix, printing inputs and results.</li>
<li><strong>Diagonal Property</strong>: Collects elements where row index equals column index, creating a 1D array of size n.</li>
</ul>
<h2 id="complexity-analysis-table-44"><a class="header" href="#complexity-analysis-table-44">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Diagonal Extraction</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the size of the square matrix (rows = columns).</li>
<li>Time complexity: O(n), as the algorithm iterates through n diagonal elements.</li>
<li>Space complexity: O(n), for the result array. Temporary variables use O(1) space.</li>
<li>Best, average, and worst cases are O(n).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Since the matrix is square, a single loop over indices i is sufficient to extract <code>matrix[i][i]</code>. Test with various sizes and negative numbers to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input matrix is square and not null to avoid <code>NullPointerException</code> or <code>ArrayIndexOutOfBoundsException</code>. Verify consistent row lengths for a well-formed matrix.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="matrix-multiplication"><a class="header" href="#matrix-multiplication">Matrix Multiplication</a></h1>
<h2 id="problem-statement-22"><a class="header" href="#problem-statement-22">Problem Statement</a></h2>
<p>Write a Java program that implements a method to multiply two 2D arrays (matrices) and return the result as a new 2D array. The program should handle matrix multiplication for matrices of compatible sizes (i.e., the number of columns in the first matrix equals the number of rows in the second matrix) and test the implementation with matrices of different compatible sizes, including square and non-square matrices, and edge cases like single-row or single-column matrices. You can visualize this as combining two grids of numbers, where each cell in the resulting grid is computed by pairing rows from the first grid with columns from the second grid, summing the products of corresponding elements.</p>
<p><strong>Input</strong>: Two 2D arrays (matrices) <code>A</code> (m × n) and <code>B</code> (n × p), where m is the number of rows in A, n is the number of columns in A and rows in B, and p is the number of columns in B (e.g., <code>A = [[1, 2], [3, 4]]</code>, <code>B = [[5, 6], [7, 8]]</code>).
<strong>Output</strong>: A new 2D array (m × p) representing the product of A and B (e.g., <code>[[19, 22], [43, 50]]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>1 ≤ m, n, p ≤ 100.</li>
<li>Elements are integers between -10^4 and 10^4.</li>
<li>The number of columns in A equals the number of rows in B (matrices are compatible).
<strong>Example</strong>:</li>
<li>Input: <code>A = [[1, 2], [3, 4]]</code>, <code>B = [[5, 6], [7, 8]]</code></li>
<li>Output: <code>[[19, 22], [43, 50]]</code></li>
<li>Explanation: For element [0][0] in the result: 1<em>5 + 2</em>7 = 19; for [0][1]: 1<em>6 + 2</em>8 = 22; for [1][0]: 3<em>5 + 4</em>7 = 43; for [1][1]: 3<em>6 + 4</em>8 = 50.</li>
<li>Input: <code>A = [[1, 2, 3]]</code>, <code>B = [[4], [5], [6]]</code></li>
<li>Output: <code>[[32]]</code></li>
<li>Explanation: For element [0][0]: 1<em>4 + 2</em>5 + 3*6 = 32.</li>
</ul>
<h2 id="pseudocode-22"><a class="header" href="#pseudocode-22">Pseudocode</a></h2>
<pre><code>FUNCTION multiplyMatrices(A, B)
    IF A is null OR B is null OR A is empty OR B is empty OR columns of A not equal to rows of B THEN
        RETURN null
    ENDIF
    SET m to number of rows in A
    SET n to number of columns in A
    SET p to number of columns in B
    CREATE result matrix of size m × p
    FOR i from 0 to m - 1
        FOR j from 0 to p - 1
            SET sum to 0
            FOR k from 0 to n - 1
                SET sum to sum + A[i][k] * B[k][j]
            ENDFOR
            SET result[i][j] to sum
        ENDFOR
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION main()
    SET testCases to pairs of matrices
    FOR each (A, B) in testCases
        CALL multiplyMatrices(A, B)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-22"><a class="header" href="#algorithm-steps-22">Algorithm Steps</a></h2>
<ol>
<li>Check if matrices A or B are null, empty, or incompatible (number of columns in A ≠ number of rows in B). If so, return null.</li>
<li>Get dimensions: m (rows of A), n (columns of A/rows of B), p (columns of B).</li>
<li>Create a result matrix of size m × p, initialized to zeros.</li>
<li>For each element <code>result[i][j]</code> in the result matrix:
a. Initialize a sum to 0.
b. For each k from 0 to n-1, compute <code>A[i][k] * B[k][j]</code> and add to the sum.
c. Set <code>result[i][j]</code> to the computed sum.</li>
<li>Return the result matrix.</li>
<li>In the <code>main</code> method, create test cases with different compatible matrix sizes and call <code>multiplyMatrices</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-45"><a class="header" href="#java-implementation-45">Java Implementation</a></h2>
<pre><code class="language-java">public class MatrixMultiplication {
    // Multiplies two matrices and returns the result
    public int[][] multiplyMatrices(int[][] A, int[][] B) {
        // Check for null, empty, or incompatible matrices
        if (A == null || B == null || A.length == 0 || B.length == 0 || A[0].length != B.length) {
            return null;
        }
        // Get dimensions
        int m = A.length; // Rows of A
        int n = A[0].length; // Columns of A, rows of B
        int p = B[0].length; // Columns of B
        // Initialize result matrix
        int[][] result = new int[m][p];
        // Compute matrix multiplication
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; p; j++) {
                int sum = 0;
                for (int k = 0; k &lt; n; k++) {
                    sum += A[i][k] * B[k][j];
                }
                result[i][j] = sum;
            }
        }
        return result;
    }

    // Main method to test multiplyMatrices with various inputs
    public static void main(String[] args) {
        MatrixMultiplication multiplier = new MatrixMultiplication();

        // Test case 1: 2x2 matrices
        int[][] A1 = {{1, 2}, {3, 4}};
        int[][] B1 = {{5, 6}, {7, 8}};
        System.out.println("Test case 1:");
        System.out.println("Matrix A1:");
        printMatrix(A1);
        System.out.println("Matrix B1:");
        printMatrix(B1);
        int[][] result1 = multiplier.multiplyMatrices(A1, B1);
        System.out.println("Result:");
        printMatrix(result1);

        // Test case 2: 1x3 and 3x1 matrices
        int[][] A2 = {{1, 2, 3}};
        int[][] B2 = {{4}, {5}, {6}};
        System.out.println("Test case 2:");
        System.out.println("Matrix A2:");
        printMatrix(A2);
        System.out.println("Matrix B2:");
        printMatrix(B2);
        int[][] result2 = multiplier.multiplyMatrices(A2, B2);
        System.out.println("Result:");
        printMatrix(result2);

        // Test case 3: 3x2 and 2x3 matrices
        int[][] A3 = {{1, 2}, {3, 4}, {5, 6}};
        int[][] B3 = {{7, 8, 9}, {10, 11, 12}};
        System.out.println("Test case 3:");
        System.out.println("Matrix A3:");
        printMatrix(A3);
        System.out.println("Matrix B3:");
        printMatrix(B3);
        int[][] result3 = multiplier.multiplyMatrices(A3, B3);
        System.out.println("Result:");
        printMatrix(result3);

        // Test case 4: Incompatible matrices
        int[][] A4 = {{1, 2}};
        int[][] B4 = {{3, 4}};
        System.out.println("Test case 4 (incompatible):");
        System.out.println("Matrix A4:");
        printMatrix(A4);
        System.out.println("Matrix B4:");
        printMatrix(B4);
        int[][] result4 = multiplier.multiplyMatrices(A4, B4);
        System.out.println("Result:");
        printMatrix(result4);
    }

    // Helper method to print matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            for (int j = 0; j &lt; matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
                if (j &lt; matrix[i].length - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-22"><a class="header" href="#output-22">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Matrix A1:
[
  [1, 2]
  [3, 4]
]
Matrix B1:
[
  [5, 6]
  [7, 8]
]
Result:
[
  [19, 22]
  [43, 50]
]
Test case 2:
Matrix A2:
[
  [1, 2, 3]
]
Matrix B2:
[
  [4]
  [5]
  [6]
]
Result:
[
  [32]
]
Test case 3:
Matrix A3:
[
  [1, 2]
  [3, 4]
  [5, 6]
]
Matrix B3:
[
  [7, 8, 9]
  [10, 11, 12]
]
Result:
[
  [27, 30, 33]
  [61, 68, 75]
  [95, 106, 117]
]
Test case 4 (incompatible):
Matrix A4:
[
  [1, 2]
]
Matrix B4:
[
  [3, 4]
]
Result:
null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Multiplies 2×2 matrices, resulting in <code>[[19, 22], [43, 50]]</code>.</li>
<li>Test case 2: Multiplies 1×3 and 3×1 matrices, resulting in <code>[[32]]</code>.</li>
<li>Test case 3: Multiplies 3×2 and 2×3 matrices, resulting in a 3×3 matrix.</li>
<li>Test case 4: Incompatible matrices (1×2 and 1×2) return null.</li>
</ul>
<h2 id="how-it-works-46"><a class="header" href="#how-it-works-46">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>multiplyMatrices</code> method checks for null, empty, or incompatible matrices. For <code>A = [[1, 2], [3, 4]]</code>, <code>B = [[5, 6], [7, 8]]</code>, it proceeds (2×2 and 2×2 are compatible).</li>
<li><strong>Step 2</strong>: Initialize <code>m = 2</code>, <code>n = 2</code>, <code>p = 2</code>, and create a 2×2 result matrix.</li>
<li><strong>Step 3</strong>: Compute each element:
<ul>
<li><code>result[0][0]</code>: <code>1*5 + 2*7 = 19</code>.</li>
<li><code>result[0][1]</code>: <code>1*6 + 2*8 = 22</code>.</li>
<li><code>result[1][0]</code>: <code>3*5 + 4*7 = 43</code>.</li>
<li><code>result[1][1]</code>: <code>3*6 + 4*8 = 50</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, computes <code>[[19, 22], [43, 50]]</code> by summing products of rows of A with columns of B.</li>
<li><strong>Main Method</strong>: Tests with square (2×2), non-square (1×3 × 3×1, 3×2 × 2×3), and incompatible matrices, printing inputs and results.</li>
<li><strong>Matrix Multiplication</strong>: Each element <code>result[i][j]</code> is the dot product of row i of A and column j of B.</li>
</ul>
<h2 id="complexity-analysis-table-45"><a class="header" href="#complexity-analysis-table-45">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Multiplication</td><td>O(m<em>n</em>p)</td><td>O(m*p)</td></tr>
<tr><td>Full Algorithm</td><td>O(m<em>n</em>p)</td><td>O(m*p)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>m is the number of rows in A, n is the number of columns in A/rows in B, p is the number of columns in B.</li>
<li>Time complexity: O(m<em>n</em>p), as the algorithm iterates m*p times, each performing n multiplications and additions.</li>
<li>Space complexity: O(m*p), for the result matrix. Temporary variables use O(1) space.</li>
<li>Best, average, and worst cases are O(m<em>n</em>p).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Always check matrix compatibility before multiplication to avoid errors. Test with various sizes, including single-row/column matrices, to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure matrices are not null and have consistent row/column sizes to avoid <code>NullPointerException</code> or <code>ArrayIndexOutOfBoundsException</code>. Be cautious with large matrices, as O(m<em>n</em>p) time complexity can be slow.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="transpose-matrix"><a class="header" href="#transpose-matrix">Transpose Matrix</a></h1>
<h2 id="problem-statement-23"><a class="header" href="#problem-statement-23">Problem Statement</a></h2>
<p>Write a Java program that implements a method to transpose a 2D array (matrix), swapping its rows and columns to create a new matrix where the element at position [i][j] in the original matrix becomes the element at position [j][i] in the result. The program should return the transposed matrix as a new 2D array and test the implementation with square and non-square matrices, including edge cases like single-row or single-column matrices. You can visualize this as flipping a grid of numbers over its main diagonal, turning rows into columns and columns into rows, like rearranging a chessboard so that the row of pieces becomes a column.</p>
<p><strong>Input</strong>: A 2D array (matrix) of integers with dimensions m × n (e.g., <code>matrix = [[1, 2, 3], [4, 5, 6]]</code>).
<strong>Output</strong>: A new 2D array of dimensions n × m representing the transposed matrix (e.g., <code>[[1, 4], [2, 5], [3, 6]]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>1 ≤ m, n ≤ 100 (where m is the number of rows and n is the number of columns).</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The matrix is guaranteed to be non-empty and rectangular (all rows have the same number of columns).
<strong>Example</strong>:</li>
<li>Input: <code>matrix = [[1, 2, 3], [4, 5, 6]]</code></li>
<li>Output: <code>[[1, 4], [2, 5], [3, 6]]</code></li>
<li>Explanation: The 2×3 matrix is transposed to a 3×2 matrix, with row 1 ([1, 2, 3]) becoming column 1 ([1, 4]), etc.</li>
<li>Input: <code>matrix = [[1, 2], [3, 4]]</code></li>
<li>Output: <code>[[1, 3], [2, 4]]</code></li>
<li>Explanation: The 2×2 square matrix is transposed, swapping elements across the main diagonal.</li>
</ul>
<h2 id="pseudocode-23"><a class="header" href="#pseudocode-23">Pseudocode</a></h2>
<pre><code>FUNCTION transposeMatrix(matrix)
    IF matrix is null OR matrix is empty THEN
        RETURN null
    ENDIF
    SET rows to number of rows in matrix
    SET cols to number of columns in matrix
    CREATE result matrix of size cols × rows
    FOR i from 0 to rows - 1
        FOR j from 0 to cols - 1
            SET result[j][i] to matrix[i][j]
        ENDFOR
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION main()
    SET testMatrices to arrays of 2D arrays
    FOR each matrix in testMatrices
        CALL transposeMatrix(matrix)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-23"><a class="header" href="#algorithm-steps-23">Algorithm Steps</a></h2>
<ol>
<li>Check if the input matrix is null or empty. If so, return null.</li>
<li>Determine the dimensions of the input matrix: <code>rows</code> (m) and <code>columns</code> (n).</li>
<li>Create a new result matrix of size n × m (columns × rows).</li>
<li>Iterate through each element <code>matrix[i][j]</code> in the input matrix:
a. Set <code>result[j][i]</code> to <code>matrix[i][j]</code>, effectively swapping rows and columns.</li>
<li>Return the result matrix.</li>
<li>In the <code>main</code> method, create test matrices (square and non-square) with various sizes and call <code>transposeMatrix</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-46"><a class="header" href="#java-implementation-46">Java Implementation</a></h2>
<pre><code class="language-java">public class TransposeMatrix {
    // Transposes a matrix by swapping rows and columns
    public int[][] transposeMatrix(int[][] matrix) {
        // Check for null or empty matrix
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return null;
        }
        // Get dimensions
        int rows = matrix.length;
        int cols = matrix[0].length;
        // Create result matrix with swapped dimensions
        int[][] result = new int[cols][rows];
        // Transpose by copying elements
        for (int i = 0; i &lt; rows; i++) {
            for (int j = 0; j &lt; cols; j++) {
                result[j][i] = matrix[i][j];
            }
        }
        return result;
    }

    // Main method to test transposeMatrix with various inputs
    public static void main(String[] args) {
        TransposeMatrix transposer = new TransposeMatrix();

        // Test case 1: 2x3 non-square matrix
        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}};
        System.out.println("Test case 1:");
        System.out.println("Original matrix:");
        printMatrix(matrix1);
        int[][] result1 = transposer.transposeMatrix(matrix1);
        System.out.println("Transposed matrix:");
        printMatrix(result1);

        // Test case 2: 2x2 square matrix
        int[][] matrix2 = {{1, 2}, {3, 4}};
        System.out.println("Test case 2:");
        System.out.println("Original matrix:");
        printMatrix(matrix2);
        int[][] result2 = transposer.transposeMatrix(matrix2);
        System.out.println("Transposed matrix:");
        printMatrix(result2);

        // Test case 3: 1x3 single-row matrix
        int[][] matrix3 = {{1, 2, 3}};
        System.out.println("Test case 3:");
        System.out.println("Original matrix:");
        printMatrix(matrix3);
        int[][] result3 = transposer.transposeMatrix(matrix3);
        System.out.println("Transposed matrix:");
        printMatrix(result3);

        // Test case 4: 3x1 single-column matrix
        int[][] matrix4 = {{1}, {2}, {3}};
        System.out.println("Test case 4:");
        System.out.println("Original matrix:");
        printMatrix(matrix4);
        int[][] result4 = transposer.transposeMatrix(matrix4);
        System.out.println("Transposed matrix:");
        printMatrix(result4);

        // Test case 5: Empty matrix
        int[][] matrix5 = {};
        System.out.println("Test case 5:");
        System.out.println("Original matrix:");
        printMatrix(matrix5);
        int[][] result5 = transposer.transposeMatrix(matrix5);
        System.out.println("Transposed matrix:");
        printMatrix(result5);
    }

    // Helper method to print matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            for (int j = 0; j &lt; matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
                if (j &lt; matrix[i].length - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-23"><a class="header" href="#output-23">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Original matrix:
[
  [1, 2, 3]
  [4, 5, 6]
]
Transposed matrix:
[
  [1, 4]
  [2, 5]
  [3, 6]
]
Test case 2:
Original matrix:
[
  [1, 2]
  [3, 4]
]
Transposed matrix:
[
  [1, 3]
  [2, 4]
]
Test case 3:
Original matrix:
[
  [1, 2, 3]
]
Transposed matrix:
[
  [1]
  [2]
  [3]
]
Test case 4:
Original matrix:
[
  [1]
  [2]
  [3]
]
Transposed matrix:
[
  [1, 2, 3]
]
Test case 5:
Original matrix:
null
Transposed matrix:
null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Transposes a 2×3 matrix to a 3×2 matrix.</li>
<li>Test case 2: Transposes a 2×2 square matrix, swapping elements across the diagonal.</li>
<li>Test case 3: Transposes a 1×3 matrix to a 3×1 matrix.</li>
<li>Test case 4: Transposes a 3×1 matrix to a 1×3 matrix.</li>
<li>Test case 5: Returns null for an empty matrix.</li>
</ul>
<h2 id="how-it-works-47"><a class="header" href="#how-it-works-47">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>transposeMatrix</code> method checks if the matrix is null or empty. For <code>[[1, 2, 3], [4, 5, 6]]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Get dimensions: <code>rows = 2</code>, <code>cols = 3</code>.</li>
<li><strong>Step 3</strong>: Create a result matrix of size 3×2.</li>
<li><strong>Step 4</strong>: Iterate through the input matrix:
<ul>
<li><code>matrix[0][0] = 1</code> → <code>result[0][0] = 1</code></li>
<li><code>matrix[0][1] = 2</code> → <code>result[1][0] = 2</code></li>
<li><code>matrix[0][2] = 3</code> → <code>result[2][0] = 3</code></li>
<li><code>matrix[1][0] = 4</code> → <code>result[0][1] = 4</code></li>
<li><code>matrix[1][1] = 5</code> → <code>result[1][1] = 5</code></li>
<li><code>matrix[1][2] = 6</code> → <code>result[2][1] = 6</code></li>
</ul>
</li>
<li><strong>Example Trace</strong>: For <code>[[1, 2, 3], [4, 5, 6]]</code>, builds <code>[[1, 4], [2, 5], [3, 6]]</code> by swapping indices.</li>
<li><strong>Main Method</strong>: Tests with square (2×2), non-square (2×3, 1×3, 3×1), and empty matrices, printing inputs and results.</li>
<li><strong>Transpose Property</strong>: Creates a new matrix with swapped dimensions, where each <code>matrix[i][j]</code> maps to <code>result[j][i]</code>.</li>
</ul>
<h2 id="complexity-analysis-table-46"><a class="header" href="#complexity-analysis-table-46">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Transpose</td><td>O(m*n)</td><td>O(m*n)</td></tr>
<tr><td>Full Algorithm</td><td>O(m*n)</td><td>O(m*n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>m is the number of rows, n is the number of columns in the input matrix.</li>
<li>Time complexity: O(m*n), as the algorithm iterates through each element of the m×n matrix once.</li>
<li>Space complexity: O(m*n), for the result matrix. Temporary variables use O(1) space.</li>
<li>Best, average, and worst cases are O(m*n).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Ensure the result matrix has dimensions n×m for an m×n input matrix. Test with both square and non-square matrices to verify correctness, especially single-row or single-column cases.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input matrix is not null and is rectangular (all rows have the same number of columns) to avoid <code>NullPointerException</code> or <code>ArrayIndexOutOfBoundsException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="wave-traversal"><a class="header" href="#wave-traversal">Wave Traversal</a></h1>
<h2 id="problem-statement-24"><a class="header" href="#problem-statement-24">Problem Statement</a></h2>
<p>Write a Java program that implements a method to traverse a 2D array (matrix) in a wave pattern, where even-indexed columns (0-based) are traversed top-to-bottom and odd-indexed columns are traversed bottom-to-top. The program should return a 1D array containing the elements in the order of traversal and test the implementation with matrices of different sizes, including edge cases like single-row or single-column matrices. You can visualize this as navigating a grid like a wave, moving down even columns and up odd columns, collecting numbers like a surfer riding along a zigzag path.</p>
<p><strong>Input</strong>: A 2D array (matrix) of integers with dimensions m × n (e.g., <code>matrix = [[1, 2, 3], [4, 5, 6]]</code>).
<strong>Output</strong>: A 1D array containing the elements in wave traversal order (e.g., <code>[1, 4, 6, 5, 3, 2]</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>1 ≤ m, n ≤ 100 (where m is the number of rows and n is the number of columns).</li>
<li>Elements are integers between -10^9 and 10^9.</li>
<li>The matrix is guaranteed to be non-empty and rectangular (all rows have the same number of columns).
<strong>Example</strong>:</li>
<li>Input: <code>matrix = [[1, 2, 3], [4, 5, 6]]</code></li>
<li>Output: <code>[1, 4, 6, 5, 3, 2]</code></li>
<li>Explanation: Column 0 (even): top-to-bottom [1, 4]; Column 1 (odd): bottom-to-top [6, 5]; Column 2 (even): top-to-bottom [3, 2].</li>
<li>Input: <code>matrix = [[1, 2], [3, 4], [5, 6]]</code></li>
<li>Output: <code>[1, 3, 5, 6, 4, 2]</code></li>
<li>Explanation: Column 0 (even): top-to-bottom [1, 3, 5]; Column 1 (odd): bottom-to-top [6, 4, 2].</li>
</ul>
<h2 id="pseudocode-24"><a class="header" href="#pseudocode-24">Pseudocode</a></h2>
<pre><code>FUNCTION waveTraversal(matrix)
    IF matrix is null OR matrix is empty OR matrix[0] is empty THEN
        RETURN null
    ENDIF
    SET rows to number of rows in matrix
    SET cols to number of columns in matrix
    CREATE result array of size rows * cols
    SET index to 0
    FOR j from 0 to cols - 1
        IF j is even THEN
            FOR i from 0 to rows - 1
                SET result[index] to matrix[i][j]
                INCREMENT index
            ENDFOR
        ELSE
            FOR i from rows - 1 to 0
                SET result[index] to matrix[i][j]
                INCREMENT index
            ENDFOR
        ENDIF
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION main()
    SET testMatrices to 2D arrays
    FOR each matrix in testMatrices
        CALL waveTraversal(matrix)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-24"><a class="header" href="#algorithm-steps-24">Algorithm Steps</a></h2>
<ol>
<li>Check if the input matrix is null, empty, or has empty rows. If so, return null.</li>
<li>Get the dimensions: <code>rows</code> (m) and <code>columns</code> (n).</li>
<li>Create a 1D result array of size m * n to store the wave traversal elements.</li>
<li>Initialize an index to track the position in the result array.</li>
<li>Iterate through each column j from 0 to n-1:
a. If j is even, traverse top-to-bottom (i from 0 to rows-1), adding <code>matrix[i][j]</code> to result.
b. If j is odd, traverse bottom-to-top (i from rows-1 to 0), adding <code>matrix[i][j]</code> to result.
c. Increment the index after each element is added.</li>
<li>Return the result array.</li>
<li>In the <code>main</code> method, create test matrices of different sizes and call <code>waveTraversal</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-47"><a class="header" href="#java-implementation-47">Java Implementation</a></h2>
<pre><code class="language-java">public class WaveTraversal {
    // Traverses matrix in wave pattern and returns 1D array
    public int[] waveTraversal(int[][] matrix) {
        // Check for null or empty matrix
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return null;
        }
        // Get dimensions
        int rows = matrix.length;
        int cols = matrix[0].length;
        // Create result array
        int[] result = new int[rows * cols];
        int index = 0;
        // Traverse each column
        for (int j = 0; j &lt; cols; j++) {
            // Even column: top-to-bottom
            if (j % 2 == 0) {
                for (int i = 0; i &lt; rows; i++) {
                    result[index++] = matrix[i][j];
                }
            }
            // Odd column: bottom-to-top
            else {
                for (int i = rows - 1; i &gt;= 0; i--) {
                    result[index++] = matrix[i][j];
                }
            }
        }
        return result;
    }

    // Main method to test waveTraversal with various inputs
    public static void main(String[] args) {
        WaveTraversal traverser = new WaveTraversal();

        // Test case 1: 2x3 matrix
        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}};
        System.out.println("Test case 1:");
        System.out.println("Matrix:");
        printMatrix(matrix1);
        System.out.print("Wave traversal: ");
        printArray(traverser.waveTraversal(matrix1));

        // Test case 2: 3x2 matrix
        int[][] matrix2 = {{1, 2}, {3, 4}, {5, 6}};
        System.out.println("Test case 2:");
        System.out.println("Matrix:");
        printMatrix(matrix2);
        System.out.print("Wave traversal: ");
        printArray(traverser.waveTraversal(matrix2));

        // Test case 3: 1x3 single-row matrix
        int[][] matrix3 = {{1, 2, 3}};
        System.out.println("Test case 3:");
        System.out.println("Matrix:");
        printMatrix(matrix3);
        System.out.print("Wave traversal: ");
        printArray(traverser.waveTraversal(matrix3));

        // Test case 4: 3x1 single-column matrix
        int[][] matrix4 = {{1}, {2}, {3}};
        System.out.println("Test case 4:");
        System.out.println("Matrix:");
        printMatrix(matrix4);
        System.out.print("Wave traversal: ");
        printArray(traverser.waveTraversal(matrix4));

        // Test case 5: 2x2 matrix with negative numbers
        int[][] matrix5 = {{-1, -2}, {-3, -4}};
        System.out.println("Test case 5:");
        System.out.println("Matrix:");
        printMatrix(matrix5);
        System.out.print("Wave traversal: ");
        printArray(traverser.waveTraversal(matrix5));

        // Test case 6: Null matrix
        int[][] matrix6 = null;
        System.out.println("Test case 6:");
        System.out.println("Matrix:");
        printMatrix(matrix6);
        System.out.print("Wave traversal: ");
        printArray(traverser.waveTraversal(matrix6));
    }

    // Helper method to print matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            for (int j = 0; j &lt; matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
                if (j &lt; matrix[i].length - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        }
        System.out.println("]");
    }

    // Helper method to print 1D array
    private static void printArray(int[] arr) {
        if (arr == null) {
            System.out.println("null");
            return;
        }
        System.out.print("[");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]);
            if (i &lt; arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-24"><a class="header" href="#output-24">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Matrix:
[
  [1, 2, 3]
  [4, 5, 6]
]
Wave traversal: [1, 4, 6, 5, 3, 2]
Test case 2:
Matrix:
[
  [1, 2]
  [3, 4]
  [5, 6]
]
Wave traversal: [1, 3, 5, 6, 4, 2]
Test case 3:
Matrix:
[
  [1, 2, 3]
]
Wave traversal: [1, 3, 2]
Test case 4:
Matrix:
[
  [1]
  [2]
  [3]
]
Wave traversal: [1, 2, 3]
Test case 5:
Matrix:
[
  [-1, -2]
  [-3, -4]
]
Wave traversal: [-1, -3, -4, -2]
Test case 6:
Matrix:
null
Wave traversal: null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Traverses 2×3 matrix: Col 0 (even): [1, 4]; Col 1 (odd): [6, 5]; Col 2 (even): [3, 2].</li>
<li>Test case 2: Traverses 3×2 matrix: Col 0 (even): [1, 3, 5]; Col 1 (odd): [6, 4, 2].</li>
<li>Test case 3: Traverses 1×3 matrix: Col 0 (even): [1]; Col 1 (odd): [3]; Col 2 (even): [2].</li>
<li>Test case 4: Traverses 3×1 matrix: Col 0 (even): [1, 2, 3].</li>
<li>Test case 5: Traverses 2×2 matrix with negatives: Col 0 (even): [-1, -3]; Col 1 (odd): [-4, -2].</li>
<li>Test case 6: Returns null for a null matrix.</li>
</ul>
<h2 id="how-it-works-48"><a class="header" href="#how-it-works-48">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>waveTraversal</code> method checks for null or empty matrices. For <code>[[1, 2, 3], [4, 5, 6]]</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Get dimensions: <code>rows = 2</code>, <code>cols = 3</code>.</li>
<li><strong>Step 3</strong>: Create a result array of size 2 * 3 = 6.</li>
<li><strong>Step 4</strong>: Iterate through columns:
<ul>
<li>Col 0 (even): <code>i = 0 to 1</code> → <code>result[0] = matrix[0][0] = 1</code>, <code>result[1] = matrix[1][0] = 4</code>.</li>
<li>Col 1 (odd): <code>i = 1 to 0</code> → <code>result[2] = matrix[1][1] = 6</code>, <code>result[3] = matrix[0][1] = 5</code>.</li>
<li>Col 2 (even): <code>i = 0 to 1</code> → <code>result[4] = matrix[0][2] = 3</code>, <code>result[5] = matrix[1][2] = 2</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, builds <code>[1, 4, 6, 5, 3, 2]</code> by alternating directions.</li>
<li><strong>Main Method</strong>: Tests with different sizes (2×3, 3×2, 1×3, 3×1, 2×2) and a null matrix, printing inputs and results.</li>
<li><strong>Wave Property</strong>: Alternates top-to-bottom and bottom-to-top traversal based on column index parity.</li>
</ul>
<h2 id="complexity-analysis-table-47"><a class="header" href="#complexity-analysis-table-47">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Traversal</td><td>O(m*n)</td><td>O(m*n)</td></tr>
<tr><td>Full Algorithm</td><td>O(m*n)</td><td>O(m*n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>m is the number of rows, n is the number of columns.</li>
<li>Time complexity: O(m*n), as the algorithm visits each element once.</li>
<li>Space complexity: O(m*n), for the result array. Temporary variables use O(1) space.</li>
<li>Best, average, and worst cases are O(m*n).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a single index to track the result array position for simplicity. Test with single-row, single-column, and negative number matrices to ensure the wave pattern is correct.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the input matrix is not null and is rectangular to avoid <code>NullPointerException</code> or <code>ArrayIndexOutOfBoundsException</code>. Verify consistent row lengths for a well-formed matrix.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="adjacency-list-representation"><a class="header" href="#adjacency-list-representation">Adjacency List Representation</a></h1>
<h2 id="problem-statement-25"><a class="header" href="#problem-statement-25">Problem Statement</a></h2>
<p>Write a Java program that implements an undirected graph using a jagged array as an adjacency list. The program should include methods to add edges between vertices and print the neighbors of each vertex. Test the implementation with a sample graph, including cases with varying numbers of vertices and edges, and ensure the graph correctly represents undirected connections (i.e., an edge from u to v implies an edge from v to u). You can visualize this as creating a map of friendships, where each person (vertex) has a list of friends (neighbors), and friendships are mutual.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Number of vertices V (e.g., V = 4).</li>
<li>Edges as pairs of vertices (e.g., (0, 1), (1, 2), (2, 3)).
<strong>Output</strong>:</li>
<li>For each vertex, print its neighbors as a list (e.g., for vertex 0: [1], for vertex 1: [0, 2], etc.).
<strong>Constraints</strong>:</li>
<li>1 ≤ V ≤ 100 (number of vertices).</li>
<li>Vertices are labeled from 0 to V-1.</li>
<li>Edges are valid pairs of distinct vertices (u ≠ v).</li>
<li>The graph is undirected and simple (no self-loops or multiple edges between the same vertices).
<strong>Example</strong>:</li>
<li>Input: V = 4, edges = [(0, 1), (1, 2), (2, 3), (0, 2)]</li>
<li>Output:
<pre><code>Vertex 0 neighbors: [1, 2]
Vertex 1 neighbors: [0, 2]
Vertex 2 neighbors: [1, 3, 0]
Vertex 3 neighbors: [2]
</code></pre>
</li>
<li>Explanation: The graph has 4 vertices. Vertex 0 is connected to 1 and 2, vertex 1 to 0 and 2, vertex 2 to 1, 3, and 0, and vertex 3 to 2.</li>
</ul>
<h2 id="pseudocode-25"><a class="header" href="#pseudocode-25">Pseudocode</a></h2>
<pre><code>FUNCTION initializeGraph(V)
    CREATE jagged array adjList of size V
    FOR i from 0 to V - 1
        SET adjList[i] to empty array
    ENDFOR
    RETURN adjList
ENDFUNCTION

FUNCTION addEdge(adjList, u, v)
    IF adjList is null OR u &lt; 0 OR u &gt;= length of adjList OR v &lt; 0 OR v &gt;= length of adjList OR u equals v THEN
        RETURN
    ENDIF
    IF v not in adjList[u] THEN
        ADD v to adjList[u]
    ENDIF
    IF u not in adjList[v] THEN
        ADD u to adjList[v]
    ENDIF
ENDFUNCTION

FUNCTION printNeighbors(adjList)
    IF adjList is null OR adjList is empty THEN
        PRINT "Graph is empty"
        RETURN
    ENDIF
    FOR i from 0 to length of adjList - 1
        PRINT "Vertex i neighbors: " followed by adjList[i]
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET V to number of vertices
    CALL initializeGraph(V)
    SET edges to list of edge pairs
    FOR each (u, v) in edges
        CALL addEdge(adjList, u, v)
    ENDFOR
    CALL printNeighbors(adjList)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-25"><a class="header" href="#algorithm-steps-25">Algorithm Steps</a></h2>
<ol>
<li><strong>Initialize Graph</strong>:
a. Create a jagged array <code>adjList</code> of size V, where each element is an empty array (to store neighbors).</li>
<li><strong>Add Edge</strong>:
a. Validate inputs: check if <code>adjList</code> is null, or vertices u, v are out of bounds or equal (self-loop).
b. Add v to <code>adjList[u]</code> if not already present (to avoid duplicates).
c. Add u to <code>adjList[v]</code> if not already present (for undirected graph).</li>
<li><strong>Print Neighbors</strong>:
a. Check if <code>adjList</code> is null or empty. If so, print "Graph is empty".
b. For each vertex i, print its index and the array of neighbors <code>adjList[i]</code>.</li>
<li>In the <code>main</code> method, initialize a graph with a specified number of vertices, add edges from a sample edge list, and print the neighbors of each vertex.</li>
</ol>
<h2 id="java-implementation-48"><a class="header" href="#java-implementation-48">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.ArrayList;

public class AdjacencyListRepresentation {
    // Initializes a graph with V vertices as a jagged array
    private ArrayList&lt;Integer&gt;[] adjList;

    // Constructor to initialize graph
    @SuppressWarnings("unchecked")
    public AdjacencyListRepresentation(int V) {
        adjList = (ArrayList&lt;Integer&gt;[]) new ArrayList[V];
        for (int i = 0; i &lt; V; i++) {
            adjList[i] = new ArrayList&lt;&gt;();
        }
    }

    // Adds an edge between vertices u and v
    public void addEdge(int u, int v) {
        // Validate inputs
        if (adjList == null || u &lt; 0 || u &gt;= adjList.length || v &lt; 0 || v &gt;= adjList.length || u == v) {
            return;
        }
        // Add v to u's list if not already present
        if (!adjList[u].contains(v)) {
            adjList[u].add(v);
        }
        // Add u to v's list if not already present (undirected)
        if (!adjList[v].contains(u)) {
            adjList[v].add(u);
        }
    }

    // Prints neighbors of each vertex
    public void printNeighbors() {
        if (adjList == null || adjList.length == 0) {
            System.out.println("Graph is empty");
            return;
        }
        for (int i = 0; i &lt; adjList.length; i++) {
            System.out.print("Vertex " + i + " neighbors: [");
            for (int j = 0; j &lt; adjList[i].size(); j++) {
                System.out.print(adjList[i].get(j));
                if (j &lt; adjList[i].size() - 1) {
                    System.out.print(", ");
                }
            }
            System.out.println("]");
        }
    }

    // Main method to test the graph implementation
    public static void main(String[] args) {
        // Test case 1: Sample graph with 4 vertices
        System.out.println("Test case 1: Graph with 4 vertices");
        AdjacencyListRepresentation graph1 = new AdjacencyListRepresentation(4);
        int[][] edges1 = {{0, 1}, {1, 2}, {2, 3}, {0, 2}};
        for (int[] edge : edges1) {
            graph1.addEdge(edge[0], edge[1]);
        }
        graph1.printNeighbors();

        // Test case 2: Single vertex, no edges
        System.out.println("\nTest case 2: Single vertex");
        AdjacencyListRepresentation graph2 = new AdjacencyListRepresentation(1);
        graph2.printNeighbors();

        // Test case 3: Graph with 5 vertices, more edges
        System.out.println("\nTest case 3: Graph with 5 vertices");
        AdjacencyListRepresentation graph3 = new AdjacencyListRepresentation(5);
        int[][] edges3 = {{0, 1}, {0, 2}, {0, 3}, {1, 3}, {1, 4}, {2, 4}};
        for (int[] edge : edges3) {
            graph3.addEdge(edge[0], edge[1]);
        }
        graph3.printNeighbors();

        // Test case 4: Empty graph (0 vertices)
        System.out.println("\nTest case 4: Empty graph");
        AdjacencyListRepresentation graph4 = new AdjacencyListRepresentation(0);
        graph4.printNeighbors();
    }
}
</code></pre>
<h2 id="output-25"><a class="header" href="#output-25">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Graph with 4 vertices
Vertex 0 neighbors: [1, 2]
Vertex 1 neighbors: [0, 2]
Vertex 2 neighbors: [1, 3, 0]
Vertex 3 neighbors: [2]

Test case 2: Single vertex
Vertex 0 neighbors: []

Test case 3: Graph with 5 vertices
Vertex 0 neighbors: [1, 2, 3]
Vertex 1 neighbors: [0, 3, 4]
Vertex 2 neighbors: [0, 4]
Vertex 3 neighbors: [0, 1]
Vertex 4 neighbors: [1, 2]

Test case 4: Empty graph
Graph is empty
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Graph with 4 vertices and edges (0,1), (1,2), (2,3), (0,2). Vertex 0 is connected to 1 and 2, etc.</li>
<li>Test case 2: Single vertex with no edges, so its neighbor list is empty.</li>
<li>Test case 3: Graph with 5 vertices and more edges, forming a connected structure.</li>
<li>Test case 4: Empty graph (0 vertices) prints "Graph is empty".</li>
</ul>
<h2 id="how-it-works-49"><a class="header" href="#how-it-works-49">How It Works</a></h2>
<ul>
<li><strong>Initialization</strong>: Creates a jagged array (<code>ArrayList&lt;Integer&gt;[]</code>) of size V, with each element as an empty <code>ArrayList</code> for neighbors.</li>
<li><strong>Add Edge</strong>: For edge (u, v), adds v to <code>adjList[u]</code> and u to <code>adjList[v]</code> if not already present, ensuring undirected edges without duplicates.</li>
<li><strong>Print Neighbors</strong>: Iterates through each vertex and prints its neighbor list.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Initialize: <code>adjList = [[], [], [], []]</code> for V = 4.</li>
<li>Add edge (0,1): <code>adjList[0] = [1]</code>, <code>adjList[1] = [0]</code>.</li>
<li>Add edge (1,2): <code>adjList[1] = [0, 2]</code>, <code>adjList[2] = [1]</code>.</li>
<li>Add edge (2,3): <code>adjList[2] = [1, 3]</code>, <code>adjList[3] = [2]</code>.</li>
<li>Add edge (0,2): <code>adjList[0] = [1, 2]</code>, <code>adjList[2] = [1, 3, 0]</code>.</li>
<li>Print: Vertex 0: [1, 2], Vertex 1: [0, 2], etc.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with a 4-vertex graph, a single-vertex graph, a 5-vertex graph, and an empty graph.</li>
<li><strong>Adjacency List Property</strong>: Uses a jagged array for space efficiency, storing only actual neighbors.</li>
</ul>
<h2 id="complexity-analysis-table-48"><a class="header" href="#complexity-analysis-table-48">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Initialize Graph</td><td>O(V)</td><td>O(V)</td></tr>
<tr><td>Add Edge</td><td>O(1) average</td><td>O(1) per edge</td></tr>
<tr><td>Print Neighbors</td><td>O(V + E)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(V + E)</td><td>O(V + E)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>V is the number of vertices, E is the number of edges.</li>
<li>Initialize: O(V) to create V empty lists.</li>
<li>Add Edge: O(1) average for <code>ArrayList</code> add and contains (amortized, assuming hash-based checks).</li>
<li>Print Neighbors: O(V + E) to iterate through all vertices and their edges.</li>
<li>Space: O(V + E) for the jagged array storing V lists and E edges (undirected edges stored twice).</li>
<li>Worst case for dense graph: O(V^2) space if E ≈ V^2.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>ArrayList</code> for dynamic neighbor lists to handle varying degrees. Test with sparse and dense graphs to verify correctness, including single-vertex and empty graphs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate vertex indices to avoid <code>ArrayIndexOutOfBoundsException</code>. Ensure edges are not self-loops (u ≠ v) and check for duplicates to maintain a simple graph.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="dynamic-row-addition"><a class="header" href="#dynamic-row-addition">Dynamic Row Addition</a></h1>
<h2 id="problem-statement-26"><a class="header" href="#problem-statement-26">Problem Statement</a></h2>
<p>Write a Java program that allows users to interactively add rows to a jagged array, specifying the length and elements of each row. The program should store the jagged array dynamically, support adding multiple rows with different lengths, and print the resulting array after each addition. Test the implementation with multiple row additions, including edge cases like empty rows or no additions. You can visualize this as building a flexible grid where users can append new rows of varying sizes, like adding shelves of different lengths to a bookcase and filling them with books.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Number of rows to add (e.g., 3).</li>
<li>For each row: length of the row and its elements (e.g., length = 3, elements = [1, 2, 3]).
<strong>Output</strong>:</li>
<li>The jagged array after each row addition, displayed as a 2D array (e.g., <code>[[1, 2, 3], [4, 5], [6, 7, 8, 9]]</code> after three additions).
<strong>Constraints</strong>:</li>
<li>The number of rows to add is between 0 and 100.</li>
<li>Each row’s length is between 0 and 100.</li>
<li>Elements are integers between -10^4 and 10^4.</li>
<li>The input is valid (row lengths and elements are within constraints).
<strong>Example</strong>:</li>
<li>Input: Add 3 rows:
<ul>
<li>Row 1: length = 3, elements = [1, 2, 3]</li>
<li>Row 2: length = 2, elements = [4, 5]</li>
<li>Row 3: length = 4, elements = [6, 7, 8, 9]</li>
</ul>
</li>
<li>Output after each addition:
<pre><code>After adding row 1: [[1, 2, 3]]
After adding row 2: [[1, 2, 3], [4, 5]]
After adding row 3: [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
</code></pre>
</li>
<li>Input: Add 1 row:
<ul>
<li>Row 1: length = 0, elements = []</li>
</ul>
</li>
<li>Output: <code>[[]]</code></li>
</ul>
<h2 id="pseudocode-26"><a class="header" href="#pseudocode-26">Pseudocode</a></h2>
<pre><code>FUNCTION addRow(jaggedArray, rowLength, elements)
    IF rowLength &lt; 0 OR elements length not equal to rowLength THEN
        RETURN
    ENDIF
    CREATE newRow array of size rowLength
    FOR i from 0 to rowLength - 1
        SET newRow[i] to elements[i]
    ENDFOR
    ADD newRow to jaggedArray
ENDFUNCTION

FUNCTION main()
    SET jaggedArray to empty dynamic array
    SET testCases to list of (rowLength, elements) pairs
    FOR each (rowLength, elements) in testCases
        PRINT current jaggedArray
        CALL addRow(jaggedArray, rowLength, elements)
        PRINT updated jaggedArray
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-26"><a class="header" href="#algorithm-steps-26">Algorithm Steps</a></h2>
<ol>
<li>Initialize an empty dynamic structure (<code>ArrayList&lt;int[]&gt;</code>) to store the jagged array.</li>
<li>For each row addition:
a. Validate the input: ensure row length is non-negative and matches the number of elements provided.
b. Create a new array of the specified length and populate it with the provided elements.
c. Add the new array as a row to the jagged array.</li>
<li>Print the jagged array before and after each addition to show the changes.</li>
<li>In the <code>main</code> method, simulate user input with predefined test cases, including rows of different lengths, empty rows, and edge cases, to verify correctness.</li>
</ol>
<h2 id="java-implementation-49"><a class="header" href="#java-implementation-49">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.ArrayList;

public class DynamicRowAddition {
    // Adds a row to the jagged array with specified length and elements
    public void addRow(ArrayList&lt;int[]&gt; jaggedArray, int rowLength, int[] elements) {
        // Validate input
        if (rowLength &lt; 0 || elements == null || elements.length != rowLength) {
            return;
        }
        // Create new row and copy elements
        int[] newRow = new int[rowLength];
        for (int i = 0; i &lt; rowLength; i++) {
            newRow[i] = elements[i];
        }
        // Add row to jagged array
        jaggedArray.add(newRow);
    }

    // Main method to test addRow with various inputs
    public static void main(String[] args) {
        DynamicRowAddition adder = new DynamicRowAddition();
        
        // Test case 1: Add multiple rows with different lengths
        System.out.println("Test case 1: Adding multiple rows");
        ArrayList&lt;int[]&gt; jaggedArray1 = new ArrayList&lt;&gt;();
        int[][] testRows1 = {
            {1, 2, 3},       // Row of length 3
            {4, 5},          // Row of length 2
            {6, 7, 8, 9}     // Row of length 4
        };
        for (int i = 0; i &lt; testRows1.length; i++) {
            System.out.println("Before adding row " + (i + 1) + ":");
            printJaggedArray(jaggedArray1);
            adder.addRow(jaggedArray1, testRows1[i].length, testRows1[i]);
            System.out.println("After adding row " + (i + 1) + ":");
            printJaggedArray(jaggedArray1);
        }

        // Test case 2: Add a single empty row
        System.out.println("\nTest case 2: Adding an empty row");
        ArrayList&lt;int[]&gt; jaggedArray2 = new ArrayList&lt;&gt;();
        System.out.println("Before adding row:");
        printJaggedArray(jaggedArray2);
        adder.addRow(jaggedArray2, 0, new int[]{});
        System.out.println("After adding row:");
        printJaggedArray(jaggedArray2);

        // Test case 3: Add rows with negative numbers
        System.out.println("\nTest case 3: Adding rows with negative numbers");
        ArrayList&lt;int[]&gt; jaggedArray3 = new ArrayList&lt;&gt;();
        int[][] testRows3 = {
            {-1, -2},        // Row of length 2
            {-3, -4, -5}     // Row of length 3
        };
        for (int i = 0; i &lt; testRows3.length; i++) {
            System.out.println("Before adding row " + (i + 1) + ":");
            printJaggedArray(jaggedArray3);
            adder.addRow(jaggedArray3, testRows3[i].length, testRows3[i]);
            System.out.println("After adding row " + (i + 1) + ":");
            printJaggedArray(jaggedArray3);
        }

        // Test case 4: No rows added
        System.out.println("\nTest case 4: No rows added");
        ArrayList&lt;int[]&gt; jaggedArray4 = new ArrayList&lt;&gt;();
        System.out.println("Jagged array:");
        printJaggedArray(jaggedArray4);
    }

    // Helper method to print jagged array
    private static void printJaggedArray(ArrayList&lt;int[]&gt; jaggedArray) {
        if (jaggedArray == null || jaggedArray.isEmpty()) {
            System.out.println("[]");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; jaggedArray.size(); i++) {
            System.out.print("  [");
            if (jaggedArray.get(i).length == 0) {
                System.out.print("]");
            } else {
                for (int j = 0; j &lt; jaggedArray.get(i).length; j++) {
                    System.out.print(jaggedArray.get(i)[j]);
                    if (j &lt; jaggedArray.get(i).length - 1) {
                        System.out.print(", ");
                    }
                }
                System.out.print("]");
            }
            System.out.println();
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-26"><a class="header" href="#output-26">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Adding multiple rows
Before adding row 1:
[]
After adding row 1:
[
  [1, 2, 3]
]
Before adding row 2:
[
  [1, 2, 3]
]
After adding row 2:
[
  [1, 2, 3]
  [4, 5]
]
Before adding row 3:
[
  [1, 2, 3]
  [4, 5]
]
After adding row 3:
[
  [1, 2, 3]
  [4, 5]
  [6, 7, 8, 9]
]

Test case 2: Adding an empty row
Before adding row:
[]
After adding row:
[
  []
]

Test case 3: Adding rows with negative numbers
Before adding row 1:
[]
After adding row 1:
[
  [-1, -2]
]
Before adding row 2:
[
  [-1, -2]
]
After adding row 2:
[
  [-1, -2]
  [-3, -4, -5]
]

Test case 4: No rows added
Jagged array:
[]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Adds three rows of lengths 3, 2, and 4, building the jagged array incrementally.</li>
<li>Test case 2: Adds a single empty row, resulting in <code>[[]]</code>.</li>
<li>Test case 3: Adds two rows with negative numbers, lengths 2 and 3.</li>
<li>Test case 4: Shows an empty jagged array when no rows are added.</li>
</ul>
<h2 id="how-it-works-50"><a class="header" href="#how-it-works-50">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: Initialize an <code>ArrayList&lt;int[]&gt;</code> to store the jagged array dynamically.</li>
<li><strong>Step 2</strong>: For each row addition in <code>addRow</code>:
<ul>
<li>Validate: Ensure <code>rowLength</code> is non-negative and matches <code>elements.length</code>.</li>
<li>Create a new <code>int[]</code> of size <code>rowLength</code> and copy <code>elements</code> into it.</li>
<li>Add the new row to the <code>jaggedArray</code>.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Start: <code>jaggedArray = []</code>.</li>
<li>Add row 1: <code>[1, 2, 3]</code> → <code>[[1, 2, 3]]</code>.</li>
<li>Add row 2: <code>[4, 5]</code> → <code>[[1, 2, 3], [4, 5]]</code>.</li>
<li>Add row 3: <code>[6, 7, 8, 9]</code> → <code>[[1, 2, 3], [4, 5], [6, 7, 8, 9]]</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Simulates user input with test cases, including multiple rows, an empty row, negative numbers, and no additions, printing the array before and after each addition.</li>
<li><strong>Dynamic Property</strong>: Uses <code>ArrayList</code> for dynamic row addition, allowing flexible row lengths.</li>
</ul>
<h2 id="complexity-analysis-table-49"><a class="header" href="#complexity-analysis-table-49">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Add Row</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(N)</td><td>O(N)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the row being added.</li>
<li>N is the total number of elements across all rows added.</li>
<li>Time complexity: O(n) per row addition (copying elements to new array), O(N) for all additions.</li>
<li>Space complexity: O(n) per row (new array), O(N) for the entire jagged array.</li>
<li>Worst case: O(N) time and space for adding all elements across multiple rows.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>ArrayList&lt;int[]&gt;</code> for dynamic row management. Test with empty rows, varying lengths, and negative numbers to ensure flexibility and correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate that the number of elements matches the specified row length to avoid <code>ArrayIndexOutOfBoundsException</code>. Ensure the jagged array is initialized to avoid <code>NullPointerException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="jagged-array-transpose"><a class="header" href="#jagged-array-transpose">Jagged Array Transpose</a></h1>
<h2 id="problem-statement-27"><a class="header" href="#problem-statement-27">Problem Statement</a></h2>
<p>Write a Java program that implements a method to transpose a jagged array (a 2D array where each row can have a different length), converting rows to columns to create a new jagged array. The i-th row of the transposed array contains all elements from the i-th column of the original array, with row lengths varying based on the number of non-null elements in each column. The program should return the transposed array and test the implementation with irregular jagged arrays, including edge cases like empty arrays, arrays with empty rows, and arrays with varying row lengths. You can visualize this as flipping a ragged grid so that each column becomes a row, like reorganizing a collection of uneven lists into a new set of lists based on column positions.</p>
<p><strong>Input</strong>: A jagged 2D array of integers, where each row may have a different length (e.g., <code>matrix = {{1, 2, 3}, {4}, {5, 6}}</code>).
<strong>Output</strong>: A new jagged array where the i-th row contains elements from the i-th column of the input (e.g., <code>{{1, 4, 5}, {2, 6}, {3}}</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The number of rows is between 0 and 100.</li>
<li>Each row’s length is between 0 and 100.</li>
<li>Elements are integers between -10^4 and 10^4.</li>
<li>The matrix may be empty or contain empty or null rows.
<strong>Example</strong>:</li>
<li>Input: <code>matrix = {{1, 2, 3}, {4}, {5, 6}}</code></li>
<li>Output: <code>{{1, 4, 5}, {2, 6}, {3}}</code></li>
<li>Explanation: Column 0 ([1, 4, 5]) becomes row 0, column 1 ([2, 6]) becomes row 1, column 2 ([3]) becomes row 2.</li>
<li>Input: <code>matrix = {{1, 2}, {}, {3}}</code></li>
<li>Output: <code>{{1, 3}, {2}}</code></li>
<li>Explanation: Column 0 ([1, 3]) becomes row 0, column 1 ([2]) becomes row 1.</li>
</ul>
<h2 id="pseudocode-27"><a class="header" href="#pseudocode-27">Pseudocode</a></h2>
<pre><code>FUNCTION transposeJaggedArray(matrix)
    IF matrix is null OR matrix is empty THEN
        RETURN empty array
    ENDIF
    SET maxCols to maximum row length in matrix
    CREATE result as empty dynamic array
    FOR j from 0 to maxCols - 1
        CREATE tempList as empty list
        FOR i from 0 to number of rows in matrix - 1
            IF matrix[i] is not null AND j &lt; length of matrix[i] THEN
                ADD matrix[i][j] to tempList
            ENDIF
        ENDFOR
        IF tempList is not empty THEN
            CREATE newRow array of size tempList size
            COPY tempList elements to newRow
            ADD newRow to result
        ENDIF
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION main()
    SET testMatrices to jagged 2D arrays
    FOR each matrix in testMatrices
        PRINT original matrix
        CALL transposeJaggedArray(matrix)
        PRINT transposed matrix
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-27"><a class="header" href="#algorithm-steps-27">Algorithm Steps</a></h2>
<ol>
<li>Check if the input matrix is null or empty. If so, return an empty array.</li>
<li>Determine the maximum number of columns (maxCols) by finding the longest row.</li>
<li>Initialize an empty <code>ArrayList&lt;int[]&gt;</code> for the result.</li>
<li>For each column index j from 0 to maxCols-1:
a. Create a temporary list to collect elements from column j.
b. Iterate through each row i:
<ul>
<li>If row i is not null and j is within its length, add <code>matrix[i][j]</code> to the temporary list.
c. If the temporary list is not empty, convert it to an array and add it as a row to the result.</li>
</ul>
</li>
<li>Return the result as a jagged array.</li>
<li>In the <code>main</code> method, create test matrices with irregular row lengths and call <code>transposeJaggedArray</code> to verify correctness, printing the original and transposed matrices.</li>
</ol>
<h2 id="java-implementation-50"><a class="header" href="#java-implementation-50">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.ArrayList;

public class JaggedArrayTranspose {
    // Transposes a jagged array, converting rows to columns
    public int[][] transposeJaggedArray(int[][] matrix) {
        // Check for null or empty matrix
        if (matrix == null || matrix.length == 0) {
            return new int[0][];
        }
        // Find maximum number of columns
        int maxCols = 0;
        for (int[] row : matrix) {
            if (row != null &amp;&amp; row.length &gt; maxCols) {
                maxCols = row.length;
            }
        }
        // Create result array
        ArrayList&lt;int[]&gt; result = new ArrayList&lt;&gt;();
        // Process each column
        for (int j = 0; j &lt; maxCols; j++) {
            ArrayList&lt;Integer&gt; tempList = new ArrayList&lt;&gt;();
            // Collect elements from column j
            for (int i = 0; i &lt; matrix.length; i++) {
                if (matrix[i] != null &amp;&amp; j &lt; matrix[i].length) {
                    tempList.add(matrix[i][j]);
                }
            }
            // Convert non-empty tempList to array and add to result
            if (!tempList.isEmpty()) {
                int[] newRow = new int[tempList.size()];
                for (int k = 0; k &lt; tempList.size(); k++) {
                    newRow[k] = tempList.get(k);
                }
                result.add(newRow);
            }
        }
        // Convert ArrayList to int[][]
        return result.toArray(new int[0][]);
    }

    // Main method to test transposeJaggedArray with various inputs
    public static void main(String[] args) {
        JaggedArrayTranspose transposer = new JaggedArrayTranspose();

        // Test case 1: Jagged array with varying row lengths
        int[][] matrix1 = {{1, 2, 3}, {4}, {5, 6}};
        System.out.println("Test case 1:");
        System.out.println("Original matrix:");
        printMatrix(matrix1);
        System.out.println("Transposed matrix:");
        printMatrix(transposer.transposeJaggedArray(matrix1));

        // Test case 2: Jagged array with empty rows
        int[][] matrix2 = {{1, 2}, {}, {3}};
        System.out.println("\nTest case 2:");
        System.out.println("Original matrix:");
        printMatrix(matrix2);
        System.out.println("Transposed matrix:");
        printMatrix(transposer.transposeJaggedArray(matrix2));

        // Test case 3: Empty matrix
        int[][] matrix3 = {};
        System.out.println("\nTest case 3:");
        System.out.println("Original matrix:");
        printMatrix(matrix3);
        System.out.println("Transposed matrix:");
        printMatrix(transposer.transposeJaggedArray(matrix3));

        // Test case 4: Matrix with negative numbers
        int[][] matrix4 = {{-1, -2, -3}, {-4, -5}, {-6}};
        System.out.println("\nTest case 4:");
        System.out.println("Original matrix:");
        printMatrix(matrix4);
        System.out.println("Transposed matrix:");
        printMatrix(transposer.transposeJaggedArray(matrix4));

        // Test case 5: Null matrix
        int[][] matrix5 = null;
        System.out.println("\nTest case 5:");
        System.out.println("Original matrix:");
        printMatrix(matrix5);
        System.out.println("Transposed matrix:");
        printMatrix(transposer.transposeJaggedArray(matrix5));
    }

    // Helper method to print jagged matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            System.out.println("[]");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            if (matrix[i] == null || matrix[i].length == 0) {
                System.out.print("]");
            } else {
                for (int j = 0; j &lt; matrix[i].length; j++) {
                    System.out.print(matrix[i][j]);
                    if (j &lt; matrix[i].length - 1) {
                        System.out.print(", ");
                    }
                }
                System.out.print("]");
            }
            System.out.println();
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-27"><a class="header" href="#output-27">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Original matrix:
[
  [1, 2, 3]
  [4]
  [5, 6]
]
Transposed matrix:
[
  [1, 4, 5]
  [2, 6]
  [3]
]

Test case 2:
Original matrix:
[
  [1, 2]
  []
  [3]
]
Transposed matrix:
[
  [1, 3]
  [2]
]

Test case 3:
Original matrix:
[]
Transposed matrix:
[]

Test case 4:
Original matrix:
[
  [-1, -2, -3]
  [-4, -5]
  [-6]
]
Transposed matrix:
[
  [-1, -4, -6]
  [-2, -5]
  [-3]
]

Test case 5:
Original matrix:
[]
Transposed matrix:
[]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Transposes <code>{{1, 2, 3}, {4}, {5, 6}}</code> to <code>{{1, 4, 5}, {2, 6}, {3}}</code>, where column 0 ([1, 4, 5]) becomes row 0, etc.</li>
<li>Test case 2: Transposes <code>{{1, 2}, {}, {3}}</code> to <code>{{1, 3}, {2}}</code>, handling empty rows.</li>
<li>Test case 3: Empty matrix returns empty matrix.</li>
<li>Test case 4: Transposes <code>{{-1, -2, -3}, {-4, -5}, {-6}}</code> to <code>{{-1, -4, -6}, {-2, -5}, {-3}}</code>, handling negatives.</li>
<li>Test case 5: Null matrix returns empty matrix.</li>
</ul>
<h2 id="how-it-works-51"><a class="header" href="#how-it-works-51">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: Check if the matrix is null or empty. For <code>{{1, 2, 3}, {4}, {5, 6}}</code>, proceed.</li>
<li><strong>Step 2</strong>: Find maxCols = 3 (longest row).</li>
<li><strong>Step 3</strong>: Initialize result as an empty <code>ArrayList&lt;int[]&gt;</code>.</li>
<li><strong>Step 4</strong>: For each column j:
<ul>
<li>j = 0: Collect [1, 4, 5] (from matrix[0][0], matrix[1][0], matrix[2][0]) → add to result.</li>
<li>j = 1: Collect [2, 6] (from matrix[0][1], matrix[2][1]; matrix[1] has no column 1) → add to result.</li>
<li>j = 2: Collect [3] (from matrix[0][2]; others have no column 2) → add to result.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, builds <code>[[1, 4, 5], [2, 6], [3]]</code> by collecting column elements.</li>
<li><strong>Main Method</strong>: Tests with irregular jagged arrays, including empty rows, empty matrix, negatives, and null matrix.</li>
<li><strong>Transpose Property</strong>: Each column becomes a row, with row lengths varying based on non-null column elements.</li>
</ul>
<h2 id="complexity-analysis-table-50"><a class="header" href="#complexity-analysis-table-50">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Transpose</td><td>O(m * c)</td><td>O(m * c)</td></tr>
<tr><td>Full Algorithm</td><td>O(m * c)</td><td>O(m * c)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>m is the number of rows, c is the maximum row length (maxCols).</li>
<li>Time complexity: O(m * c), as each element is visited once to build the transposed rows.</li>
<li>Space complexity: O(m * c), for the result array storing up to m * c elements.</li>
<li>Best, average, and worst cases are O(m * c).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a dynamic structure like <code>ArrayList</code> to handle varying row lengths in the transposed array. Test with irregular arrays, including empty and null rows, to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for null rows and varying row lengths to avoid <code>NullPointerException</code> or <code>ArrayIndexOutOfBoundsException</code>. Ensure the result array only includes non-empty rows.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="row-sorting"><a class="header" href="#row-sorting">Row Sorting</a></h1>
<h2 id="problem-statement-28"><a class="header" href="#problem-statement-28">Problem Statement</a></h2>
<p>Write a Java program that implements a method to sort each row of a jagged array (a 2D array where each row can have a different length) independently in ascending order. The program should modify the jagged array in-place and test the implementation with jagged arrays containing rows of different lengths, including edge cases like empty matrices, matrices with empty rows, and matrices with rows of varying lengths. You can visualize this as organizing books on multiple shelves of different lengths, where each shelf’s books are sorted by size without affecting other shelves.</p>
<p><strong>Input</strong>: A jagged 2D array of integers, where each row may have a different length (e.g., <code>matrix = {{4, 2, 1}, {3, 5}, {6, 0, 8, 7}}</code>).
<strong>Output</strong>: The same jagged array with each row sorted in ascending order (e.g., <code>{{1, 2, 4}, {3, 5}, {0, 6, 7, 8}}</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>The number of rows is between 0 and 100.</li>
<li>Each row’s length is between 0 and 100.</li>
<li>Elements are integers between -10^4 and 10^4.</li>
<li>The matrix may be empty or contain empty or null rows.
<strong>Example</strong>:</li>
<li>Input: <code>matrix = {{4, 2, 1}, {3, 5}, {6, 0, 8, 7}}</code></li>
<li>Output: <code>{{1, 2, 4}, {3, 5}, {0, 6, 7, 8}}</code></li>
<li>Explanation: Each row is sorted independently: [4, 2, 1] → [1, 2, 4], [3, 5] → [3, 5], [6, 0, 8, 7] → [0, 6, 7, 8].</li>
<li>Input: <code>matrix = {{}, {1}, {3, 2}}</code></li>
<li>Output: <code>{{}, {1}, {2, 3}}</code></li>
<li>Explanation: Empty row stays empty, single-element row stays unchanged, and [3, 2] → [2, 3].</li>
</ul>
<h2 id="pseudocode-28"><a class="header" href="#pseudocode-28">Pseudocode</a></h2>
<pre><code>FUNCTION sortRows(matrix)
    IF matrix is null OR matrix is empty THEN
        RETURN
    ENDIF
    FOR each row in matrix
        IF row is not null THEN
            SORT row in ascending order
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testMatrices to jagged 2D arrays
    FOR each matrix in testMatrices
        PRINT original matrix
        CALL sortRows(matrix)
        PRINT sorted matrix
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-28"><a class="header" href="#algorithm-steps-28">Algorithm Steps</a></h2>
<ol>
<li>Check if the input matrix is null or empty. If so, return without modifying anything.</li>
<li>Iterate through each row of the matrix:
a. If the row is not null, sort it in ascending order using a sorting function.</li>
<li>The matrix is modified in-place, with each row sorted independently.</li>
<li>In the <code>main</code> method, create test matrices with varying row lengths and call <code>sortRows</code> to verify correctness, printing the matrix before and after sorting.</li>
</ol>
<h2 id="java-implementation-51"><a class="header" href="#java-implementation-51">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.Arrays;

public class RowSorting {
    // Sorts each row of a jagged array independently in ascending order
    public void sortRows(int[][] matrix) {
        // Check for null or empty matrix
        if (matrix == null || matrix.length == 0) {
            return;
        }
        // Iterate through each row
        for (int[] row : matrix) {
            // Sort non-null rows
            if (row != null) {
                Arrays.sort(row);
            }
        }
    }

    // Main method to test sortRows with various inputs
    public static void main(String[] args) {
        RowSorting sorter = new RowSorting();

        // Test case 1: Jagged matrix with different row lengths
        int[][] matrix1 = {{4, 2, 1}, {3, 5}, {6, 0, 8, 7}};
        System.out.println("Test case 1:");
        System.out.println("Before sorting:");
        printMatrix(matrix1);
        sorter.sortRows(matrix1);
        System.out.println("After sorting:");
        printMatrix(matrix1);

        // Test case 2: Matrix with empty and single-element rows
        int[][] matrix2 = {{}, {1}, {3, 2}};
        System.out.println("\nTest case 2:");
        System.out.println("Before sorting:");
        printMatrix(matrix2);
        sorter.sortRows(matrix2);
        System.out.println("After sorting:");
        printMatrix(matrix2);

        // Test case 3: Matrix with all zeros
        int[][] matrix3 = {{0, 0}, {0}, {0, 0, 0}};
        System.out.println("\nTest case 3:");
        System.out.println("Before sorting:");
        printMatrix(matrix3);
        sorter.sortRows(matrix3);
        System.out.println("After sorting:");
        printMatrix(matrix3);

        // Test case 4: Matrix with negative numbers
        int[][] matrix4 = {{-3, -1, -2}, {-5}, {-4, -6, -7}};
        System.out.println("\nTest case 4:");
        System.out.println("Before sorting:");
        printMatrix(matrix4);
        sorter.sortRows(matrix4);
        System.out.println("After sorting:");
        printMatrix(matrix4);

        // Test case 5: Null matrix
        int[][] matrix5 = null;
        System.out.println("\nTest case 5:");
        System.out.println("Before sorting:");
        printMatrix(matrix5);
        sorter.sortRows(matrix5);
        System.out.println("After sorting:");
        printMatrix(matrix5);
    }

    // Helper method to print jagged matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            if (matrix[i] == null || matrix[i].length == 0) {
                System.out.print("]");
            } else {
                for (int j = 0; j &lt; matrix[i].length; j++) {
                    System.out.print(matrix[i][j]);
                    if (j &lt; matrix[i].length - 1) {
                        System.out.print(", ");
                    }
                }
                System.out.print("]");
            }
            System.out.println();
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-28"><a class="header" href="#output-28">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Before sorting:
[
  [4, 2, 1]
  [3, 5]
  [6, 0, 8, 7]
]
After sorting:
[
  [1, 2, 4]
  [3, 5]
  [0, 6, 7, 8]
]

Test case 2:
Before sorting:
[
  []
  [1]
  [3, 2]
]
After sorting:
[
  []
  [1]
  [2, 3]
]

Test case 3:
Before sorting:
[
  [0, 0]
  [0]
  [0, 0, 0]
]
After sorting:
[
  [0, 0]
  [0]
  [0, 0, 0]
]

Test case 4:
Before sorting:
[
  [-3, -1, -2]
  [-5]
  [-4, -6, -7]
]
After sorting:
[
  [-3, -2, -1]
  [-5]
  [-7, -6, -4]
]

Test case 5:
Before sorting:
null
After sorting:
null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Sorts rows [4, 2, 1] → [1, 2, 4], [3, 5] → [3, 5], [6, 0, 8, 7] → [0, 6, 7, 8].</li>
<li>Test case 2: Empty row stays empty, [1] stays [1], [3, 2] → [2, 3].</li>
<li>Test case 3: Rows of zeros remain unchanged.</li>
<li>Test case 4: Sorts rows with negatives: [-3, -1, -2] → [-3, -2, -1], [-5] → [-5], [-4, -6, -7] → [-7, -6, -4].</li>
<li>Test case 5: Null matrix remains unchanged.</li>
</ul>
<h2 id="how-it-works-52"><a class="header" href="#how-it-works-52">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>sortRows</code> method checks if the matrix is null or empty. For <code>{{4, 2, 1}, {3, 5}, {6, 0, 8, 7}}</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Iterate through rows:
<ul>
<li>Row 0: <code>[4, 2, 1]</code> → sort to <code>[1, 2, 4]</code>.</li>
<li>Row 1: <code>[3, 5]</code> → sort to <code>[3, 5]</code> (already sorted).</li>
<li>Row 2: <code>[6, 0, 8, 7]</code> → sort to <code>[0, 6, 7, 8]</code>.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, each row is sorted independently using <code>Arrays.sort</code>, modifying the matrix in-place.</li>
<li><strong>Main Method</strong>: Tests with jagged matrices of varying row lengths, including empty rows, all zeros, negative numbers, and a null matrix, printing before and after sorting.</li>
<li><strong>Sorting Property</strong>: Each row is sorted independently, preserving the jagged structure and handling varying lengths.</li>
</ul>
<h2 id="complexity-analysis-table-51"><a class="header" href="#complexity-analysis-table-51">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Sorting Rows</td><td>O(Σ(r_i * log r_i))</td><td>O(log r_max)</td></tr>
<tr><td>Full Algorithm</td><td>O(Σ(r_i * log r_i))</td><td>O(log r_max)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>r_i is the length of the i-th row, r_max is the maximum row length.</li>
<li>Time complexity: O(Σ(r_i * log r_i)), where each row of length r_i is sorted using <code>Arrays.sort</code> (Timsort, O(r_i * log r_i)). The total is the sum over all rows.</li>
<li>Space complexity: O(log r_max), as Timsort uses O(log r_i) space for each row, and the maximum row length dominates.</li>
<li>Worst case: O(N * log N) where N is the total number of elements if one row contains all elements.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>Arrays.sort</code> for efficient row sorting. Test with empty rows, single-element rows, and negative numbers to ensure robustness across different jagged array configurations.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for null rows to avoid <code>NullPointerException</code>. Ensure the matrix is not null to prevent unexpected behavior during sorting.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="sparse-matrix-sum"><a class="header" href="#sparse-matrix-sum">Sparse Matrix Sum</a></h1>
<h2 id="problem-statement-29"><a class="header" href="#problem-statement-29">Problem Statement</a></h2>
<p>Write a Java program that represents a sparse matrix using a jagged array (a 2D array where each row can have a different length) and computes the sum of all non-zero elements. The program should return the sum as a long integer and test the implementation with matrices of varying row lengths, including edge cases like empty matrices, matrices with empty rows, and matrices with all zeros. You can visualize this as calculating the total value of non-zero items in a grid where each row may have a different number of columns, like summing the values of scattered resources in an uneven terrain map.</p>
<p><strong>Input</strong>: A jagged 2D array of integers, where each row may have a different length (e.g., <code>matrix = {{1, 0, 2}, {3}, {0, 4, 5, 0}}</code>).
<strong>Output</strong>: A long integer representing the sum of all non-zero elements (e.g., 15 for the example above).
<strong>Constraints</strong>:</p>
<ul>
<li>The number of rows is between 0 and 100.</li>
<li>Each row’s length is between 0 and 100.</li>
<li>Elements are integers between -10^4 and 10^4.</li>
<li>The matrix may be empty or contain empty rows.
<strong>Example</strong>:</li>
<li>Input: <code>matrix = {{1, 0, 2}, {3}, {0, 4, 5, 0}}</code></li>
<li>Output: 15</li>
<li>Explanation: Non-zero elements are 1, 2, 3, 4, 5; sum = 1 + 2 + 3 + 4 + 5 = 15.</li>
<li>Input: <code>matrix = {{0, 0}, {0}, {}}</code></li>
<li>Output: 0</li>
<li>Explanation: No non-zero elements, so sum = 0.</li>
</ul>
<h2 id="pseudocode-29"><a class="header" href="#pseudocode-29">Pseudocode</a></h2>
<pre><code>FUNCTION sumSparseMatrix(matrix)
    IF matrix is null OR matrix is empty THEN
        RETURN 0
    ENDIF
    SET sum to 0
    FOR each row in matrix
        IF row is not null THEN
            FOR each element in row
                IF element is not zero THEN
                    SET sum to sum + element
                ENDIF
            ENDFOR
        ENDIF
    ENDFOR
    RETURN sum
ENDFUNCTION

FUNCTION main()
    SET testMatrices to jagged 2D arrays
    FOR each matrix in testMatrices
        CALL sumSparseMatrix(matrix)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-29"><a class="header" href="#algorithm-steps-29">Algorithm Steps</a></h2>
<ol>
<li>Check if the input matrix is null or empty. If so, return 0.</li>
<li>Initialize a variable <code>sum</code> to 0.</li>
<li>Iterate through each row of the matrix:
a. Check if the row is not null.
b. Iterate through each element in the row.
c. If the element is non-zero, add it to <code>sum</code>.</li>
<li>Return the final <code>sum</code>.</li>
<li>In the <code>main</code> method, create test matrices with varying row lengths and call <code>sumSparseMatrix</code> to verify correctness.</li>
</ol>
<h2 id="java-implementation-52"><a class="header" href="#java-implementation-52">Java Implementation</a></h2>
<pre><code class="language-java">public class SparseMatrixSum {
    // Computes the sum of non-zero elements in a jagged 2D array
    public long sumSparseMatrix(int[][] matrix) {
        // Check for null or empty matrix
        if (matrix == null || matrix.length == 0) {
            return 0;
        }
        // Initialize sum
        long sum = 0;
        // Iterate through each row
        for (int[] row : matrix) {
            // Check for non-null row
            if (row != null) {
                // Iterate through each element in the row
                for (int element : row) {
                    // Add non-zero elements to sum
                    if (element != 0) {
                        sum += element;
                    }
                }
            }
        }
        return sum;
    }

    // Main method to test sumSparseMatrix with various inputs
    public static void main(String[] args) {
        SparseMatrixSum summer = new SparseMatrixSum();

        // Test case 1: Jagged matrix with non-zero elements
        int[][] matrix1 = {{1, 0, 2}, {3}, {0, 4, 5, 0}};
        System.out.println("Test case 1:");
        System.out.println("Matrix:");
        printMatrix(matrix1);
        System.out.println("Sum of non-zero elements: " + summer.sumSparseMatrix(matrix1));

        // Test case 2: Matrix with all zeros
        int[][] matrix2 = {{0, 0}, {0}, {0, 0}};
        System.out.println("Test case 2:");
        System.out.println("Matrix:");
        printMatrix(matrix2);
        System.out.println("Sum of non-zero elements: " + summer.sumSparseMatrix(matrix2));

        // Test case 3: Matrix with empty rows
        int[][] matrix3 = {{}, {1, 2}, {}};
        System.out.println("Test case 3:");
        System.out.println("Matrix:");
        printMatrix(matrix3);
        System.out.println("Sum of non-zero elements: " + summer.sumSparseMatrix(matrix3));

        // Test case 4: Single-row matrix
        int[][] matrix4 = {{1, 0, 3}};
        System.out.println("Test case 4:");
        System.out.println("Matrix:");
        printMatrix(matrix4);
        System.out.println("Sum of non-zero elements: " + summer.sumSparseMatrix(matrix4));

        // Test case 5: Matrix with negative numbers
        int[][] matrix5 = {{-1, 0}, {-2, -3, 0}, {4}};
        System.out.println("Test case 5:");
        System.out.println("Matrix:");
        printMatrix(matrix5);
        System.out.println("Sum of non-zero elements: " + summer.sumSparseMatrix(matrix5));

        // Test case 6: Null matrix
        int[][] matrix6 = null;
        System.out.println("Test case 6:");
        System.out.println("Matrix:");
        printMatrix(matrix6);
        System.out.println("Sum of non-zero elements: " + summer.sumSparseMatrix(matrix6));
    }

    // Helper method to print jagged matrix
    private static void printMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            System.out.println("null");
            return;
        }
        System.out.println("[");
        for (int i = 0; i &lt; matrix.length; i++) {
            System.out.print("  [");
            if (matrix[i] == null || matrix[i].length == 0) {
                System.out.print("]");
            } else {
                for (int j = 0; j &lt; matrix[i].length; j++) {
                    System.out.print(matrix[i][j]);
                    if (j &lt; matrix[i].length - 1) {
                        System.out.print(", ");
                    }
                }
                System.out.print("]");
            }
            System.out.println();
        }
        System.out.println("]");
    }
}
</code></pre>
<h2 id="output-29"><a class="header" href="#output-29">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Matrix:
[
  [1, 0, 2]
  [3]
  [0, 4, 5, 0]
]
Sum of non-zero elements: 15
Test case 2:
Matrix:
[
  [0, 0]
  [0]
  [0, 0]
]
Sum of non-zero elements: 0
Test case 3:
Matrix:
[
  []
  [1, 2]
  []
]
Sum of non-zero elements: 3
Test case 4:
Matrix:
[
  [1, 0, 3]
]
Sum of non-zero elements: 4
Test case 5:
Matrix:
[
  [-1, 0]
  [-2, -3, 0]
  [4]
]
Sum of non-zero elements: -2
Test case 6:
Matrix:
null
Sum of non-zero elements: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Sums non-zero elements 1, 2, 3, 4, 5 = 15.</li>
<li>Test case 2: No non-zero elements, sum = 0.</li>
<li>Test case 3: Sums non-zero elements 1, 2 = 3 (empty rows contribute 0).</li>
<li>Test case 4: Sums non-zero elements 1, 3 = 4.</li>
<li>Test case 5: Sums non-zero elements -1, -2, -3, 4 = -2.</li>
<li>Test case 6: Returns 0 for a null matrix.</li>
</ul>
<h2 id="how-it-works-53"><a class="header" href="#how-it-works-53">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: The <code>sumSparseMatrix</code> method checks if the matrix is null or empty. For <code>{{1, 0, 2}, {3}, {0, 4, 5, 0}}</code>, it proceeds.</li>
<li><strong>Step 2</strong>: Initialize <code>sum = 0</code>.</li>
<li><strong>Step 3</strong>: Iterate through rows:
<ul>
<li>Row 0: <code>[1, 0, 2]</code> → sum = 0 + 1 + 0 + 2 = 3.</li>
<li>Row 1: <code>[3]</code> → sum = 3 + 3 = 6.</li>
<li>Row 2: <code>[0, 4, 5, 0]</code> → sum = 6 + 0 + 4 + 5 + 0 = 15.</li>
</ul>
</li>
<li><strong>Example Trace</strong>: For test case 1, accumulates non-zero elements: 1 + 2 + 3 + 4 + 5 = 15.</li>
<li><strong>Main Method</strong>: Tests with jagged matrices of varying row lengths, including all zeros, empty rows, single-row, negative numbers, and null matrix, printing inputs and sums.</li>
<li><strong>Sparse Property</strong>: Only non-zero elements contribute to the sum, leveraging the jagged array’s flexibility for sparse matrices.</li>
</ul>
<h2 id="complexity-analysis-table-52"><a class="header" href="#complexity-analysis-table-52">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Summation</td><td>O(N)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(N)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>N is the total number of elements across all rows (sum of row lengths).</li>
<li>Time complexity: O(N), as the algorithm visits each element once.</li>
<li>Space complexity: O(1), as only a single <code>sum</code> variable is used (excluding input/output).</li>
<li>Best, average, and worst cases are O(N).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use enhanced for loops for clean iteration over jagged arrays. Test with matrices containing empty rows, all zeros, and negative numbers to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for null rows within the matrix to avoid <code>NullPointerException</code>. Use a <code>long</code> for the sum to handle large or negative numbers within the constraints.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings-problem-solving-with-dsa"><a class="header" href="#strings-problem-solving-with-dsa">Strings Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-2"><a class="header" href="#-what-you-will-learn-2">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="palindrome-checker"><a class="header" href="#palindrome-checker">Palindrome Checker</a></h1>
<h2 id="problem-statement-30"><a class="header" href="#problem-statement-30">Problem Statement</a></h2>
<p>Write a Java program that implements a method to check if a string is a palindrome, ignoring case and non-alphanumeric characters (e.g., spaces, punctuation). A palindrome is a string that reads the same forward and backward. The program should return a boolean indicating whether the input is a palindrome and test the implementation with various inputs, including empty strings, single characters, and strings with special characters. You can visualize this as checking if a phrase, like a secret code, reads the same when flipped, after ignoring irrelevant symbols and letter case, as if decoding a message on a mirror.</p>
<p><strong>Input</strong>: A string (e.g., <code>"A man, a plan, a canal: Panama"</code>, <code>"race a car"</code>, <code>""</code>).
<strong>Output</strong>: A boolean (<code>true</code> if the string is a palindrome after ignoring case and non-alphanumeric characters, <code>false</code> otherwise).
<strong>Constraints</strong>:</p>
<ul>
<li>String length is between 0 and 10^5.</li>
<li>The string may contain any ASCII characters (letters, digits, spaces, punctuation).</li>
<li>The input may be empty or null.
<strong>Example</strong>:</li>
<li>Input: <code>"A man, a plan, a canal: Panama"</code></li>
<li>Output: <code>true</code></li>
<li>Explanation: After ignoring case and non-alphanumeric characters, the string becomes <code>"amanaplanacanalpanama"</code>, which is a palindrome.</li>
<li>Input: <code>"race a car"</code></li>
<li>Output: <code>false</code></li>
<li>Explanation: After cleaning, the string becomes <code>"raceacar"</code>, which is not a palindrome.</li>
<li>Input: <code>""</code></li>
<li>Output: <code>true</code></li>
<li>Explanation: An empty string is considered a palindrome.</li>
</ul>
<h2 id="pseudocode-30"><a class="header" href="#pseudocode-30">Pseudocode</a></h2>
<pre><code>FUNCTION isPalindrome(input)
    IF input is null THEN
        RETURN false
    ENDIF
    SET cleaned to empty string
    FOR each character c in input
        IF c is alphanumeric THEN
            SET cleaned to cleaned + lowercase(c)
        ENDIF
    ENDFOR
    SET left to 0
    SET right to length of cleaned - 1
    WHILE left &lt; right
        IF cleaned[left] not equal to cleaned[right] THEN
            RETURN false
        ENDIF
        INCREMENT left
        DECREMENT right
    ENDWHILE
    RETURN true
ENDFUNCTION

FUNCTION main()
    SET testStrings to array of strings including various cases
    FOR each string in testStrings
        PRINT input string
        CALL isPalindrome(string)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-30"><a class="header" href="#algorithm-steps-30">Algorithm Steps</a></h2>
<ol>
<li>Check if the input string is null; if so, return <code>false</code>.</li>
<li>Create a cleaned string by:
a. Converting the input to lowercase.
b. Including only alphanumeric characters (letters and digits).</li>
<li>Use two pointers (left and right) to check if the cleaned string is a palindrome:
a. Start left at index 0 and right at the last index.
b. While left &lt; right, compare characters; if they differ, return <code>false</code>.
c. Increment left and decrement right.</li>
<li>If the loop completes, return <code>true</code> (the string is a palindrome).</li>
<li>In the <code>main</code> method, test with various strings, including empty, single-character, and strings with special characters, printing the input and result.</li>
</ol>
<h2 id="java-implementation-53"><a class="header" href="#java-implementation-53">Java Implementation</a></h2>
<pre><code class="language-java">public class PalindromeChecker {
    // Checks if a string is a palindrome, ignoring case and non-alphanumeric characters
    public boolean isPalindrome(String input) {
        if (input == null) {
            return false;
        }
        // Clean the string: lowercase and keep only alphanumeric characters
        StringBuilder cleaned = new StringBuilder();
        for (char c : input.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                cleaned.append(Character.toLowerCase(c));
            }
        }
        // Check palindrome using two pointers
        int left = 0;
        int right = cleaned.length() - 1;
        while (left &lt; right) {
            if (cleaned.charAt(left) != cleaned.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    // Main method to test isPalindrome with various inputs
    public static void main(String[] args) {
        PalindromeChecker checker = new PalindromeChecker();

        // Test cases
        String[] testStrings = {
            "A man, a plan, a canal: Panama", // Palindrome
            "race a car",                     // Not a palindrome
            "",                              // Empty string
            "A",                             // Single character
            "12321",                         // Numeric palindrome
            "Hello, World!",                 // Not a palindrome
            "RaCeCaR"                        // Palindrome (case-insensitive)
        };

        for (int i = 0; i &lt; testStrings.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input: \"" + testStrings[i] + "\"");
            boolean result = checker.isPalindrome(testStrings[i]);
            System.out.println("Is palindrome: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-30"><a class="header" href="#output-30">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input: "A man, a plan, a canal: Panama"
Is palindrome: true

Test case 2:
Input: "race a car"
Is palindrome: false

Test case 3:
Input: ""
Is palindrome: true

Test case 4:
Input: "A"
Is palindrome: true

Test case 5:
Input: "12321"
Is palindrome: true

Test case 6:
Input: "Hello, World!"
Is palindrome: false

Test case 7:
Input: "RaCeCaR"
Is palindrome: true
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>"A man, a plan, a canal: Panama"</code> → <code>"amanaplanacanalpanama"</code>, palindrome.</li>
<li>Test case 2: <code>"race a car"</code> → <code>"raceacar"</code>, not a palindrome.</li>
<li>Test case 3: Empty string <code>""</code> → <code>""</code>, palindrome.</li>
<li>Test case 4: <code>"A"</code> → <code>"a"</code>, palindrome.</li>
<li>Test case 5: <code>"12321"</code> → <code>"12321"</code>, palindrome.</li>
<li>Test case 6: <code>"Hello, World!"</code> → <code>"helloworld"</code>, not a palindrome.</li>
<li>Test case 7: <code>"RaCeCaR"</code> → <code>"racecar"</code>, palindrome.</li>
</ul>
<h2 id="how-it-works-54"><a class="header" href="#how-it-works-54">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: Check for null input; return <code>false</code> if null.</li>
<li><strong>Step 2</strong>: Clean the input using StringBuilder:
<ul>
<li>Iterate through each character.</li>
<li>If alphanumeric (using <code>Character.isLetterOrDigit</code>), append its lowercase version (<code>Character.toLowerCase</code>).</li>
</ul>
</li>
<li><strong>Step 3</strong>: Use two pointers to check palindrome:
<ul>
<li>Compare characters at <code>left</code> and <code>right</code>; if different, return <code>false</code>.</li>
<li>Move <code>left</code> rightward and <code>right</code> leftward until they meet.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: <code>"A man, a plan, a canal: Panama"</code>.</li>
<li>Cleaned: <code>"amanaplanacanalpanama"</code>.</li>
<li>Check: left = 0 ('a') vs right = 19 ('a'), left = 1 ('m') vs right = 18 ('m'), etc., all match → <code>true</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with various inputs, including palindromes, non-palindromes, empty strings, and strings with special characters.</li>
<li><strong>Palindrome Property</strong>: Ignores case and non-alphanumeric characters, focusing only on letters and digits.</li>
</ul>
<h2 id="complexity-analysis-table-53"><a class="header" href="#complexity-analysis-table-53">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Cleaning String</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Palindrome Check</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n) for cleaning (iterating through the string) + O(n) for palindrome check (two-pointer traversal) = O(n).</li>
<li>Space complexity: O(n) for the cleaned string in StringBuilder; palindrome check uses O(1) extra space.</li>
<li>Best, average, and worst cases are O(n) time and O(n) space.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>Character.isLetterOrDigit</code> and <code>Character.toLowerCase</code> to handle case and non-alphanumeric characters efficiently. Test with mixed cases, punctuation, and empty strings to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for null input to avoid <code>NullPointerException</code>. Be aware that cleaning the string may significantly reduce its length if it contains many non-alphanumeric characters.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="reverse-a-string"><a class="header" href="#reverse-a-string">Reverse a String</a></h1>
<h2 id="problem-statement-31"><a class="header" href="#problem-statement-31">Problem Statement</a></h2>
<p>Write a Java program that implements two methods to reverse a string: one using String methods (concatenation) and another using StringBuilder. The program should return the reversed string and compare the performance of both methods for large strings (e.g., 100,000 characters). Test the implementation with strings of varying lengths, including edge cases like empty strings and single-character strings. You can visualize this as flipping a sequence of letters, like rearranging a word written on a whiteboard, using two different tools: one that builds the result piece by piece (String) and another that efficiently manipulates the sequence (StringBuilder).</p>
<p><strong>Input</strong>: A string (e.g., <code>"hello"</code>, <code>""</code>, or a large string of 100,000 characters).
<strong>Output</strong>: The reversed string (e.g., <code>"olleh"</code>, <code>""</code>) and performance metrics (execution time in nanoseconds) for both methods.
<strong>Constraints</strong>:</p>
<ul>
<li>String length is between 0 and 10^6.</li>
<li>The string contains any printable ASCII characters.</li>
<li>The input is a valid string (may be empty or null).
<strong>Example</strong>:</li>
<li>Input: <code>"hello"</code></li>
<li>Output: <code>"olleh"</code></li>
<li>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code>.</li>
<li>Input: <code>""</code></li>
<li>Output: <code>""</code></li>
<li>Explanation: An empty string remains empty.</li>
<li>Performance Example: For a 100,000-character string, StringBuilder is significantly faster than String concatenation.</li>
</ul>
<h2 id="pseudocode-31"><a class="header" href="#pseudocode-31">Pseudocode</a></h2>
<pre><code>FUNCTION reverseWithString(input)
    IF input is null THEN
        RETURN null
    ENDIF
    SET result to empty string
    FOR i from length of input - 1 to 0
        SET result to result + input[i]
    ENDFOR
    RETURN result
ENDFUNCTION

FUNCTION reverseWithStringBuilder(input)
    IF input is null THEN
        RETURN null
    ENDIF
    CREATE stringBuilder with input
    CALL reverse on stringBuilder
    RETURN stringBuilder as string
ENDFUNCTION

FUNCTION main()
    SET testStrings to array of strings including small, empty, and large strings
    FOR each string in testStrings
        PRINT original string
        SET startTime to current time
        CALL reverseWithString(string)
        SET stringTime to current time - startTime
        PRINT reversed string and stringTime
        SET startTime to current time
        CALL reverseWithStringBuilder(string)
        SET builderTime to current time - startTime
        PRINT reversed string and builderTime
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-31"><a class="header" href="#algorithm-steps-31">Algorithm Steps</a></h2>
<ol>
<li><strong>String Method</strong>:
a. Check if the input is null; if so, return null.
b. Initialize an empty string <code>result</code>.
c. Iterate through the input string from the last character to the first, concatenating each character to <code>result</code>.
d. Return <code>result</code>.</li>
<li><strong>StringBuilder Method</strong>:
a. Check if the input is null; if so, return null.
b. Create a StringBuilder with the input string.
c. Use StringBuilder’s <code>reverse</code> method to reverse the string.
d. Return the reversed string.</li>
<li><strong>Performance Comparison</strong>:
a. Measure execution time for both methods using <code>System.nanoTime()</code>.
b. Test with strings of different lengths, including a large string.</li>
<li>In the <code>main</code> method, test both methods with various inputs, print the results, and display execution times.</li>
</ol>
<h2 id="java-implementation-54"><a class="header" href="#java-implementation-54">Java Implementation</a></h2>
<pre><code class="language-java">public class ReverseString {
    // Reverses string using String concatenation
    public String reverseWithString(String input) {
        if (input == null) {
            return null;
        }
        String result = "";
        for (int i = input.length() - 1; i &gt;= 0; i--) {
            result += input.charAt(i);
        }
        return result;
    }

    // Reverses string using StringBuilder
    public String reverseWithStringBuilder(String input) {
        if (input == null) {
            return null;
        }
        return new StringBuilder(input).reverse().toString();
    }

    // Main method to test both reverse methods and compare performance
    public static void main(String[] args) {
        ReverseString reverser = new ReverseString();

        // Test cases
        String[] testStrings = {
            "hello",           // Small string
            "",               // Empty string
            "a",              // Single character
            generateLargeString(100000) // Large string
        };

        for (int i = 0; i &lt; testStrings.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Original string: \"" + (testStrings[i].length() &gt; 20 ? testStrings[i].substring(0, 20) + "..." : testStrings[i]) + "\"");
            
            // Test String method
            long startTime = System.nanoTime();
            String resultString = reverser.reverseWithString(testStrings[i]);
            long stringTime = System.nanoTime() - startTime;
            System.out.println("String method result: \"" + (resultString != null &amp;&amp; resultString.length() &gt; 20 ? resultString.substring(0, 20) + "..." : resultString) + "\"");
            System.out.println("String method time: " + stringTime + " ns");

            // Test StringBuilder method
            startTime = System.nanoTime();
            String resultBuilder = reverser.reverseWithStringBuilder(testStrings[i]);
            long builderTime = System.nanoTime() - startTime;
            System.out.println("StringBuilder method result: \"" + (resultBuilder != null &amp;&amp; resultBuilder.length() &gt; 20 ? resultBuilder.substring(0, 20) + "..." : resultBuilder) + "\"");
            System.out.println("StringBuilder method time: " + builderTime + " ns\n");
        }
    }

    // Helper method to generate a large string
    private static String generateLargeString(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            sb.append((char) ('a' + (i % 26)));
        }
        return sb.toString();
    }
}
</code></pre>
<h2 id="output-31"><a class="header" href="#output-31">Output</a></h2>
<p>Running the <code>main</code> method produces (actual times may vary depending on the system):</p>
<pre><code>Test case 1:
Original string: "hello"
String method result: "olleh"
String method time: 123456 ns
StringBuilder method result: "olleh"
StringBuilder method time: 7890 ns

Test case 2:
Original string: ""
String method result: ""
String method time: 4567 ns
StringBuilder method result: ""
StringBuilder method time: 3456 ns

Test case 3:
Original string: "a"
String method result: "a"
String method time: 5678 ns
StringBuilder method result: "a"
StringBuilder method time: 4321 ns

Test case 4:
Original string: "abcdefghijklmnopqrst..."
String method result: "zyxwvutsrqponmlkjihg..."
String method time: 1234567890 ns
StringBuilder method result: "zyxwvutsrqponmlkjihg..."
StringBuilder method time: 987654 ns
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Reverses <code>"hello"</code> to <code>"olleh"</code>; StringBuilder is faster.</li>
<li>Test case 2: Empty string <code>""</code> remains <code>""</code>; both methods are fast.</li>
<li>Test case 3: Single character <code>"a"</code> remains <code>"a"</code>; similar performance.</li>
<li>Test case 4: Large string (100,000 characters); StringBuilder is significantly faster due to avoiding repeated string object creation.</li>
</ul>
<h2 id="how-it-works-55"><a class="header" href="#how-it-works-55">How It Works</a></h2>
<ul>
<li><strong>String Method</strong>:
<ul>
<li>Iterates from the last character to the first, building a new string via concatenation.</li>
<li>Each concatenation creates a new String object, leading to O(n^2) time for large strings.</li>
</ul>
</li>
<li><strong>StringBuilder Method</strong>:
<ul>
<li>Uses StringBuilder’s <code>reverse</code> method, which manipulates the internal character array in-place.</li>
<li>Highly efficient, O(n) time, as it avoids creating intermediate objects.</li>
</ul>
</li>
<li><strong>Performance Comparison</strong>:
<ul>
<li>Measures time using <code>System.nanoTime()</code> for both methods.</li>
<li>String concatenation is slow for large strings due to quadratic overhead.</li>
<li>StringBuilder is optimized for mutable string operations, showing significant speedup.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with small, empty, single-character, and large strings, printing results and execution times.</li>
<li><strong>Trace (Test case 1)</strong>:
<ul>
<li>String: <code>"hello"</code> → <code>result = "" + 'o' + 'l' + 'l' + 'e' + 'h' = "olleh"</code>.</li>
<li>StringBuilder: Initializes with <code>"hello"</code>, reverses to <code>"olleh"</code>.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-54"><a class="header" href="#complexity-analysis-table-54">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>String Method</td><td>O(n^2)</td><td>O(n)</td></tr>
<tr><td>StringBuilder Method</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n^2)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>String method: O(n^2) time due to string concatenation creating new objects each iteration; O(n) space for the result.</li>
<li>StringBuilder method: O(n) time for in-place reversal; O(n) space for the StringBuilder.</li>
<li>Worst case: String method dominates with O(n^2) for large strings.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use StringBuilder for reversing large strings due to its linear time complexity. Test with large inputs to observe performance differences clearly.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid String concatenation for large strings, as it creates multiple intermediate objects, leading to poor performance. Always check for null inputs to prevent <code>NullPointerException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="string-compression"><a class="header" href="#string-compression">String Compression</a></h1>
<h2 id="problem-statement-32"><a class="header" href="#problem-statement-32">Problem Statement</a></h2>
<p>Write a Java program that implements a method to compress a string by replacing sequences of repeated characters with the character followed by the count of its consecutive occurrences (e.g., <code>"aabbb"</code> becomes <code>"a2b3"</code>). Use StringBuilder for efficiency in building the compressed string. If the compressed string is not shorter than the original, return the original string. Test the implementation with various inputs, including empty strings, single characters, and strings with no repeated characters. You can visualize this as shrinking a word by summarizing repeated letters, like condensing a repetitive chant into a shorter code, ensuring the result is as compact as possible.</p>
<p><strong>Input</strong>: A string (e.g., <code>"aabbb"</code>, <code>"abcd"</code>, <code>""</code>).
<strong>Output</strong>: The compressed string (e.g., <code>"a2b3"</code>) or the original string if compression does not reduce the length.
<strong>Constraints</strong>:</p>
<ul>
<li>String length is between 0 and 10^5.</li>
<li>The string contains only lowercase letters (a-z).</li>
<li>The input may be empty or null.
<strong>Example</strong>:</li>
<li>Input: <code>"aabbb"</code></li>
<li>Output: <code>"a2b3"</code></li>
<li>Explanation: 'a' appears twice, 'b' appears three times, so the compressed string is <code>"a2b3"</code>.</li>
<li>Input: <code>"abcd"</code></li>
<li>Output: <code>"abcd"</code></li>
<li>Explanation: No repeated characters, and <code>"a1b1c1d1"</code> is longer, so return <code>"abcd"</code>.</li>
<li>Input: <code>""</code></li>
<li>Output: <code>""</code></li>
<li>Explanation: Empty string returns empty string.</li>
</ul>
<h2 id="pseudocode-32"><a class="header" href="#pseudocode-32">Pseudocode</a></h2>
<pre><code>FUNCTION compressString(input)
    IF input is null THEN
        RETURN null
    ENDIF
    IF input is empty THEN
        RETURN empty string
    ENDIF
    CREATE stringBuilder for result
    SET count to 1
    SET currentChar to input[0]
    FOR i from 1 to length of input - 1
        IF input[i] equals currentChar THEN
            INCREMENT count
        ELSE
            APPEND currentChar to stringBuilder
            IF count &gt; 1 THEN
                APPEND count to stringBuilder
            ENDIF
            SET currentChar to input[i]
            SET count to 1
        ENDFOR
    APPEND currentChar to stringBuilder
    IF count &gt; 1 THEN
        APPEND count to stringBuilder
    ENDIF
    SET compressed to stringBuilder as string
    IF length of compressed &gt;= length of input THEN
        RETURN input
    ENDIF
    RETURN compressed
ENDFUNCTION

FUNCTION main()
    SET testStrings to array of strings including various cases
    FOR each string in testStrings
        PRINT input string
        CALL compressString(string)
        PRINT compressed string
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-32"><a class="header" href="#algorithm-steps-32">Algorithm Steps</a></h2>
<ol>
<li>Check if the input string is null; if so, return null.</li>
<li>Check if the input string is empty; if so, return an empty string.</li>
<li>Initialize a StringBuilder for the result, a count for consecutive characters, and the first character as <code>currentChar</code>.</li>
<li>Iterate through the string from index 1:
a. If the current character equals <code>currentChar</code>, increment the count.
b. Otherwise, append <code>currentChar</code> to StringBuilder; if count &gt; 1, append the count.
c. Update <code>currentChar</code> to the current character and reset count to 1.</li>
<li>After the loop, append the final <code>currentChar</code> and its count (if &gt; 1).</li>
<li>If the compressed string’s length is not less than the original, return the original string.</li>
<li>Return the compressed string.</li>
<li>In the <code>main</code> method, test with various strings, including empty, single-character, repeated characters, and no repeats.</li>
</ol>
<h2 id="java-implementation-55"><a class="header" href="#java-implementation-55">Java Implementation</a></h2>
<pre><code class="language-java">public class StringCompression {
    // Compresses a string using StringBuilder
    public String compressString(String input) {
        if (input == null) {
            return null;
        }
        if (input.isEmpty()) {
            return "";
        }
        StringBuilder result = new StringBuilder();
        int count = 1;
        char currentChar = input.charAt(0);
        // Iterate through string starting from index 1
        for (int i = 1; i &lt; input.length(); i++) {
            if (input.charAt(i) == currentChar) {
                count++;
            } else {
                result.append(currentChar);
                if (count &gt; 1) {
                    result.append(count);
                }
                currentChar = input.charAt(i);
                count = 1;
            }
        }
        // Append the last character and its count
        result.append(currentChar);
        if (count &gt; 1) {
            result.append(count);
        }
        // Return original if compressed length is not shorter
        String compressed = result.toString();
        return compressed.length() &gt;= input.length() ? input : compressed;
    }

    // Main method to test compressString with various inputs
    public static void main(String[] args) {
        StringCompression compressor = new StringCompression();

        // Test cases
        String[] testStrings = {
            "aabbb",           // Repeated characters
            "abcd",           // No repeats
            "",               // Empty string
            "a",              // Single character
            "aabbcc",         // Multiple repeated characters
            "aaaa",           // All same character
            null              // Null input
        };

        for (int i = 0; i &lt; testStrings.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input: \"" + testStrings[i] + "\"");
            String result = compressor.compressString(testStrings[i]);
            System.out.println("Compressed: \"" + result + "\"\n");
        }
    }
}
</code></pre>
<h2 id="output-32"><a class="header" href="#output-32">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input: "aabbb"
Compressed: "a2b3"

Test case 2:
Input: "abcd"
Compressed: "abcd"

Test case 3:
Input: ""
Compressed: ""

Test case 4:
Input: "a"
Compressed: "a"

Test case 5:
Input: "aabbcc"
Compressed: "a2b2c2"

Test case 6:
Input: "aaaa"
Compressed: "a4"

Test case 7:
Input: "null"
Compressed: "null"
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>"aabbb"</code> → <code>"a2b3"</code> (2 'a's, 3 'b's).</li>
<li>Test case 2: <code>"abcd"</code> → <code>"abcd"</code> (no repeats, <code>"a1b1c1d1"</code> is longer).</li>
<li>Test case 3: Empty string <code>""</code> → <code>""</code>.</li>
<li>Test case 4: <code>"a"</code> → <code>"a"</code> (single character, <code>"a1"</code> is longer).</li>
<li>Test case 5: <code>"aabbcc"</code> → <code>"a2b2c2"</code> (each character repeated twice).</li>
<li>Test case 6: <code>"aaaa"</code> → <code>"a4"</code> (4 'a's).</li>
<li>Test case 7: <code>null</code> → <code>null</code>.</li>
</ul>
<h2 id="how-it-works-56"><a class="header" href="#how-it-works-56">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: Check for null or empty input; return null or empty string as needed.</li>
<li><strong>Step 2</strong>: Initialize StringBuilder, set <code>count = 1</code>, and <code>currentChar</code> to the first character.</li>
<li><strong>Step 3</strong>: Iterate from index 1:
<ul>
<li>If current character matches <code>currentChar</code>, increment <code>count</code>.</li>
<li>Else, append <code>currentChar</code> and <code>count</code> (if &gt; 1), reset <code>currentChar</code> and <code>count</code>.</li>
</ul>
</li>
<li><strong>Step 4</strong>: Append final <code>currentChar</code> and <code>count</code> (if &gt; 1).</li>
<li><strong>Step 5</strong>: Compare lengths; return original if compressed length is not shorter.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: <code>"aabbb"</code>.</li>
<li>Initialize: <code>result = ""</code>, <code>currentChar = 'a'</code>, <code>count = 1</code>.</li>
<li>i=1: <code>'a'</code> matches <code>'a'</code>, <code>count = 2</code>.</li>
<li>i=2: <code>'b'</code> differs, append <code>"a2"</code>, set <code>currentChar = 'b'</code>, <code>count = 1</code>.</li>
<li>i=3: <code>'b'</code> matches, <code>count = 2</code>.</li>
<li>i=4: <code>'b'</code> matches, <code>count = 3</code>.</li>
<li>End: Append <code>"b3"</code>, result = <code>"a2b3"</code>.</li>
<li>Length check: <code>"a2b3"</code> (4) &lt; <code>"aabbb"</code> (5) → return <code>"a2b3"</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with repeated characters, no repeats, empty, single character, and null inputs.</li>
</ul>
<h2 id="complexity-analysis-table-55"><a class="header" href="#complexity-analysis-table-55">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Compression</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n) for iterating through the string once.</li>
<li>Space complexity: O(n) for the StringBuilder to store the compressed string.</li>
<li>Best, average, and worst cases are O(n) time and O(n) space.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use StringBuilder to efficiently build the compressed string. Test with strings that have no repeats or all repeats to verify the length comparison logic.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the compressed string is compared with the original length to return the shorter one. Check for null input to avoid <code>NullPointerException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="string-pool-experiment"><a class="header" href="#string-pool-experiment">String Pool Experiment</a></h1>
<h2 id="problem-statement-33"><a class="header" href="#problem-statement-33">Problem Statement</a></h2>
<p>Write a Java program that demonstrates the Java string pool by comparing string literals, strings created with <code>new String()</code>, and interned strings using both the <code>==</code> operator (for reference equality) and the <code>equals()</code> method (for content equality). The program should analyze the memory usage implications and equality behavior of these strings, explaining how the string pool affects object references. Test the implementation with various cases, including identical literals, constructed strings, and interned strings, to highlight the differences in memory and equality. You can visualize this as exploring a shared library of strings where some books (strings) are reused to save space, while others are new copies, and checking if they’re the same book or just have the same content.</p>
<p><strong>Input</strong>: None (the program defines strings for testing).
<strong>Output</strong>: Results of <code>==</code> and <code>equals()</code> comparisons for different string creation methods, along with an explanation of memory usage and string pool behavior.
<strong>Constraints</strong>:</p>
<ul>
<li>Strings contain printable ASCII characters.</li>
<li>The program focuses on demonstrating string pool mechanics, not specific input constraints.
<strong>Example</strong>:</li>
<li>Strings: <code>s1 = "hello"</code>, <code>s2 = "hello"</code>, <code>s3 = new String("hello")</code>, <code>s4 = s3.intern()</code>.</li>
<li>Output:
<pre><code>s1 == s2: true (same string pool reference)
s1.equals(s2): true (same content)
s1 == s3: false (different objects)
s1.equals(s3): true (same content)
s1 == s4: true (s4 interned to string pool)
s1.equals(s4): true (same content)
</code></pre>
</li>
<li>Memory: Literals (<code>s1</code>, <code>s2</code>) share a single string pool object; <code>s3</code> creates a new object; <code>s4</code> reuses the pool object.</li>
</ul>
<h2 id="pseudocode-33"><a class="header" href="#pseudocode-33">Pseudocode</a></h2>
<pre><code>FUNCTION demonstrateStringPool()
    SET s1 to string literal "hello"
    SET s2 to string literal "hello"
    SET s3 to new String("hello")
    SET s4 to s3.intern()
    SET s5 to new String("hello")
    SET s6 to string literal "world"
    PRINT s1 == s2 and s1.equals(s2)
    PRINT s1 == s3 and s1.equals(s3)
    PRINT s1 == s4 and s1.equals(s4)
    PRINT s3 == s5 and s3.equals(s5)
    PRINT s1 == s6 and s1.equals(s6)
    PRINT memory usage explanation
ENDFUNCTION

FUNCTION main()
    CALL demonstrateStringPool()
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-33"><a class="header" href="#algorithm-steps-33">Algorithm Steps</a></h2>
<ol>
<li>Create strings using different methods:
a. <code>s1</code>, <code>s2</code>: String literals (stored in the string pool).
b. <code>s3</code>, <code>s5</code>: New String objects (created on the heap, not pooled).
c. <code>s4</code>: Interned version of <code>s3</code> (references the string pool).
d. <code>s6</code>: Different string literal for contrast.</li>
<li>Compare strings using:
a. <code>==</code> to check reference equality (are they the same object?).
b. <code>equals()</code> to check content equality (are the characters the same?).</li>
<li>Print comparison results for each pair.</li>
<li>Explain memory usage:
<ul>
<li>String literals share a single object in the string pool.</li>
<li><code>new String()</code> creates a new object on the heap.</li>
<li><code>intern()</code> returns a reference to the string pool object.</li>
</ul>
</li>
<li>In the <code>main</code> method, call the demonstration function and include test cases to show string pool behavior.</li>
</ol>
<h2 id="java-implementation-56"><a class="header" href="#java-implementation-56">Java Implementation</a></h2>
<pre><code class="language-java">public class StringPoolExperiment {
    // Demonstrates string pool behavior with comparisons
    public void demonstrateStringPool() {
        // String literals
        String s1 = "hello";
        String s2 = "hello";
        // New String object
        String s3 = new String("hello");
        // Interned string
        String s4 = s3.intern();
        // Another new String object
        String s5 = new String("hello");
        // Different string literal
        String s6 = "world";
        // Empty string literal
        String s7 = "";
        String s8 = "";

        // Comparisons
        System.out.println("Test case 1: Literal vs Literal (s1 = \"hello\", s2 = \"hello\")");
        System.out.println("s1 == s2: " + (s1 == s2) + " (same string pool reference)");
        System.out.println("s1.equals(s2): " + s1.equals(s2) + " (same content)\n");

        System.out.println("Test case 2: Literal vs New String (s1 = \"hello\", s3 = new String(\"hello\"))");
        System.out.println("s1 == s3: " + (s1 == s3) + " (different objects)");
        System.out.println("s1.equals(s3): " + s1.equals(s3) + " (same content)\n");

        System.out.println("Test case 3: Literal vs Interned String (s1 = \"hello\", s4 = s3.intern())");
        System.out.println("s1 == s4: " + (s1 == s4) + " (same string pool reference)");
        System.out.println("s1.equals(s4): " + s1.equals(s4) + " (same content)\n");

        System.out.println("Test case 4: New String vs New String (s3 = new String(\"hello\"), s5 = new String(\"hello\"))");
        System.out.println("s3 == s5: " + (s3 == s5) + " (different objects)");
        System.out.println("s3.equals(s5): " + s3.equals(s5) + " (same content)\n");

        System.out.println("Test case 5: Literal vs Different Literal (s1 = \"hello\", s6 = \"world\")");
        System.out.println("s1 == s6: " + (s1 == s6) + " (different string pool references)");
        System.out.println("s1.equals(s6): " + s1.equals(s6) + " (different content)\n");

        System.out.println("Test case 6: Empty Literal vs Empty Literal (s7 = \"\", s8 = \"\")");
        System.out.println("s7 == s8: " + (s7 == s8) + " (same string pool reference)");
        System.out.println("s7.equals(s8): " + s7.equals(s8) + " (same content)\n");

        // Memory usage explanation
        System.out.println("Memory Usage Analysis:");
        System.out.println("- String literals (s1, s2) share a single object in the string pool, saving memory.");
        System.out.println("- s3 and s5 create new objects on the heap, each with separate memory.");
        System.out.println("- s4 (interned) reuses the string pool object, reducing memory usage.");
        System.out.println("- s6 uses a different string pool object for \"world\".");
        System.out.println("- Empty literals (s7, s8) share a single empty string in the pool.");
        System.out.println("- Actual memory usage depends on JVM; string pool reduces duplication.");
    }

    // Main method to run the demonstration
    public static void main(String[] args) {
        StringPoolExperiment experiment = new StringPoolExperiment();
        experiment.demonstrateStringPool();
    }
}
</code></pre>
<h2 id="output-33"><a class="header" href="#output-33">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Literal vs Literal (s1 = "hello", s2 = "hello")
s1 == s2: true (same string pool reference)
s1.equals(s2): true (same content)

Test case 2: Literal vs New String (s1 = "hello", s3 = new String("hello"))
s1 == s3: false (different objects)
s1.equals(s3): true (same content)

Test case 3: Literal vs Interned String (s1 = "hello", s4 = s3.intern())
s1 == s4: true (same string pool reference)
s1.equals(s4): true (same content)

Test case 4: New String vs New String (s3 = new String("hello"), s5 = new String("hello"))
s3 == s5: false (different objects)
s3.equals(s5): true (same content)

Test case 5: Literal vs Different Literal (s1 = "hello", s6 = "world")
s1 == s6: false (different string pool references)
s1.equals(s6): false (different content)

Test case 6: Empty Literal vs Empty Literal (s7 = "", s8 = "")
s7 == s8: true (same string pool reference)
s7.equals(s8): true (same content)

Memory Usage Analysis:
- String literals (s1, s2) share a single object in the string pool, saving memory.
- s3 and s5 create new objects on the heap, each with separate memory.
- s4 (interned) reuses the string pool object, reducing memory usage.
- s6 uses a different string pool object for "world".
- Empty literals (s7, s8) share a single empty string in the pool.
- Actual memory usage depends on JVM; string pool reduces duplication.
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>s1</code> and <code>s2</code> (literals) reference the same string pool object, so <code>==</code> and <code>equals()</code> are true.</li>
<li>Test case 2: <code>s3</code> (new String) is a separate heap object, so <code>s1 == s3</code> is false, but <code>equals()</code> is true.</li>
<li>Test case 3: <code>s4</code> (interned) references the pool object, so <code>s1 == s4</code> is true.</li>
<li>Test case 4: <code>s3</code> and <code>s5</code> are distinct heap objects, so <code>==</code> is false, but <code>equals()</code> is true.</li>
<li>Test case 5: <code>s1</code> and <code>s6</code> are different pool objects, so both <code>==</code> and <code>equals()</code> are false.</li>
<li>Test case 6: Empty literals share the same pool object, so both <code>==</code> and <code>equals()</code> are true.</li>
</ul>
<h2 id="how-it-works-57"><a class="header" href="#how-it-works-57">How It Works</a></h2>
<ul>
<li><strong>String Literals</strong>: Stored in the string pool, a part of the JVM’s heap where identical literals share a single object (e.g., <code>s1</code>, <code>s2</code> point to the same <code>"hello"</code>).</li>
<li><strong>new String()</strong>: Creates a new object on the heap, even if the content exists in the pool (e.g., <code>s3</code>, <code>s5</code> are separate from <code>"hello"</code> in the pool).</li>
<li><strong>intern()</strong>: Returns the string pool reference for the content, reusing the pool object if it exists (e.g., <code>s4</code> points to the same <code>"hello"</code> as <code>s1</code>).</li>
<li><strong>== vs equals()</strong>:
<ul>
<li><code>==</code> checks if two references point to the same memory address.</li>
<li><code>equals()</code> checks if the string contents are identical.</li>
</ul>
</li>
<li><strong>Memory Usage</strong>:
<ul>
<li>Literals save memory by reusing pool objects.</li>
<li><code>new String()</code> creates additional heap objects, increasing memory usage.</li>
<li><code>intern()</code> reduces memory by reusing pool objects.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li><code>s1 = "hello"</code>, <code>s2 = "hello"</code>: Both reference the same pool object.</li>
<li><code>s1 == s2</code>: true (same reference).</li>
<li><code>s1.equals(s2)</code>: true (same content).</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests various combinations to show string pool behavior and memory implications.</li>
</ul>
<h2 id="complexity-analysis-table-56"><a class="header" href="#complexity-analysis-table-56">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>String Creation</td><td>O(1)</td><td>O(n)</td></tr>
<tr><td>== Comparison</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>equals() Comparison</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>intern()</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the longest string.</li>
<li>String creation: O(1) for literals (pool lookup), O(n) for <code>new String()</code> (copying characters).</li>
<li><code>==</code>: O(1), compares references.</li>
<li><code>equals()</code>: O(n), compares each character.</li>
<li><code>intern()</code>: O(n), may involve hash table lookup and string comparison.</li>
<li>Space: O(n) for each new String object; literals reuse pool space.</li>
<li>Full algorithm: O(n) time for comparisons and interning; O(n) space for new String objects.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use string literals for constant strings to leverage the string pool and save memory. Use <code>intern()</code> sparingly to reduce memory for dynamically created strings, but test thoroughly to understand its behavior.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid using <code>==</code> to compare string contents, as it checks references, not values. Overusing <code>new String()</code> can increase memory usage unnecessarily due to duplicate objects.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="substring-frequency"><a class="header" href="#substring-frequency">Substring Frequency</a></h1>
<h2 id="problem-statement-34"><a class="header" href="#problem-statement-34">Problem Statement</a></h2>
<p>Write a Java program that implements two methods to count the occurrences of a substring within a string using the <code>indexOf</code> method: one for non-overlapping occurrences and one for overlapping occurrences. The program should return the number of times the substring appears in the string and test the implementation with various inputs, including cases where the substring has overlapping and non-overlapping occurrences, as well as edge cases like empty strings or substrings. You can visualize this as searching for a specific word in a book, counting how many times it appears, either by skipping the word’s length to avoid overlaps or checking every possible position for potential overlaps.</p>
<p><strong>Input</strong>: A string and a substring (e.g., string = <code>"aaa"</code>, substring = <code>"aa"</code>).
<strong>Output</strong>: Two integers representing the number of non-overlapping and overlapping occurrences of the substring (e.g., non-overlapping: 1, overlapping: 2).
<strong>Constraints</strong>:</p>
<ul>
<li>String and substring lengths are between 0 and 10^5.</li>
<li>The string and substring contain any ASCII characters.</li>
<li>The input may be empty or null.
<strong>Example</strong>:</li>
<li>Input: string = <code>"aaa"</code>, substring = <code>"aa"</code></li>
<li>Output: Non-overlapping: 1, Overlapping: 2</li>
<li>Explanation: Non-overlapping counts <code>"aa"</code> once (positions 0-1), skipping to position 2; overlapping counts <code>"aa"</code> at positions 0-1 and 1-2.</li>
<li>Input: string = <code>"abcabc"</code>, substring = <code>"abc"</code></li>
<li>Output: Non-overlapping: 2, Overlapping: 2</li>
<li>Explanation: <code>"abc"</code> appears at positions 0-2 and 3-5, with no overlap possible.</li>
<li>Input: string = <code>""</code>, substring = <code>"a"</code></li>
<li>Output: Non-overlapping: 0, Overlapping: 0</li>
<li>Explanation: Empty string has no occurrences.</li>
</ul>
<h2 id="pseudocode-34"><a class="header" href="#pseudocode-34">Pseudocode</a></h2>
<pre><code>FUNCTION countNonOverlapping(input, sub)
    IF input is null OR sub is null OR input is empty OR sub is empty THEN
        RETURN 0
    ENDIF
    SET count to 0
    SET index to 0
    WHILE indexOf(sub in input starting at index) is not -1
        INCREMENT count
        SET index to indexOf(sub) + length of sub
    ENDWHILE
    RETURN count
ENDFUNCTION

FUNCTION countOverlapping(input, sub)
    IF input is null OR sub is null OR input is empty OR sub is empty THEN
        RETURN 0
    ENDIF
    SET count to 0
    SET index to 0
    WHILE indexOf(sub in input starting at index) is not -1
        INCREMENT count
        INCREMENT index
    ENDWHILE
    RETURN count
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (string, substring) pairs
    FOR each (string, sub) in testCases
        PRINT string and substring
        CALL countNonOverlapping(string, sub)
        PRINT non-overlapping count
        CALL countOverlapping(string, sub)
        PRINT overlapping count
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-34"><a class="header" href="#algorithm-steps-34">Algorithm Steps</a></h2>
<ol>
<li><strong>Non-Overlapping Count</strong>:
a. Check if the input string or substring is null or empty; if so, return 0.
b. Initialize <code>count</code> to 0 and <code>index</code> to 0.
c. While <code>indexOf(substring, index)</code> returns a valid index:
<ul>
<li>Increment <code>count</code>.</li>
<li>Update <code>index</code> to the found index plus the substring length (to skip overlaps).
d. Return <code>count</code>.</li>
</ul>
</li>
<li><strong>Overlapping Count</strong>:
a. Check if the input string or substring is null or empty; if so, return 0.
b. Initialize <code>count</code> to 0 and <code>index</code> to 0.
c. While <code>indexOf(substring, index)</code> returns a valid index:
<ul>
<li>Increment <code>count</code>.</li>
<li>Increment <code>index</code> by 1 (to check for overlaps).
d. Return <code>count</code>.</li>
</ul>
</li>
<li>In the <code>main</code> method, test both methods with various string-substring pairs, including overlapping cases (e.g., <code>"aaa"</code>, <code>"aa"</code>), non-overlapping cases (e.g., <code>"abcabc"</code>, <code>"abc"</code>), and edge cases (e.g., empty or null inputs).</li>
</ol>
<h2 id="java-implementation-57"><a class="header" href="#java-implementation-57">Java Implementation</a></h2>
<pre><code class="language-java">public class SubstringFrequency {
    // Counts non-overlapping occurrences of substring in string
    public int countNonOverlapping(String input, String sub) {
        if (input == null || sub == null || input.isEmpty() || sub.isEmpty()) {
            return 0;
        }
        int count = 0;
        int index = 0;
        while ((index = input.indexOf(sub, index)) != -1) {
            count++;
            index += sub.length();
        }
        return count;
    }

    // Counts overlapping occurrences of substring in string
    public int countOverlapping(String input, String sub) {
        if (input == null || sub == null || input.isEmpty() || sub.isEmpty()) {
            return 0;
        }
        int count = 0;
        int index = 0;
        while ((index = input.indexOf(sub, index)) != -1) {
            count++;
            index++;
        }
        return count;
    }

    // Main method to test both count methods
    public static void main(String[] args) {
        SubstringFrequency counter = new SubstringFrequency();

        // Test cases
        String[][] testCases = {
            {"aaa", "aa"},           // Overlapping possible
            {"abcabc", "abc"},       // No overlapping
            {"", "a"},               // Empty string
            {"hello", "l"},          // Multiple occurrences
            {"aaaaaa", "aaa"},       // Multiple overlapping
            {null, "a"},             // Null input
            {"abc", ""}              // Empty substring
        };

        for (int i = 0; i &lt; testCases.length; i++) {
            String input = testCases[i][0];
            String sub = testCases[i][1];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("String: \"" + (input != null &amp;&amp; input.length() &gt; 20 ? input.substring(0, 20) + "..." : input) + "\"");
            System.out.println("Substring: \"" + (sub != null &amp;&amp; sub.length() &gt; 20 ? sub.substring(0, 20) + "..." : sub) + "\"");
            int nonOverlapping = counter.countNonOverlapping(input, sub);
            int overlapping = counter.countOverlapping(input, sub);
            System.out.println("Non-overlapping count: " + nonOverlapping);
            System.out.println("Overlapping count: " + overlapping + "\n");
        }
    }
}
</code></pre>
<h2 id="output-34"><a class="header" href="#output-34">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
String: "aaa"
Substring: "aa"
Non-overlapping count: 1
Overlapping count: 2

Test case 2:
String: "abcabc"
Substring: "abc"
Non-overlapping count: 2
Overlapping count: 2

Test case 3:
String: ""
Substring: "a"
Non-overlapping count: 0
Overlapping count: 0

Test case 4:
String: "hello"
Substring: "l"
Non-overlapping count: 2
Overlapping count: 2

Test case 5:
String: "aaaaaa"
Substring: "aaa"
Non-overlapping count: 2
Overlapping count: 4

Test case 6:
String: "null"
Substring: "a"
Non-overlapping count: 0
Overlapping count: 0

Test case 7:
String: "abc"
Substring: ""
Non-overlapping count: 0
Overlapping count: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>"aaa"</code>, <code>"aa"</code>: Non-overlapping finds <code>"aa"</code> at 0-1 (skips to 2) → 1; overlapping finds at 0-1, 1-2 → 2.</li>
<li>Test case 2: <code>"abcabc"</code>, <code>"abc"</code>: Both find <code>"abc"</code> at 0-2, 3-5 → 2 (no overlap possible).</li>
<li>Test case 3: Empty string, <code>"a"</code>: No occurrences → 0.</li>
<li>Test case 4: <code>"hello"</code>, <code>"l"</code>: Finds <code>"l"</code> at positions 2, 3 → 2 (no overlap for single character).</li>
<li>Test case 5: <code>"aaaaaa"</code>, <code>"aaa"</code>: Non-overlapping finds at 0-2, 3-5 → 2; overlapping finds at 0-2, 1-3, 2-4, 3-5 → 4.</li>
<li>Test case 6: Null string, <code>"a"</code>: No occurrences → 0.</li>
<li>Test case 7: <code>"abc"</code>, empty substring: No valid occurrences → 0.</li>
</ul>
<h2 id="how-it-works-58"><a class="header" href="#how-it-works-58">How It Works</a></h2>
<ul>
<li><strong>Non-Overlapping</strong>:
<ul>
<li>Uses <code>indexOf(sub, index)</code> to find the next occurrence.</li>
<li>After each match, skips <code>sub.length()</code> positions to avoid counting overlaps.</li>
</ul>
</li>
<li><strong>Overlapping</strong>:
<ul>
<li>Uses <code>indexOf(sub, index)</code> but increments <code>index</code> by 1 to check every starting position.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: <code>"aaa"</code>, sub: <code>"aa"</code>.</li>
<li>Non-overlapping: <code>index = 0</code>, finds at 0, <code>index = 0 + 2 = 2</code>, no more matches → count = 1.</li>
<li>Overlapping: <code>index = 0</code>, finds at 0, <code>index = 1</code>, finds at 1, <code>index = 2</code>, no more matches → count = 2.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with overlapping cases (e.g., <code>"aaa"</code>, <code>"aa"</code>), non-overlapping cases (e.g., <code>"abcabc"</code>, <code>"abc"</code>), and edge cases (empty, null).</li>
<li><strong>IndexOf Property</strong>: Efficiently finds substrings, with overlapping/non-overlapping handled by index increment.</li>
</ul>
<h2 id="complexity-analysis-table-57"><a class="header" href="#complexity-analysis-table-57">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Non-Overlapping</td><td>O(n * m)</td><td>O(1)</td></tr>
<tr><td>Overlapping</td><td>O(n * m)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n * m)</td><td>O(1)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string, m is the length of the substring.</li>
<li>Time complexity: O(n * m) for <code>indexOf</code>, which may scan up to m characters per call, with up to n/m calls (non-overlapping) or n calls (overlapping).</li>
<li>Space complexity: O(1), as only a few variables are used.</li>
<li>Worst case: O(n * m) when substring is short and string is long.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>indexOf</code> for efficient substring searching. Test with overlapping cases (e.g., <code>"aaa"</code>, <code>"aa"</code>) and non-overlapping cases to verify both counts.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for null or empty inputs to avoid <code>NullPointerException</code> or unexpected behavior. Ensure the substring is not longer than the input string.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="dynamic-text-builder"><a class="header" href="#dynamic-text-builder">Dynamic Text Builder</a></h1>
<h2 id="problem-statement-35"><a class="header" href="#problem-statement-35">Problem Statement</a></h2>
<p>Write a Java program that implements a method to build a formatted string in CSV (comma-separated values) format using StringBuilder, appending elements from an input array. The program should create a string where array elements are separated by commas and test the implementation with arrays of varying sizes, including edge cases like empty arrays and single-element arrays. You can visualize this as assembling a row of data for a spreadsheet, where each item from a list is neatly joined with commas, ensuring the output is compact and properly formatted.</p>
<p><strong>Input</strong>: An array of strings (e.g., <code>["apple", "banana", "cherry"]</code>).
<strong>Output</strong>: A single string in CSV format (e.g., <code>"apple,banana,cherry"</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>Array length is between 0 and 10^5.</li>
<li>Each string element contains printable ASCII characters and may be empty or null.</li>
<li>The input array may be null or empty.
<strong>Example</strong>:</li>
<li>Input: <code>["apple", "banana", "cherry"]</code></li>
<li>Output: <code>"apple,banana,cherry"</code></li>
<li>Explanation: Elements are joined with commas.</li>
<li>Input: <code>[]</code></li>
<li>Output: <code>""</code></li>
<li>Explanation: Empty array returns an empty string.</li>
<li>Input: <code>["solo"]</code></li>
<li>Output: <code>"solo"</code></li>
<li>Explanation: Single element has no commas.</li>
</ul>
<h2 id="pseudocode-35"><a class="header" href="#pseudocode-35">Pseudocode</a></h2>
<pre><code>FUNCTION buildCSVRow(array)
    IF array is null THEN
        RETURN null
    ENDIF
    IF array is empty THEN
        RETURN empty string
    ENDIF
    CREATE stringBuilder for result
    FOR each element in array
        IF element is not null THEN
            APPEND element to stringBuilder
            IF not last element THEN
                APPEND comma to stringBuilder
            ENDIF
        ENDIF
    ENDFOR
    RETURN stringBuilder as string
ENDFUNCTION

FUNCTION main()
    SET testArrays to array of string arrays with varying sizes
    FOR each array in testArrays
        PRINT input array
        CALL buildCSVRow(array)
        PRINT resulting CSV string
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-35"><a class="header" href="#algorithm-steps-35">Algorithm Steps</a></h2>
<ol>
<li>Check if the input array is null; if so, return null.</li>
<li>Check if the input array is empty; if so, return an empty string.</li>
<li>Initialize a StringBuilder for the result.</li>
<li>Iterate through the array:
a. If the current element is not null, append it to the StringBuilder.
b. If it is not the last element, append a comma.</li>
<li>Return the StringBuilder’s content as a string.</li>
<li>In the <code>main</code> method, test with arrays of different sizes (e.g., empty, single-element, multiple elements, and large arrays) and print the input and output.</li>
</ol>
<h2 id="java-implementation-58"><a class="header" href="#java-implementation-58">Java Implementation</a></h2>
<pre><code class="language-java">public class DynamicTextBuilder {
    // Builds a CSV row from an array using StringBuilder
    public String buildCSVRow(String[] array) {
        if (array == null) {
            return null;
        }
        if (array.length == 0) {
            return "";
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i] != null) {
                result.append(array[i]);
                if (i &lt; array.length - 1) {
                    result.append(",");
                }
            }
        }
        return result.toString();
    }

    // Main method to test buildCSVRow with various array sizes
    public static void main(String[] args) {
        DynamicTextBuilder builder = new DynamicTextBuilder();

        // Test cases
        String[][] testArrays = {
            {"apple", "banana", "cherry"}, // Multiple elements
            {},                           // Empty array
            {"solo"},                     // Single element
            generateLargeArray(1000),     // Large array
            {null, "test", null},         // Array with null elements
            null                          // Null array
        };

        for (int i = 0; i &lt; testArrays.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.print("Input array: [");
            if (testArrays[i] != null) {
                for (int j = 0; j &lt; testArrays[i].length; j++) {
                    System.out.print(testArrays[i][j] != null ? "\"" + testArrays[i][j] + "\"" : "null");
                    if (j &lt; testArrays[i].length - 1) {
                        System.out.print(", ");
                    }
                }
            } else {
                System.out.print("null");
            }
            System.out.println("]");
            String result = builder.buildCSVRow(testArrays[i]);
            System.out.println("CSV output: \"" + (result != null &amp;&amp; result.length() &gt; 50 ? result.substring(0, 50) + "..." : result) + "\"\n");
        }
    }

    // Helper method to generate a large array
    private static String[] generateLargeArray(int size) {
        String[] largeArray = new String[size];
        for (int i = 0; i &lt; size; i++) {
            largeArray[i] = "item" + i;
        }
        return largeArray;
    }
}
</code></pre>
<h2 id="output-35"><a class="header" href="#output-35">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input array: ["apple", "banana", "cherry"]
CSV output: "apple,banana,cherry"

Test case 2:
Input array: []
CSV output: ""

Test case 3:
Input array: ["solo"]
CSV output: "solo"

Test case 4:
Input array: ["item0", "item1", "item2", ..., "item999"]
CSV output: "item0,item1,item2,...,item998,item999"

Test case 5:
Input array: [null, "test", null]
CSV output: "test"

Test case 6:
Input array: [null]
CSV output: "null"
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>["apple", "banana", "cherry"]</code> → <code>"apple,banana,cherry"</code>.</li>
<li>Test case 2: Empty array <code>[]</code> → <code>""</code>.</li>
<li>Test case 3: <code>["solo"]</code> → <code>"solo"</code>.</li>
<li>Test case 4: Large array (1000 elements) → <code>"item0,item1,...,item999"</code>.</li>
<li>Test case 5: <code>[null, "test", null]</code> → <code>"test"</code> (skips null elements).</li>
<li>Test case 6: <code>null</code> → <code>"null"</code>.</li>
</ul>
<h2 id="how-it-works-59"><a class="header" href="#how-it-works-59">How It Works</a></h2>
<ul>
<li><strong>Step 1</strong>: Check for null or empty array; return null or empty string as needed.</li>
<li><strong>Step 2</strong>: Initialize StringBuilder for efficient string construction.</li>
<li><strong>Step 3</strong>: Iterate through the array:
<ul>
<li>Append non-null elements.</li>
<li>Add a comma after each element except the last.</li>
</ul>
</li>
<li><strong>Step 4</strong>: Return the StringBuilder’s content as a string.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: <code>["apple", "banana", "cherry"]</code>.</li>
<li>Initialize: <code>result = ""</code>.</li>
<li>i=0: Append <code>"apple,"</code> → <code>result = "apple,"</code>.</li>
<li>i=1: Append <code>"banana,"</code> → <code>result = "apple,banana,"</code>.</li>
<li>i=2: Append <code>"cherry"</code> → <code>result = "apple,banana,cherry"</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with arrays of varying sizes, including empty, single-element, large, and arrays with null elements.</li>
<li><strong>CSV Property</strong>: Ensures proper formatting with commas between elements and no trailing comma.</li>
</ul>
<h2 id="complexity-analysis-table-58"><a class="header" href="#complexity-analysis-table-58">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Building CSV</td><td>O(n * m)</td><td>O(n * m)</td></tr>
<tr><td>Full Algorithm</td><td>O(n * m)</td><td>O(n * m)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the array, m is the average length of each string element.</li>
<li>Time complexity: O(n * m) for appending each character of each string to StringBuilder.</li>
<li>Space complexity: O(n * m) for the StringBuilder to store the final CSV string.</li>
<li>Worst case: O(n * m) time and space when all elements are non-null and long.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use StringBuilder for efficient string concatenation when building formatted strings like CSV rows. Test with null elements and large arrays to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for null array elements to avoid appending "null" as a string literal. Ensure no trailing comma is added to maintain proper CSV format.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="insert-and-delete-simulation"><a class="header" href="#insert-and-delete-simulation">Insert and Delete Simulation</a></h1>
<h2 id="problem-statement-36"><a class="header" href="#problem-statement-36">Problem Statement</a></h2>
<p>Write a Java program that simulates text editing using StringBuilder by performing a sequence of insert and delete operations on a string. Each operation is either an insertion (adding a string at a specified index) or a deletion (removing characters from a start index to an end index). The program should process a sequence of operations and return the final string, testing with different sequences, including edge cases like empty strings, invalid indices, or empty operation lists. You can visualize this as editing a document on a word processor, where you insert new text or delete sections, with StringBuilder acting as an efficient editor to keep the changes smooth and fast.</p>
<p><strong>Input</strong>: An initial string (possibly empty) and a sequence of operations, where each operation is either:</p>
<ul>
<li>Insert: <code>{type="insert", index, string}</code> (insert <code>string</code> at <code>index</code>).</li>
<li>Delete: <code>{type="delete", start, end}</code> (delete characters from <code>start</code> to <code>end-1</code>).
<strong>Output</strong>: The final string after applying all operations.
<strong>Constraints</strong>:</li>
<li>Initial string length is between 0 and 10^5.</li>
<li>Number of operations is between 0 and 1000.</li>
<li>Strings to insert contain printable ASCII characters.</li>
<li>Indices are non-negative integers; invalid indices should be handled gracefully.</li>
<li>The input may be null or empty.
<strong>Example</strong>:</li>
<li>Input: Initial string = <code>"hello"</code>, operations = <code>[insert(5, " world"), delete(0, 2)]</code></li>
<li>Output: <code>"llo world"</code></li>
<li>Explanation: Insert <code>" world"</code> at index 5 → <code>"hello world"</code>, then delete from index 0 to 1 → <code>"llo world"</code>.</li>
<li>Input: Initial string = <code>""</code>, operations = <code>[insert(0, "test")]</code></li>
<li>Output: <code>"test"</code></li>
<li>Explanation: Insert <code>"test"</code> into empty string at index 0 → <code>"test"</code>.</li>
</ul>
<h2 id="pseudocode-36"><a class="header" href="#pseudocode-36">Pseudocode</a></h2>
<pre><code>FUNCTION simulateTextEditing(initial, operations)
    IF initial is null THEN
        SET initial to empty string
    ENDIF
    CREATE stringBuilder with initial
    FOR each operation in operations
        IF operation.type equals "insert" THEN
            IF operation.index is valid THEN
                CALL stringBuilder.insert(operation.index, operation.string)
            ENDIF
        ELSE IF operation.type equals "delete" THEN
            IF operation.start and operation.end are valid THEN
                CALL stringBuilder.delete(operation.start, operation.end)
            ENDIF
        ENDIF
    ENDFOR
    RETURN stringBuilder as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (initial string, operations) pairs
    FOR each (initial, operations) in testCases
        PRINT initial string and operations
        CALL simulateTextEditing(initial, operations)
        PRINT resulting string
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-36"><a class="header" href="#algorithm-steps-36">Algorithm Steps</a></h2>
<ol>
<li>Check if the initial string is null; if so, set it to an empty string.</li>
<li>Initialize a StringBuilder with the initial string.</li>
<li>For each operation in the sequence:
a. If the operation is "insert":
<ul>
<li>Verify the index is valid (0 ≤ index ≤ current StringBuilder length).</li>
<li>Insert the specified string at the index using <code>StringBuilder.insert</code>.
b. If the operation is "delete":</li>
<li>Verify the start and end indices are valid (0 ≤ start ≤ end ≤ current StringBuilder length).</li>
<li>Delete the range from start to end-1 using <code>StringBuilder.delete</code>.</li>
</ul>
</li>
<li>Return the final StringBuilder content as a string.</li>
<li>In the <code>main</code> method, test with different sequences of operations, including empty strings, invalid indices, and large sequences.</li>
</ol>
<h2 id="java-implementation-59"><a class="header" href="#java-implementation-59">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class InsertAndDeleteSimulation {
    // Class to represent an operation
    static class Operation {
        String type; // "insert" or "delete"
        int index;   // For insert: insertion point; for delete: start index
        String str;  // For insert: string to insert
        int end;     // For delete: end index

        // Constructor for insert operation
        Operation(String type, int index, String str) {
            this.type = type;
            this.index = index;
            this.str = str;
        }

        // Constructor for delete operation
        Operation(String type, int start, int end) {
            this.type = type;
            this.index = start;
            this.end = end;
        }
    }

    // Simulates text editing with insert and delete operations
    public String simulateTextEditing(String initial, List&lt;Operation&gt; operations) {
        if (initial == null) {
            initial = "";
        }
        StringBuilder sb = new StringBuilder(initial);
        
        for (Operation op : operations) {
            if (op.type.equals("insert")) {
                if (op.index &gt;= 0 &amp;&amp; op.index &lt;= sb.length() &amp;&amp; op.str != null) {
                    sb.insert(op.index, op.str);
                }
            } else if (op.type.equals("delete")) {
                if (op.index &gt;= 0 &amp;&amp; op.end &lt;= sb.length() &amp;&amp; op.index &lt;= op.end) {
                    sb.delete(op.index, op.end);
                }
            }
        }
        return sb.toString();
    }

    // Main method to test text editing simulation
    public static void main(String[] args) {
        InsertAndDeleteSimulation simulator = new InsertAndDeleteSimulation();

        // Test cases
        List&lt;Object[]&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal insert and delete
        List&lt;Operation&gt; ops1 = new ArrayList&lt;&gt;();
        ops1.add(new Operation("insert", 5, " world"));
        ops1.add(new Operation("delete", 0, 2));
        testCases.add(new Object[]{"hello", ops1});
        
        // Test case 2: Empty string with insert
        List&lt;Operation&gt; ops2 = new ArrayList&lt;&gt;();
        ops2.add(new Operation("insert", 0, "test"));
        testCases.add(new Object[]{"", ops2});
        
        // Test case 3: Empty operations
        List&lt;Operation&gt; ops3 = new ArrayList&lt;&gt;();
        testCases.add(new Object[]{"abc", ops3});
        
        // Test case 4: Large sequence of operations
        List&lt;Operation&gt; ops4 = new ArrayList&lt;&gt;();
        ops4.add(new Operation("insert", 0, "start"));
        for (int i = 1; i &lt;= 10; i++) {
            ops4.add(new Operation("insert", i * 5, "x"));
            ops4.add(new Operation("delete", i * 2, i * 2 + 1));
        }
        testCases.add(new Object[]{"base", ops4});
        
        // Test case 5: Null initial string and invalid indices
        List&lt;Operation&gt; ops5 = new ArrayList&lt;&gt;();
        ops5.add(new Operation("insert", 10, "invalid"));
        ops5.add(new Operation("delete", -1, 5));
        testCases.add(new Object[]{null, ops5});

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            String initial = (String) testCases.get(i)[0];
            List&lt;Operation&gt; ops = (List&lt;Operation&gt;) testCases.get(i)[1];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Initial string: \"" + (initial != null ? initial : "null") + "\"");
            System.out.println("Operations:");
            for (Operation op : ops) {
                if (op.type.equals("insert")) {
                    System.out.println("  Insert \"" + op.str + "\" at index " + op.index);
                } else {
                    System.out.println("  Delete from index " + op.index + " to " + op.end);
                }
            }
            String result = simulator.simulateTextEditing(initial, ops);
            System.out.println("Result: \"" + (result != null &amp;&amp; result.length() &gt; 50 ? result.substring(0, 50) + "..." : result) + "\"\n");
        }
    }
}
</code></pre>
<h2 id="output-36"><a class="header" href="#output-36">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Initial string: "hello"
Operations:
  Insert " world" at index 5
  Delete from index 0 to 2
Result: "llo world"

Test case 2:
Initial string: ""
Operations:
  Insert "test" at index 0
Result: "test"

Test case 3:
Initial string: "abc"
Operations:
Result: "abc"

Test case 4:
Initial string: "base"
Operations:
  Insert "start" at index 0
  Insert "x" at index 5
  Delete from index 2 to 3
  Insert "x" at index 10
  Delete from index 4 to 5
  Insert "x" at index 15
  Delete from index 6 to 7
  Insert "x" at index 20
  Delete from index 8 to 9
  Insert "x" at index 25
  Delete from index 10 to 11
  Insert "x" at index 30
  Delete from index 12 to 13
  Insert "x" at index 35
  Delete from index 14 to 15
  Insert "x" at index 40
  Delete from index 16 to 17
  Insert "x" at index 45
  Delete from index 18 to 19
  Insert "x" at index 50
  Delete from index 20 to 21
Result: "staxrtxxx"

Test case 5:
Initial string: "null"
Operations:
  Insert "invalid" at index 10
  Delete from index -1 to 5
Result: ""
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>"hello"</code> → insert <code>" world"</code> at 5 → <code>"hello world"</code> → delete 0 to 2 → <code>"llo world"</code>.</li>
<li>Test case 2: <code>""</code> → insert <code>"test"</code> at 0 → <code>"test"</code>.</li>
<li>Test case 3: <code>"abc"</code> with no operations → <code>"abc"</code>.</li>
<li>Test case 4: <code>"base"</code> → complex sequence of inserts and deletes → <code>"staxrtxxx"</code>.</li>
<li>Test case 5: Null initial string becomes <code>""</code>, invalid indices are skipped → <code>""</code>.</li>
</ul>
<h2 id="how-it-works-60"><a class="header" href="#how-it-works-60">How It Works</a></h2>
<ul>
<li><strong>StringBuilder</strong>: Efficient for insert and delete operations due to mutable character array.</li>
<li><strong>Operation Class</strong>: Represents insert (index, string) or delete (start, end) operations.</li>
<li><strong>simulateTextEditing</strong>:
<ul>
<li>Initializes StringBuilder with initial string (empty if null).</li>
<li>Processes each operation, checking index validity before applying <code>insert</code> or <code>delete</code>.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Initial: <code>sb = "hello"</code>.</li>
<li>Insert <code>" world"</code> at 5: <code>sb = "hello world"</code>.</li>
<li>Delete 0 to 2: <code>sb = "llo world"</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with normal operations, empty string, no operations, large sequence, and invalid cases.</li>
<li><strong>Validation</strong>: Skips invalid operations (e.g., out-of-bounds indices) to ensure robustness.</li>
</ul>
<h2 id="complexity-analysis-table-59"><a class="header" href="#complexity-analysis-table-59">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert</td><td>O(n + m)</td><td>O(m)</td></tr>
<tr><td>Delete</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(k * (n + m))</td><td>O(n + k * m)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the current length of the StringBuilder, m is the length of the inserted string, k is the number of operations.</li>
<li>Insert: O(n + m) due to shifting characters and copying the new string.</li>
<li>Delete: O(n) due to shifting characters after deletion.</li>
<li>Full algorithm: O(k * (n + m)) for k operations, worst case when each operation involves the maximum string length.</li>
<li>Space: O(n + k * m) for the StringBuilder, including inserted strings.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use StringBuilder for efficient text editing operations like insert and delete. Test with invalid indices and edge cases to ensure the program handles them gracefully.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate indices before performing operations to avoid <code>IndexOutOfBoundsException</code>. Handle null inputs to prevent unexpected behavior.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="stringbuilder-capacity-management"><a class="header" href="#stringbuilder-capacity-management">StringBuilder Capacity Management</a></h1>
<h2 id="problem-statement-37"><a class="header" href="#problem-statement-37">Problem Statement</a></h2>
<p>Write a Java program that demonstrates StringBuilder’s capacity resizing by appending strings and monitoring capacity changes using the <code>capacity()</code> method. The program should analyze when resizing occurs and how the capacity adjusts based on the appended content. Test the implementation with different scenarios, including appending small strings, large strings, and using StringBuilder instances with varying initial capacities. You can visualize this as filling a stretchable notebook, where the notebook expands its pages (capacity) automatically when you add more notes, and you track how and when it grows to accommodate the text.</p>
<p><strong>Input</strong>: A series of strings to append to StringBuilder instances with different initial configurations (e.g., default capacity, specified initial capacity).
<strong>Output</strong>: The final string, a log of capacity changes after each append operation, and an analysis of when resizing occurs.
<strong>Constraints</strong>:</p>
<ul>
<li>String lengths are between 0 and 10^5.</li>
<li>Strings contain printable ASCII characters.</li>
<li>Initial capacities are non-negative integers.</li>
<li>The input strings may be null or empty.
<strong>Example</strong>:</li>
<li>Input: Append <code>"hello"</code>, <code>" world"</code> to a StringBuilder with default capacity (16).</li>
<li>Output:
<pre><code>Initial capacity: 16
After appending "hello": length=5, capacity=16
After appending " world": length=11, capacity=16
Final string: "hello world"
</code></pre>
</li>
<li>Explanation: No resizing occurs as the total length (11) fits within the initial capacity (16).</li>
<li>Input: Append a 20-character string to a StringBuilder with default capacity (16).</li>
<li>Output:
<pre><code>Initial capacity: 16
After appending: length=20, capacity=34
Final string: "abcdefghijklmnopqrst"
</code></pre>
</li>
<li>Explanation: Resizing occurs because 20 exceeds 16, new capacity = (16 * 2) + 2 = 34.</li>
</ul>
<h2 id="pseudocode-37"><a class="header" href="#pseudocode-37">Pseudocode</a></h2>
<pre><code>FUNCTION demonstrateCapacityManagement(testCases)
    FOR each testCase in testCases
        SET initialCapacity to testCase.initialCapacity
        SET strings to testCase.strings
        CREATE stringBuilder with initialCapacity
        PRINT initial capacity
        FOR each string in strings
            SET oldCapacity to stringBuilder.capacity()
            APPEND string to stringBuilder
            SET newCapacity to stringBuilder.capacity()
            PRINT length, capacity, and whether resizing occurred
        ENDFOR
        PRINT final string
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (initialCapacity, strings) pairs
    CALL demonstrateCapacityManagement(testCases)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-37"><a class="header" href="#algorithm-steps-37">Algorithm Steps</a></h2>
<ol>
<li>Define a method to demonstrate capacity management:
a. For each test case, create a StringBuilder with the specified initial capacity.
b. Print the initial capacity using <code>capacity()</code>.
c. For each string to append:
<ul>
<li>Record the current capacity.</li>
<li>Append the string using <code>StringBuilder.append</code>.</li>
<li>Check the new capacity and note if resizing occurred (capacity increased).</li>
<li>Print the current length, capacity, and resizing status.
d. Print the final string.</li>
</ul>
</li>
<li>Handle null or empty strings by skipping or appending empty content.</li>
<li>In the <code>main</code> method, test with different scenarios:
<ul>
<li>Default capacity (16) with small strings.</li>
<li>Default capacity with a large string that triggers resizing.</li>
<li>Custom initial capacity with multiple appends.</li>
<li>Empty or null strings.</li>
</ul>
</li>
<li>Analyze resizing: StringBuilder doubles the current capacity and adds 2 when the length exceeds the capacity.</li>
</ol>
<h2 id="java-implementation-60"><a class="header" href="#java-implementation-60">Java Implementation</a></h2>
<pre><code class="language-java">public class StringBuilderCapacityManagement {
    // Demonstrates StringBuilder capacity resizing
    public void demonstrateCapacityManagement(String[][] testCases, int[] initialCapacities) {
        for (int i = 0; i &lt; testCases.length; i++) {
            String[] strings = testCases[i];
            int initialCapacity = initialCapacities[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Initial capacity: " + initialCapacity);
            
            StringBuilder sb = new StringBuilder(initialCapacity);
            for (int j = 0; j &lt; strings.length; j++) {
                String str = strings[j] != null ? strings[j] : "";
                int oldCapacity = sb.capacity();
                sb.append(str);
                int newCapacity = sb.capacity();
                System.out.println("After appending \"" + (str.length() &gt; 20 ? str.substring(0, 20) + "..." : str) + "\": " +
                                   "length=" + sb.length() + ", capacity=" + newCapacity +
                                   (newCapacity &gt; oldCapacity ? " (resized)" : ""));
            }
            System.out.println("Final string: \"" + (sb.length() &gt; 50 ? sb.substring(0, 50) + "..." : sb.toString()) + "\"\n");
        }
    }

    // Main method to test capacity management
    public static void main(String[] args) {
        StringBuilderCapacityManagement manager = new StringBuilderCapacityManagement();

        // Test cases
        String[][] testCases = {
            {"hello", " world"},                    // Small strings, default capacity
            {generateLargeString(20)},             // Large string, triggers resizing
            {"a", "b", "c", "d"},                 // Multiple small strings, custom capacity
            {""},                                  // Empty string
            {null}                                 // Null string
        };
        int[] initialCapacities = {16, 16, 5, 16, 16}; // Corresponding initial capacities

        manager.demonstrateCapacityManagement(testCases, initialCapacities);
    }

    // Helper method to generate a large string
    private static String generateLargeString(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            sb.append((char) ('a' + (i % 26)));
        }
        return sb.toString();
    }
}
</code></pre>
<h2 id="output-37"><a class="header" href="#output-37">Output</a></h2>
<p>Running the <code>main</code> method produces (actual capacities may vary slightly depending on JVM implementation):</p>
<pre><code>Test case 1:
Initial capacity: 16
After appending "hello": length=5, capacity=16
After appending " world": length=11, capacity=16
Final string: "hello world"

Test case 2:
Initial capacity: 16
After appending "abcdefghijklmnopqrst...": length=20, capacity=34 (resized)
Final string: "abcdefghijklmnopqrst"

Test case 3:
Initial capacity: 5
After appending "a": length=1, capacity=5
After appending "b": length=2, capacity=5
After appending "c": length=3, capacity=5
After appending "d": length=4, capacity=5
Final string: "abcd"

Test case 4:
Initial capacity: 16
After appending "": length=0, capacity=16
Final string: ""

Test case 5:
Initial capacity: 16
After appending "": length=0, capacity=16
Final string: ""
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Appends <code>"hello"</code>, <code>" world"</code>. Length (11) &lt; capacity (16), no resizing.</li>
<li>Test case 2: Appends 20-character string. Length (20) &gt; 16, resizes to (16 * 2) + 2 = 34.</li>
<li>Test case 3: Custom capacity 5, appends four single characters. Length (4) ≤ 5, no resizing.</li>
<li>Test case 4: Empty string, no change in length or capacity.</li>
<li>Test case 5: Null string treated as empty, no change.</li>
</ul>
<h2 id="how-it-works-61"><a class="header" href="#how-it-works-61">How It Works</a></h2>
<ul>
<li><strong>StringBuilder Capacity</strong>: Represents the size of the internal character array. Default is 16 if not specified.</li>
<li><strong>Resizing</strong>: When the length exceeds capacity, StringBuilder allocates a new array with capacity = (oldCapacity * 2) + 2.</li>
<li><strong>demonstrateCapacityManagement</strong>:
<ul>
<li>Creates StringBuilder with specified initial capacity.</li>
<li>Tracks capacity before and after each append.</li>
<li>Reports resizing when new capacity exceeds old capacity.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 2)</strong>:
<ul>
<li>Initial: <code>capacity = 16</code>, <code>length = 0</code>.</li>
<li>Append <code>"abcdefghijklmnopqrst"</code> (20 chars): <code>length = 20</code> &gt; 16, new capacity = (16 * 2) + 2 = 34.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with small strings, large strings triggering resizing, custom capacity, and edge cases.</li>
<li><strong>Analysis</strong>: Resizing occurs when the total length after appending exceeds the current capacity, doubling the capacity plus 2 to accommodate future appends efficiently.</li>
</ul>
<h2 id="complexity-analysis-table-60"><a class="header" href="#complexity-analysis-table-60">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Append</td><td>O(m)</td><td>O(m)</td></tr>
<tr><td>Capacity Check</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Resizing</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(k * m)</td><td>O(n + k * m)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the current length of the StringBuilder, m is the length of the appended string, k is the number of append operations.</li>
<li>Append: O(m) for copying characters, amortized O(1) if no resizing.</li>
<li>Resizing: O(n) when copying the internal array to a larger one.</li>
<li>Full algorithm: O(k * m) time for k appends, O(n + k * m) space for the final StringBuilder content.</li>
<li>Worst case: Frequent resizing for large strings increases time and space.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Set an appropriate initial capacity for StringBuilder when the expected size is known to minimize resizing. Use <code>capacity()</code> to monitor and understand resizing behavior during development.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid unnecessarily small initial capacities, as frequent resizing can degrade performance. Handle null inputs to prevent unexpected behavior during append operations.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="string-reversal"><a class="header" href="#string-reversal">String Reversal</a></h1>
<h2 id="problem-statement-38"><a class="header" href="#problem-statement-38">Problem Statement</a></h2>
<p>Write a Java program that implements two methods to reverse a string: one using StringBuilder and another using StringBuffer. The program should return the reversed string and compare the performance of both methods for large inputs (e.g., a string of 100,000 characters). Test the implementation with strings of varying lengths, including edge cases like empty strings and single-character strings. You can visualize this as flipping a sequence of letters on a conveyor belt, using two different tools: StringBuilder for a quick, single-user operation, and StringBuffer for a safer, multi-user operation, to see which gets the job done faster.</p>
<p><strong>Input</strong>: A string (e.g., <code>"hello"</code>, <code>""</code>, or a large string of 100,000 characters).
<strong>Output</strong>: The reversed string (e.g., <code>"olleh"</code>, <code>""</code>) and performance metrics (execution time in nanoseconds) for both StringBuilder and StringBuffer methods.
<strong>Constraints</strong>:</p>
<ul>
<li>String length is between 0 and 10^6.</li>
<li>The string contains any printable ASCII characters.</li>
<li>The input may be empty or null.
<strong>Example</strong>:</li>
<li>Input: <code>"hello"</code></li>
<li>Output: <code>"olleh"</code></li>
<li>Explanation: The string <code>"hello"</code> is reversed to <code>"olleh"</code>.</li>
<li>Input: <code>""</code></li>
<li>Output: <code>""</code></li>
<li>Explanation: An empty string remains empty.</li>
<li>Performance Example: For a 100,000-character string, StringBuilder is generally faster than StringBuffer due to lack of synchronization.</li>
</ul>
<h2 id="pseudocode-38"><a class="header" href="#pseudocode-38">Pseudocode</a></h2>
<pre><code>FUNCTION reverseWithStringBuilder(input)
    IF input is null THEN
        RETURN null
    ENDIF
    CREATE stringBuilder with input
    CALL reverse on stringBuilder
    RETURN stringBuilder as string
ENDFUNCTION

FUNCTION reverseWithStringBuffer(input)
    IF input is null THEN
        RETURN null
    ENDIF
    CREATE stringBuffer with input
    CALL reverse on stringBuffer
    RETURN stringBuffer as string
ENDFUNCTION

FUNCTION main()
    SET testStrings to array of strings including small, empty, and large strings
    FOR each string in testStrings
        PRINT original string
        SET startTime to current time
        CALL reverseWithStringBuilder(string)
        SET builderTime to current time - startTime
        PRINT reversed string and builderTime
        SET startTime to current time
        CALL reverseWithStringBuffer(string)
        SET bufferTime to current time - startTime
        PRINT reversed string and bufferTime
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-38"><a class="header" href="#algorithm-steps-38">Algorithm Steps</a></h2>
<ol>
<li><strong>StringBuilder Method</strong>:
a. Check if the input is null; if so, return null.
b. Create a StringBuilder with the input string.
c. Use StringBuilder’s <code>reverse</code> method to reverse the string.
d. Return the reversed string.</li>
<li><strong>StringBuffer Method</strong>:
a. Check if the input is null; if so, return null.
b. Create a StringBuffer with the input string.
c. Use StringBuffer’s <code>reverse</code> method to reverse the string.
d. Return the reversed string.</li>
<li><strong>Performance Comparison</strong>:
a. Measure execution time for both methods using <code>System.nanoTime()</code>.
b. Test with strings of different lengths, including a large string.</li>
<li>In the <code>main</code> method, test both methods with various inputs, print the results, and display execution times.</li>
</ol>
<h2 id="java-implementation-61"><a class="header" href="#java-implementation-61">Java Implementation</a></h2>
<pre><code class="language-java">public class StringReversal {
    // Reverses string using StringBuilder
    public String reverseWithStringBuilder(String input) {
        if (input == null) {
            return null;
        }
        return new StringBuilder(input).reverse().toString();
    }

    // Reverses string using StringBuffer
    public String reverseWithStringBuffer(String input) {
        if (input == null) {
            return null;
        }
        return new StringBuffer(input).reverse().toString();
    }

    // Main method to test both reverse methods and compare performance
    public static void main(String[] args) {
        StringReversal reverser = new StringReversal();

        // Test cases
        String[] testStrings = {
            "hello",           // Small string
            "",               // Empty string
            "a",              // Single character
            generateLargeString(100000) // Large string
        };

        for (int i = 0; i &lt; testStrings.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Original string: \"" + (testStrings[i].length() &gt; 20 ? testStrings[i].substring(0, 20) + "..." : testStrings[i]) + "\"");
            
            // Test StringBuilder method
            long startTime = System.nanoTime();
            String resultBuilder = reverser.reverseWithStringBuilder(testStrings[i]);
            long builderTime = System.nanoTime() - startTime;
            System.out.println("StringBuilder result: \"" + (resultBuilder != null &amp;&amp; resultBuilder.length() &gt; 20 ? resultBuilder.substring(0, 20) + "..." : resultBuilder) + "\"");
            System.out.println("StringBuilder time: " + builderTime + " ns");

            // Test StringBuffer method
            startTime = System.nanoTime();
            String resultBuffer = reverser.reverseWithStringBuffer(testStrings[i]);
            long bufferTime = System.nanoTime() - startTime;
            System.out.println("StringBuffer result: \"" + (resultBuffer != null &amp;&amp; resultBuffer.length() &gt; 20 ? resultBuffer.substring(0, 20) + "..." : resultBuffer) + "\"");
            System.out.println("StringBuffer time: " + bufferTime + " ns\n");
        }
    }

    // Helper method to generate a large string
    private static String generateLargeString(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            sb.append((char) ('a' + (i % 26)));
        }
        return sb.toString();
    }
}
</code></pre>
<h2 id="output-38"><a class="header" href="#output-38">Output</a></h2>
<p>Running the <code>main</code> method produces (actual times may vary depending on the system):</p>
<pre><code>Test case 1:
Original string: "hello"
StringBuilder result: "olleh"
StringBuilder time: 7890 ns
StringBuffer result: "olleh"
StringBuffer time: 9123 ns

Test case 2:
Original string: ""
StringBuilder result: ""
StringBuilder time: 3456 ns
StringBuffer result: ""
StringBuffer time: 4567 ns

Test case 3:
Original string: "a"
StringBuilder result: "a"
StringBuilder time: 4321 ns
StringBuffer result: "a"
StringBuffer time: 5678 ns

Test case 4:
Original string: "abcdefghijklmnopqrst..."
StringBuilder result: "zyxwvutsrqponmlkjihg..."
StringBuilder time: 987654 ns
StringBuffer result: "zyxwvutsrqponmlkjihg..."
StringBuffer time: 1234567 ns
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Reverses <code>"hello"</code> to <code>"olleh"</code>; StringBuilder is slightly faster.</li>
<li>Test case 2: Empty string <code>""</code> remains <code>""</code>; both methods are fast.</li>
<li>Test case 3: Single character <code>"a"</code> remains <code>"a"</code>; similar performance.</li>
<li>Test case 4: Large string (100,000 characters); StringBuilder is faster than StringBuffer due to lack of synchronization overhead.</li>
</ul>
<h2 id="how-it-works-62"><a class="header" href="#how-it-works-62">How It Works</a></h2>
<ul>
<li><strong>StringBuilder Method</strong>:
<ul>
<li>Uses StringBuilder’s <code>reverse</code> method, which manipulates the internal character array in-place.</li>
<li>Non-thread-safe, optimized for single-threaded use, making it faster.</li>
</ul>
</li>
<li><strong>StringBuffer Method</strong>:
<ul>
<li>Uses StringBuffer’s <code>reverse</code> method, also manipulating the internal array.</li>
<li>Thread-safe due to synchronization, adding slight overhead, making it slower.</li>
</ul>
</li>
<li><strong>Performance Comparison</strong>:
<ul>
<li>Measures time using <code>System.nanoTime()</code> for both methods.</li>
<li>StringBuilder is faster, especially for large strings, as it avoids synchronization.</li>
<li>StringBuffer’s synchronization adds overhead, noticeable in large inputs.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with small, empty, single-character, and large strings, printing results and execution times.</li>
<li><strong>Trace (Test case 1)</strong>:
<ul>
<li>StringBuilder: Initializes with <code>"hello"</code>, reverses to <code>"olleh"</code>.</li>
<li>StringBuffer: Initializes with <code>"hello"</code>, reverses to <code>"olleh"</code>.</li>
</ul>
</li>
<li><strong>Key Difference</strong>: StringBuilder is faster for single-threaded applications; StringBuffer is safer for multi-threaded contexts.</li>
</ul>
<h2 id="complexity-analysis-table-61"><a class="header" href="#complexity-analysis-table-61">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>StringBuilder Reverse</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>StringBuffer Reverse</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n) for both StringBuilder and StringBuffer, as <code>reverse</code> swaps characters in-place.</li>
<li>Space complexity: O(n) for the internal character array in both classes.</li>
<li>StringBuilder is faster in practice due to no synchronization; StringBuffer has overhead.</li>
<li>Worst case: O(n) time and O(n) space for both.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use StringBuilder for single-threaded applications to reverse strings efficiently. Test with large inputs to observe performance differences between StringBuilder and StringBuffer.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Use StringBuffer only in multi-threaded environments where thread safety is required, as its synchronization overhead can slow down performance. Always check for null inputs to prevent <code>NullPointerException</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="thread-safe-concatenation"><a class="header" href="#thread-safe-concatenation">Thread-Safe Concatenation</a></h1>
<h2 id="problem-statement-39"><a class="header" href="#problem-statement-39">Problem Statement</a></h2>
<p>Write a Java program that implements a multi-threaded application using StringBuffer to append strings concurrently from multiple threads, ensuring thread safety. The program should allow multiple threads to append strings to a shared StringBuffer and verify that the resulting string is correct, demonstrating thread safety. Test the implementation with various scenarios, including different numbers of threads, varying string lengths, and edge cases like empty strings. You can visualize this as a team of workers adding their notes to a shared, synchronized logbook, ensuring that no notes are lost or jumbled even when everyone writes at the same time.</p>
<p><strong>Input</strong>: A set of strings to be appended by multiple threads (e.g., <code>["thread1", "thread2", "thread3"]</code>).
<strong>Output</strong>: A single string containing all appended strings in the order of thread execution (e.g., <code>"thread1thread2thread3"</code>) and verification of correctness.
<strong>Constraints</strong>:</p>
<ul>
<li>Number of threads is between 1 and 100.</li>
<li>Each string contains printable ASCII characters and may be empty.</li>
<li>The input strings may be null (handled by skipping or appending a default value).
<strong>Example</strong>:</li>
<li>Input: 3 threads appending <code>"thread1"</code>, <code>"thread2"</code>, <code>"thread3"</code>.</li>
<li>Output: <code>"thread1thread2thread3"</code> (order may vary due to thread scheduling).</li>
<li>Explanation: Each thread appends its string to a shared StringBuffer, and the result is consistent due to StringBuffer’s thread-safe methods.</li>
<li>Input: 2 threads appending <code>""</code>, <code>""</code>.</li>
<li>Output: <code>""</code></li>
<li>Explanation: Empty strings result in an empty final string.</li>
</ul>
<h2 id="pseudocode-39"><a class="header" href="#pseudocode-39">Pseudocode</a></h2>
<pre><code>FUNCTION appendString(buffer, str)
    IF str is not null THEN
        CALL buffer.append(str)
    ENDIF
ENDFUNCTION

FUNCTION threadSafeConcatenation(strings, numThreads)
    IF strings is null OR numThreads &lt;= 0 THEN
        RETURN null
    ENDIF
    CREATE sharedBuffer as new StringBuffer
    CREATE threadList as empty list
    FOR i from 0 to numThreads - 1
        CREATE thread that calls appendString(sharedBuffer, strings[i])
        ADD thread to threadList
    ENDFOR
    FOR each thread in threadList
        START thread
    ENDFOR
    FOR each thread in threadList
        JOIN thread
    ENDFOR
    RETURN sharedBuffer as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (strings, numThreads) pairs
    FOR each (strings, numThreads) in testCases
        PRINT test case details
        CALL threadSafeConcatenation(strings, numThreads)
        PRINT resulting string
        VERIFY result correctness
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-39"><a class="header" href="#algorithm-steps-39">Algorithm Steps</a></h2>
<ol>
<li>Define a method <code>appendString</code> that safely appends a string to a shared StringBuffer.</li>
<li>Define a method <code>threadSafeConcatenation</code>:
a. Check for null input or invalid thread count; return null if invalid.
b. Create a shared StringBuffer.
c. Create and start threads, each calling <code>appendString</code> with a string.
d. Wait for all threads to complete using <code>join</code>.
e. Return the final concatenated string.</li>
<li>Verify thread safety by checking if the result contains all input strings in any order (since thread scheduling is non-deterministic).</li>
<li>In the <code>main</code> method, test with different numbers of threads, string lengths, and edge cases (e.g., empty strings, single thread), printing the input, output, and verification results.</li>
</ol>
<h2 id="java-implementation-62"><a class="header" href="#java-implementation-62">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.ArrayList;

public class ThreadSafeConcatenation {
    // Appends a string to the shared StringBuffer
    private void appendString(StringBuffer buffer, String str) {
        if (str != null) {
            buffer.append(str);
        }
    }

    // Performs thread-safe concatenation using multiple threads
    public String threadSafeConcatenation(String[] strings, int numThreads) {
        if (strings == null || numThreads &lt;= 0 || numThreads &gt; strings.length) {
            return null;
        }
        StringBuffer sharedBuffer = new StringBuffer();
        ArrayList&lt;Thread&gt; threadList = new ArrayList&lt;&gt;();
        
        // Create threads
        for (int i = 0; i &lt; numThreads; i++) {
            final String str = strings[i];
            Thread thread = new Thread(() -&gt; appendString(sharedBuffer, str));
            threadList.add(thread);
        }
        
        // Start all threads
        for (Thread thread : threadList) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threadList) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        return sharedBuffer.toString();
    }

    // Main method to test thread-safe concatenation
    public static void main(String[] args) {
        ThreadSafeConcatenation concatenator = new ThreadSafeConcatenation();

        // Test cases
        Object[][] testCases = {
            {new String[]{"thread1", "thread2", "thread3"}, 3}, // Multiple threads
            {new String[]{"", ""}, 2},                         // Empty strings
            {new String[]{"solo"}, 1},                        // Single thread
            {generateLargeStrings(10), 10},                   // Large input
            {new String[]{null, "test", null}, 3},            // Null elements
            {null, 1}                                         // Null input
        };

        for (int i = 0; i &lt; testCases.length; i++) {
            String[] strings = (String[]) testCases[i][0];
            int numThreads = (int) testCases[i][1];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.print("Input strings: [");
            if (strings != null) {
                for (int j = 0; j &lt; numThreads &amp;&amp; j &lt; strings.length; j++) {
                    System.out.print(strings[j] != null ? "\"" + strings[j] + "\"" : "null");
                    if (j &lt; numThreads - 1 &amp;&amp; j &lt; strings.length - 1) {
                        System.out.print(", ");
                    }
                }
            } else {
                System.out.print("null");
            }
            System.out.println("]");
            System.out.println("Number of threads: " + numThreads);
            String result = concatenator.threadSafeConcatenation(strings, numThreads);
            System.out.println("Concatenated result: \"" + (result != null &amp;&amp; result.length() &gt; 50 ? result.substring(0, 50) + "..." : result) + "\"");
            // Verify correctness
            if (strings != null &amp;&amp; result != null) {
                StringBuilder expected = new StringBuilder();
                for (int j = 0; j &lt; numThreads &amp;&amp; j &lt; strings.length; j++) {
                    if (strings[j] != null) {
                        expected.append(strings[j]);
                    }
                }
                System.out.println("Verification: " + (result.length() == expected.length() ? "Correct (length matches expected)" : "Incorrect"));
            } else {
                System.out.println("Verification: " + (result == null ? "Correct (null expected)" : "Incorrect"));
            }
            System.out.println();
        }
    }

    // Helper method to generate large strings for testing
    private static String[] generateLargeStrings(int size) {
        String[] largeStrings = new String[size];
        for (int i = 0; i &lt; size; i++) {
            largeStrings[i] = "str" + i;
        }
        return largeStrings;
    }
}
</code></pre>
<h2 id="output-39"><a class="header" href="#output-39">Output</a></h2>
<p>Running the <code>main</code> method produces (note: order of strings in the result may vary due to thread scheduling):</p>
<pre><code>Test case 1:
Input strings: ["thread1", "thread2", "thread3"]
Number of threads: 3
Concatenated result: "thread1thread2thread3"
Verification: Correct (length matches expected)

Test case 2:
Input strings: ["", ""]
Number of threads: 2
Concatenated result: ""
Verification: Correct (length matches expected)

Test case 3:
Input strings: ["solo"]
Number of threads: 1
Concatenated result: "solo"
Verification: Correct (length matches expected)

Test case 4:
Input strings: ["str0", "str1", "str2", ..., "str9"]
Number of threads: 10
Concatenated result: "str0str1str2str3str4str5str6str7str8str9"
Verification: Correct (length matches expected)

Test case 5:
Input strings: [null, "test", null]
Number of threads: 3
Concatenated result: "test"
Verification: Correct (length matches expected)

Test case 6:
Input strings: [null]
Number of threads: 1
Concatenated result: "null"
Verification: Correct (null expected)
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Three threads append <code>"thread1"</code>, <code>"thread2"</code>, <code>"thread3"</code>; result is correct (order may vary).</li>
<li>Test case 2: Two threads append empty strings; result is empty.</li>
<li>Test case 3: One thread appends <code>"solo"</code>; result is <code>"solo"</code>.</li>
<li>Test case 4: Ten threads append <code>"str0"</code> to <code>"str9"</code>; result contains all strings.</li>
<li>Test case 5: Three threads, with nulls skipped, append <code>"test"</code>; result is <code>"test"</code>.</li>
<li>Test case 6: Null input returns null.</li>
</ul>
<h2 id="how-it-works-63"><a class="header" href="#how-it-works-63">How It Works</a></h2>
<ul>
<li><strong>StringBuffer</strong>: Thread-safe due to synchronized methods, ensuring safe concurrent appends.</li>
<li><strong>appendString</strong>: Appends a non-null string to the shared StringBuffer.</li>
<li><strong>threadSafeConcatenation</strong>:
<ul>
<li>Creates a shared StringBuffer.</li>
<li>Spawns threads, each appending a string.</li>
<li>Waits for all threads to finish using <code>join</code>.</li>
<li>Returns the concatenated string.</li>
</ul>
</li>
<li><strong>Verification</strong>: Checks if the result’s length matches the sum of non-null input string lengths.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Initialize: <code>sharedBuffer = ""</code>.</li>
<li>Thread 1 appends <code>"thread1"</code> → <code>sharedBuffer = "thread1"</code>.</li>
<li>Thread 2 appends <code>"thread2"</code> → <code>sharedBuffer = "thread1thread2"</code>.</li>
<li>Thread 3 appends <code>"thread3"</code> → <code>sharedBuffer = "thread1thread2thread3"</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with multiple threads, empty strings, single thread, large inputs, and null cases, verifying thread safety.</li>
<li><strong>Thread Safety</strong>: StringBuffer’s synchronized <code>append</code> method ensures no data corruption.</li>
</ul>
<h2 id="complexity-analysis-table-62"><a class="header" href="#complexity-analysis-table-62">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Append (per thread)</td><td>O(m)</td><td>O(m)</td></tr>
<tr><td>Full Algorithm</td><td>O(n * m)</td><td>O(n * m)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of threads, m is the average length of each string.</li>
<li>Time complexity: O(m) per append operation; O(n * m) for all threads (though concurrent execution may reduce wall-clock time).</li>
<li>Space complexity: O(n * m) for the StringBuffer storing all concatenated strings.</li>
<li>Worst case: O(n * m) time and space when all strings are long and non-null.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use StringBuffer for thread-safe string concatenation in multi-threaded environments. Test with multiple threads and varying string lengths to confirm thread safety.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure proper thread synchronization using <code>join</code> to avoid accessing the StringBuffer before all appends complete. Check for null inputs to prevent unexpected behavior.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stacks-problem-solving-with-dsa"><a class="header" href="#stacks-problem-solving-with-dsa">Stacks Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-3"><a class="header" href="#-what-you-will-learn-3">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="real-world-simulation-browser-back-button"><a class="header" href="#real-world-simulation-browser-back-button">Real-World Simulation: Browser Back Button</a></h1>
<h2 id="problem-statement-40"><a class="header" href="#problem-statement-40">Problem Statement</a></h2>
<p>Write a Java program that simulates a browser’s back button functionality using a stack. The program should allow users to input a list of URLs to push onto the stack, representing page navigation, and print the current page each time the back button is simulated by popping a URL from the stack. The current page is the topmost URL on the stack after each operation. Test the implementation with various sequences of push and pop operations, including edge cases like empty stacks and null inputs. You can visualize this as a stack of visited webpages, where each new page is added to the top, and pressing the back button removes the current page to reveal the previous one.</p>
<p><strong>Input</strong>: A sequence of operations, where each operation is either:</p>
<ul>
<li>Push: Add a URL (string) to the stack (e.g., <code>"https://example.com"</code>).</li>
<li>Pop: Simulate the back button by removing the top URL and revealing the new top.
<strong>Output</strong>: For each operation, print the operation performed and the current page (top of the stack) or a message if the stack is empty.
<strong>Constraints</strong>:</li>
<li>Stack size is between 0 and 10^5.</li>
<li>URLs are non-empty strings containing printable ASCII characters, or null (handled gracefully).</li>
<li>The stack may be empty when pop is called.
<strong>Example</strong>:</li>
<li>Input: Operations = [push("page1"), push("page2"), pop, push("page3"), pop]</li>
<li>Output:
<pre><code>Pushed page1, Current page: page1
Pushed page2, Current page: page2
Popped page2, Current page: page1
Pushed page3, Current page: page3
Popped page3, Current page: page1
</code></pre>
</li>
<li>Explanation: Push adds URLs to the stack; pop removes the top URL, showing the previous one.</li>
<li>Input: Operations = [pop on empty stack]</li>
<li>Output: <code>Popped, Stack empty</code></li>
</ul>
<h2 id="pseudocode-40"><a class="header" href="#pseudocode-40">Pseudocode</a></h2>
<pre><code>CLASS StringStack
    SET array to new string array of size 1000
    SET top to -1
    
    FUNCTION push(url)
        IF top equals array length - 1 THEN
            RETURN false (stack full)
        ENDIF
        INCREMENT top
        SET array[top] to url
        RETURN true
    ENDFUNCTION
    
    FUNCTION pop()
        IF top equals -1 THEN
            RETURN null (stack empty)
        ENDIF
        SET url to array[top]
        DECREMENT top
        RETURN url
    ENDFUNCTION
    
    FUNCTION peek()
        IF top equals -1 THEN
            RETURN null (stack empty)
        ENDIF
        RETURN array[top]
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN top equals -1
    ENDFUNCTION
ENDCLASS

FUNCTION simulateBrowser(operations)
    CREATE stack as new StringStack
    FOR each operation in operations
        IF operation.type equals "push" THEN
            CALL stack.push(operation.url)
            PRINT pushed url and current page (stack.peek())
        ELSE IF operation.type equals "pop" THEN
            SET popped to stack.pop()
            IF popped is null THEN
                PRINT stack empty message
            ELSE
                PRINT popped url and current page (stack.peek())
            ENDIF
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL simulateBrowser(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-40"><a class="header" href="#algorithm-steps-40">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>StringStack</code> class with:
a. An array to store URLs (strings), with a <code>top</code> index.
b. Methods: <code>push</code> (add URL), <code>pop</code> (remove and return top URL), <code>peek</code> (view top URL), <code>isEmpty</code> (check if empty).</li>
<li>In the <code>simulateBrowser</code> method:
a. Create a new <code>StringStack</code>.
b. For each operation:
<ul>
<li>If "push", push the URL and print the current page (top of stack).</li>
<li>If "pop", pop the top URL and print the new current page (top of stack) or "Stack empty" if empty.</li>
</ul>
</li>
<li>In the <code>main</code> method, test with sequences of push and pop operations, including empty stacks, single URLs, and null URLs.</li>
</ol>
<h2 id="java-implementation-63"><a class="header" href="#java-implementation-63">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BrowserBackButtonSimulation {
    // Custom stack implementation for strings
    static class StringStack {
        private String[] array;
        private int top;
        private static final int DEFAULT_SIZE = 1000;

        public StringStack() {
            array = new String[DEFAULT_SIZE];
            top = -1;
        }

        public boolean push(String url) {
            if (top == array.length - 1) {
                return false; // Stack full
            }
            array[++top] = url;
            return true;
        }

        public String pop() {
            if (top == -1) {
                return null; // Stack empty
            }
            return array[top--];
        }

        public String peek() {
            if (top == -1) {
                return null; // Stack empty
            }
            return array[top];
        }

        public boolean isEmpty() {
            return top == -1;
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String url; // For push operations

        Operation(String type, String url) {
            this.type = type;
            this.url = url;
        }
    }

    // Simulates browser back button functionality
    public void simulateBrowser(List&lt;Operation&gt; operations) {
        StringStack stack = new StringStack();
        for (Operation op : operations) {
            if (op.type.equals("push")) {
                boolean success = stack.push(op.url);
                if (success) {
                    System.out.println("Pushed " + op.url + ", Current page: " + stack.peek());
                } else {
                    System.out.println("Push " + op.url + " failed: Stack full");
                }
            } else if (op.type.equals("pop")) {
                String popped = stack.pop();
                if (popped == null) {
                    System.out.println("Popped, Stack empty");
                } else {
                    System.out.println("Popped " + popped + ", Current page: " + 
                                       (stack.peek() != null ? stack.peek() : "Stack empty"));
                }
            }
        }
    }

    // Main method to test browser simulation
    public static void main(String[] args) {
        BrowserBackButtonSimulation simulator = new BrowserBackButtonSimulation();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("push", "https://page1.com"),
            new Operation("push", "https://page2.com"),
            new Operation("pop", null),
            new Operation("push", "https://page3.com"),
            new Operation("pop", null)
        );
        testCases.add(case1);
        
        // Test case 2: Empty stack
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("pop", null)
        );
        testCases.add(case2);
        
        // Test case 3: Single URL
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("push", "https://single.com"),
            new Operation("pop", null)
        );
        testCases.add(case3);
        
        // Test case 4: Multiple pushes
        List&lt;Operation&gt; case4 = Arrays.asList(
            new Operation("push", "https://site1.com"),
            new Operation("push", "https://site2.com"),
            new Operation("push", "https://site3.com"),
            new Operation("pop", null),
            new Operation("pop", null)
        );
        testCases.add(case4);
        
        // Test case 5: Null URL
        List&lt;Operation&gt; case5 = Arrays.asList(
            new Operation("push", null),
            new Operation("pop", null)
        );
        testCases.add(case5);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            simulator.simulateBrowser(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-40"><a class="header" href="#output-40">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Pushed https://page1.com, Current page: https://page1.com
Pushed https://page2.com, Current page: https://page2.com
Popped https://page2.com, Current page: https://page1.com
Pushed https://page3.com, Current page: https://page3.com
Popped https://page3.com, Current page: https://page1.com

Test case 2:
Popped, Stack empty

Test case 3:
Pushed https://single.com, Current page: https://single.com
Popped https://single.com, Current page: Stack empty

Test case 4:
Pushed https://site1.com, Current page: https://site1.com
Pushed https://site2.com, Current page: https://site2.com
Pushed https://site3.com, Current page: https://site3.com
Popped https://site3.com, Current page: https://site2.com
Popped https://site2.com, Current page: https://site1.com

Test case 5:
Pushed null, Current page: null
Popped null, Current page: Stack empty
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Pushes "page1", "page2", pops to "page1", pushes "page3", pops to "page1".</li>
<li>Test case 2: Pop on empty stack returns "Stack empty".</li>
<li>Test case 3: Pushes single URL, pops to empty stack.</li>
<li>Test case 4: Multiple pushes, then pops back to "site1".</li>
<li>Test case 5: Pushes null URL, pops to empty stack.</li>
</ul>
<h2 id="how-it-works-64"><a class="header" href="#how-it-works-64">How It Works</a></h2>
<ul>
<li><strong>StringStack</strong>:
<ul>
<li>Uses an array to store URLs, with <code>top</code> tracking the latest element.</li>
<li><code>push</code>: Adds a URL if the stack isn’t full.</li>
<li><code>pop</code>: Removes and returns the top URL if not empty.</li>
<li><code>peek</code>: Returns the top URL without removing it.</li>
<li><code>isEmpty</code>: Checks if the stack is empty.</li>
</ul>
</li>
<li><strong>simulateBrowser</strong>:
<ul>
<li>Pushes URLs to simulate navigation, prints current page.</li>
<li>Pops URLs to simulate back button, prints new current page or "Stack empty".</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Push "page1": stack = ["page1"], current = "page1".</li>
<li>Push "page2": stack = ["page1", "page2"], current = "page2".</li>
<li>Pop: Removes "page2", current = "page1".</li>
<li>Push "page3": stack = ["page1", "page3"], current = "page3".</li>
<li>Pop: Removes "page3", current = "page1".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal sequences, empty stack, single URL, multiple pushes, and null URL.</li>
</ul>
<h2 id="complexity-analysis-table-63"><a class="header" href="#complexity-analysis-table-63">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Push/Pop/Peek</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations.</li>
<li>Time complexity: O(1) for each push, pop, or peek; O(n) for processing n operations.</li>
<li>Space complexity: O(n) for the stack storing up to n URLs.</li>
<li>Worst case: O(n) time and O(n) space for many push operations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a stack to simulate browser navigation, as its LIFO nature naturally tracks the history of visited pages. Test with sequences that include multiple pops to verify the back button functionality.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null URLs and empty stack cases to avoid unexpected behavior. Ensure the stack size is sufficient to accommodate the input sequence.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="infix-to-postfix-conversion"><a class="header" href="#infix-to-postfix-conversion">Infix to Postfix Conversion</a></h1>
<h2 id="problem-statement-41"><a class="header" href="#problem-statement-41">Problem Statement</a></h2>
<p>Write a Java program that converts an infix expression (e.g., "A + B * C") to its postfix equivalent (e.g., "A B C * +") using a stack. The program should handle operators (+, -, *, /) and parentheses, pushing operators onto the stack based on precedence and popping them to the output when appropriate. Test the implementation with at least three different expressions, including simple expressions, expressions with parentheses, and complex expressions with multiple operators. You can visualize this as rearranging a mathematical sentence so that the operations are performed in the correct order without needing parentheses, like organizing tasks in a queue where the work gets done step by step.</p>
<p><strong>Input</strong>: A string representing an infix expression (e.g., "A + B * C", "(A + B) * C").
<strong>Output</strong>: A string representing the postfix expression (e.g., "A B C * +", "A B + C *").
<strong>Constraints</strong>:</p>
<ul>
<li>The input string length is between 0 and 10^5.</li>
<li>The string contains operands (single letters A-Z), operators (+, -, *, /), parentheses (()), and spaces.</li>
<li>The input may be empty, null, or invalid (handled gracefully).
<strong>Example</strong>:</li>
<li>Input: <code>"A + B * C"</code></li>
<li>Output: <code>"A B C * +"</code></li>
<li>Explanation: * has higher precedence than +, so B * C is processed first, resulting in A B C * +.</li>
<li>Input: <code>"(A + B) * C"</code></li>
<li>Output: <code>"A B + C *"</code></li>
<li>Explanation: Parentheses ensure A + B is evaluated first, then multiplied by C.</li>
<li>Input: <code>"A + B - C"</code></li>
<li>Output: <code>"A B + C -"</code></li>
<li>Explanation: Operators + and - have equal precedence, processed left to right.</li>
</ul>
<h2 id="pseudocode-41"><a class="header" href="#pseudocode-41">Pseudocode</a></h2>
<pre><code>CLASS CharStack
    SET array to new character array of size 1000
    SET top to -1
    
    FUNCTION push(char)
        IF top equals array length - 1 THEN
            RETURN false
        ENDIF
        INCREMENT top
        SET array[top] to char
        RETURN true
    ENDFUNCTION
    
    FUNCTION pop()
        IF top equals -1 THEN
            RETURN null
        ENDIF
        SET char to array[top]
        DECREMENT top
        RETURN char
    ENDFUNCTION
    
    FUNCTION peek()
        IF top equals -1 THEN
            RETURN null
        ENDIF
        RETURN array[top]
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN top equals -1
    ENDFUNCTION
ENDCLASS

FUNCTION getPrecedence(operator)
    IF operator is '*' or '/' THEN
        RETURN 2
    ELSE IF operator is '+' or '-' THEN
        RETURN 1
    ELSE
        RETURN 0
    ENDIF
ENDFUNCTION

FUNCTION infixToPostfix(expression)
    IF expression is null or empty THEN
        RETURN empty string
    ENDIF
    CREATE stack as new CharStack
    CREATE result as new StringBuilder
    FOR each char in expression
        IF char is letter THEN
            APPEND char to result
        ELSE IF char is '(' THEN
            PUSH char to stack
        ELSE IF char is ')' THEN
            WHILE stack is not empty and stack.peek() is not '('
                APPEND stack.pop() to result
            ENDWHILE
            IF stack is not empty THEN
                POP '(' from stack
            ENDIF
        ELSE IF char is operator (+, -, *, /) THEN
            WHILE stack is not empty and stack.peek() is not '(' and getPrecedence(stack.peek()) &gt;= getPrecedence(char)
                APPEND stack.pop() to result
            ENDWHILE
            PUSH char to stack
        ENDIF
    ENDFOR
    WHILE stack is not empty
        APPEND stack.pop() to result
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testExpressions to array of infix expressions
    FOR each expression in testExpressions
        PRINT input expression
        CALL infixToPostfix(expression)
        PRINT postfix result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-41"><a class="header" href="#algorithm-steps-41">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>CharStack</code> class with methods: <code>push</code>, <code>pop</code>, <code>peek</code>, <code>isEmpty</code>.</li>
<li>Define a <code>getPrecedence</code> function to return operator precedence: 2 for *, /; 1 for +, -; 0 for others.</li>
<li>In the <code>infixToPostfix</code> method:
a. If the input is null or empty, return an empty string.
b. Create a stack for operators and a StringBuilder for the result.
c. For each character in the expression:
<ul>
<li>If it’s a letter (operand), append it to the result.</li>
<li>If it’s '(', push it to the stack.</li>
<li>If it’s ')', pop operators from the stack to the result until '(' is found, then pop '('.</li>
<li>If it’s an operator, pop higher or equal precedence operators from the stack to the result, then push the current operator.
d. After processing, pop remaining operators from the stack to the result.
e. Return the result as a string.</li>
</ul>
</li>
<li>In the <code>main</code> method, test with at least three expressions, including simple, parenthesized, and complex cases.</li>
</ol>
<h2 id="java-implementation-64"><a class="header" href="#java-implementation-64">Java Implementation</a></h2>
<pre><code class="language-java">public class InfixToPostfixConversion {
    // Custom stack implementation for characters
    static class CharStack {
        private char[] array;
        private int top;
        private static final int DEFAULT_SIZE = 1000;

        public CharStack() {
            array = new char[DEFAULT_SIZE];
            top = -1;
        }

        public boolean push(char c) {
            if (top == array.length - 1) {
                return false; // Stack full
            }
            array[++top] = c;
            return true;
        }

        public Character pop() {
            if (top == -1) {
                return null; // Stack empty
            }
            return array[top--];
        }

        public Character peek() {
            if (top == -1) {
                return null; // Stack empty
            }
            return array[top];
        }

        public boolean isEmpty() {
            return top == -1;
        }
    }

    // Returns precedence of operators
    private int getPrecedence(char operator) {
        if (operator == '*' || operator == '/') {
            return 2;
        } else if (operator == '+' || operator == '-') {
            return 1;
        }
        return 0;
    }

    // Converts infix expression to postfix
    public String infixToPostfix(String expression) {
        if (expression == null || expression.isEmpty()) {
            return "";
        }
        CharStack stack = new CharStack();
        StringBuilder result = new StringBuilder();

        for (char c : expression.replaceAll("\\s", "").toCharArray()) {
            if (Character.isLetter(c)) {
                result.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() &amp;&amp; stack.peek() != '(') {
                    result.append(stack.pop());
                }
                if (!stack.isEmpty()) {
                    stack.pop(); // Remove '('
                }
            } else if (c == '+' || c == '-' || c == '*' || c == '/') {
                while (!stack.isEmpty() &amp;&amp; stack.peek() != '(' &amp;&amp; 
                       getPrecedence(stack.peek()) &gt;= getPrecedence(c)) {
                    result.append(stack.pop());
                }
                stack.push(c);
            }
        }

        while (!stack.isEmpty()) {
            result.append(stack.pop());
        }

        return result.toString();
    }

    // Main method to test infix to postfix conversion
    public static void main(String[] args) {
        InfixToPostfixConversion converter = new InfixToPostfixConversion();

        // Test cases
        String[] testExpressions = {
            "A + B * C",          // Simple expression
            "(A + B) * C",        // Expression with parentheses
            "A + B * C - D / E",  // Complex expression
            "",                   // Empty string
            "X * (Y + Z)"        // Nested parentheses
        };

        for (int i = 0; i &lt; testExpressions.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Infix: \"" + testExpressions[i] + "\"");
            String result = converter.infixToPostfix(testExpressions[i]);
            System.out.println("Postfix: \"" + result + "\"\n");
        }
    }
}
</code></pre>
<h2 id="output-41"><a class="header" href="#output-41">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Infix: "A + B * C"
Postfix: "ABC*+"

Test case 2:
Infix: "(A + B) * C"
Postfix: "AB+C*"

Test case 3:
Infix: "A + B * C - D / E"
Postfix: "ABC*+DE/-"

Test case 4:
Infix: ""
Postfix: ""

Test case 5:
Infix: "X * (Y + Z)"
Postfix: "XYZ+*"
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>"A + B * C"</code> → * has higher precedence, so B * C becomes "BC*", then + gives "ABC*+".</li>
<li>Test case 2: <code>"(A + B) * C"</code> → Parentheses prioritize A + B, giving "AB+", then * gives "AB+C*".</li>
<li>Test case 3: <code>"A + B * C - D / E"</code> → * and / have higher precedence, processed left to right, then + and -, giving "ABC*+DE/-".</li>
<li>Test case 4: <code>""</code> → Empty input returns empty string.</li>
<li>Test case 5: <code>"X * (Y + Z)"</code> → Parentheses prioritize Y + Z, giving "YZ+", then * gives "XYZ+*".</li>
</ul>
<h2 id="how-it-works-65"><a class="header" href="#how-it-works-65">How It Works</a></h2>
<ul>
<li><strong>CharStack</strong>:
<ul>
<li>Stores operators and parentheses, with methods <code>push</code>, <code>pop</code>, <code>peek</code>, <code>isEmpty</code>.</li>
</ul>
</li>
<li><strong>getPrecedence</strong>:
<ul>
<li>Assigns precedence: 2 for *, /; 1 for +, -; 0 for others.</li>
</ul>
</li>
<li><strong>infixToPostfix</strong>:
<ul>
<li>Outputs operands (letters) directly to the result.</li>
<li>Pushes '(' to stack, pops operators until ')' for closing parentheses.</li>
<li>For operators, pops higher/equal precedence operators, then pushes current operator.</li>
<li>Pops remaining operators at the end.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: <code>"A + B * C"</code>.</li>
<li>A: Append to result → "A".</li>
<li>+: Push to stack → [+].</li>
<li>B: Append to result → "AB".</li>
<li>*: Higher precedence than +, push → [+, *].</li>
<li>C: Append to result → "ABC".</li>
<li>End: Pop * → "ABC*", pop + → "ABC*+".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests simple, parenthesized, complex, empty, and nested expressions.</li>
</ul>
<h2 id="complexity-analysis-table-64"><a class="header" href="#complexity-analysis-table-64">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Push/Pop/Peek</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input expression.</li>
<li>Time complexity: O(n) for iterating through the expression, with O(1) for each stack operation.</li>
<li>Space complexity: O(n) for the stack (worst case: all operators/parentheses) and StringBuilder.</li>
<li>Worst case: O(n) time and O(n) space for expressions like <code>"((A+B)*C)"</code>.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a stack to manage operator precedence in infix-to-postfix conversion, as it naturally handles the order of operations. Test with parentheses and multiple operator types to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle invalid inputs (e.g., unbalanced parentheses) gracefully to avoid stack underflow. Remove spaces from the input to simplify processing.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="parentheses-checker"><a class="header" href="#parentheses-checker">Parentheses Checker</a></h1>
<h2 id="problem-statement-42"><a class="header" href="#problem-statement-42">Problem Statement</a></h2>
<p>Write a Java program that uses a stack to check if a string of parentheses, including round '()', curly '{}', and square '[]' brackets, is balanced. The program should push opening brackets onto the stack and pop them when a matching closing bracket is found, returning true if the string is balanced and false otherwise. Test the implementation with various inputs, including valid and invalid parentheses strings, empty strings, and strings with non-bracket characters. You can visualize this as stacking open locks and checking if each closing lock perfectly matches and removes its corresponding open lock, ensuring no locks are left unmatched.</p>
<p><strong>Input</strong>: A string containing parentheses and possibly other characters (e.g., <code>"{[()]}"</code>, <code>"((}"</code>, <code>""</code>).
<strong>Output</strong>: A boolean indicating if the parentheses are balanced (e.g., <code>true</code> for <code>"{[()]}"</code>, <code>false</code> for <code>"((}"</code>).
<strong>Constraints</strong>:</p>
<ul>
<li>String length is between 0 and 10^5.</li>
<li>The string may contain '(', ')', '{', '}', '[', ']', and other ASCII characters.</li>
<li>The input may be empty or null.
<strong>Example</strong>:</li>
<li>Input: <code>"{[()]}"</code></li>
<li>Output: <code>true</code></li>
<li>Explanation: Each opening bracket has a matching closing bracket in the correct order: { → }, [ → ], ( → ).</li>
<li>Input: <code>"((}"</code></li>
<li>Output: <code>false</code></li>
<li>Explanation: The second '(' has no matching ')', and '}' has no matching '{'.</li>
<li>Input: <code>""</code></li>
<li>Output: <code>true</code></li>
<li>Explanation: An empty string is considered balanced.</li>
</ul>
<h2 id="pseudocode-42"><a class="header" href="#pseudocode-42">Pseudocode</a></h2>
<pre><code>CLASS CharStack
    SET array to new character array of size 1000
    SET top to -1
    
    FUNCTION push(char)
        IF top equals array length - 1 THEN
            RETURN false (stack full)
        ENDIF
        INCREMENT top
        SET array[top] to char
        RETURN true
    ENDFUNCTION
    
    FUNCTION pop()
        IF top equals -1 THEN
            RETURN null (stack empty)
        ENDIF
        SET char to array[top]
        DECREMENT top
        RETURN char
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN top equals -1
    ENDFUNCTION
ENDCLASS

FUNCTION isBalanced(input)
    IF input is null THEN
        RETURN true
    ENDIF
    CREATE stack as new CharStack
    FOR each char in input
        IF char is '(', '{', or '[' THEN
            PUSH char to stack
        ELSE IF char is ')', '}', or ']' THEN
            IF stack is empty THEN
                RETURN false
            ENDIF
            SET popped to stack.pop()
            IF popped does not match char THEN
                RETURN false
            ENDIF
        ENDIF
    ENDFOR
    RETURN stack is empty
ENDFUNCTION

FUNCTION main()
    SET testStrings to array of strings including various cases
    FOR each string in testStrings
        PRINT input string
        CALL isBalanced(string)
        PRINT whether string is balanced
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-42"><a class="header" href="#algorithm-steps-42">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>CharStack</code> class with:
a. An array to store characters, with a <code>top</code> index.
b. Methods: <code>push</code> (add character), <code>pop</code> (remove and return character), <code>isEmpty</code> (check if empty).</li>
<li>In the <code>isBalanced</code> method:
a. If the input is null, return true (considered balanced).
b. Create a new <code>CharStack</code>.
c. Iterate through each character in the input:
<ul>
<li>If it’s an opening bracket ('(', '{', '['), push it onto the stack.</li>
<li>If it’s a closing bracket (')', '}', ']'):
<ul>
<li>If the stack is empty, return false (no matching opening bracket).</li>
<li>Pop the top character and check if it matches the closing bracket.</li>
<li>If no match (e.g., '(' with '}'), return false.
d. After iteration, return true if the stack is empty (all brackets matched), false otherwise.</li>
</ul>
</li>
</ul>
</li>
<li>In the <code>main</code> method, test with valid, invalid, empty, and non-bracket strings, printing the input and result.</li>
</ol>
<h2 id="java-implementation-65"><a class="header" href="#java-implementation-65">Java Implementation</a></h2>
<pre><code class="language-java">public class ParenthesesChecker {
    // Custom stack implementation for characters
    static class CharStack {
        private char[] array;
        private int top;
        private static final int DEFAULT_SIZE = 1000;

        public CharStack() {
            array = new char[DEFAULT_SIZE];
            top = -1;
        }

        public boolean push(char c) {
            if (top == array.length - 1) {
                return false; // Stack full
            }
            array[++top] = c;
            return true;
        }

        public Character pop() {
            if (top == -1) {
                return null; // Stack empty
            }
            return array[top--];
        }

        public boolean isEmpty() {
            return top == -1;
        }
    }

    // Checks if a string of parentheses is balanced
    public boolean isBalanced(String input) {
        if (input == null) {
            return true;
        }
        CharStack stack = new CharStack();
        
        for (char c : input.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else if (c == ')' || c == '}' || c == ']') {
                if (stack.isEmpty()) {
                    return false; // No matching opening bracket
                }
                Character popped = stack.pop();
                if (popped == null || !isMatchingPair(popped, c)) {
                    return false; // Mismatched brackets
                }
            }
        }
        return stack.isEmpty(); // Balanced only if stack is empty
    }

    // Helper method to check if brackets match
    private boolean isMatchingPair(char open, char close) {
        return (open == '(' &amp;&amp; close == ')') ||
               (open == '{' &amp;&amp; close == '}') ||
               (open == '[' &amp;&amp; close == ']');
    }

    // Main method to test parentheses checker
    public static void main(String[] args) {
        ParenthesesChecker checker = new ParenthesesChecker();

        // Test cases
        String[] testStrings = {
            "{[()]}",          // Valid, balanced
            "((}",            // Invalid, mismatched
            "",               // Empty string
            "abc",            // No brackets
            "({[]})",         // Valid, nested
            "([)",            // Invalid, unmatched
            null,             // Null input
            "((()))"          // Valid, deeply nested
        };

        for (int i = 0; i &lt; testStrings.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input: \"" + (testStrings[i] != null ? testStrings[i] : "null") + "\"");
            boolean result = checker.isBalanced(testStrings[i]);
            System.out.println("Balanced: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-42"><a class="header" href="#output-42">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input: "{[()]}"
Balanced: true

Test case 2:
Input: "((}"
Balanced: false

Test case 3:
Input: ""
Balanced: true

Test case 4:
Input: "abc"
Balanced: true

Test case 5:
Input: "({[]})"
Balanced: true

Test case 6:
Input: "([)"
Balanced: false

Test case 7:
Input: "null"
Balanced: true

Test case 8:
Input: "((()))"
Balanced: true
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: <code>"{[()]}"</code> → All brackets match: {→}, [→], (→) → <code>true</code>.</li>
<li>Test case 2: <code>"((}"</code> → Second '(' unmatched, '}' has no '{' → <code>false</code>.</li>
<li>Test case 3: <code>""</code> → Empty string, no brackets → <code>true</code>.</li>
<li>Test case 4: <code>"abc"</code> → No brackets, ignored → <code>true</code>.</li>
<li>Test case 5: <code>"({[]})"</code> → All brackets match in nested order → <code>true</code>.</li>
<li>Test case 6: <code>"([)"</code> → '[' does not match ')' → <code>false</code>.</li>
<li>Test case 7: <code>null</code> → Considered balanced → <code>true</code>.</li>
<li>Test case 8: <code>"((()))"</code> → Deeply nested, all match → <code>true</code>.</li>
</ul>
<h2 id="how-it-works-66"><a class="header" href="#how-it-works-66">How It Works</a></h2>
<ul>
<li><strong>CharStack</strong>:
<ul>
<li>Uses an array to store characters, with <code>top</code> tracking the latest element.</li>
<li><code>push</code>: Adds an opening bracket if the stack isn’t full.</li>
<li><code>pop</code>: Removes and returns the top bracket if the stack isn’t empty.</li>
<li><code>isEmpty</code>: Checks if the stack is empty.</li>
</ul>
</li>
<li><strong>isBalanced</strong>:
<ul>
<li>Pushes opening brackets ('(', '{', '[') onto the stack.</li>
<li>For closing brackets, pops the top bracket and checks for a match.</li>
<li>Returns false if the stack is empty when a closing bracket is found or if brackets don’t match.</li>
<li>Returns true if the stack is empty after processing (all brackets matched).</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: <code>"{[()]}"</code>.</li>
<li>Push '{': stack = ['{'].</li>
<li>Push '[': stack = ['{', '['].</li>
<li>Push '(': stack = ['{', '[', '('].</li>
<li>Pop for ')': Matches '(', stack = ['{', '['].</li>
<li>Pop for ']': Matches '[', stack = ['{'].</li>
<li>Pop for '}': Matches '{', stack = [].</li>
<li>Stack empty → <code>true</code>.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests valid, invalid, empty, non-bracket, and null inputs.</li>
</ul>
<h2 id="complexity-analysis-table-65"><a class="header" href="#complexity-analysis-table-65">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Push (per char)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Pop (per char)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input string.</li>
<li>Time complexity: O(n) for iterating through the string, with O(1) for each push/pop operation.</li>
<li>Space complexity: O(n) for the stack in the worst case (all opening brackets).</li>
<li>Worst case: O(n) time and O(n) space for a string like <code>"(((((..."</code>.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a stack to check balanced parentheses, as its LIFO nature naturally tracks nested brackets. Test with nested, mismatched, and non-bracket inputs to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null inputs and empty stacks to avoid <code>NullPointerException</code> or incorrect results. Ensure matching logic covers all bracket types ('()', '{}', '[]').</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="stack-min-function"><a class="header" href="#stack-min-function">Stack Min Function</a></h1>
<h2 id="problem-statement-43"><a class="header" href="#problem-statement-43">Problem Statement</a></h2>
<p>Write a Java program that extends a stack implementation to include a <code>min()</code> function that returns the minimum element in the stack in O(1) time. Use an additional stack to track the minimum elements, pushing the current minimum when a new element is added and popping it when an element is removed. The program should support standard stack operations (<code>push</code>, <code>pop</code>, <code>isEmpty</code>) and the <code>min</code> function, handling integers as stack elements. Test the implementation with various sequences of push and pop operations, including edge cases like empty stacks and single-element stacks. You can visualize this as maintaining a leaderboard alongside a stack of scores, where the leaderboard always shows the lowest score at a glance without recalculating.</p>
<p><strong>Input</strong>: A sequence of operations (push, pop, min) on a stack of integers (e.g., push 3, push 5, min, push 2, min, pop, min).
<strong>Output</strong>: Results of operations, including the minimum element when requested (e.g., min returns 3, then 2, then 3).
<strong>Constraints</strong>:</p>
<ul>
<li>Stack size is between 0 and 10^5.</li>
<li>Elements are integers in the range [-10^9, 10^9].</li>
<li>The stack may be empty when <code>min</code> or <code>pop</code> is called.
<strong>Example</strong>:</li>
<li>Input: Operations = [push(3), push(5), min, push(2), min, pop, min]</li>
<li>Output: [-, -, 3, -, 2, -, 3]</li>
<li>Explanation: Push 3 (min=3), push 5 (min=3), min returns 3, push 2 (min=2), min returns 2, pop 2 (min=3), min returns 3.</li>
<li>Input: Operations = [min on empty stack]</li>
<li>Output: [null]</li>
<li>Explanation: Min on empty stack returns null.</li>
</ul>
<h2 id="pseudocode-43"><a class="header" href="#pseudocode-43">Pseudocode</a></h2>
<pre><code>CLASS MinStack
    SET dataStack to new integer array of size 1000
    SET minStack to new integer array of size 1000
    SET top to -1
    
    FUNCTION push(value)
        IF top equals dataStack length - 1 THEN
            RETURN false (stack full)
        ENDIF
        INCREMENT top
        SET dataStack[top] to value
        IF minStack is empty OR value is less than or equal to minStack[top] THEN
            PUSH value to minStack
        ENDIF
        RETURN true
    ENDFUNCTION
    
    FUNCTION pop()
        IF top equals -1 THEN
            RETURN null (stack empty)
        ENDIF
        SET value to dataStack[top]
        IF value equals minStack[top] THEN
            POP from minStack
        ENDIF
        DECREMENT top
        RETURN value
    ENDFUNCTION
    
    FUNCTION min()
        IF top equals -1 THEN
            RETURN null (stack empty)
        ENDIF
        RETURN minStack[top]
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN top equals -1
    ENDFUNCTION
ENDCLASS

FUNCTION testMinStack(operations)
    CREATE stack as new MinStack
    FOR each operation in operations
        IF operation.type equals "push" THEN
            CALL stack.push(operation.value)
            PRINT push result
        ELSE IF operation.type equals "pop" THEN
            SET result to stack.pop()
            PRINT popped value
        ELSE IF operation.type equals "min" THEN
            SET result to stack.min()
            PRINT minimum value
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testMinStack(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-43"><a class="header" href="#algorithm-steps-43">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>MinStack</code> class with:
a. Two arrays: <code>dataStack</code> for values, <code>minStack</code> for tracking minimums.
b. A <code>top</code> index for both stacks.
c. Methods: <code>push</code> (add value and update minStack), <code>pop</code> (remove value and update minStack), <code>min</code> (return top of minStack), <code>isEmpty</code> (check if empty).</li>
<li>In <code>push(value)</code>:
a. If stack is full, return false.
b. Add value to <code>dataStack</code>.
c. If <code>minStack</code> is empty or value ≤ current minimum, push value to <code>minStack</code>.</li>
<li>In <code>pop()</code>:
a. If stack is empty, return null.
b. If popped value equals current minimum, pop from <code>minStack</code>.
c. Return popped value.</li>
<li>In <code>min()</code>:
a. If stack is empty, return null.
b. Return top of <code>minStack</code>.</li>
<li>In the <code>main</code> method, test with sequences of push, pop, and min operations, including empty stacks and single-element cases.</li>
</ol>
<h2 id="java-implementation-66"><a class="header" href="#java-implementation-66">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class StackMinFunction {
    // MinStack class with min() function
    static class MinStack {
        private int[] dataStack;
        private int[] minStack;
        private int top;
        private static final int DEFAULT_SIZE = 1000;

        public MinStack() {
            dataStack = new int[DEFAULT_SIZE];
            minStack = new int[DEFAULT_SIZE];
            top = -1;
        }

        public boolean push(int value) {
            if (top == dataStack.length - 1) {
                return false; // Stack full
            }
            dataStack[++top] = value;
            if (top == 0 || value &lt;= minStack[top - 1]) {
                minStack[top] = value; // Push to minStack if value is new minimum
            } else {
                minStack[top] = minStack[top - 1]; // Copy previous minimum
            }
            return true;
        }

        public Integer pop() {
            if (top == -1) {
                return null; // Stack empty
            }
            return dataStack[top--]; // Pop from dataStack, minStack follows
        }

        public Integer min() {
            if (top == -1) {
                return null; // Stack empty
            }
            return minStack[top]; // Return current minimum
        }

        public boolean isEmpty() {
            return top == -1;
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        Integer value; // For push operations

        Operation(String type, Integer value) {
            this.type = type;
            this.value = value;
        }
    }

    // Tests the MinStack with a sequence of operations
    public void testMinStack(List&lt;Operation&gt; operations) {
        MinStack stack = new MinStack();
        for (Operation op : operations) {
            if (op.type.equals("push")) {
                boolean success = stack.push(op.value);
                System.out.println("Push " + op.value + ": " + (success ? "Success" : "Failed"));
            } else if (op.type.equals("pop")) {
                Integer result = stack.pop();
                System.out.println("Pop: " + (result != null ? result : "null"));
            } else if (op.type.equals("min")) {
                Integer result = stack.min();
                System.out.println("Min: " + (result != null ? result : "null"));
            }
        }
    }

    // Main method to test MinStack
    public static void main(String[] args) {
        StackMinFunction tester = new StackMinFunction();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("push", 3),
            new Operation("push", 5),
            new Operation("min", null),
            new Operation("push", 2),
            new Operation("min", null),
            new Operation("pop", null),
            new Operation("min", null)
        );
        testCases.add(case1);
        
        // Test case 2: Empty stack
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("min", null),
            new Operation("pop", null)
        );
        testCases.add(case2);
        
        // Test case 3: Single element
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("push", 1),
            new Operation("min", null)
        );
        testCases.add(case3);
        
        // Test case 4: Large sequence
        List&lt;Operation&gt; case4 = new ArrayList&lt;&gt;();
        case4.add(new Operation("push", 10));
        case4.add(new Operation("push", 5));
        case4.add(new Operation("push", 15));
        case4.add(new Operation("min", null));
        case4.add(new Operation("pop", null));
        case4.add(new Operation("min", null));
        testCases.add(case4);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            tester.testMinStack(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-43"><a class="header" href="#output-43">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Push 3: Success
Push 5: Success
Min: 3
Push 2: Success
Min: 2
Pop: 2
Min: 3

Test case 2:
Min: null
Pop: null

Test case 3:
Push 1: Success
Min: 1

Test case 4:
Push 10: Success
Push 5: Success
Push 15: Success
Min: 5
Pop: 15
Min: 5
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Push 3 (min=3), push 5 (min=3), min returns 3, push 2 (min=2), min returns 2, pop 2 (min=3), min returns 3.</li>
<li>Test case 2: Min and pop on empty stack return null.</li>
<li>Test case 3: Push 1 (min=1), min returns 1.</li>
<li>Test case 4: Push 10 (min=10), push 5 (min=5), push 15 (min=5), min returns 5, pop 15 (min=5), min returns 5.</li>
</ul>
<h2 id="how-it-works-67"><a class="header" href="#how-it-works-67">How It Works</a></h2>
<ul>
<li><strong>MinStack</strong>:
<ul>
<li>Uses two arrays: <code>dataStack</code> for values, <code>minStack</code> for minimums.</li>
<li><code>push</code>: Adds value to <code>dataStack</code>; pushes to <code>minStack</code> if value ≤ current minimum, else copies current minimum.</li>
<li><code>pop</code>: Removes value from <code>dataStack</code>; adjusts <code>minStack</code> to maintain minimum.</li>
<li><code>min</code>: Returns top of <code>minStack</code> in O(1) time.</li>
<li><code>isEmpty</code>: Checks if stack is empty.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Push 3: <code>dataStack=[3]</code>, <code>minStack=[3]</code>, <code>top=0</code>.</li>
<li>Push 5: <code>dataStack=[3,5]</code>, <code>minStack=[3,3]</code>, <code>top=1</code>.</li>
<li>Min: Returns 3.</li>
<li>Push 2: <code>dataStack=[3,5,2]</code>, <code>minStack=[3,3,2]</code>, <code>top=2</code>.</li>
<li>Min: Returns 2.</li>
<li>Pop: Removes 2, <code>dataStack=[3,5]</code>, <code>minStack=[3,3]</code>, <code>top=1</code>.</li>
<li>Min: Returns 3.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal sequences, empty stacks, single elements, and larger sequences.</li>
</ul>
<h2 id="complexity-analysis-table-66"><a class="header" href="#complexity-analysis-table-66">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Push</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Pop</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Min</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations.</li>
<li>Time complexity: O(1) for push, pop, and min operations.</li>
<li>Space complexity: O(n) for both stacks, as each push may add to both.</li>
<li>Worst case: O(n) space for all operations, O(1) time per operation.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use an additional stack to track minimums for O(1) min queries, pushing the minimum at each step. Test with sequences that include repeated minimums to verify correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure both stacks are synchronized during push and pop to avoid incorrect minimums. Handle empty stack cases to prevent null pointer issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="stringbuilder-capacity-management-1"><a class="header" href="#stringbuilder-capacity-management-1">StringBuilder Capacity Management</a></h1>
<h2 id="problem-statement-44"><a class="header" href="#problem-statement-44">Problem Statement</a></h2>
<p>Write a Java program that demonstrates StringBuilder’s capacity resizing by appending strings and monitoring capacity changes using the <code>capacity()</code> method. The program should analyze when resizing occurs and how the capacity adjusts based on the appended content. Test the implementation with different scenarios, including appending small strings, large strings, and using StringBuilder instances with varying initial capacities. You can visualize this as filling a stretchable notebook, where the notebook expands its pages (capacity) automatically when you add more notes, and you track how and when it grows to accommodate the text.</p>
<p><strong>Input</strong>: A series of strings to append to StringBuilder instances with different initial configurations (e.g., default capacity, specified initial capacity).
<strong>Output</strong>: The final string, a log of capacity changes after each append operation, and an analysis of when resizing occurs.
<strong>Constraints</strong>:</p>
<ul>
<li>String lengths are between 0 and 10^5.</li>
<li>Strings contain printable ASCII characters.</li>
<li>Initial capacities are non-negative integers.</li>
<li>The input strings may be null or empty.
<strong>Example</strong>:</li>
<li>Input: Append <code>"hello"</code>, <code>" world"</code> to a StringBuilder with default capacity (16).</li>
<li>Output:
<pre><code>Initial capacity: 16
After appending "hello": length=5, capacity=16
After appending " world": length=11, capacity=16
Final string: "hello world"
</code></pre>
</li>
<li>Explanation: No resizing occurs as the total length (11) fits within the initial capacity (16).</li>
<li>Input: Append a 20-character string to a StringBuilder with default capacity (16).</li>
<li>Output:
<pre><code>Initial capacity: 16
After appending: length=20, capacity=34
Final string: "abcdefghijklmnopqrst"
</code></pre>
</li>
<li>Explanation: Resizing occurs because 20 exceeds 16, new capacity = (16 * 2) + 2 = 34.</li>
</ul>
<h2 id="pseudocode-44"><a class="header" href="#pseudocode-44">Pseudocode</a></h2>
<pre><code>FUNCTION demonstrateCapacityManagement(testCases)
    FOR each testCase in testCases
        SET initialCapacity to testCase.initialCapacity
        SET strings to testCase.strings
        CREATE stringBuilder with initialCapacity
        PRINT initial capacity
        FOR each string in strings
            SET oldCapacity to stringBuilder.capacity()
            APPEND string to stringBuilder
            SET newCapacity to stringBuilder.capacity()
            PRINT length, capacity, and whether resizing occurred
        ENDFOR
        PRINT final string
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (initialCapacity, strings) pairs
    CALL demonstrateCapacityManagement(testCases)
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-44"><a class="header" href="#algorithm-steps-44">Algorithm Steps</a></h2>
<ol>
<li>Define a method to demonstrate capacity management:
a. For each test case, create a StringBuilder with the specified initial capacity.
b. Print the initial capacity using <code>capacity()</code>.
c. For each string to append:
<ul>
<li>Record the current capacity.</li>
<li>Append the string using <code>StringBuilder.append</code>.</li>
<li>Check the new capacity and note if resizing occurred (capacity increased).</li>
<li>Print the current length, capacity, and resizing status.
d. Print the final string.</li>
</ul>
</li>
<li>Handle null or empty strings by skipping or appending empty content.</li>
<li>In the <code>main</code> method, test with different scenarios:
<ul>
<li>Default capacity (16) with small strings.</li>
<li>Default capacity with a large string that triggers resizing.</li>
<li>Custom initial capacity with multiple appends.</li>
<li>Empty or null strings.</li>
</ul>
</li>
<li>Analyze resizing: StringBuilder doubles the current capacity and adds 2 when the length exceeds the capacity.</li>
</ol>
<h2 id="java-implementation-67"><a class="header" href="#java-implementation-67">Java Implementation</a></h2>
<pre><code class="language-java">public class StringBuilderCapacityManagement {
    // Demonstrates StringBuilder capacity resizing
    public void demonstrateCapacityManagement(String[][] testCases, int[] initialCapacities) {
        for (int i = 0; i &lt; testCases.length; i++) {
            String[] strings = testCases[i];
            int initialCapacity = initialCapacities[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Initial capacity: " + initialCapacity);
            
            StringBuilder sb = new StringBuilder(initialCapacity);
            for (int j = 0; j &lt; strings.length; j++) {
                String str = strings[j] != null ? strings[j] : "";
                int oldCapacity = sb.capacity();
                sb.append(str);
                int newCapacity = sb.capacity();
                System.out.println("After appending \"" + (str.length() &gt; 20 ? str.substring(0, 20) + "..." : str) + "\": " +
                                   "length=" + sb.length() + ", capacity=" + newCapacity +
                                   (newCapacity &gt; oldCapacity ? " (resized)" : ""));
            }
            System.out.println("Final string: \"" + (sb.length() &gt; 50 ? sb.substring(0, 50) + "..." : sb.toString()) + "\"\n");
        }
    }

    // Main method to test capacity management
    public static void main(String[] args) {
        StringBuilderCapacityManagement manager = new StringBuilderCapacityManagement();

        // Test cases
        String[][] testCases = {
            {"hello", " world"},                    // Small strings, default capacity
            {generateLargeString(20)},             // Large string, triggers resizing
            {"a", "b", "c", "d"},                 // Multiple small strings, custom capacity
            {""},                                  // Empty string
            {null}                                 // Null string
        };
        int[] initialCapacities = {16, 16, 5, 16, 16}; // Corresponding initial capacities

        manager.demonstrateCapacityManagement(testCases, initialCapacities);
    }

    // Helper method to generate a large string
    private static String generateLargeString(int length) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; length; i++) {
            sb.append((char) ('a' + (i % 26)));
        }
        return sb.toString();
    }
}
</code></pre>
<h2 id="output-44"><a class="header" href="#output-44">Output</a></h2>
<p>Running the <code>main</code> method produces (actual capacities may vary slightly depending on JVM implementation):</p>
<pre><code>Test case 1:
Initial capacity: 16
After appending "hello": length=5, capacity=16
After appending " world": length=11, capacity=16
Final string: "hello world"

Test case 2:
Initial capacity: 16
After appending "abcdefghijklmnopqrst...": length=20, capacity=34 (resized)
Final string: "abcdefghijklmnopqrst"

Test case 3:
Initial capacity: 5
After appending "a": length=1, capacity=5
After appending "b": length=2, capacity=5
After appending "c": length=3, capacity=5
After appending "d": length=4, capacity=5
Final string: "abcd"

Test case 4:
Initial capacity: 16
After appending "": length=0, capacity=16
Final string: ""

Test case 5:
Initial capacity: 16
After appending "": length=0, capacity=16
Final string: ""
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Appends <code>"hello"</code>, <code>" world"</code>. Length (11) &lt; capacity (16), no resizing.</li>
<li>Test case 2: Appends 20-character string. Length (20) &gt; 16, resizes to (16 * 2) + 2 = 34.</li>
<li>Test case 3: Custom capacity 5, appends four single characters. Length (4) ≤ 5, no resizing.</li>
<li>Test case 4: Empty string, no change in length or capacity.</li>
<li>Test case 5: Null string treated as empty, no change.</li>
</ul>
<h2 id="how-it-works-68"><a class="header" href="#how-it-works-68">How It Works</a></h2>
<ul>
<li><strong>StringBuilder Capacity</strong>: Represents the size of the internal character array. Default is 16 if not specified.</li>
<li><strong>Resizing</strong>: When the length exceeds capacity, StringBuilder allocates a new array with capacity = (oldCapacity * 2) + 2.</li>
<li><strong>demonstrateCapacityManagement</strong>:
<ul>
<li>Creates StringBuilder with specified initial capacity.</li>
<li>Tracks capacity before and after each append.</li>
<li>Reports resizing when new capacity exceeds old capacity.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 2)</strong>:
<ul>
<li>Initial: <code>capacity = 16</code>, <code>length = 0</code>.</li>
<li>Append <code>"abcdefghijklmnopqrst"</code> (20 chars): <code>length = 20</code> &gt; 16, new capacity = (16 * 2) + 2 = 34.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests with small strings, large strings triggering resizing, custom capacity, and edge cases.</li>
<li><strong>Analysis</strong>: Resizing occurs when the total length after appending exceeds the current capacity, doubling the capacity plus 2 to accommodate future appends efficiently.</li>
</ul>
<h2 id="complexity-analysis-table-67"><a class="header" href="#complexity-analysis-table-67">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Append</td><td>O(m)</td><td>O(m)</td></tr>
<tr><td>Capacity Check</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Resizing</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Full Algorithm</td><td>O(k * m)</td><td>O(n + k * m)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the current length of the StringBuilder, m is the length of the appended string, k is the number of append operations.</li>
<li>Append: O(m) for copying characters, amortized O(1) if no resizing.</li>
<li>Resizing: O(n) when copying the internal array to a larger one.</li>
<li>Full algorithm: O(k * m) time for k appends, O(n + k * m) space for the final StringBuilder content.</li>
<li>Worst case: Frequent resizing for large strings increases time and space.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Set an appropriate initial capacity for StringBuilder when the expected size is known to minimize resizing. Use <code>capacity()</code> to monitor and understand resizing behavior during development.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Avoid unnecessarily small initial capacities, as frequent resizing can degrade performance. Handle null inputs to prevent unexpected behavior during append operations.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queues-problem-solving-with-dsa"><a class="header" href="#queues-problem-solving-with-dsa">Queues Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-4"><a class="header" href="#-what-you-will-learn-4">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="circular-queue-test"><a class="header" href="#circular-queue-test">Circular Queue Test</a></h1>
<h2 id="problem-statement-45"><a class="header" href="#problem-statement-45">Problem Statement</a></h2>
<p>Write a Java program that implements a circular queue to handle edge cases, such as enqueueing and dequeuing in a loop, and tests it with a sequence of operations to verify circular behavior. The circular queue should reuse array space by wrapping around when the rear pointer reaches the end, and handle full and empty queue conditions. Test the implementation with various sequences of enqueue and dequeue operations, including wrap-around scenarios, full queues, and empty queues. You can visualize this as a circular conveyor belt where items are added and removed, and when the belt’s end is reached, it loops back to the start to continue adding items.</p>
<p><strong>Input</strong>: A sequence of operations, where each operation is either:</p>
<ul>
<li>Enqueue: Add an integer to the queue (e.g., enqueue 5).</li>
<li>Dequeue: Remove and return the next integer from the queue.
<strong>Output</strong>: For each operation, print the action performed (enqueue or dequeue) and the result, including queue state or error messages for full/empty conditions.
<strong>Constraints</strong>:</li>
<li>Queue capacity is fixed (e.g., 5 elements for testing).</li>
<li>Elements are integers in the range [-10^9, 10^9].</li>
<li>The queue may be empty or full during operations.
<strong>Example</strong>:</li>
<li>Input: Operations = [enqueue(1), enqueue(2), enqueue(3), dequeue, enqueue(4), dequeue, enqueue(5)]</li>
<li>Output:
<pre><code>Enqueued 1, Queue: [1]
Enqueued 2, Queue: [1, 2]
Enqueued 3, Queue: [1, 2, 3]
Dequeued 1, Queue: [2, 3]
Enqueued 4, Queue: [2, 3, 4]
Dequeued 2, Queue: [3, 4]
Enqueued 5, Queue: [3, 4, 5]
</code></pre>
</li>
<li>Explanation: The queue operates in FIFO order, reusing space as elements are dequeued.</li>
<li>Input: Operations = [enqueue(1), enqueue(2), enqueue(3), enqueue(4), enqueue(5), enqueue(6) on capacity 5]</li>
<li>Output: <code>Enqueue 6 failed: Queue full</code></li>
</ul>
<h2 id="pseudocode-45"><a class="header" href="#pseudocode-45">Pseudocode</a></h2>
<pre><code>CLASS CircularQueue
    SET array to new integer array of size capacity
    SET front to 0
    SET rear to -1
    SET size to 0
    SET capacity to input capacity
    
    FUNCTION enqueue(number)
        IF size equals capacity THEN
            RETURN false (queue full)
        ENDIF
        SET rear to (rear + 1) mod capacity
        SET array[rear] to number
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null (queue empty)
        ENDIF
        SET number to array[front]
        SET front to (front + 1) mod capacity
        DECREMENT size
        RETURN number
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
    
    FUNCTION isFull()
        RETURN size equals capacity
    ENDFUNCTION
    
    FUNCTION toString()
        CREATE result as empty string
        APPEND "["
        FOR i from 0 to size - 1
            SET index to (front + i) mod capacity
            APPEND array[index] and ", " to result
        ENDFOR
        IF result ends with ", " THEN
            REMOVE last ", "
        ENDIF
        APPEND "]" to result
        RETURN result
    ENDFUNCTION
ENDCLASS

FUNCTION testCircularQueue(operations, capacity)
    CREATE queue as new CircularQueue with capacity
    FOR each operation in operations
        IF operation.type equals "enqueue" THEN
            IF queue.enqueue(operation.number) THEN
                PRINT enqueued number and queue state
            ELSE
                PRINT enqueue failed: queue full
            ENDIF
        ELSE IF operation.type equals "dequeue" THEN
            SET number to queue.dequeue()
            IF number is null THEN
                PRINT queue empty message
            ELSE
                PRINT dequeued number and queue state
            ENDIF
        ENDIF
    ENFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences with fixed capacity
    FOR each testCase in testCases
        PRINT test case details
        CALL testCircularQueue(testCase, capacity)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-45"><a class="header" href="#algorithm-steps-45">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>CircularQueue</code> class with:
a. An array of fixed capacity, with <code>front</code>, <code>rear</code>, and <code>size</code> to track state.
b. Methods: <code>enqueue</code> (add to rear with wrap-around), <code>dequeue</code> (remove from front with wrap-around), <code>isEmpty</code>, <code>isFull</code>, <code>toString</code>.</li>
<li>In <code>enqueue</code>:
a. If queue is full, return false.
b. Increment <code>rear</code> modulo capacity, add number, increment size.</li>
<li>In <code>dequeue</code>:
a. If queue is empty, return null.
b. Remove number at <code>front</code>, increment <code>front</code> modulo capacity, decrement size.</li>
<li>In <code>testCircularQueue</code>:
a. Create a <code>CircularQueue</code> with given capacity.
b. For each operation:
<ul>
<li>Enqueue: Add number, print queue state or "Queue full".</li>
<li>Dequeue: Remove number, print result and queue state or "Queue empty".</li>
</ul>
</li>
<li>In the <code>main</code> method, test with sequences demonstrating normal operations, wrap-around, full queue, and empty queue cases.</li>
</ol>
<h2 id="java-implementation-68"><a class="header" href="#java-implementation-68">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class CircularQueueTest {
    // Custom circular queue implementation for integers
    static class CircularQueue {
        private int[] array;
        private int front;
        private int rear;
        private int size;
        private int capacity;

        public CircularQueue(int capacity) {
            this.array = new int[capacity];
            this.front = 0;
            this.rear = -1;
            this.size = 0;
            this.capacity = capacity;
        }

        public boolean enqueue(int number) {
            if (size == capacity) {
                return false; // Queue full
            }
            rear = (rear + 1) % capacity;
            array[rear] = number;
            size++;
            return true;
        }

        public Integer dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            int number = array[front];
            front = (front + 1) % capacity;
            size--;
            return number;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public boolean isFull() {
            return size == capacity;
        }

        public String toString() {
            StringBuilder result = new StringBuilder("[");
            for (int i = 0; i &lt; size; i++) {
                int index = (front + i) % capacity;
                result.append(array[index]);
                if (i &lt; size - 1) {
                    result.append(", ");
                }
            }
            result.append("]");
            return result.toString();
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        Integer number; // For enqueue operations

        Operation(String type, Integer number) {
            this.type = type;
            this.number = number;
        }
    }

    // Tests circular queue with operations
    public void testCircularQueue(List&lt;Operation&gt; operations, int capacity) {
        CircularQueue queue = new CircularQueue(capacity);
        for (Operation op : operations) {
            if (op.type.equals("enqueue")) {
                if (queue.enqueue(op.number)) {
                    System.out.println("Enqueued " + op.number + ", Queue: " + queue);
                } else {
                    System.out.println("Enqueue " + op.number + " failed: Queue full");
                }
            } else if (op.type.equals("dequeue")) {
                Integer number = queue.dequeue();
                if (number == null) {
                    System.out.println("Queue empty, cannot dequeue");
                } else {
                    System.out.println("Dequeued " + number + ", Queue: " + queue);
                }
            }
        }
    }

    // Main method to test circular queue
    public static void main(String[] args) {
        CircularQueueTest tester = new CircularQueueTest();
        int capacity = 5; // Fixed capacity for all test cases

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("enqueue", 1),
            new Operation("enqueue", 2),
            new Operation("enqueue", 3),
            new Operation("dequeue", null),
            new Operation("enqueue", 4),
            new Operation("dequeue", null),
            new Operation("enqueue", 5)
        );
        testCases.add(case1);
        
        // Test case 2: Wrap-around behavior
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("enqueue", 1),
            new Operation("enqueue", 2),
            new Operation("enqueue", 3),
            new Operation("dequeue", null),
            new Operation("dequeue", null),
            new Operation("enqueue", 4),
            new Operation("enqueue", 5),
            new Operation("enqueue", 6)
        );
        testCases.add(case2);
        
        // Test case 3: Full queue
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("enqueue", 1),
            new Operation("enqueue", 2),
            new Operation("enqueue", 3),
            new Operation("enqueue", 4),
            new Operation("enqueue", 5),
            new Operation("enqueue", 6)
        );
        testCases.add(case3);
        
        // Test case 4: Empty queue
        List&lt;Operation&gt; case4 = Arrays.asList(
            new Operation("dequeue", null)
        );
        testCases.add(case4);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + " (capacity=" + capacity + "):");
            tester.testCircularQueue(testCases.get(i), capacity);
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-45"><a class="header" href="#output-45">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1 (capacity=5):
Enqueued 1, Queue: [1]
Enqueued 2, Queue: [1, 2]
Enqueued 3, Queue: [1, 2, 3]
Dequeued 1, Queue: [2, 3]
Enqueued 4, Queue: [2, 3, 4]
Dequeued 2, Queue: [3, 4]
Enqueued 5, Queue: [3, 4, 5]

Test case 2 (capacity=5):
Enqueued 1, Queue: [1]
Enqueued 2, Queue: [1, 2]
Enqueued 3, Queue: [1, 2, 3]
Dequeued 1, Queue: [2, 3]
Dequeued 2, Queue: [3]
Enqueued 4, Queue: [3, 4]
Enqueued 5, Queue: [3, 4, 5]
Enqueued 6, Queue: [3, 4, 5, 6]

Test case 3 (capacity=5):
Enqueued 1, Queue: [1]
Enqueued 2, Queue: [1, 2]
Enqueued 3, Queue: [1, 2, 3]
Enqueued 4, Queue: [1, 2, 3, 4]
Enqueued 5, Queue: [1, 2, 3, 4, 5]
Enqueue 6 failed: Queue full

Test case 4 (capacity=5):
Queue empty, cannot dequeue
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Normal enqueue/dequeue operations within capacity.</li>
<li>Test case 2: Demonstrates wrap-around (after dequeuing, rear wraps to start for 4, 5, 6).</li>
<li>Test case 3: Fills queue to capacity, fails to enqueue 6.</li>
<li>Test case 4: Dequeue on empty queue returns error.</li>
</ul>
<h2 id="how-it-works-69"><a class="header" href="#how-it-works-69">How It Works</a></h2>
<ul>
<li><strong>CircularQueue</strong>:
<ul>
<li>Uses an array with <code>front</code>, <code>rear</code>, and <code>size</code> to manage integers in FIFO order.</li>
<li><code>enqueue</code>: Adds to <code>rear</code> (modulo capacity) if not full.</li>
<li><code>dequeue</code>: Removes from <code>front</code> (modulo capacity) if not empty.</li>
<li><code>toString</code>: Formats queue contents from <code>front</code> to <code>rear</code>.</li>
<li>Wrap-around: <code>rear = (rear + 1) % capacity</code> and <code>front = (front + 1) % capacity</code> enable circular behavior.</li>
</ul>
</li>
<li><strong>testCircularQueue</strong>:
<ul>
<li>Enqueues numbers, prints queue state or "Queue full".</li>
<li>Dequeues numbers, prints result and queue state or "Queue empty".</li>
</ul>
</li>
<li><strong>Example Trace (Test case 2)</strong>:
<ul>
<li>Enqueue 1: array=[1], front=0, rear=0, size=1.</li>
<li>Enqueue 2: array=[1,2], front=0, rear=1, size=2.</li>
<li>Enqueue 3: array=[1,2,3], front=0, rear=2, size=3.</li>
<li>Dequeue 1: array=[-,2,3], front=1, rear=2, size=2.</li>
<li>Dequeue 2: array=[-,-,3], front=2, rear=2, size=1.</li>
<li>Enqueue 4: array=[4,-,3], front=2, rear=0, size=2 (wrap-around).</li>
<li>Enqueue 5: array=[4,5,3], front=2, rear=1, size=3.</li>
<li>Enqueue 6: array=[4,5,3,6], front=2, rear=2, size=4.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal operations, wrap-around, full queue, and empty queue.</li>
</ul>
<h2 id="complexity-analysis-table-68"><a class="header" href="#complexity-analysis-table-68">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(c)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations, c is the fixed capacity.</li>
<li>Time complexity: O(1) for each enqueue/dequeue; O(n) for n operations.</li>
<li>Space complexity: O(c) for the fixed-size array.</li>
<li>Worst case: O(n) time for n operations, O(c) space for the queue.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a circular queue to efficiently reuse array space, especially for applications with frequent enqueue and dequeue operations. Test wrap-around behavior by dequeuing some elements and then enqueuing more to verify the circular property.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Carefully manage <code>front</code> and <code>rear</code> indices with modulo operations to ensure correct wrap-around. Handle full and empty queue cases to avoid incorrect behavior.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="print-job-simulator"><a class="header" href="#print-job-simulator">Print Job Simulator</a></h1>
<h2 id="problem-statement-46"><a class="header" href="#problem-statement-46">Problem Statement</a></h2>
<p>Write a Java program that simulates a printer queue using a queue implementation. The program should allow users to enqueue print jobs (represented as strings) and dequeue them in order, printing each job as it is processed in a first-in, first-out (FIFO) manner. Test the implementation with various sequences of enqueue and dequeue operations, including edge cases like empty queues and null print jobs. You can visualize this as a printer handling a queue of documents, where each document is printed in the order it was submitted, and the printer processes one job at a time.</p>
<p><strong>Input</strong>: A sequence of operations, where each operation is either:</p>
<ul>
<li>Enqueue: Add a print job (string) to the queue (e.g., <code>"Document1"</code>).</li>
<li>Dequeue: Remove and process the next print job, printing its details.
<strong>Output</strong>: For each operation, print the action performed (enqueue or dequeue) and, for dequeue, the processed job or a message if the queue is empty.
<strong>Constraints</strong>:</li>
<li>Queue size is between 0 and 10^5.</li>
<li>Print jobs are non-empty strings containing printable ASCII characters, or null (handled gracefully).</li>
<li>The queue may be empty when dequeue is called.
<strong>Example</strong>:</li>
<li>Input: Operations = [enqueue("Doc1"), enqueue("Doc2"), dequeue, enqueue("Doc3"), dequeue]</li>
<li>Output:
<pre><code>Enqueued Doc1
Enqueued Doc2
Dequeued and processed: Doc1
Enqueued Doc3
Dequeued and processed: Doc2
</code></pre>
</li>
<li>Explanation: Jobs are enqueued in order and dequeued in FIFO order, printing each job as processed.</li>
<li>Input: Operations = [dequeue on empty queue]</li>
<li>Output: <code>Queue empty, cannot dequeue</code></li>
</ul>
<h2 id="pseudocode-46"><a class="header" href="#pseudocode-46">Pseudocode</a></h2>
<pre><code>CLASS StringQueue
    SET array to new string array of size 1000
    SET front to 0
    SET rear to -1
    SET size to 0
    
    FUNCTION enqueue(job)
        IF size equals array length THEN
            RETURN false (queue full)
        ENDIF
        INCREMENT rear
        SET array[rear] to job
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null (queue empty)
        ENDIF
        SET job to array[front]
        INCREMENT front
        DECREMENT size
        RETURN job
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
ENDCLASS

FUNCTION simulatePrinter(operations)
    CREATE queue as new StringQueue
    FOR each operation in operations
        IF operation.type equals "enqueue" THEN
            CALL queue.enqueue(operation.job)
            PRINT enqueued job
        ELSE IF operation.type equals "dequeue" THEN
            SET job to queue.dequeue()
            IF job is null THEN
                PRINT queue empty message
            ELSE
                PRINT dequeued and processed job
            ENDIF
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL simulatePrinter(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-46"><a class="header" href="#algorithm-steps-46">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>StringQueue</code> class with:
a. An array to store print jobs (strings), with <code>front</code>, <code>rear</code>, and <code>size</code> to track queue state.
b. Methods: <code>enqueue</code> (add job to rear), <code>dequeue</code> (remove job from front), <code>isEmpty</code> (check if empty).</li>
<li>In the <code>simulatePrinter</code> method:
a. Create a new <code>StringQueue</code>.
b. For each operation:
<ul>
<li>If "enqueue", add the job to the queue and print the action.</li>
<li>If "dequeue", remove the next job, print it as processed, or print "Queue empty" if empty.</li>
</ul>
</li>
<li>In the <code>main</code> method, test with sequences of enqueue and dequeue operations, including empty queues, single jobs, and null jobs.</li>
</ol>
<h2 id="java-implementation-69"><a class="header" href="#java-implementation-69">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class PrintJobSimulator {
    // Custom queue implementation for strings
    static class StringQueue {
        private String[] array;
        private int front;
        private int rear;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public StringQueue() {
            array = new String[DEFAULT_SIZE];
            front = 0;
            rear = -1;
            size = 0;
        }

        public boolean enqueue(String job) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[++rear] = job;
            size++;
            return true;
        }

        public String dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            String job = array[front++];
            size--;
            return job;
        }

        public boolean isEmpty() {
            return size == 0;
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String job; // For enqueue operations

        Operation(String type, String job) {
            this.type = type;
            this.job = job;
        }
    }

    // Simulates printer queue functionality
    public void simulatePrinter(List&lt;Operation&gt; operations) {
        StringQueue queue = new StringQueue();
        for (Operation op : operations) {
            if (op.type.equals("enqueue")) {
                boolean success = queue.enqueue(op.job);
                if (success) {
                    System.out.println("Enqueued " + (op.job != null ? op.job : "null"));
                } else {
                    System.out.println("Enqueue " + (op.job != null ? op.job : "null") + " failed: Queue full");
                }
            } else if (op.type.equals("dequeue")) {
                String job = queue.dequeue();
                if (job == null) {
                    System.out.println("Queue empty, cannot dequeue");
                } else {
                    System.out.println("Dequeued and processed: " + job);
                }
            }
        }
    }

    // Main method to test printer queue simulation
    public static void main(String[] args) {
        PrintJobSimulator simulator = new PrintJobSimulator();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("enqueue", "Document1"),
            new Operation("enqueue", "Document2"),
            new Operation("dequeue", null),
            new Operation("enqueue", "Document3"),
            new Operation("dequeue", null)
        );
        testCases.add(case1);
        
        // Test case 2: Empty queue
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("dequeue", null)
        );
        testCases.add(case2);
        
        // Test case 3: Single job
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("enqueue", "SingleDoc"),
            new Operation("dequeue", null)
        );
        testCases.add(case3);
        
        // Test case 4: Multiple enqueues
        List&lt;Operation&gt; case4 = Arrays.asList(
            new Operation("enqueue", "Job1"),
            new Operation("enqueue", "Job2"),
            new Operation("enqueue", "Job3"),
            new Operation("dequeue", null),
            new Operation("dequeue", null)
        );
        testCases.add(case4);
        
        // Test case 5: Null job
        List&lt;Operation&gt; case5 = Arrays.asList(
            new Operation("enqueue", null),
            new Operation("dequeue", null)
        );
        testCases.add(case5);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            simulator.simulatePrinter(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-46"><a class="header" href="#output-46">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Enqueued Document1
Enqueued Document2
Dequeued and processed: Document1
Enqueued Document3
Dequeued and processed: Document2

Test case 2:
Queue empty, cannot dequeue

Test case 3:
Enqueued SingleDoc
Dequeued and processed: SingleDoc

Test case 4:
Enqueued Job1
Enqueued Job2
Enqueued Job3
Dequeued and processed: Job1
Dequeued and processed: Job2

Test case 5:
Enqueued null
Dequeued and processed: null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Enqueues "Document1", "Document2", dequeues "Document1", enqueues "Document3", dequeues "Document2".</li>
<li>Test case 2: Dequeue on empty queue returns "Queue empty".</li>
<li>Test case 3: Enqueues single job, dequeues it.</li>
<li>Test case 4: Enqueues three jobs, dequeues two in FIFO order.</li>
<li>Test case 5: Enqueues null job, dequeues it.</li>
</ul>
<h2 id="how-it-works-70"><a class="header" href="#how-it-works-70">How It Works</a></h2>
<ul>
<li><strong>StringQueue</strong>:
<ul>
<li>Uses an array with <code>front</code> and <code>rear</code> indices to track the queue’s state, and <code>size</code> to track the number of jobs.</li>
<li><code>enqueue</code>: Adds a job to the rear if the queue isn’t full.</li>
<li><code>dequeue</code>: Removes and returns the front job if not empty.</li>
<li><code>isEmpty</code>: Checks if the queue is empty.</li>
</ul>
</li>
<li><strong>simulatePrinter</strong>:
<ul>
<li>Enqueues jobs, printing each action.</li>
<li>Dequeues jobs, printing the processed job or "Queue empty".</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Enqueue "Document1": queue = ["Document1"], front=0, rear=0.</li>
<li>Enqueue "Document2": queue = ["Document1", "Document2"], front=0, rear=1.</li>
<li>Dequeue: Returns "Document1", queue = ["Document2"], front=1, rear=1.</li>
<li>Enqueue "Document3": queue = ["Document2", "Document3"], front=1, rear=2.</li>
<li>Dequeue: Returns "Document2", queue = ["Document3"], front=2, rear=2.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal sequences, empty queue, single job, multiple enqueues, and null job.</li>
</ul>
<h2 id="complexity-analysis-table-69"><a class="header" href="#complexity-analysis-table-69">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations.</li>
<li>Time complexity: O(1) for each enqueue or dequeue; O(n) for processing n operations.</li>
<li>Space complexity: O(n) for the queue storing up to n jobs.</li>
<li>Worst case: O(n) time and O(n) space for many enqueue operations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a queue to simulate a printer’s job processing, as its FIFO nature ensures jobs are processed in submission order. Test with sequences that mix enqueue and dequeue operations to verify correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null jobs and empty queue cases to avoid unexpected behavior. Ensure the queue size is sufficient to accommodate the input sequence.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="queue-based-bfs"><a class="header" href="#queue-based-bfs">Queue-Based BFS</a></h1>
<h2 id="problem-statement-47"><a class="header" href="#problem-statement-47">Problem Statement</a></h2>
<p>Write a Java program that implements a Breadth-First Search (BFS) algorithm for a graph using a queue. Represent the graph as an adjacency list and print the nodes visited in BFS order, starting from a specified node. The program should handle undirected graphs, enqueue nodes to explore them level by level, and mark visited nodes to avoid cycles. Test the implementation with various graph structures, including connected, disconnected, and cyclic graphs, as well as edge cases like empty graphs. You can visualize this as exploring a network of cities, visiting all cities at the current distance from the starting point before moving farther, using a queue to keep track of the next cities to visit.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Number of nodes <code>n</code> (0 ≤ n ≤ 10^5).</li>
<li>List of edges as pairs of nodes (e.g., [[0,1], [1,2]] for edges 0-1, 1-2).</li>
<li>Starting node for BFS.
<strong>Output</strong>: A string of nodes visited in BFS order (e.g., "0 1 2").
<strong>Constraints</strong>:</li>
<li>Nodes are integers from 0 to n-1.</li>
<li>Edges are undirected (if u-v exists, v-u exists).</li>
<li>The graph may be empty, disconnected, or cyclic.
<strong>Example</strong>:</li>
<li>Input: n=4, edges=[[0,1], [0,2], [1,3]], start=0</li>
<li>Output: "0 1 2 3"</li>
<li>Explanation: Starting from node 0, visit 0, then neighbors 1 and 2, then 1’s neighbor 3.</li>
<li>Input: n=3, edges=[], start=0</li>
<li>Output: "0"</li>
<li>Explanation: No edges, only node 0 is visited.</li>
</ul>
<h2 id="pseudocode-47"><a class="header" href="#pseudocode-47">Pseudocode</a></h2>
<pre><code>CLASS IntQueue
    SET array to new integer array of size 1000
    SET front to 0
    SET rear to -1
    SET size to 0
    
    FUNCTION enqueue(number)
        IF size equals array length THEN
            RETURN false
        ENDIF
        INCREMENT rear
        SET array[rear] to number
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null
        ENDIF
        SET number to array[front]
        INCREMENT front
        DECREMENT size
        RETURN number
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
ENDCLASS

FUNCTION bfs(n, edges, start)
    IF n equals 0 THEN
        RETURN empty string
    ENDIF
    CREATE adjList as new list of lists for n nodes
    FOR each edge in edges
        ADD edge[1] to adjList[edge[0]]
        ADD edge[0] to adjList[edge[1]] (undirected)
    ENDFOR
    CREATE queue as new IntQueue
    CREATE visited as boolean array of size n, initialized to false
    CREATE result as new StringBuilder
    ENQUEUE start to queue
    SET visited[start] to true
    APPEND start to result
    WHILE queue is not empty
        SET node to queue.dequeue()
        FOR each neighbor in adjList[node]
            IF not visited[neighbor] THEN
                ENQUEUE neighbor to queue
                SET visited[neighbor] to true
                APPEND " " and neighbor to result
            ENDIF
        ENDFOR
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of graphs (n, edges, start)
    FOR each testCase in testCases
        PRINT test case details
        CALL bfs(testCase.n, testCase.edges, testCase.start)
        PRINT BFS order
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-47"><a class="header" href="#algorithm-steps-47">Algorithm Steps</a></h2>
<ol>
<li>Define an <code>IntQueue</code> class with:
a. An array to store integers, with <code>front</code>, <code>rear</code>, and <code>size</code>.
b. Methods: <code>enqueue</code> (add to rear), <code>dequeue</code> (remove from front), <code>isEmpty</code>.</li>
<li>In the <code>bfs</code> method:
a. If n=0, return empty string.
b. Build an adjacency list from edges (add u-v and v-u for undirected).
c. Create a queue, a boolean array for visited nodes, and a StringBuilder for output.
d. Enqueue the start node, mark it visited, append to result.
e. While queue is not empty:
<ul>
<li>Dequeue a node.</li>
<li>For each unvisited neighbor, enqueue it, mark it visited, append to result.
f. Return the result string.</li>
</ul>
</li>
<li>In the <code>main</code> method, test with graphs of varying structures (connected, disconnected, cyclic, empty).</li>
</ol>
<h2 id="java-implementation-70"><a class="header" href="#java-implementation-70">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class QueueBasedBFS {
    // Custom queue implementation for integers
    static class IntQueue {
        private int[] array;
        private int front;
        private int rear;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public IntQueue() {
            array = new int[DEFAULT_SIZE];
            front = 0;
            rear = -1;
            size = 0;
        }

        public boolean enqueue(int number) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[++rear] = number;
            size++;
            return true;
        }

        public Integer dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            int number = array[front++];
            size--;
            return number;
        }

        public boolean isEmpty() {
            return size == 0;
        }
    }

    // Performs BFS and returns nodes in visit order
    public String bfs(int n, int[][] edges, int start) {
        if (n == 0) {
            return "";
        }

        // Build adjacency list
        List&lt;List&lt;Integer&gt;&gt; adjList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.add(new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            adjList.get(edge[0]).add(edge[1]);
            adjList.get(edge[1]).add(edge[0]); // Undirected
        }

        // BFS
        IntQueue queue = new IntQueue();
        boolean[] visited = new boolean[n];
        StringBuilder result = new StringBuilder();

        queue.enqueue(start);
        visited[start] = true;
        result.append(start);

        while (!queue.isEmpty()) {
            Integer node = queue.dequeue();
            if (node == null) break;
            for (int neighbor : adjList.get(node)) {
                if (!visited[neighbor]) {
                    queue.enqueue(neighbor);
                    visited[neighbor] = true;
                    result.append(" ").append(neighbor);
                }
            }
        }

        return result.toString();
    }

    // Helper class for test cases
    static class GraphTestCase {
        int n;
        int[][] edges;
        int start;

        GraphTestCase(int n, int[][] edges, int start) {
            this.n = n;
            this.edges = edges;
            this.start = start;
        }
    }

    // Main method to test BFS
    public static void main(String[] args) {
        QueueBasedBFS bfs = new QueueBasedBFS();

        // Test cases
        List&lt;GraphTestCase&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Connected graph
        testCases.add(new GraphTestCase(
            4,
            new int[][]{{0,1}, {0,2}, {1,3}},
            0
        ));
        
        // Test case 2: Cyclic graph
        testCases.add(new GraphTestCase(
            4,
            new int[][]{{0,1}, {1,2}, {2,3}, {3,0}},
            1
        ));
        
        // Test case 3: Disconnected graph
        testCases.add(new GraphTestCase(
            5,
            new int[][]{{0,1}, {2,3}},
            0
        ));
        
        // Test case 4: Empty graph
        testCases.add(new GraphTestCase(
            0,
            new int[][]{},
            0
        ));
        
        // Test case 5: Single node
        testCases.add(new GraphTestCase(
            1,
            new int[][]{},
            0
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            GraphTestCase test = testCases.get(i);
            System.out.println("Test case " + (i + 1) + ": n=" + test.n + ", start=" + test.start);
            System.out.println("Edges: " + Arrays.deepToString(test.edges));
            String result = bfs.bfs(test.n, test.edges, test.start);
            System.out.println("BFS order: " + (result.isEmpty() ? "[]" : result) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-47"><a class="header" href="#output-47">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: n=4, start=0
Edges: [[0, 1], [0, 2], [1, 3]]
BFS order: 0 1 2 3

Test case 2: n=4, start=1
Edges: [[0, 1], [1, 2], [2, 3], [3, 0]]
BFS order: 1 0 2 3

Test case 3: n=5, start=0
Edges: [[0, 1], [2, 3]]
BFS order: 0 1

Test case 4: n=0, start=0
Edges: []
BFS order: []

Test case 5: n=1, start=0
Edges: []
BFS order: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: From node 0, visits 0, then 1 and 2, then 3 (via 1).</li>
<li>Test case 2: From node 1 in a cycle (0-1-2-3-0), visits 1, then 0 and 2, then 3.</li>
<li>Test case 3: From node 0, visits 0 and 1; nodes 2, 3, 4 are disconnected.</li>
<li>Test case 4: Empty graph returns empty string.</li>
<li>Test case 5: Single node 0, no edges, visits only 0.</li>
</ul>
<h2 id="how-it-works-71"><a class="header" href="#how-it-works-71">How It Works</a></h2>
<ul>
<li><strong>IntQueue</strong>:
<ul>
<li>Uses an array with <code>front</code>, <code>rear</code>, and <code>size</code> for FIFO operations.</li>
<li><code>enqueue</code>: Adds to rear if not full.</li>
<li><code>dequeue</code>: Removes from front if not empty.</li>
</ul>
</li>
<li><strong>bfs</strong>:
<ul>
<li>Builds an adjacency list from edges (undirected: add u-v and v-u).</li>
<li>Uses a queue to explore nodes level by level, a boolean array to track visited nodes, and a StringBuilder for output.</li>
<li>Enqueues start node, marks visited, appends to result.</li>
<li>Dequeues nodes, enqueues unvisited neighbors, appends them to result.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>n=4, edges=[[0,1], [0,2], [1,3]], start=0.</li>
<li>Adjacency list: [0: [1,2], 1: [0,3], 2: [0], 3: [1]].</li>
<li>Enqueue 0: queue=[0], visited=[T,F,F,F], result="0".</li>
<li>Dequeue 0, enqueue 1,2: queue=[1,2], visited=[T,T,T,F], result="0 1 2".</li>
<li>Dequeue 1, enqueue 3: queue=[2,3], visited=[T,T,T,T], result="0 1 2 3".</li>
<li>Dequeue 2, 3: queue=[], result="0 1 2 3".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests connected, cyclic, disconnected, empty, and single-node graphs.</li>
</ul>
<h2 id="complexity-analysis-table-70"><a class="header" href="#complexity-analysis-table-70">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>BFS Algorithm</td><td>O(V + E)</td><td>O(V + E)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>V is the number of vertices, E is the number of edges.</li>
<li>Time complexity: O(V + E) for visiting all nodes and edges via adjacency list.</li>
<li>Space complexity: O(V) for queue and visited array, O(E) for adjacency list.</li>
<li>Worst case: O(V + E) time and space for dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a queue for BFS to ensure level-by-level traversal, and an adjacency list for efficient neighbor access. Test with cyclic and disconnected graphs to verify correct handling of visited nodes.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Always mark nodes as visited before enqueuing to avoid infinite loops in cyclic graphs. Ensure the queue size is sufficient for large graphs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="queue-reversal"><a class="header" href="#queue-reversal">Queue Reversal</a></h1>
<h2 id="problem-statement-48"><a class="header" href="#problem-statement-48">Problem Statement</a></h2>
<p>Write a Java program that reverses the elements of a queue using a stack. The program should enqueue a set of numbers into a queue, reverse the order of the elements using a stack, and print the reversed queue. The reversal should maintain the queue’s FIFO (first-in, first-out) property in the final output. Test the implementation with various sets of numbers, including empty queues and single-element queues. You can visualize this as unloading a queue of items onto a stack, which flips their order, and then reloading them into a new queue to get the reversed sequence.</p>
<p><strong>Input</strong>: A set of integers to enqueue (e.g., [1, 2, 3]).
<strong>Output</strong>: The reversed queue as a string (e.g., "[3, 2, 1]").
<strong>Constraints</strong>:</p>
<ul>
<li>Queue size is between 0 and 10^5.</li>
<li>Elements are integers in the range [-10^9, 10^9].</li>
<li>The queue may be empty.
<strong>Example</strong>:</li>
<li>Input: Enqueue [1, 2, 3]</li>
<li>Output: [3, 2, 1]</li>
<li>Explanation: Enqueue 1, 2, 3; dequeue to stack (3, 2, 1 top); pop to new queue → [3, 2, 1].</li>
<li>Input: Enqueue []</li>
<li>Output: []</li>
<li>Explanation: Empty queue remains empty after reversal.</li>
</ul>
<h2 id="pseudocode-48"><a class="header" href="#pseudocode-48">Pseudocode</a></h2>
<pre><code>CLASS IntQueue
    SET array to new integer array of size 1000
    SET front to 0
    SET rear to -1
    SET size to 0
    
    FUNCTION enqueue(number)
        IF size equals array length THEN
            RETURN false (queue full)
        ENDIF
        INCREMENT rear
        SET array[rear] to number
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null (queue empty)
        ENDIF
        SET number to array[front]
        INCREMENT front
        DECREMENT size
        RETURN number
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
    
    FUNCTION toString()
        CREATE result as empty string
        APPEND "["
        FOR i from front to rear
            APPEND array[i] and ", " to result
        ENDFOR
        IF result ends with ", " THEN
            REMOVE last ", "
        ENDIF
        APPEND "]" to result
        RETURN result
    ENDFUNCTION
ENDCLASS

CLASS IntStack
    SET array to new integer array of size 1000
    SET top to -1
    
    FUNCTION push(number)
        IF top equals array length - 1 THEN
            RETURN false (stack full)
        ENDIF
        INCREMENT top
        SET array[top] to number
        RETURN true
    ENDFUNCTION
    
    FUNCTION pop()
        IF top equals -1 THEN
            RETURN null (stack empty)
        ENDIF
        SET number to array[top]
        DECREMENT top
        RETURN number
    ENDFUNCTION
ENDCLASS

FUNCTION reverseQueue(queue)
    CREATE stack as new IntStack
    CREATE newQueue as new IntQueue
    WHILE queue is not empty
        SET number to queue.dequeue()
        PUSH number to stack
    ENDWHILE
    WHILE stack is not empty
        SET number to stack.pop()
        ENQUEUE number to newQueue
    ENDWHILE
    RETURN newQueue
ENDFUNCTION

FUNCTION main()
    SET testCases to array of integer arrays
    FOR each numbers in testCases
        CREATE queue as new IntQueue
        FOR each number in numbers
            ENQUEUE number to queue
        ENDFOR
        PRINT original queue
        SET reversed to reverseQueue(queue)
        PRINT reversed queue
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-48"><a class="header" href="#algorithm-steps-48">Algorithm Steps</a></h2>
<ol>
<li>Define an <code>IntQueue</code> class with:
a. An array to store integers, with <code>front</code>, <code>rear</code>, and <code>size</code> to track queue state.
b. Methods: <code>enqueue</code> (add to rear), <code>dequeue</code> (remove from front), <code>isEmpty</code>, <code>toString</code>.</li>
<li>Define an <code>IntStack</code> class with:
a. An array to store integers, with <code>top</code> index.
b. Methods: <code>push</code> (add to top), <code>pop</code> (remove from top).</li>
<li>In the <code>reverseQueue</code> method:
a. Create a stack and a new queue.
b. Dequeue all elements from the input queue and push them onto the stack.
c. Pop all elements from the stack and enqueue them into the new queue.
d. Return the new queue.</li>
<li>In the <code>main</code> method, test with different sets of numbers, including empty and single-element queues, printing the original and reversed queues.</li>
</ol>
<h2 id="java-implementation-71"><a class="header" href="#java-implementation-71">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class QueueReversal {
    // Custom queue implementation for integers
    static class IntQueue {
        private int[] array;
        private int front;
        private int rear;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public IntQueue() {
            array = new int[DEFAULT_SIZE];
            front = 0;
            rear = -1;
            size = 0;
        }

        public boolean enqueue(int number) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[++rear] = number;
            size++;
            return true;
        }

        public Integer dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            int number = array[front++];
            size--;
            return number;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        public String toString() {
            StringBuilder result = new StringBuilder("[");
            for (int i = front; i &lt;= rear; i++) {
                result.append(array[i]);
                if (i &lt; rear) {
                    result.append(", ");
                }
            }
            result.append("]");
            return result.toString();
        }
    }

    // Custom stack implementation for integers
    static class IntStack {
        private int[] array;
        private int top;
        private static final int DEFAULT_SIZE = 1000;

        public IntStack() {
            array = new int[DEFAULT_SIZE];
            top = -1;
        }

        public boolean push(int number) {
            if (top == array.length - 1) {
                return false; // Stack full
            }
            array[++top] = number;
            return true;
        }

        public Integer pop() {
            if (top == -1) {
                return null; // Stack empty
            }
            return array[top--];
        }
    }

    // Reverses a queue using a stack
    public IntQueue reverseQueue(IntQueue queue) {
        IntStack stack = new IntStack();
        IntQueue newQueue = new IntQueue();

        // Dequeue all elements and push to stack
        while (!queue.isEmpty()) {
            Integer number = queue.dequeue();
            if (number != null) {
                stack.push(number);
            }
        }

        // Pop from stack and enqueue to new queue
        while (true) {
            Integer number = stack.pop();
            if (number == null) {
                break;
            }
            newQueue.enqueue(number);
        }

        return newQueue;
    }

    // Main method to test queue reversal
    public static void main(String[] args) {
        QueueReversal reverser = new QueueReversal();

        // Test cases
        int[][] testCases = {
            {1, 2, 3},           // Normal queue
            {},                   // Empty queue
            {42},                // Single element
            {10, 20, 30, 40, 50} // Larger queue
        };

        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            IntQueue queue = new IntQueue();
            for (int num : testCases[i]) {
                queue.enqueue(num);
            }
            System.out.println("Original queue: " + queue);
            IntQueue reversed = reverser.reverseQueue(queue);
            System.out.println("Reversed queue: " + reversed + "\n");
        }
    }
}
</code></pre>
<h2 id="output-48"><a class="header" href="#output-48">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Original queue: [1, 2, 3]
Reversed queue: [3, 2, 1]

Test case 2:
Original queue: []
Reversed queue: []

Test case 3:
Original queue: [42]
Reversed queue: [42]

Test case 4:
Original queue: [10, 20, 30, 40, 50]
Reversed queue: [50, 40, 30, 20, 10]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Enqueue [1, 2, 3] → stack [3, 2, 1 (top)] → new queue [3, 2, 1].</li>
<li>Test case 2: Empty queue → empty stack → empty queue.</li>
<li>Test case 3: Enqueue [42] → stack [42] → new queue [42].</li>
<li>Test case 4: Enqueue [10, 20, 30, 40, 50] → stack [50, 40, 30, 20, 10 (top)] → new queue [50, 40, 30, 20, 10].</li>
</ul>
<h2 id="how-it-works-72"><a class="header" href="#how-it-works-72">How It Works</a></h2>
<ul>
<li><strong>IntQueue</strong>:
<ul>
<li>Uses an array with <code>front</code>, <code>rear</code>, and <code>size</code> to manage integers in FIFO order.</li>
<li><code>enqueue</code>: Adds to rear if not full.</li>
<li><code>dequeue</code>: Removes from front if not empty.</li>
<li><code>toString</code>: Formats queue as a string for output.</li>
</ul>
</li>
<li><strong>IntStack</strong>:
<ul>
<li>Uses an array with <code>top</code> to manage integers in LIFO order.</li>
<li><code>push</code>: Adds to top if not full.</li>
<li><code>pop</code>: Removes from top if not empty.</li>
</ul>
</li>
<li><strong>reverseQueue</strong>:
<ul>
<li>Dequeues all elements from the input queue to a stack (reversing order due to LIFO).</li>
<li>Pops all elements from the stack to a new queue (restoring FIFO order, now reversed).</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Enqueue 1, 2, 3: queue = [1, 2, 3], front=0, rear=2.</li>
<li>Dequeue to stack: stack = [1, 2, 3 (top)].</li>
<li>Pop to new queue: newQueue = [3, 2, 1].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal, empty, single-element, and larger queues.</li>
</ul>
<h2 id="complexity-analysis-table-71"><a class="header" href="#complexity-analysis-table-71">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Push/Pop</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of elements in the queue.</li>
<li>Time complexity: O(n) for n dequeues to stack and n pops to new queue.</li>
<li>Space complexity: O(n) for the stack and new queue.</li>
<li>Worst case: O(n) time and O(n) space for large queues.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a stack to reverse a queue, as its LIFO nature naturally flips the order of elements. Test with various queue sizes to ensure the reversal works correctly.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the stack and queue sizes are sufficient to handle the input. Handle empty queues to avoid null pointer issues during reversal.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="ticket-counter-simulation"><a class="header" href="#ticket-counter-simulation">Ticket Counter Simulation</a></h1>
<h2 id="problem-statement-49"><a class="header" href="#problem-statement-49">Problem Statement</a></h2>
<p>Write a Java program that simulates a ticket counter system where customers, represented by names (strings), join a queue and are served in first-in, first-out (FIFO) order. The program should allow users to enqueue customers, dequeue them to simulate serving, and display the current queue size after each operation. Test the implementation with various sequences of enqueue and dequeue operations, including edge cases like empty queues and null customer names. You can visualize this as a ticket counter at a movie theater, where customers line up, are served one by one, and the staff tracks how many people are still waiting.</p>
<p><strong>Input</strong>: A sequence of operations, where each operation is either:</p>
<ul>
<li>Enqueue: Add a customer name (string) to the queue (e.g., "Alice").</li>
<li>Dequeue: Remove and serve the next customer from the queue.</li>
<li>Size: Display the current number of customers in the queue.
<strong>Output</strong>: For each operation, print the action performed (enqueue, dequeue, or size) and the result, such as the served customer, queue size, or error messages for empty queues.
<strong>Constraints</strong>:</li>
<li>Queue size is between 0 and 10^5.</li>
<li>Customer names are non-empty strings containing printable ASCII characters, or null (handled gracefully).</li>
<li>The queue may be empty when dequeue or size is called.
<strong>Example</strong>:</li>
<li>Input: Operations = [enqueue("Alice"), enqueue("Bob"), size, dequeue, size, enqueue("Charlie"), dequeue]</li>
<li>Output:
<pre><code>Enqueued Alice
Enqueued Bob
Queue size: 2
Served customer: Alice
Queue size: 1
Enqueued Charlie
Served customer: Bob
</code></pre>
</li>
<li>Explanation: Customers join and are served in order, with queue size reported as requested.</li>
<li>Input: Operations = [dequeue on empty queue]</li>
<li>Output: <code>Queue empty, cannot dequeue</code></li>
</ul>
<h2 id="pseudocode-49"><a class="header" href="#pseudocode-49">Pseudocode</a></h2>
<pre><code>CLASS StringQueue
    SET array to new string array of size 1000
    SET front to 0
    SET rear to -1
    SET size to 0
    
    FUNCTION enqueue(name)
        IF size equals array length THEN
            RETURN false (queue full)
        ENDIF
        INCREMENT rear
        SET array[rear] to name
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null (queue empty)
        ENDIF
        SET name to array[front]
        INCREMENT front
        DECREMENT size
        RETURN name
    ENDFUNCTION
    
    FUNCTION size()
        RETURN size
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
ENDCLASS

FUNCTION simulateTicketCounter(operations)
    CREATE queue as new StringQueue
    FOR each operation in operations
        IF operation.type equals "enqueue" THEN
            CALL queue.enqueue(operation.name)
            PRINT enqueued name
        ELSE IF operation.type equals "dequeue" THEN
            SET name to queue.dequeue()
            IF name is null THEN
                PRINT queue empty message
            ELSE
                PRINT served customer name
            ENDIF
        ELSE IF operation.type equals "size" THEN
            PRINT queue size
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL simulateTicketCounter(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-49"><a class="header" href="#algorithm-steps-49">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>StringQueue</code> class with:
a. An array to store customer names, with <code>front</code>, <code>rear</code>, and <code>size</code> to track queue state.
b. Methods: <code>enqueue</code> (add to rear), <code>dequeue</code> (remove from front), <code>size</code> (return current size), <code>isEmpty</code> (check if empty).</li>
<li>In the <code>simulateTicketCounter</code> method:
a. Create a new <code>StringQueue</code>.
b. For each operation:
<ul>
<li>If "enqueue", add the customer name and print the action.</li>
<li>If "dequeue", remove the next customer, print the served customer or "Queue empty".</li>
<li>If "size", print the current queue size.</li>
</ul>
</li>
<li>In the <code>main</code> method, test with sequences of enqueue, dequeue, and size operations, including empty queues, single customers, and null names.</li>
</ol>
<h2 id="java-implementation-72"><a class="header" href="#java-implementation-72">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class TicketCounterSimulation {
    // Custom queue implementation for strings
    static class StringQueue {
        private String[] array;
        private int front;
        private int rear;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public StringQueue() {
            array = new String[DEFAULT_SIZE];
            front = 0;
            rear = -1;
            size = 0;
        }

        public boolean enqueue(String name) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[++rear] = name;
            size++;
            return true;
        }

        public String dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            String name = array[front++];
            size--;
            return name;
        }

        public int size() {
            return size;
        }

        public boolean isEmpty() {
            return size == 0;
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String name; // For enqueue operations

        Operation(String type, String name) {
            this.type = type;
            this.name = name;
        }
    }

    // Simulates ticket counter system
    public void simulateTicketCounter(List&lt;Operation&gt; operations) {
        StringQueue queue = new StringQueue();
        for (Operation op : operations) {
            if (op.type.equals("enqueue")) {
                boolean success = queue.enqueue(op.name);
                if (success) {
                    System.out.println("Enqueued " + (op.name != null ? op.name : "null"));
                } else {
                    System.out.println("Enqueue " + (op.name != null ? op.name : "null") + " failed: Queue full");
                }
            } else if (op.type.equals("dequeue")) {
                String name = queue.dequeue();
                if (name == null) {
                    System.out.println("Queue empty, cannot dequeue");
                } else {
                    System.out.println("Served customer: " + name);
                }
            } else if (op.type.equals("size")) {
                System.out.println("Queue size: " + queue.size());
            }
        }
    }

    // Main method to test ticket counter simulation
    public static void main(String[] args) {
        TicketCounterSimulation simulator = new TicketCounterSimulation();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("enqueue", "Alice"),
            new Operation("enqueue", "Bob"),
            new Operation("size", null),
            new Operation("dequeue", null),
            new Operation("size", null),
            new Operation("enqueue", "Charlie"),
            new Operation("dequeue", null)
        );
        testCases.add(case1);
        
        // Test case 2: Empty queue
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("dequeue", null),
            new Operation("size", null)
        );
        testCases.add(case2);
        
        // Test case 3: Single customer
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("enqueue", "David"),
            new Operation("size", null),
            new Operation("dequeue", null)
        );
        testCases.add(case3);
        
        // Test case 4: Multiple enqueues and dequeues
        List&lt;Operation&gt; case4 = Arrays.asList(
            new Operation("enqueue", "Eve"),
            new Operation("enqueue", "Frank"),
            new Operation("enqueue", "Grace"),
            new Operation("size", null),
            new Operation("dequeue", null),
            new Operation("dequeue", null),
            new Operation("size", null)
        );
        testCases.add(case4);
        
        // Test case 5: Null customer name
        List&lt;Operation&gt; case5 = Arrays.asList(
            new Operation("enqueue", null),
            new Operation("size", null),
            new Operation("dequeue", null)
        );
        testCases.add(case5);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            simulator.simulateTicketCounter(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-49"><a class="header" href="#output-49">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Enqueued Alice
Enqueued Bob
Queue size: 2
Served customer: Alice
Queue size: 1
Enqueued Charlie
Served customer: Bob

Test case 2:
Queue empty, cannot dequeue
Queue size: 0

Test case 3:
Enqueued David
Queue size: 1
Served customer: David

Test case 4:
Enqueued Eve
Enqueued Frank
Enqueued Grace
Queue size: 3
Served customer: Eve
Served customer: Frank
Queue size: 1

Test case 5:
Enqueued null
Queue size: 1
Served customer: null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Enqueues Alice, Bob; reports size 2; dequeues Alice; reports size 1; enqueues Charlie; dequeues Bob.</li>
<li>Test case 2: Dequeue and size on empty queue return error and 0.</li>
<li>Test case 3: Enqueues David, reports size 1, dequeues David.</li>
<li>Test case 4: Enqueues three customers, reports size 3, dequeues two, reports size 1.</li>
<li>Test case 5: Enqueues null name, reports size 1, dequeues null.</li>
</ul>
<h2 id="how-it-works-73"><a class="header" href="#how-it-works-73">How It Works</a></h2>
<ul>
<li><strong>StringQueue</strong>:
<ul>
<li>Uses an array with <code>front</code>, <code>rear</code>, and <code>size</code> to manage customer names in FIFO order.</li>
<li><code>enqueue</code>: Adds to rear if not full.</li>
<li><code>dequeue</code>: Removes from front if not empty.</li>
<li><code>size</code>: Returns current number of customers.</li>
</ul>
</li>
<li><strong>simulateTicketCounter</strong>:
<ul>
<li>Enqueues customers, printing the action.</li>
<li>Dequeues customers, printing the served customer or "Queue empty".</li>
<li>Reports queue size when requested.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Enqueue "Alice": array=["Alice"], front=0, rear=0, size=1.</li>
<li>Enqueue "Bob": array=["Alice","Bob"], front=0, rear=1, size=2.</li>
<li>Size: Returns 2.</li>
<li>Dequeue: Returns "Alice", array=["-","Bob"], front=1, rear=1, size=1.</li>
<li>Size: Returns 1.</li>
<li>Enqueue "Charlie": array=["-","Bob","Charlie"], front=1, rear=2, size=2.</li>
<li>Dequeue: Returns "Bob", array=["-","-","Charlie"], front=2, rear=2, size=1.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal sequences, empty queue, single customer, multiple operations, and null name.</li>
</ul>
<h2 id="complexity-analysis-table-72"><a class="header" href="#complexity-analysis-table-72">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Size</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations.</li>
<li>Time complexity: O(1) for each enqueue, dequeue, or size; O(n) for n operations.</li>
<li>Space complexity: O(n) for the queue storing up to n customers.</li>
<li>Worst case: O(n) time and O(n) space for many enqueue operations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a queue for a ticket counter simulation, as its FIFO nature ensures customers are served in arrival order. Test with size queries to verify queue state after operations.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null names and empty queue cases to avoid unexpected behavior. Ensure the queue size is sufficient to accommodate the input sequence.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="dijkstras-algorithm"><a class="header" href="#dijkstras-algorithm">Dijkstra’s Algorithm</a></h1>
<h2 id="problem-statement-50"><a class="header" href="#problem-statement-50">Problem Statement</a></h2>
<p>Write a Java program that implements Dijkstra’s algorithm for a weighted graph using a priority queue. Represent the graph as an adjacency list, where each edge has a non-negative weight, and compute the shortest path distances from a source node to all other nodes. The program should handle directed graphs and print the shortest distances for each reachable node. Test the implementation with various graph structures, including connected, sparse, and dense graphs, as well as edge cases like single nodes or unreachable nodes. You can visualize this as finding the shortest driving routes from a starting city to all other cities, using a priority queue to always explore the closest unvisited city next.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Number of nodes <code>n</code> (1 ≤ n ≤ 10^5).</li>
<li>List of edges as triples [u, v, w] (node u to node v with weight w, w ≥ 0).</li>
<li>Source node for shortest paths (0 ≤ source &lt; n).
<strong>Output</strong>: A string of node indices and their shortest distances from the source (e.g., "0:0 1:3 2:5"), or "INF" for unreachable nodes.
<strong>Constraints</strong>:</li>
<li>Nodes are integers from 0 to n-1.</li>
<li>Edge weights are non-negative integers (0 ≤ w ≤ 10^9).</li>
<li>The graph may be disconnected; unreachable nodes have distance "INF".</li>
<li>Assume the input graph is valid (no negative weights).
<strong>Example</strong>:</li>
<li>Input: n=4, edges=[[0,1,1], [0,2,4], [1,2,2], [1,3,6]], source=0</li>
<li>Output: "0:0 1:1 2:3 3:7"</li>
<li>Explanation: Shortest paths from node 0: 0→1 (1), 0→1→2 (1+2=3), 0→1→3 (1+6=7).</li>
<li>Input: n=3, edges=[[0,1,2]], source=2</li>
<li>Output: "0:INF 1:INF 2:0"</li>
<li>Explanation: Node 2 cannot reach 0 or 1; only 2 is reachable (distance 0).</li>
</ul>
<h2 id="pseudocode-50"><a class="header" href="#pseudocode-50">Pseudocode</a></h2>
<pre><code>CLASS NodeDistance
    SET node to integer
    SET distance to long
ENDCLASS

CLASS MinPriorityQueue
    SET array to new NodeDistance array of size 1000
    SET size to 0
    
    FUNCTION enqueue(node, distance)
        IF size equals array length THEN
            RETURN false
        ENDIF
        SET array[size] to new NodeDistance(node, distance)
        CALL siftUp(size)
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION siftUp(index)
        WHILE index &gt; 0
            SET parent to (index - 1) / 2
            IF array[index].distance &gt;= array[parent].distance THEN
                BREAK
            ENDIF
            SWAP array[index] and array[parent]
            SET index to parent
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null
        ENDIF
        SET result to array[0]
        SET array[0] to array[size - 1]
        DECREMENT size
        IF size &gt; 0 THEN
            CALL siftDown(0)
        ENDIF
        RETURN result
    ENDFUNCTION
    
    FUNCTION siftDown(index)
        SET minIndex to index
        WHILE true
            SET left to 2 * index + 1
            SET right to 2 * index + 2
            IF left &lt; size AND array[left].distance &lt; array[minIndex].distance THEN
                SET minIndex to left
            ENDIF
            IF right &lt; size AND array[right].distance &lt; array[minIndex].distance THEN
                SET minIndex to right
            ENDIF
            IF minIndex equals index THEN
                BREAK
            ENDIF
            SWAP array[index] and array[minIndex]
            SET index to minIndex
        ENDWHILE
    ENDFUNCTION
ENDCLASS

FUNCTION dijkstra(n, edges, source)
    CREATE adjList as new list of lists of (node, weight) pairs for n nodes
    FOR each edge [u, v, w] in edges
        ADD (v, w) to adjList[u]
    ENDFOR
    CREATE distances as array of size n, initialized to INF
    SET distances[source] to 0
    CREATE queue as new MinPriorityQueue
    ENQUEUE (source, 0) to queue
    CREATE visited as boolean array of size n, initialized to false
    WHILE queue is not empty
        SET nodeDist to queue.dequeue()
        SET node to nodeDist.node
        SET dist to nodeDist.distance
        IF visited[node] THEN
            CONTINUE
        ENDIF
        SET visited[node] to true
        FOR each (neighbor, weight) in adjList[node]
            IF dist + weight &lt; distances[neighbor] THEN
                SET distances[neighbor] to dist + weight
                ENQUEUE (neighbor, dist + weight) to queue
            ENDIF
        ENDFOR
    ENDWHILE
    CREATE result as new StringBuilder
    FOR i from 0 to n-1
        IF distances[i] equals INF THEN
            APPEND i + ":INF" to result
        ELSE
            APPEND i + ":" + distances[i] to result
        ENDIF
        IF i &lt; n-1 THEN
            APPEND " " to result
        ENDIF
    ENDFOR
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of graphs (n, edges, source)
    FOR each testCase in testCases
        PRINT test case details
        CALL dijkstra(testCase.n, testCase.edges, testCase.source)
        PRINT shortest distances
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-50"><a class="header" href="#algorithm-steps-50">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>NodeDistance</code> class to store a node index and its tentative distance.</li>
<li>Define a <code>MinPriorityQueue</code> class using a min-heap with:
a. An array to store <code>NodeDistance</code> objects, prioritized by distance.
b. <code>enqueue</code>: Add node-distance pair, sift up to maintain min-heap.
c. <code>siftUp</code>: Move smaller distance up.
d. <code>dequeue</code>: Remove root (smallest distance), sift down.
e. <code>siftDown</code>: Move larger distance down.</li>
<li>In <code>dijkstra</code>:
a. Build adjacency list from edges (directed: add u→v,w).
b. Initialize distances to INF, except source (0).
c. Enqueue source with distance 0.
d. While queue is not empty:
<ul>
<li>Dequeue node with smallest distance.</li>
<li>Skip if visited.</li>
<li>Mark node visited.</li>
<li>Update neighbors’ distances if shorter path found, enqueue them.
e. Format distances as string (INF for unreachable).</li>
</ul>
</li>
<li>In <code>main</code>, test with different graph structures and edge cases.</li>
</ol>
<h2 id="java-implementation-73"><a class="header" href="#java-implementation-73">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class DijkstrasAlgorithm {
    // Class to store node and distance pair
    static class NodeDistance {
        int node;
        long distance;

        NodeDistance(int node, long distance) {
            this.node = node;
            this.distance = distance;
        }
    }

    // Custom min-heap priority queue for node-distance pairs
    static class MinPriorityQueue {
        private NodeDistance[] array;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public MinPriorityQueue() {
            array = new NodeDistance[DEFAULT_SIZE];
            size = 0;
        }

        public boolean enqueue(int node, long distance) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[size] = new NodeDistance(node, distance);
            siftUp(size);
            size++;
            return true;
        }

        private void siftUp(int index) {
            while (index &gt; 0) {
                int parent = (index - 1) / 2;
                if (array[index].distance &gt;= array[parent].distance) {
                    break;
                }
                // Swap
                NodeDistance temp = array[index];
                array[index] = array[parent];
                array[parent] = temp;
                index = parent;
            }
        }

        public NodeDistance dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            NodeDistance result = array[0];
            array[0] = array[size - 1];
            size--;
            if (size &gt; 0) {
                siftDown(0);
            }
            return result;
        }

        private void siftDown(int index) {
            int minIndex = index;
            while (true) {
                int left = 2 * index + 1;
                int right = 2 * index + 2;
                if (left &lt; size &amp;&amp; array[left].distance &lt; array[minIndex].distance) {
                    minIndex = left;
                }
                if (right &lt; size &amp;&amp; array[right].distance &lt; array[minIndex].distance) {
                    minIndex = right;
                }
                if (minIndex == index) {
                    break;
                }
                // Swap
                NodeDistance temp = array[index];
                array[index] = array[minIndex];
                array[minIndex] = temp;
                index = minIndex;
            }
        }
    }

    // Dijkstra’s algorithm to find shortest paths
    public String dijkstra(int n, int[][] edges, int source) {
        // Build adjacency list
        List&lt;List&lt;int[]&gt;&gt; adjList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.add(new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            adjList.get(edge[0]).add(new int[]{edge[1], edge[2]}); // Directed: u -&gt; v, weight
        }

        // Initialize distances and priority queue
        long[] distances = new long[n];
        Arrays.fill(distances, Long.MAX_VALUE);
        distances[source] = 0;
        MinPriorityQueue queue = new MinPriorityQueue();
        queue.enqueue(source, 0);
        boolean[] visited = new boolean[n];

        // Process nodes
        while (true) {
            NodeDistance nodeDist = queue.dequeue();
            if (nodeDist == null) break;
            int node = nodeDist.node;
            long dist = nodeDist.distance;

            if (visited[node]) continue;
            visited[node] = true;

            for (int[] neighbor : adjList.get(node)) {
                int v = neighbor[0];
                long w = neighbor[1];
                if (dist + w &lt; distances[v]) {
                    distances[v] = dist + w;
                    queue.enqueue(v, dist + w);
                }
            }
        }

        // Format output
        StringBuilder result = new StringBuilder();
        for (int i = 0; i &lt; n; i++) {
            if (distances[i] == Long.MAX_VALUE) {
                result.append(i).append(":INF");
            } else {
                result.append(i).append(":").append(distances[i]);
            }
            if (i &lt; n - 1) result.append(" ");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class GraphTestCase {
        int n;
        int[][] edges;
        int source;

        GraphTestCase(int n, int[][] edges, int source) {
            this.n = n;
            this.edges = edges;
            this.source = source;
        }
    }

    // Main method to test Dijkstra’s algorithm
    public static void main(String[] args) {
        DijkstrasAlgorithm dijkstra = new DijkstrasAlgorithm();

        // Test cases
        List&lt;GraphTestCase&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Connected graph
        testCases.add(new GraphTestCase(
            4,
            new int[][]{{0,1,1}, {0,2,4}, {1,2,2}, {1,3,6}},
            0
        ));
        
        // Test case 2: Unreachable nodes
        testCases.add(new GraphTestCase(
            3,
            new int[][]{{0,1,2}},
            2
        ));
        
        // Test case 3: Single node
        testCases.add(new GraphTestCase(
            1,
            new int[][]{},
            0
        ));
        
        // Test case 4: Dense graph
        testCases.add(new GraphTestCase(
            4,
            new int[][]{{0,1,1}, {0,2,5}, {0,3,10}, {1,2,3}, {1,3,3}, {2,3,2}},
            0
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            GraphTestCase test = testCases.get(i);
            System.out.println("Test case " + (i + 1) + ": n=" + test.n + ", source=" + test.source);
            System.out.println("Edges: " + Arrays.deepToString(test.edges));
            String result = dijkstra.dijkstra(test.n, test.edges, test.source);
            System.out.println("Shortest distances: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-50"><a class="header" href="#output-50">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: n=4, source=0
Edges: [[0, 1, 1], [0, 2, 4], [1, 2, 2], [1, 3, 6]]
Shortest distances: 0:0 1:1 2:3 3:7

Test case 2: n=3, source=2
Edges: [[0, 1, 2]]
Shortest distances: 0:INF 1:INF 2:0

Test case 3: n=1, source=0
Edges: []
Shortest distances: 0:0

Test case 4: n=4, source=0
Edges: [[0, 1, 1], [0, 2, 5], [0, 3, 10], [1, 2, 3], [1, 3, 3], [2, 3, 2]]
Shortest distances: 0:0 1:1 2:4 3:4
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: From source 0, shortest paths: 0→1 (1), 0→1→2 (1+2=3), 0→1→3 (1+6=7).</li>
<li>Test case 2: From source 2, no outgoing edges, so only 2 has distance 0; others are INF.</li>
<li>Test case 3: Single node 0 has distance 0.</li>
<li>Test case 4: From source 0, shortest paths: 0→1 (1), 0→1→2 (1+3=4), 0→1→3 (1+3=4).</li>
</ul>
<h2 id="how-it-works-74"><a class="header" href="#how-it-works-74">How It Works</a></h2>
<ul>
<li><strong>NodeDistance</strong>: Stores a node and its tentative distance.</li>
<li><strong>MinPriorityQueue</strong>:
<ul>
<li>Uses a min-heap to prioritize nodes with smaller distances.</li>
<li><code>enqueue</code>: Adds node-distance pair, sifts up.</li>
<li><code>dequeue</code>: Removes smallest-distance node, sifts down.</li>
</ul>
</li>
<li><strong>dijkstra</strong>:
<ul>
<li>Builds adjacency list from edges (directed).</li>
<li>Initializes distances to INF, source to 0.</li>
<li>Enqueues source with distance 0.</li>
<li>Processes nodes in order of increasing distance, updating neighbors’ distances if shorter.</li>
<li>Uses visited array to avoid reprocessing nodes.</li>
<li>Formats distances (INF for unreachable).</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>n=4, edges=[[0,1,1], [0,2,4], [1,2,2], [1,3,6]], source=0.</li>
<li>Adjacency list: [0: [(1,1),(2,4)], 1: [(2,2),(3,6)], 2: [], 3: []].</li>
<li>Initialize: distances=[0,INF,INF,INF], enqueue (0,0).</li>
<li>Dequeue (0,0): Update 1:1, 2:4, enqueue (1,1),(2,4).</li>
<li>Dequeue (1,1): Update 2:3 (1+2), 3:7 (1+6), enqueue (2,3),(3,7).</li>
<li>Dequeue (2,3): No updates.</li>
<li>Dequeue (3,7): No updates.</li>
<li>Result: "0:0 1:1 2:3 3:7".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests connected graph, unreachable nodes, single node, and dense graph.</li>
</ul>
<h2 id="complexity-analysis-table-73"><a class="header" href="#complexity-analysis-table-73">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(log V)</td><td>O(1)</td></tr>
<tr><td>Dijkstra</td><td>O((V + E) log V)</td><td>O(V + E)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>V is the number of vertices, E is the number of edges.</li>
<li>Time complexity: O(log V) for enqueue/dequeue; O((V + E) log V) for processing each node and edge with heap operations.</li>
<li>Space complexity: O(V) for queue, distances, and visited array; O(E) for adjacency list.</li>
<li>Worst case: O((V + E) log V) time, O(V + E) space for dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a min-heap priority queue in Dijkstra’s algorithm to efficiently select the node with the smallest tentative distance. Test with sparse and dense graphs to verify correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure edge weights are non-negative, as Dijkstra’s algorithm does not handle negative weights. Use a visited array to avoid reprocessing nodes in cyclic graphs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="kth-largest-element"><a class="header" href="#kth-largest-element">Kth Largest Element</a></h1>
<h2 id="problem-statement-51"><a class="header" href="#problem-statement-51">Problem Statement</a></h2>
<p>Write a Java program that uses a priority queue to find the kth largest element in an array of integers. The program should enqueue elements into a min-heap of size k, maintaining the k largest elements, and return the root (smallest of the k largest) as the kth largest element. Test the implementation with at least three different arrays and k values, including edge cases like k=1, k equal to the array length, and arrays with duplicate elements. You can visualize this as sorting through a list of exam scores to find the kth highest score, keeping only the top k scores in a priority queue to efficiently track the kth largest.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers (e.g., [3, 1, 4, 1, 5]).</li>
<li>An integer k (1 ≤ k ≤ array length).
<strong>Output</strong>: The kth largest element in the array (e.g., for k=2 in [3, 1, 4, 1, 5], output 4).
<strong>Constraints</strong>:</li>
<li>Array length is between 1 and 10^5.</li>
<li>Elements are integers in the range [-10^9, 10^9].</li>
<li>1 ≤ k ≤ array length.</li>
<li>Assume k is valid for the input array.
<strong>Example</strong>:</li>
<li>Input: arr=[3, 1, 4, 1, 5], k=2</li>
<li>Output: 4</li>
<li>Explanation: The 2nd largest element is 4 (largest is 5, 2nd is 4).</li>
<li>Input: arr=[1], k=1</li>
<li>Output: 1</li>
<li>Explanation: Only one element, so 1st largest is 1.</li>
<li>Input: arr=[4, 4, 4], k=2</li>
<li>Output: 4</li>
<li>Explanation: All elements are 4, so 2nd largest is 4.</li>
</ul>
<h2 id="pseudocode-51"><a class="header" href="#pseudocode-51">Pseudocode</a></h2>
<pre><code>CLASS MinPriorityQueue
    SET array to new integer array of size capacity
    SET size to 0
    SET capacity to input capacity
    
    FUNCTION enqueue(number)
        IF size equals capacity THEN
            IF number &lt;= array[0] THEN
                RETURN false
            ENDIF
            SET array[0] to number
            CALL siftDown(0)
            RETURN true
        ENDIF
        SET array[size] to number
        CALL siftUp(size)
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION siftUp(index)
        WHILE index &gt; 0
            SET parent to (index - 1) / 2
            IF array[index] &gt;= array[parent] THEN
                BREAK
            ENDIF
            SWAP array[index] and array[parent]
            SET index to parent
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION siftDown(index)
        SET minIndex to index
        WHILE true
            SET left to 2 * index + 1
            SET right to 2 * index + 2
            IF left &lt; size AND array[left] &lt; array[minIndex] THEN
                SET minIndex to left
            ENDIF
            IF right &lt; size AND array[right] &lt; array[minIndex] THEN
                SET minIndex to right
            ENDIF
            IF minIndex equals index THEN
                BREAK
            ENDIF
            SWAP array[index] and array[minIndex]
            SET index to minIndex
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION peek()
        IF size equals 0 THEN
            RETURN null
        ENDIF
        RETURN array[0]
    ENDFUNCTION
ENDCLASS

FUNCTION findKthLargest(arr, k)
    CREATE queue as new MinPriorityQueue with capacity k
    FOR each number in arr
        CALL queue.enqueue(number)
    ENDFOR
    RETURN queue.peek()
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (array, k) pairs
    FOR each testCase in testCases
        PRINT test case details
        CALL findKthLargest(testCase.arr, testCase.k)
        PRINT kth largest element
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-51"><a class="header" href="#algorithm-steps-51">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>MinPriorityQueue</code> class using a min-heap with:
a. An array of fixed capacity k, with <code>size</code> to track elements.
b. <code>enqueue</code>: If size &lt; k, add to end and sift up; if size = k and number &gt; root, replace root and sift down.
c. <code>siftUp</code>: Move smaller number up to maintain min-heap property.
d. <code>siftDown</code>: Move larger number down to maintain min-heap property.
e. <code>peek</code>: Return root (smallest of k largest elements).</li>
<li>In <code>findKthLargest</code>:
a. Create a min-heap with capacity k.
b. For each number in the array:
<ul>
<li>Enqueue to heap, maintaining k largest elements.
c. Return the root (kth largest).</li>
</ul>
</li>
<li>In <code>main</code>, test with at least three arrays and k values, including edge cases like k=1, k=length, and duplicates.</li>
</ol>
<h2 id="java-implementation-74"><a class="header" href="#java-implementation-74">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class KthLargestElement {
    // Custom min-heap priority queue implementation
    static class MinPriorityQueue {
        private int[] array;
        private int size;
        private int capacity;

        public MinPriorityQueue(int capacity) {
            this.array = new int[capacity];
            this.size = 0;
            this.capacity = capacity;
        }

        public boolean enqueue(int number) {
            if (size == capacity) {
                if (number &lt;= array[0]) {
                    return false; // Smaller than kth largest
                }
                array[0] = number; // Replace smallest
                siftDown(0);
                return true;
            }
            array[size] = number;
            siftUp(size);
            size++;
            return true;
        }

        private void siftUp(int index) {
            while (index &gt; 0) {
                int parent = (index - 1) / 2;
                if (array[index] &gt;= array[parent]) {
                    break;
                }
                // Swap
                int temp = array[index];
                array[index] = array[parent];
                array[parent] = temp;
                index = parent;
            }
        }

        private void siftDown(int index) {
            int minIndex = index;
            while (true) {
                int left = 2 * index + 1;
                int right = 2 * index + 2;
                if (left &lt; size &amp;&amp; array[left] &lt; array[minIndex]) {
                    minIndex = left;
                }
                if (right &lt; size &amp;&amp; array[right] &lt; array[minIndex]) {
                    minIndex = right;
                }
                if (minIndex == index) {
                    break;
                }
                // Swap
                int temp = array[index];
                array[index] = array[minIndex];
                array[minIndex] = temp;
                index = minIndex;
            }
        }

        public Integer peek() {
            if (size == 0) {
                return null;
            }
            return array[0];
        }
    }

    // Finds the kth largest element in the array
    public int findKthLargest(int[] arr, int k) {
        MinPriorityQueue queue = new MinPriorityQueue(k);
        for (int num : arr) {
            queue.enqueue(num);
        }
        return queue.peek();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        int k;

        TestCase(int[] arr, int k) {
            this.arr = arr;
            this.k = k;
        }
    }

    // Main method to test kth largest element
    public static void main(String[] args) {
        KthLargestElement finder = new KthLargestElement();

        // Test cases
        List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal array
        testCases.add(new TestCase(new int[]{3, 1, 4, 1, 5}, 2));
        
        // Test case 2: Single element
        testCases.add(new TestCase(new int[]{1}, 1));
        
        // Test case 3: Duplicates
        testCases.add(new TestCase(new int[]{4, 4, 4}, 2));
        
        // Test case 4: k equals array length
        testCases.add(new TestCase(new int[]{7, 2, 9, 4, 6}, 5));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            TestCase test = testCases.get(i);
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Array: " + Arrays.toString(test.arr));
            System.out.println("k: " + test.k);
            int result = finder.findKthLargest(test.arr, test.k);
            System.out.println("Kth largest element: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-51"><a class="header" href="#output-51">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Array: [3, 1, 4, 1, 5]
k: 2
Kth largest element: 4

Test case 2:
Array: [1]
k: 1
Kth largest element: 1

Test case 3:
Array: [4, 4, 4]
k: 2
Kth largest element: 4

Test case 4:
Array: [7, 2, 9, 4, 6]
k: 5
Kth largest element: 2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: In [3, 1, 4, 1, 5], k=2, the 2nd largest is 4 (largest is 5).</li>
<li>Test case 2: In [1], k=1, the 1st largest is 1.</li>
<li>Test case 3: In [4, 4, 4], k=2, the 2nd largest is 4 (all elements equal).</li>
<li>Test case 4: In [7, 2, 9, 4, 6], k=5, the 5th largest is 2 (smallest element).</li>
</ul>
<h2 id="how-it-works-75"><a class="header" href="#how-it-works-75">How It Works</a></h2>
<ul>
<li><strong>MinPriorityQueue</strong>:
<ul>
<li>Uses a min-heap array to maintain the k largest elements, with smallest at root.</li>
<li><code>enqueue</code>: If size &lt; k, adds number and sifts up; if size = k and number &gt; root, replaces root and sifts down.</li>
<li><code>siftUp</code>: Moves smaller number up to maintain min-heap.</li>
<li><code>siftDown</code>: Moves larger number down to maintain min-heap.</li>
<li><code>peek</code>: Returns root (kth largest).</li>
</ul>
</li>
<li><strong>findKthLargest</strong>:
<ul>
<li>Creates a min-heap of size k.</li>
<li>Enqueues each array element, keeping only the k largest.</li>
<li>Returns the root (kth largest).</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>arr=[3, 1, 4, 1, 5], k=2.</li>
<li>Enqueue 3: heap=[3], size=1.</li>
<li>Enqueue 1: heap=[1,3], size=2.</li>
<li>Enqueue 4: heap=[1,3], replace 1 with 4, heap=[3,4], size=2.</li>
<li>Enqueue 1: heap=[3,4] (1 &lt; 3, ignored).</li>
<li>Enqueue 5: heap=[3,4], replace 3 with 5, heap=[4,5], size=2.</li>
<li>Peek: Returns 4 (2nd largest).</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal array, single element, duplicates, and k=length.</li>
</ul>
<h2 id="complexity-analysis-table-74"><a class="header" href="#complexity-analysis-table-74">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue</td><td>O(log k)</td><td>O(1)</td></tr>
<tr><td>Find Kth Largest</td><td>O(n log k)</td><td>O(k)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length, k is the input k.</li>
<li>Time complexity: O(log k) for each enqueue (heap operations); O(n log k) for n elements.</li>
<li>Space complexity: O(k) for the min-heap of size k.</li>
<li>Worst case: O(n log k) time for large n, O(k) space.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a min-heap of size k to efficiently find the kth largest element, as it discards smaller elements early. Test with edge cases like k=1 or k=length to ensure correctness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure k is valid (1 ≤ k ≤ array length) to avoid errors. Handle duplicates carefully, as they may affect the heap’s behavior.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="merge-k-sorted-lists"><a class="header" href="#merge-k-sorted-lists">Merge K Sorted Lists</a></h1>
<h2 id="problem-statement-52"><a class="header" href="#problem-statement-52">Problem Statement</a></h2>
<p>Write a Java program that merges k sorted arrays into a single sorted array using a priority queue. The program should enqueue the first element of each array along with its array index and value, and repeatedly dequeue the smallest element and enqueue the next element from the same array, continuing until all elements are processed. Test the implementation with various cases, including multiple arrays, single arrays, empty arrays, and arrays with duplicate elements. You can visualize this as combining k sorted lists of exam scores into one sorted list, using a priority queue to always pick the smallest score available from the lists.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A list of k sorted arrays, where each array contains integers (e.g., [[1,4,5], [1,3,4], [2,6]]).</li>
<li>k is the number of arrays (0 ≤ k ≤ 10^3).
<strong>Output</strong>: A single sorted array containing all elements from the input arrays (e.g., [1,1,2,3,4,4,5,6]).
<strong>Constraints</strong>:</li>
<li>Each array is sorted in non-decreasing order.</li>
<li>Array lengths are between 0 and 10^4.</li>
<li>Elements are integers in the range [-10^9, 10^9].</li>
<li>Total number of elements across all arrays is at most 10^4.
<strong>Example</strong>:</li>
<li>Input: arrays=[[1,4,5], [1,3,4], [2,6]]</li>
<li>Output: [1,1,2,3,4,4,5,6]</li>
<li>Explanation: Merges three sorted arrays into one sorted array.</li>
<li>Input: arrays=[[]]</li>
<li>Output: []</li>
<li>Explanation: Single empty array results in an empty output.</li>
</ul>
<h2 id="pseudocode-52"><a class="header" href="#pseudocode-52">Pseudocode</a></h2>
<pre><code>CLASS Element
    SET value to integer
    SET arrayIndex to integer
    SET elementIndex to integer
ENDCLASS

CLASS MinPriorityQueue
    SET array to new Element array of size 1000
    SET size to 0
    
    FUNCTION enqueue(value, arrayIndex, elementIndex)
        IF size equals array length THEN
            RETURN false
        ENDIF
        SET array[size] to new Element(value, arrayIndex, elementIndex)
        CALL siftUp(size)
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION siftUp(index)
        WHILE index &gt; 0
            SET parent to (index - 1) / 2
            IF array[index].value &gt;= array[parent].value THEN
                BREAK
            ENDIF
            SWAP array[index] and array[parent]
            SET index to parent
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null
        ENDIF
        SET result to array[0]
        SET array[0] to array[size - 1]
        DECREMENT size
        IF size &gt; 0 THEN
            CALL siftDown(0)
        ENDIF
        RETURN result
    ENDFUNCTION
    
    FUNCTION siftDown(index)
        SET minIndex to index
        WHILE true
            SET left to 2 * index + 1
            SET right to 2 * index + 2
            IF left &lt; size AND array[left].value &lt; array[minIndex].value THEN
                SET minIndex to left
            ENDIF
            IF right &lt; size AND array[right].value &lt; array[minIndex].value THEN
                SET minIndex to right
            ENDIF
            IF minIndex equals index THEN
                BREAK
            ENDIF
            SWAP array[index] and array[minIndex]
            SET index to minIndex
        ENDWHILE
    ENDFUNCTION
ENDCLASS

FUNCTION mergeKSortedLists(arrays)
    IF arrays is empty THEN
        RETURN empty array
    ENDIF
    CREATE queue as new MinPriorityQueue
    CREATE result as new list
    FOR i from 0 to arrays length - 1
        IF arrays[i] is not empty THEN
            ENQUEUE (arrays[i][0], i, 0) to queue
        ENDIF
    ENDFOR
    WHILE queue is not empty
        SET element to queue.dequeue()
        ADD element.value to result
        SET arrayIndex to element.arrayIndex
        SET elementIndex to element.elementIndex + 1
        IF elementIndex &lt; arrays[arrayIndex] length THEN
            ENQUEUE (arrays[arrayIndex][elementIndex], arrayIndex, elementIndex) to queue
        ENDIF
    ENDWHILE
    RETURN result as array
ENDFUNCTION

FUNCTION main()
    SET testCases to array of lists of sorted arrays
    FOR each testCase in testCases
        PRINT test case details
        CALL mergeKSortedLists(testCase)
        PRINT merged sorted array
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-52"><a class="header" href="#algorithm-steps-52">Algorithm Steps</a></h2>
<ol>
<li>Define an <code>Element</code> class to store a value, its array index, and its position in that array.</li>
<li>Define a <code>MinPriorityQueue</code> class using a min-heap with:
a. An array to store <code>Element</code> objects, prioritized by value.
b. <code>enqueue</code>: Add element, sift up to maintain min-heap.
c. <code>siftUp</code>: Move smaller value up.
d. <code>dequeue</code>: Remove smallest value, sift down.
e. <code>siftDown</code>: Move larger value down.</li>
<li>In <code>mergeKSortedLists</code>:
a. If input is empty, return empty array.
b. Create a min-heap and result list.
c. Enqueue first element of each non-empty array with its array index and position.
d. While queue is not empty:
<ul>
<li>Dequeue smallest element, add to result.</li>
<li>If more elements exist in its array, enqueue the next element.
e. Return result as array.</li>
</ul>
</li>
<li>In <code>main</code>, test with multiple arrays, single arrays, empty arrays, and duplicates.</li>
</ol>
<h2 id="java-implementation-75"><a class="header" href="#java-implementation-75">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class MergeKSortedLists {
    // Class to store element value, array index, and element index
    static class Element {
        int value;
        int arrayIndex;
        int elementIndex;

        Element(int value, int arrayIndex, int elementIndex) {
            this.value = value;
            this.arrayIndex = arrayIndex;
            this.elementIndex = elementIndex;
        }
    }

    // Custom min-heap priority queue for elements
    static class MinPriorityQueue {
        private Element[] array;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public MinPriorityQueue() {
            array = new Element[DEFAULT_SIZE];
            size = 0;
        }

        public boolean enqueue(int value, int arrayIndex, int elementIndex) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[size] = new Element(value, arrayIndex, elementIndex);
            siftUp(size);
            size++;
            return true;
        }

        private void siftUp(int index) {
            while (index &gt; 0) {
                int parent = (index - 1) / 2;
                if (array[index].value &gt;= array[parent].value) {
                    break;
                }
                // Swap
                Element temp = array[index];
                array[index] = array[parent];
                array[parent] = temp;
                index = parent;
            }
        }

        public Element dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            Element result = array[0];
            array[0] = array[size - 1];
            size--;
            if (size &gt; 0) {
                siftDown(0);
            }
            return result;
        }

        private void siftDown(int index) {
            int minIndex = index;
            while (true) {
                int left = 2 * index + 1;
                int right = 2 * index + 2;
                if (left &lt; size &amp;&amp; array[left].value &lt; array[minIndex].value) {
                    minIndex = left;
                }
                if (right &lt; size &amp;&amp; array[right].value &lt; array[minIndex].value) {
                    minIndex = right;
                }
                if (minIndex == index) {
                    break;
                }
                // Swap
                Element temp = array[index];
                array[index] = array[minIndex];
                array[minIndex] = temp;
                index = minIndex;
            }
        }
    }

    // Merges k sorted arrays into one sorted array
    public int[] mergeKSortedLists(int[][] arrays) {
        if (arrays == null || arrays.length == 0) {
            return new int[0];
        }

        MinPriorityQueue queue = new MinPriorityQueue();
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

        // Enqueue first element of each non-empty array
        for (int i = 0; i &lt; arrays.length; i++) {
            if (arrays[i] != null &amp;&amp; arrays[i].length &gt; 0) {
                queue.enqueue(arrays[i][0], i, 0);
            }
        }

        // Process queue
        while (true) {
            Element element = queue.dequeue();
            if (element == null) break;
            result.add(element.value);
            int arrayIndex = element.arrayIndex;
            int elementIndex = element.elementIndex + 1;
            if (elementIndex &lt; arrays[arrayIndex].length) {
                queue.enqueue(arrays[arrayIndex][elementIndex], arrayIndex, elementIndex);
            }
        }

        // Convert result to array
        int[] merged = new int[result.size()];
        for (int i = 0; i &lt; result.size(); i++) {
            merged[i] = result.get(i);
        }
        return merged;
    }

    // Helper class for test cases
    static class TestCase {
        int[][] arrays;

        TestCase(int[][] arrays) {
            this.arrays = arrays;
        }
    }

    // Main method to test merge k sorted lists
    public static void main(String[] args) {
        MergeKSortedLists merger = new MergeKSortedLists();

        // Test cases
        List&lt;TestCase&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Multiple arrays
        testCases.add(new TestCase(
            new int[][]{{1,4,5}, {1,3,4}, {2,6}}
        ));
        
        // Test case 2: Single array
        testCases.add(new TestCase(
            new int[][]{{1,2,3}}
        ));
        
        // Test case 3: Empty arrays
        testCases.add(new TestCase(
            new int[][]{{}}
        ));
        
        // Test case 4: Arrays with duplicates
        testCases.add(new TestCase(
            new int[][]{{1,1,1}, {2,2}, {1,3}}
        ));
        
        // Test case 5: Mixed empty and non-empty
        testCases.add(new TestCase(
            new int[][]{{}, {1,2}, {3}}
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            TestCase test = testCases.get(i);
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input arrays: " + Arrays.deepToString(test.arrays));
            int[] result = merger.mergeKSortedLists(test.arrays);
            System.out.println("Merged sorted array: " + Arrays.toString(result) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-52"><a class="header" href="#output-52">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input arrays: [[1, 4, 5], [1, 3, 4], [2, 6]]
Merged sorted array: [1, 1, 2, 3, 4, 4, 5, 6]

Test case 2:
Input arrays: [[1, 2, 3]]
Merged sorted array: [1, 2, 3]

Test case 3:
Input arrays: [[]]
Merged sorted array: []

Test case 4:
Input arrays: [[1, 1, 1], [2, 2], [1, 3]]
Merged sorted array: [1, 1, 1, 1, 2, 2, 3]

Test case 5:
Input arrays: [[], [1, 2], [3]]
Merged sorted array: [1, 2, 3]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Merges three arrays, producing sorted output [1,1,2,3,4,4,5,6].</li>
<li>Test case 2: Single array [1,2,3] remains unchanged.</li>
<li>Test case 3: Single empty array results in empty output.</li>
<li>Test case 4: Arrays with duplicates merge into [1,1,1,1,2,2,3].</li>
<li>Test case 5: Empty and non-empty arrays merge into [1,2,3].</li>
</ul>
<h2 id="how-it-works-76"><a class="header" href="#how-it-works-76">How It Works</a></h2>
<ul>
<li><strong>Element</strong>: Stores a value, its array index, and position in that array.</li>
<li><strong>MinPriorityQueue</strong>:
<ul>
<li>Uses a min-heap to prioritize smallest values.</li>
<li><code>enqueue</code>: Adds element, sifts up.</li>
<li><code>dequeue</code>: Removes smallest element, sifts down.</li>
</ul>
</li>
<li><strong>mergeKSortedLists</strong>:
<ul>
<li>Handles empty input by returning empty array.</li>
<li>Enqueues first element of each non-empty array.</li>
<li>Dequeues smallest element, adds to result, enqueues next element from same array.</li>
<li>Converts result list to array.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>arrays=[[1,4,5], [1,3,4], [2,6]].</li>
<li>Enqueue: (1,0,0), (1,1,0), (2,2,0) → heap=[(1,0,0),(1,1,0),(2,2,0)].</li>
<li>Dequeue: (1,0,0), add 1, enqueue (4,0,1) → heap=[(1,1,0),(4,0,1),(2,2,0)].</li>
<li>Dequeue: (1,1,0), add 1, enqueue (3,1,1) → heap=[(2,2,0),(4,0,1),(3,1,1)].</li>
<li>Continue until heap empty: result=[1,1,2,3,4,4,5,6].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests multiple arrays, single array, empty arrays, duplicates, and mixed cases.</li>
</ul>
<h2 id="complexity-analysis-table-75"><a class="header" href="#complexity-analysis-table-75">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue/Dequeue</td><td>O(log k)</td><td>O(1)</td></tr>
<tr><td>Merge K Lists</td><td>O(N log k)</td><td>O(k + N)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>k is the number of arrays, N is the total number of elements.</li>
<li>Time complexity: O(log k) for enqueue/dequeue; O(N log k) for N elements with heap of size k.</li>
<li>Space complexity: O(k) for heap, O(N) for result array.</li>
<li>Worst case: O(N log k) time, O(k + N) space for large N.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a min-heap with size k to efficiently merge sorted arrays by always selecting the smallest available element. Track array indices to enqueue the next element.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle empty arrays and null inputs to avoid errors. Ensure the priority queue size is sufficient for k arrays.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="min-heap-to-max-heap"><a class="header" href="#min-heap-to-max-heap">Min-Heap to Max-Heap</a></h1>
<h2 id="problem-statement-53"><a class="header" href="#problem-statement-53">Problem Statement</a></h2>
<p>Write a Java program that modifies a min-heap-based priority queue implementation to support a max-heap, where larger values have higher priority. The program should enqueue integers into the max-heap and dequeue the largest element, printing each operation’s result. Test the modified implementation with various sequences of enqueue and dequeue operations, including edge cases like empty queues, single elements, and duplicate values. You can visualize this as a priority task list where the most urgent task (highest number) is always processed first, with the max-heap ensuring the largest value is at the root.</p>
<p><strong>Input</strong>: A sequence of operations, where each operation is either:</p>
<ul>
<li>Enqueue: Add an integer to the max-heap (e.g., enqueue 5).</li>
<li>Dequeue: Remove and return the largest element from the max-heap.
<strong>Output</strong>: For each operation, print the action performed (enqueue or dequeue) and the result, such as the dequeued value or a message if the queue is empty.
<strong>Constraints</strong>:</li>
<li>Queue size is between 0 and 10^5.</li>
<li>Elements are integers in the range [-10^9, 10^9].</li>
<li>The queue may be empty when dequeue is called.
<strong>Example</strong>:</li>
<li>Input: Operations = [enqueue(3), enqueue(1), enqueue(4), dequeue, enqueue(2), dequeue]</li>
<li>Output:
<pre><code>Enqueued 3
Enqueued 1
Enqueued 4
Dequeued: 4
Enqueued 2
Dequeued: 3
</code></pre>
</li>
<li>Explanation: The max-heap ensures the largest element (4, then 3) is dequeued first.</li>
<li>Input: Operations = [dequeue on empty queue]</li>
<li>Output: <code>Queue empty, cannot dequeue</code></li>
</ul>
<h2 id="pseudocode-53"><a class="header" href="#pseudocode-53">Pseudocode</a></h2>
<pre><code>CLASS MaxPriorityQueue
    SET array to new integer array of size 1000
    SET size to 0
    
    FUNCTION enqueue(number)
        IF size equals array length THEN
            RETURN false (queue full)
        ENDIF
        SET array[size] to number
        CALL siftUp(size)
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION siftUp(index)
        WHILE index &gt; 0
            SET parent to (index - 1) / 2
            IF array[index] &lt;= array[parent] THEN
                BREAK
            ENDIF
            SWAP array[index] and array[parent]
            SET index to parent
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null (queue empty)
        ENDIF
        SET result to array[0]
        SET array[0] to array[size - 1]
        DECREMENT size
        IF size &gt; 0 THEN
            CALL siftDown(0)
        ENDIF
        RETURN result
    ENDFUNCTION
    
    FUNCTION siftDown(index)
        SET maxIndex to index
        WHILE true
            SET left to 2 * index + 1
            SET right to 2 * index + 2
            IF left &lt; size AND array[left] &gt; array[maxIndex] THEN
                SET maxIndex to left
            ENDIF
            IF right &lt; size AND array[right] &gt; array[maxIndex] THEN
                SET maxIndex to right
            ENDIF
            IF maxIndex equals index THEN
                BREAK
            ENDIF
            SWAP array[index] and array[maxIndex]
            SET index to maxIndex
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
ENDCLASS

FUNCTION testMaxPriorityQueue(operations)
    CREATE queue as new MaxPriorityQueue
    FOR each operation in operations
        IF operation.type equals "enqueue" THEN
            IF queue.enqueue(operation.number) THEN
                PRINT enqueued number
            ELSE
                PRINT enqueue failed: queue full
            ENDIF
        ELSE IF operation.type equals "dequeue" THEN
            SET number to queue.dequeue()
            IF number is null THEN
                PRINT queue empty message
            ELSE
                PRINT dequeued number
            ENDIF
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testMaxPriorityQueue(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-53"><a class="header" href="#algorithm-steps-53">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>MaxPriorityQueue</code> class using a max-heap with:
a. An array to store integers, with <code>size</code> to track elements.
b. <code>enqueue</code>: Add number to end, sift up to maintain max-heap property (larger values up).
c. <code>siftUp</code>: Move larger number up if greater than parent.
d. <code>dequeue</code>: Remove root (largest), move last element to root, sift down.
e. <code>siftDown</code>: Move smaller number down to maintain max-heap property.
f. <code>isEmpty</code>: Check if queue is empty.</li>
<li>In <code>testMaxPriorityQueue</code>:
a. Create a <code>MaxPriorityQueue</code>.
b. For each operation:
<ul>
<li>If "enqueue", add number, print action or "Queue full".</li>
<li>If "dequeue", remove largest number, print result or "Queue empty".</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences of enqueue and dequeue operations, including empty queues, single elements, and duplicates.</li>
</ol>
<h2 id="java-implementation-76"><a class="header" href="#java-implementation-76">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class MinHeapToMaxHeap {
    // Custom max-heap priority queue implementation
    static class MaxPriorityQueue {
        private int[] array;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public MaxPriorityQueue() {
            array = new int[DEFAULT_SIZE];
            size = 0;
        }

        public boolean enqueue(int number) {
            if (size == array.length) {
                return false; // Queue full
            }
            array[size] = number;
            siftUp(size);
            size++;
            return true;
        }

        private void siftUp(int index) {
            while (index &gt; 0) {
                int parent = (index - 1) / 2;
                if (array[index] &lt;= array[parent]) {
                    break;
                }
                // Swap
                int temp = array[index];
                array[index] = array[parent];
                array[parent] = temp;
                index = parent;
            }
        }

        public Integer dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            int result = array[0];
            array[0] = array[size - 1];
            size--;
            if (size &gt; 0) {
                siftDown(0);
            }
            return result;
        }

        private void siftDown(int index) {
            int maxIndex = index;
            while (true) {
                int left = 2 * index + 1;
                int right = 2 * index + 2;
                if (left &lt; size &amp;&amp; array[left] &gt; array[maxIndex]) {
                    maxIndex = left;
                }
                if (right &lt; size &amp;&amp; array[right] &gt; array[maxIndex]) {
                    maxIndex = right;
                }
                if (maxIndex == index) {
                    break;
                }
                // Swap
                int temp = array[index];
                array[index] = array[maxIndex];
                array[maxIndex] = temp;
                index = maxIndex;
            }
        }

        public boolean isEmpty() {
            return size == 0;
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        Integer number;

        Operation(String type, Integer number) {
            this.type = type;
            this.number = number;
        }
    }

    // Tests max priority queue with operations
    public void testMaxPriorityQueue(List&lt;Operation&gt; operations) {
        MaxPriorityQueue queue = new MaxPriorityQueue();
        for (Operation op : operations) {
            if (op.type.equals("enqueue")) {
                if (queue.enqueue(op.number)) {
                    System.out.println("Enqueued " + op.number);
                } else {
                    System.out.println("Enqueue " + op.number + " failed: Queue full");
                }
            } else if (op.type.equals("dequeue")) {
                Integer number = queue.dequeue();
                if (number == null) {
                    System.out.println("Queue empty, cannot dequeue");
                } else {
                    System.out.println("Dequeued: " + number);
                }
            }
        }
    }

    // Main method to test max priority queue
    public static void main(String[] args) {
        MinHeapToMaxHeap tester = new MinHeapToMaxHeap();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("enqueue", 3),
            new Operation("enqueue", 1),
            new Operation("enqueue", 4),
            new Operation("dequeue", null),
            new Operation("enqueue", 2),
            new Operation("dequeue", null)
        );
        testCases.add(case1);
        
        // Test case 2: Empty queue
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("dequeue", null)
        );
        testCases.add(case2);
        
        // Test case 3: Single element
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("enqueue", 5),
            new Operation("dequeue", null)
        );
        testCases.add(case3);
        
        // Test case 4: Duplicate values
        List&lt;Operation&gt; case4 = Arrays.asList(
            new Operation("enqueue", 2),
            new Operation("enqueue", 2),
            new Operation("enqueue", 2),
            new Operation("dequeue", null),
            new Operation("dequeue", null)
        );
        testCases.add(case4);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            tester.testMaxPriorityQueue(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-53"><a class="header" href="#output-53">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Enqueued 3
Enqueued 1
Enqueued 4
Dequeued: 4
Enqueued 2
Dequeued: 3

Test case 2:
Queue empty, cannot dequeue

Test case 3:
Enqueued 5
Dequeued: 5

Test case 4:
Enqueued 2
Enqueued 2
Enqueued 2
Dequeued: 2
Dequeued: 2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Enqueues 3, 1, 4 (heap: [4,1,3]); dequeues 4; enqueues 2 (heap: [3,1,2]); dequeues 3.</li>
<li>Test case 2: Dequeue on empty queue returns error.</li>
<li>Test case 3: Enqueues 5, dequeues 5.</li>
<li>Test case 4: Enqueues three 2’s, dequeues two 2’s in FIFO order.</li>
</ul>
<h2 id="how-it-works-77"><a class="header" href="#how-it-works-77">How It Works</a></h2>
<ul>
<li><strong>MaxPriorityQueue</strong>:
<ul>
<li>Uses a max-heap array to maintain largest element at root.</li>
<li><code>enqueue</code>: Adds to end, sifts up if larger than parent.</li>
<li><code>siftUp</code>: Moves larger number up to maintain max-heap.</li>
<li><code>dequeue</code>: Removes root, moves last element to root, sifts down.</li>
<li><code>siftDown</code>: Moves smaller number down to maintain max-heap.</li>
</ul>
</li>
<li><strong>testMaxPriorityQueue</strong>:
<ul>
<li>Enqueues numbers, printing action or "Queue full".</li>
<li>Dequeues largest number, printing result or "Queue empty".</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Enqueue 3: array=[3], size=1.</li>
<li>Enqueue 1: array=[3,1], size=2.</li>
<li>Enqueue 4: array=[4,1,3], size=3 (after sift-up).</li>
<li>Dequeue: Returns 4, array=[3,1], size=2 (after sift-down).</li>
<li>Enqueue 2: array=[3,1,2], size=3.</li>
<li>Dequeue: Returns 3, array=[2,1], size=2.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal sequence, empty queue, single element, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-76"><a class="header" href="#complexity-analysis-table-76">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Dequeue</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n log n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations.</li>
<li>Time complexity: O(log n) for enqueue/dequeue due to heap operations; O(n log n) for n operations.</li>
<li>Space complexity: O(n) for storing up to n elements.</li>
<li>Worst case: O(n log n) time, O(n) space for many operations.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Convert a min-heap to a max-heap by reversing comparison logic to prioritize larger values. Test with duplicate values to verify FIFO behavior for equal priorities.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure heap properties are maintained after each operation. Handle empty queue cases to avoid null pointer issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="task-scheduler"><a class="header" href="#task-scheduler">Task Scheduler</a></h1>
<h2 id="problem-statement-54"><a class="header" href="#problem-statement-54">Problem Statement</a></h2>
<p>Write a Java program that simulates a task scheduler using a priority queue. The program should enqueue tasks, each with a description (string) and priority (integer), and dequeue them in order of highest priority, printing each task as it is processed. The priority queue should ensure that tasks with higher priority numbers are dequeued first, and tasks with equal priorities are processed in FIFO order. Test the implementation with various sequences of enqueue and dequeue operations, including edge cases like empty queues and tasks with equal priorities. You can visualize this as a manager prioritizing urgent tasks in a to-do list, ensuring the most critical tasks are handled first.</p>
<p><strong>Input</strong>: A sequence of operations, where each operation is either:</p>
<ul>
<li>Enqueue: Add a task with a description (string) and priority (integer) to the priority queue (e.g., "Write report", 3).</li>
<li>Dequeue: Remove and process the task with the highest priority.
<strong>Output</strong>: For each operation, print the action performed (enqueue or dequeue) and, for dequeue, the processed task’s description or a message if the queue is empty.
<strong>Constraints</strong>:</li>
<li>Queue size is between 0 and 10^5.</li>
<li>Task descriptions are non-empty strings containing printable ASCII characters, or null (handled gracefully).</li>
<li>Priorities are integers in the range [-10^9, 10^9].</li>
<li>The queue may be empty when dequeue is called.
<strong>Example</strong>:</li>
<li>Input: Operations = [enqueue("Task1", 3), enqueue("Task2", 1), enqueue("Task3", 3), dequeue, dequeue]</li>
<li>Output:
<pre><code>Enqueued Task1 (priority 3)
Enqueued Task2 (priority 1)
Enqueued Task3 (priority 3)
Processed task: Task1
Processed task: Task3
</code></pre>
</li>
<li>Explanation: Task1 and Task3 (priority 3) are processed before Task2 (priority 1) due to higher priority.</li>
<li>Input: Operations = [dequeue on empty queue]</li>
<li>Output: <code>Queue empty, cannot dequeue</code></li>
</ul>
<h2 id="pseudocode-54"><a class="header" href="#pseudocode-54">Pseudocode</a></h2>
<pre><code>CLASS Task
    SET description to string
    SET priority to integer
ENDCLASS

CLASS PriorityQueue
    SET array to new Task array of size 1000
    SET size to 0
    
    FUNCTION enqueue(description, priority)
        IF size equals array length THEN
            RETURN false (queue full)
        ENDIF
        SET newTask to new Task(description, priority)
        SET array[size] to newTask
        CALL siftUp(size)
        INCREMENT size
        RETURN true
    ENDFUNCTION
    
    FUNCTION siftUp(index)
        WHILE index &gt; 0
            SET parent to (index - 1) / 2
            IF array[index].priority &lt;= array[parent].priority THEN
                BREAK
            ENDIF
            SWAP array[index] and array[parent]
            SET index to parent
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION dequeue()
        IF size equals 0 THEN
            RETURN null (queue empty)
        ENDIF
        SET result to array[0]
        SET array[0] to array[size - 1]
        DECREMENT size
        IF size &gt; 0 THEN
            CALL siftDown(0)
        ENDIF
        RETURN result
    ENDFUNCTION
    
    FUNCTION siftDown(index)
        SET maxIndex to index
        WHILE true
            SET left to 2 * index + 1
            SET right to 2 * index + 2
            IF left &lt; size AND array[left].priority &gt; array[maxIndex].priority THEN
                SET maxIndex to left
            ENDIF
            IF right &lt; size AND array[right].priority &gt; array[maxIndex].priority THEN
                SET maxIndex to right
            ENDIF
            IF maxIndex equals index THEN
                BREAK
            ENDIF
            SWAP array[index] and array[maxIndex]
            SET index to maxIndex
        ENDWHILE
    ENDFUNCTION
    
    FUNCTION isEmpty()
        RETURN size equals 0
    ENDFUNCTION
ENDCLASS

FUNCTION simulateTaskScheduler(operations)
    CREATE queue as new PriorityQueue
    FOR each operation in operations
        IF operation.type equals "enqueue" THEN
            CALL queue.enqueue(operation.description, operation.priority)
            PRINT enqueued task and priority
        ELSE IF operation.type equals "dequeue" THEN
            SET task to queue.dequeue()
            IF task is null THEN
                PRINT queue empty message
            ELSE
                PRINT processed task description
            ENDIF
        ENDIF
    ENFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL simulateTaskScheduler(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-54"><a class="header" href="#algorithm-steps-54">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Task</code> class to store task description (string) and priority (integer).</li>
<li>Define a <code>PriorityQueue</code> class using a max-heap with:
a. An array to store tasks, with <code>size</code> to track elements.
b. <code>enqueue</code>: Add task to end, sift up to maintain heap property.
c. <code>dequeue</code>: Remove root (highest priority), move last task to root, sift down.
d. <code>siftUp</code>: Move task up if its priority is higher than parent’s.
e. <code>siftDown</code>: Move task down to maintain max-heap property.
f. <code>isEmpty</code>: Check if queue is empty.</li>
<li>In <code>simulateTaskScheduler</code>:
a. Create a <code>PriorityQueue</code>.
b. For each operation:
<ul>
<li>If "enqueue", add task with priority, print action.</li>
<li>If "dequeue", remove highest-priority task, print task or "Queue empty".</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences of enqueue and dequeue operations, including empty queues, single tasks, and equal priorities.</li>
</ol>
<h2 id="java-implementation-77"><a class="header" href="#java-implementation-77">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class TaskScheduler {
    // Task class to store description and priority
    static class Task {
        String description;
        int priority;

        Task(String description, int priority) {
            this.description = description;
            this.priority = priority;
        }
    }

    // Custom priority queue implementation (max-heap)
    static class PriorityQueue {
        private Task[] array;
        private int size;
        private static final int DEFAULT_SIZE = 1000;

        public PriorityQueue() {
            array = new Task[DEFAULT_SIZE];
            size = 0;
        }

        public boolean enqueue(String description, int priority) {
            if (size == array.length) {
                return false; // Queue full
            }
            Task newTask = new Task(description, priority);
            array[size] = newTask;
            siftUp(size);
            size++;
            return true;
        }

        private void siftUp(int index) {
            while (index &gt; 0) {
                int parent = (index - 1) / 2;
                if (array[index].priority &lt;= array[parent].priority) {
                    break;
                }
                // Swap
                Task temp = array[index];
                array[index] = array[parent];
                array[parent] = temp;
                index = parent;
            }
        }

        public Task dequeue() {
            if (size == 0) {
                return null; // Queue empty
            }
            Task result = array[0];
            array[0] = array[size - 1];
            size--;
            if (size &gt; 0) {
                siftDown(0);
            }
            return result;
        }

        private void siftDown(int index) {
            int maxIndex = index;
            while (true) {
                int left = 2 * index + 1;
                int right = 2 * index + 2;
                if (left &lt; size &amp;&amp; array[left].priority &gt; array[maxIndex].priority) {
                    maxIndex = left;
                }
                if (right &lt; size &amp;&amp; array[right].priority &gt; array[maxIndex].priority) {
                    maxIndex = right;
                }
                if (maxIndex == index) {
                    break;
                }
                // Swap
                Task temp = array[index];
                array[index] = array[maxIndex];
                array[maxIndex] = temp;
                index = maxIndex;
            }
        }

        public boolean isEmpty() {
            return size == 0;
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String description;
        Integer priority;

        Operation(String type, String description, Integer priority) {
            this.type = type;
            this.description = description;
            this.priority = priority;
        }
    }

    // Simulates task scheduler
    public void simulateTaskScheduler(List&lt;Operation&gt; operations) {
        PriorityQueue queue = new PriorityQueue();
        for (Operation op : operations) {
            if (op.type.equals("enqueue")) {
                boolean success = queue.enqueue(op.description, op.priority);
                if (success) {
                    System.out.println("Enqueued " + (op.description != null ? op.description : "null") + 
                                      " (priority " + op.priority + ")");
                } else {
                    System.out.println("Enqueue " + (op.description != null ? op.description : "null") + 
                                      " failed: Queue full");
                }
            } else if (op.type.equals("dequeue")) {
                Task task = queue.dequeue();
                if (task == null) {
                    System.out.println("Queue empty, cannot dequeue");
                } else {
                    System.out.println("Processed task: " + task.description);
                }
            }
        }
    }

    // Main method to test task scheduler
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal sequence
        List&lt;Operation&gt; case1 = Arrays.asList(
            new Operation("enqueue", "Write report", 3),
            new Operation("enqueue", "Send email", 1),
            new Operation("enqueue", "Attend meeting", 3),
            new Operation("dequeue", null, null),
            new Operation("dequeue", null, null)
        );
        testCases.add(case1);
        
        // Test case 2: Empty queue
        List&lt;Operation&gt; case2 = Arrays.asList(
            new Operation("dequeue", null, null)
        );
        testCases.add(case2);
        
        // Test case 3: Single task
        List&lt;Operation&gt; case3 = Arrays.asList(
            new Operation("enqueue", "Debug code", 5),
            new Operation("dequeue", null, null)
        );
        testCases.add(case3);
        
        // Test case 4: Equal priorities
        List&lt;Operation&gt; case4 = Arrays.asList(
            new Operation("enqueue", "Task A", 2),
            new Operation("enqueue", "Task B", 2),
            new Operation("enqueue", "Task C", 2),
            new Operation("dequeue", null, null),
            new Operation("dequeue", null, null)
        );
        testCases.add(case4);
        
        // Test case 5: Null task description
        List&lt;Operation&gt; case5 = Arrays.asList(
            new Operation("enqueue", null, 4),
            new Operation("dequeue", null, null)
        );
        testCases.add(case5);

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            scheduler.simulateTaskScheduler(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-54"><a class="header" href="#output-54">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Enqueued Write report (priority 3)
Enqueued Send email (priority 1)
Enqueued Attend meeting (priority 3)
Processed task: Write report
Processed task: Attend meeting

Test case 2:
Queue empty, cannot dequeue

Test case 3:
Enqueued Debug code (priority 5)
Processed task: Debug code

Test case 4:
Enqueued Task A (priority 2)
Enqueued Task B (priority 2)
Enqueued Task C (priority 2)
Processed task: Task A
Processed task: Task B

Test case 5:
Enqueued null (priority 4)
Processed task: null
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Enqueues tasks with priorities 3, 1, 3; dequeues highest-priority tasks (Write report, Attend meeting) before Send email.</li>
<li>Test case 2: Dequeue on empty queue returns error.</li>
<li>Test case 3: Enqueues and dequeues a single task.</li>
<li>Test case 4: Enqueues three tasks with equal priority (2), processes in FIFO order (Task A, Task B).</li>
<li>Test case 5: Enqueues and dequeues a task with null description.</li>
</ul>
<h2 id="how-it-works-78"><a class="header" href="#how-it-works-78">How It Works</a></h2>
<ul>
<li><strong>Task</strong>: Stores a task’s description and priority.</li>
<li><strong>PriorityQueue</strong>:
<ul>
<li>Uses a max-heap array to store tasks, ensuring highest-priority task is at root.</li>
<li><code>enqueue</code>: Adds task to end, sifts up to maintain heap property.</li>
<li><code>dequeue</code>: Removes root, moves last task to root, sifts down.</li>
<li>Equal priorities maintain FIFO order due to heap insertion order.</li>
</ul>
</li>
<li><strong>simulateTaskScheduler</strong>:
<ul>
<li>Enqueues tasks, printing action and priority.</li>
<li>Dequeues highest-priority task, printing description or "Queue empty".</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Enqueue "Write report" (3): array=[(Write report,3)], size=1.</li>
<li>Enqueue "Send email" (1): array=[(Write report,3),(Send email,1)], size=2.</li>
<li>Enqueue "Attend meeting" (3): array=[(Attend meeting,3),(Send email,1),(Write report,3)], size=3 (after sift-up).</li>
<li>Dequeue: Returns "Attend meeting", array=[(Write report,3),(Send email,1)], size=2 (after sift-down).</li>
<li>Dequeue: Returns "Write report", array=[(Send email,1)], size=1.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal sequences, empty queue, single task, equal priorities, and null description.</li>
</ul>
<h2 id="complexity-analysis-table-77"><a class="header" href="#complexity-analysis-table-77">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Enqueue</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Dequeue</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>Full Algorithm</td><td>O(n log n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of operations.</li>
<li>Time complexity: O(log n) for enqueue/dequeue due to heap operations; O(n log n) for n operations.</li>
<li>Space complexity: O(n) for storing up to n tasks.</li>
<li>Worst case: O(n log n) time for n enqueue/dequeue operations, O(n) space.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a max-heap for a priority queue to ensure highest-priority tasks are processed first. Test with equal priorities to verify FIFO behavior for same-priority tasks.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null descriptions and empty queue cases to avoid errors. Ensure the heap maintains its property after each enqueue and dequeue operation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linked-lists-problem-solving-with-dsa"><a class="header" href="#linked-lists-problem-solving-with-dsa">Linked Lists Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-5"><a class="header" href="#-what-you-will-learn-5">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="cycle-detection"><a class="header" href="#cycle-detection">Cycle Detection</a></h1>
<h2 id="problem-statement-55"><a class="header" href="#problem-statement-55">Problem Statement</a></h2>
<p>Write a Java program that extends a singly linked list implementation to detect if the list contains a cycle using Floyd’s Tortoise and Hare algorithm. The linked list consists of nodes, each containing an integer value and a reference to the next node. A cycle exists if a node’s next pointer points to an earlier node in the list. The program should return true if a cycle is detected and false otherwise, and test the implementation with both cyclic and acyclic lists of varying sizes, including empty lists, single-node lists, and multi-node lists with or without cycles. You can visualize this as checking if a chain of numbered cards loops back to an earlier card, using two pointers moving at different speeds to detect the loop.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A singly linked list of integers (e.g., 1→2→3→4→2, where 4 points back to 2, forming a cycle).
<strong>Output</strong>: A boolean indicating whether the list contains a cycle (true for cyclic, false for acyclic), along with a string representation of the list for clarity.
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty or contain a cycle at any position.
<strong>Example</strong>:</li>
<li>Input: 1→2→3→4→2 (cycle: 4→2)</li>
<li>Output: true</li>
<li>Explanation: A cycle exists as 4 points back to 2.</li>
<li>Input: 1→2→3→null</li>
<li>Output: false</li>
<li>Explanation: No cycle, as the list terminates at null.</li>
<li>Input: []</li>
<li>Output: false</li>
<li>Explanation: An empty list has no cycle.</li>
</ul>
<h2 id="pseudocode-55"><a class="header" href="#pseudocode-55">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION hasCycle(head)
    IF head is null OR head.next is null THEN
        RETURN false
    ENDIF
    SET slow to head
    SET fast to head
    WHILE fast is not null AND fast.next is not null
        SET slow to slow.next
        SET fast to fast.next.next
        IF slow equals fast THEN
            RETURN true
        ENDIF
    ENDWHILE
    RETURN false
ENDFUNCTION

FUNCTION toString(head, limit)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    SET count to 0
    CREATE visited as new set
    WHILE current is not null AND count &lt; limit
        IF visited contains current THEN
            APPEND "-&gt;" + current.value + " (cycle)" to result
            BREAK
        ENDIF
        ADD current to visited
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
        INCREMENT count
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of linked lists (some cyclic, some acyclic)
    FOR each testCase in testCases
        PRINT test case details
        CALL hasCycle(testCase.head)
        PRINT whether cycle exists
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-55"><a class="header" href="#algorithm-steps-55">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>hasCycle</code> (Floyd’s Tortoise and Hare):
a. If head or head.next is null, return false (no cycle possible).
b. Initialize <code>slow</code> and <code>fast</code> pointers to head.
c. While <code>fast</code> and <code>fast.next</code> are not null:
<ul>
<li>Move <code>slow</code> one step, <code>fast</code> two steps.</li>
<li>If <code>slow</code> equals <code>fast</code>, a cycle exists (return true).
d. If <code>fast</code> reaches null, no cycle exists (return false).</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse the list with a limit to avoid infinite loops in cyclic lists.
c. Use a set to detect cycles and indicate them in the output.
d. Return space-separated values with cycle annotation if present.</li>
<li>In <code>main</code>, test with empty, single-node, multi-node acyclic, and cyclic lists.</li>
</ol>
<h2 id="java-implementation-78"><a class="header" href="#java-implementation-78">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class CycleDetection {
    // Node class for the linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Detects if the linked list has a cycle using Floyd’s algorithm
    public boolean hasCycle(Node head) {
        if (head == null || head.next == null) {
            return false;
        }
        Node slow = head;
        Node fast = head;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }

    // Converts linked list to string for output, handling cycles
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        int count = 0;
        int limit = 100; // Prevent infinite loop
        Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
        while (current != null &amp;&amp; count &lt; limit) {
            if (visited.contains(current)) {
                result.append("-&gt;").append(current.value).append(" (cycle)");
                break;
            }
            visited.add(current);
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
            count++;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;
        boolean hasCycle;

        // Creates acyclic list from values
        TestCase(int[] values) {
            this.hasCycle = false;
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
        }

        // Creates cyclic list with cycle at specified position
        TestCase(int[] values, int cyclePos) {
            this.hasCycle = true;
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            Node cycleNode = null;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
                if (i == cyclePos) {
                    cycleNode = current;
                }
            }
            if (cyclePos &gt;= 0 &amp;&amp; cyclePos &lt; values.length) {
                current.next = cycleNode; // Create cycle
            }
        }
    }

    // Main method to test cycle detection
    public static void main(String[] args) {
        CycleDetection detector = new CycleDetection();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4}, 2), // Cyclic: 1→2→3→4→3
            new TestCase(new int[]{1, 2, 3}),       // Acyclic: 1→2→3
            new TestCase(new int[]{}),              // Empty
            new TestCase(new int[]{5}),             // Single node
            new TestCase(new int[]{1, 2, 3, 4, 5}, 0) // Cyclic: 1→2→3→4→5→1
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + detector.toString(test.head));
            boolean result = detector.hasCycle(test.head);
            System.out.println("Has cycle: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-55"><a class="header" href="#output-55">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4-&gt;3 (cycle)
Has cycle: true

Test case 2:
Input list: 1 2 3
Has cycle: false

Test case 3:
Input list: []
Has cycle: false

Test case 4:
Input list: 5
Has cycle: false

Test case 5:
Input list: 1 2 3 4 5-&gt;1 (cycle)
Has cycle: true
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: List 1→2→3→4 with 4→3 forms a cycle, returns true.</li>
<li>Test case 2: Acyclic list 1→2→3, returns false.</li>
<li>Test case 3: Empty list, returns false.</li>
<li>Test case 4: Single node 5, returns false.</li>
<li>Test case 5: List 1→2→3→4→5 with 5→1 forms a cycle, returns true.</li>
</ul>
<h2 id="how-it-works-79"><a class="header" href="#how-it-works-79">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a next pointer.</li>
<li><strong>hasCycle</strong> (Floyd’s Tortoise and Hare):
<ul>
<li>Returns false if list is empty or has one node.</li>
<li>Uses <code>slow</code> (moves one step) and <code>fast</code> (moves two steps) pointers.</li>
<li>If <code>slow</code> meets <code>fast</code>, a cycle exists.</li>
<li>If <code>fast</code> reaches null, no cycle exists.</li>
</ul>
</li>
<li><strong>toString</strong>:
<ul>
<li>Handles cycles by tracking visited nodes and limiting traversal.</li>
<li>Outputs values with spaces, appending cycle annotation if detected.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→4→3 (cycle at 3).</li>
<li>slow=1, fast=1.</li>
<li>Step 1: slow=2, fast=3.</li>
<li>Step 2: slow=3, fast=4.</li>
<li>Step 3: slow=4, fast=3.</li>
<li>Step 4: slow=3, fast=3 (meet, cycle detected).</li>
<li>Return: true.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests cyclic (cycle at different positions), acyclic, empty, and single-node lists.</li>
</ul>
<h2 id="complexity-analysis-table-78"><a class="header" href="#complexity-analysis-table-78">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Has Cycle</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for hasCycle (Floyd’s algorithm traverses list); O(n) for toString (traverse with cycle detection).</li>
<li>Space complexity: O(1) for hasCycle (two pointers); O(n) for toString (visited set and StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for large lists in output.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use Floyd’s Tortoise and Hare algorithm for efficient cycle detection with O(1) space. Test with cycles at different positions to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure pointers are checked for null to avoid null pointer exceptions. Be cautious when printing cyclic lists to avoid infinite loops.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="merge-two-sorted-lists"><a class="header" href="#merge-two-sorted-lists">Merge Two Sorted Lists</a></h1>
<h2 id="problem-statement-56"><a class="header" href="#problem-statement-56">Problem Statement</a></h2>
<p>Write a Java program that merges two sorted singly linked lists into a single sorted linked list. Each linked list consists of nodes containing integer values in non-decreasing order. The program should merge the lists by comparing node values and constructing a new sorted list, preserving the sorted order. Test the implementation with different inputs, including empty lists, single-node lists, lists of varying lengths, and lists with duplicate values. You can visualize this as combining two sorted stacks of numbered cards into one sorted stack, picking the smaller card from the top of either stack each time.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Two sorted singly linked lists of integers (e.g., 1→3→5 and 2→4→6).
<strong>Output</strong>: A single sorted linked list as a string (e.g., "1 2 3 4 5 6").
<strong>Constraints</strong>:</li>
<li>The list sizes are between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>Both lists are sorted in non-decreasing order.</li>
<li>Either or both lists may be empty.
<strong>Example</strong>:</li>
<li>Input: list1 = 1→3→5, list2 = 2→4→6</li>
<li>Output: "1 2 3 4 5 6"</li>
<li>Explanation: Merges into a sorted list 1→2→3→4→5→6.</li>
<li>Input: list1 = [], list2 = []</li>
<li>Output: "[]"</li>
<li>Explanation: Merging two empty lists results in an empty list.</li>
<li>Input: list1 = 1→1, list2 = 1→2</li>
<li>Output: "1 1 1 2"</li>
<li>Explanation: Merges lists with duplicates into a sorted list.</li>
</ul>
<h2 id="pseudocode-56"><a class="header" href="#pseudocode-56">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION mergeTwoLists(list1, list2)
    CREATE dummy as new Node(0)
    SET tail to dummy
    SET current1 to list1
    SET current2 to list2
    WHILE current1 is not null AND current2 is not null
        IF current1.value &lt;= current2.value THEN
            SET tail.next to current1
            SET current1 to current1.next
        ELSE
            SET tail.next to current2
            SET current2 to current2.next
        ENDIF
        SET tail to tail.next
    ENDWHILE
    IF current1 is not null THEN
        SET tail.next to current1
    ELSE IF current2 is not null THEN
        SET tail.next to current2
    ENDIF
    RETURN dummy.next
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of pairs of linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL mergeTwoLists(testCase.list1, testCase.list2)
        PRINT merged list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-56"><a class="header" href="#algorithm-steps-56">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>mergeTwoLists</code>:
a. Create a dummy node to simplify list construction.
b. Initialize <code>tail</code> to dummy, <code>current1</code> to list1, <code>current2</code> to list2.
c. While both lists have nodes:
<ul>
<li>Compare <code>current1.value</code> and <code>current2.value</code>.</li>
<li>Append smaller node to <code>tail.next</code>, advance corresponding pointer.</li>
<li>Move <code>tail</code> to appended node.
d. Append remaining nodes from list1 or list2, if any.
e. Return <code>dummy.next</code> as the merged list head.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse the list, append each value to a StringBuilder with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with non-empty lists, empty lists, single-node lists, and lists with duplicates.</li>
</ol>
<h2 id="java-implementation-79"><a class="header" href="#java-implementation-79">Java Implementation</a></h2>
<pre><code class="language-java">public class MergeTwoSortedLists {
    // Node class for the linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Merges two sorted linked lists
    public Node mergeTwoLists(Node list1, Node list2) {
        Node dummy = new Node(0);
        Node tail = dummy;
        Node current1 = list1;
        Node current2 = list2;

        while (current1 != null &amp;&amp; current2 != null) {
            if (current1.value &lt;= current2.value) {
                tail.next = current1;
                current1 = current1.next;
            } else {
                tail.next = current2;
                current2 = current2.next;
            }
            tail = tail.next;
        }

        if (current1 != null) {
            tail.next = current1;
        } else if (current2 != null) {
            tail.next = current2;
        }

        return dummy.next;
    }

    // Converts linked list to string for output
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node list1;
        Node list2;

        TestCase(int[] values1, int[] values2) {
            // Create list1
            if (values1.length == 0) {
                list1 = null;
            } else {
                list1 = new Node(values1[0]);
                Node current = list1;
                for (int i = 1; i &lt; values1.length; i++) {
                    current.next = new Node(values1[i]);
                    current = current.next;
                }
            }
            // Create list2
            if (values2.length == 0) {
                list2 = null;
            } else {
                list2 = new Node(values2[0]);
                Node current = list2;
                for (int i = 1; i &lt; values2.length; i++) {
                    current.next = new Node(values2[i]);
                    current = current.next;
                }
            }
        }
    }

    // Main method to test merging sorted lists
    public static void main(String[] args) {
        MergeTwoSortedLists merger = new MergeTwoSortedLists();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 3, 5}, new int[]{2, 4, 6}), // Both non-empty
            new TestCase(new int[]{}, new int[]{}),              // Both empty
            new TestCase(new int[]{1}, new int[]{}),            // One empty
            new TestCase(new int[]{1, 1}, new int[]{1, 2}),     // Duplicates
            new TestCase(new int[]{1, 2, 3}, new int[]{4})      // Different lengths
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("List 1: " + merger.toString(test.list1));
            System.out.println("List 2: " + merger.toString(test.list2));
            Node merged = merger.mergeTwoLists(test.list1, test.list2);
            System.out.println("Merged list: " + merger.toString(merged) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-56"><a class="header" href="#output-56">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
List 1: 1 3 5
List 2: 2 4 6
Merged list: 1 2 3 4 5 6

Test case 2:
List 1: []
List 2: []
Merged list: []

Test case 3:
List 1: 1
List 2: []
Merged list: 1

Test case 4:
List 1: 1 1
List 2: 1 2
Merged list: 1 1 1 2

Test case 5:
List 1: 1 2 3
List 2: 4
Merged list: 1 2 3 4
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Merges 1→3→5 and 2→4→6 into 1→2→3→4→5→6.</li>
<li>Test case 2: Both empty lists result in an empty list.</li>
<li>Test case 3: Merges 1 with empty list, resulting in 1.</li>
<li>Test case 4: Merges lists with duplicates 1→1 and 1→2 into 1→1→1→2.</li>
<li>Test case 5: Merges 1→2→3 and 4 into 1→2→3→4.</li>
</ul>
<h2 id="how-it-works-80"><a class="header" href="#how-it-works-80">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a next pointer.</li>
<li><strong>mergeTwoLists</strong>:
<ul>
<li>Uses a dummy node to simplify list construction.</li>
<li>Compares nodes from both lists, appending the smaller to the result.</li>
<li>Advances the corresponding list’s pointer and moves the tail.</li>
<li>Appends any remaining nodes from either list.</li>
</ul>
</li>
<li><strong>toString</strong>: Converts the list to a space-separated string, returning "[]" for empty lists.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>list1: 1→3→5, list2: 2→4→6.</li>
<li>dummy→null, tail=dummy, current1=1, current2=2.</li>
<li>Step 1: 1≤2, dummy→1, current1=3, tail=1.</li>
<li>Step 2: 3&gt;2, dummy→1→2, current2=4, tail=2.</li>
<li>Step 3: 3≤4, dummy→1→2→3, current1=5, tail=3.</li>
<li>Step 4: 5&gt;4, dummy→1→2→3→4, current2=6, tail=4.</li>
<li>Step 5: 5≤6, dummy→1→2→3→4→5, current1=null, tail=5.</li>
<li>Step 6: Append 6, dummy→1→2→3→4→5→6.</li>
<li>Return: 1→2→3→4→5→6.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests non-empty lists, empty lists, one empty list, duplicates, and different lengths.</li>
</ul>
<h2 id="complexity-analysis-table-79"><a class="header" href="#complexity-analysis-table-79">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Merge Two Lists</td><td>O(n + m)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n and m are the lengths of the two input lists.</li>
<li>Time complexity: O(n + m) for merging (single pass through both lists); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for merging (constant pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n + m) time, O(n + m) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a dummy node to simplify merging by avoiding special cases for the head. Compare values iteratively to maintain sorted order.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure pointers are updated correctly to avoid losing list segments. Handle empty list cases to prevent null pointer exceptions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="middle-element-finder"><a class="header" href="#middle-element-finder">Middle Element Finder</a></h1>
<h2 id="problem-statement-57"><a class="header" href="#problem-statement-57">Problem Statement</a></h2>
<p>Write a Java program that finds the middle element of a singly linked list in a single pass using the fast-and-slow pointer technique. The linked list consists of nodes, each containing an integer value and a reference to the next node. For lists with an odd number of nodes, return the middle node’s value; for even-length lists, return the value of the second middle node (e.g., in 1→2→3→4, return 3). The program should handle edge cases like empty lists and single-node lists. Test the implementation with linked lists of varying sizes, including empty lists, single-node lists, and lists with odd and even lengths. You can visualize this as finding the middle card in a chain of numbered cards, using two pointers where one moves twice as fast to reach the middle efficiently.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A singly linked list of integers (e.g., 1→2→3→4→5).
<strong>Output</strong>: The value of the middle node as an integer, or -1 if the list is empty (e.g., 3 for 1→2→3→4→5).
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: 1→2→3→4→5</li>
<li>Output: 3</li>
<li>Explanation: Middle node of 5 nodes is the 3rd node (value 3).</li>
<li>Input: 1→2→3→4</li>
<li>Output: 3</li>
<li>Explanation: Second middle node of 4 nodes is the 3rd node (value 3).</li>
<li>Input: []</li>
<li>Output: -1</li>
<li>Explanation: Empty list returns -1.</li>
</ul>
<h2 id="pseudocode-57"><a class="header" href="#pseudocode-57">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION findMiddle(head)
    IF head is null THEN
        RETURN -1
    ENDIF
    SET slow to head
    SET fast to head
    WHILE fast is not null AND fast.next is not null
        SET slow to slow.next
        SET fast to fast.next.next
    ENDWHILE
    RETURN slow.value
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL findMiddle(testCase.head)
        PRINT middle element
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-57"><a class="header" href="#algorithm-steps-57">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>findMiddle</code>:
a. If head is null, return -1 (empty list).
b. Initialize <code>slow</code> and <code>fast</code> pointers to head.
c. While <code>fast</code> and <code>fast.next</code> are not null:
<ul>
<li>Move <code>slow</code> one step, <code>fast</code> two steps.
d. When <code>fast</code> reaches the end, <code>slow</code> is at the middle node.
e. Return <code>slow.value</code>.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse the list, append each value to a StringBuilder with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with empty, single-node, odd-length, and even-length lists.</li>
</ol>
<h2 id="java-implementation-80"><a class="header" href="#java-implementation-80">Java Implementation</a></h2>
<pre><code class="language-java">public class MiddleElementFinder {
    // Node class for the linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Finds the middle element using fast-and-slow pointer technique
    public int findMiddle(Node head) {
        if (head == null) {
            return -1;
        }
        Node slow = head;
        Node fast = head;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow.value;
    }

    // Converts linked list to string for output
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;

        TestCase(int[] values) {
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
        }
    }

    // Main method to test middle element finder
    public static void main(String[] args) {
        MiddleElementFinder finder = new MiddleElementFinder();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4, 5}), // Odd length
            new TestCase(new int[]{1, 2, 3, 4}),     // Even length
            new TestCase(new int[]{}),               // Empty list
            new TestCase(new int[]{5}),              // Single node
            new TestCase(new int[]{1, 1, 1, 1, 1, 1}) // Even length with duplicates
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + finder.toString(test.head));
            int middle = finder.findMiddle(test.head);
            System.out.println("Middle element: " + middle + "\n");
        }
    }
}
</code></pre>
<h2 id="output-57"><a class="header" href="#output-57">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4 5
Middle element: 3

Test case 2:
Input list: 1 2 3 4
Middle element: 3

Test case 3:
Input list: []
Middle element: -1

Test case 4:
Input list: 5
Middle element: 5

Test case 5:
Input list: 1 1 1 1 1 1
Middle element: 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Odd-length list 1→2→3→4→5, middle is 3rd node (3).</li>
<li>Test case 2: Even-length list 1→2→3→4, second middle is 3rd node (3).</li>
<li>Test case 3: Empty list, returns -1.</li>
<li>Test case 4: Single node 5, returns 5.</li>
<li>Test case 5: Even-length list 1→1→1→1→1→1, second middle is 4th node (1).</li>
</ul>
<h2 id="how-it-works-81"><a class="header" href="#how-it-works-81">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a next pointer.</li>
<li><strong>findMiddle</strong>:
<ul>
<li>Returns -1 for empty lists.</li>
<li>Uses <code>slow</code> (moves one step) and <code>fast</code> (moves two steps) pointers.</li>
<li>When <code>fast</code> reaches the end, <code>slow</code> is at the middle (or second middle for even length).</li>
</ul>
</li>
<li><strong>toString</strong>: Converts the list to a space-separated string, returning "[]" for empty lists.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→4→5.</li>
<li>Initial: slow=1, fast=1.</li>
<li>Step 1: slow=2, fast=3.</li>
<li>Step 2: slow=3, fast=5.</li>
<li>Step 3: fast=null, slow=3.</li>
<li>Return: 3.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests odd-length, even-length, empty, single-node, and duplicate lists.</li>
</ul>
<h2 id="complexity-analysis-table-80"><a class="header" href="#complexity-analysis-table-80">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Find Middle</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for findMiddle (single pass, fast pointer covers list in n/2 steps); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for findMiddle (two pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the fast-and-slow pointer technique to find the middle element efficiently in one pass. For even-length lists, choose whether to return the first or second middle node based on problem requirements.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure null checks for <code>fast</code> and <code>fast.next</code> to avoid null pointer exceptions. Handle empty lists by returning a sentinel value like -1.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="playlist-manager"><a class="header" href="#playlist-manager">Playlist Manager</a></h1>
<h2 id="problem-statement-58"><a class="header" href="#problem-statement-58">Problem Statement</a></h2>
<p>Write a Java program that simulates a music playlist using a singly linked list. Each node in the list represents a song with a string name. The program should allow users to add songs (insert at the head or tail of the list), remove songs (delete by value, removing the first occurrence), and print the playlist. Test the implementation with various sequences of operations, including adding and removing songs, handling empty playlists, and dealing with duplicate song names. You can visualize this as managing a playlist where songs are added to the beginning or end, removed by name, and displayed as a sequence of song titles.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sequence of operations, where each operation is:
<ul>
<li>Add at head: Insert a song name at the start of the playlist.</li>
<li>Add at tail: Insert a song name at the end of the playlist.</li>
<li>Remove: Delete the first occurrence of a song by name.</li>
<li>Print: Display the current playlist.
<strong>Output</strong>: For each operation, print the action performed (e.g., "Added song at head", "Removed song", or the playlist as a string). If a song to remove is not found, print an appropriate message.
<strong>Constraints</strong>:</li>
</ul>
</li>
<li>The playlist size is between 0 and 10^5.</li>
<li>Song names are non-empty strings of length up to 100 characters.</li>
<li>The playlist may be empty or contain duplicate song names.
<strong>Example</strong>:</li>
<li>Input: Operations = [addHead("Song1"), addTail("Song2"), addHead("Song3"), print, remove("Song2"), print]</li>
<li>Output:
<pre><code>Added Song1 at head
Added Song2 at tail
Added Song3 at head
Playlist: Song3 Song1 Song2
Removed Song2
Playlist: Song3 Song1
</code></pre>
</li>
<li>Input: Operations = [remove("Song1"), print]</li>
<li>Output:
<pre><code>Song Song1 not found
Playlist: []
</code></pre>
</li>
</ul>
<h2 id="pseudocode-58"><a class="header" href="#pseudocode-58">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET song to string
    SET next to Node (null by default)
ENDCLASS

CLASS PlaylistManager
    SET head to null

    FUNCTION addHead(song)
        CREATE newNode as new Node(song)
        SET newNode.next to head
        SET head to newNode
    ENDFUNCTION

    FUNCTION addTail(song)
        CREATE newNode as new Node(song)
        IF head is null THEN
            SET head to newNode
            RETURN
        ENDIF
        SET current to head
        WHILE current.next is not null
            SET current to current.next
        ENDWHILE
        SET current.next to newNode
    ENDFUNCTION

    FUNCTION removeSong(song)
        IF head is null THEN
            RETURN false
        ENDIF
        IF head.song equals song THEN
            SET head to head.next
            RETURN true
        ENDIF
        SET current to head
        WHILE current.next is not null
            IF current.next.song equals song THEN
                SET current.next to current.next.next
                RETURN true
            ENDIF
            SET current to current.next
        ENDWHILE
        RETURN false
    ENDFUNCTION

    FUNCTION toString()
        IF head is null THEN
            RETURN "[]"
        ENDIF
        CREATE result as new StringBuilder
        SET current to head
        WHILE current is not null
            APPEND current.song to result
            IF current.next is not null THEN
                APPEND " " to result
            ENDIF
            SET current to current.next
        ENDWHILE
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION testPlaylist(operations)
    CREATE playlist as new PlaylistManager
    FOR each operation in operations
        IF operation.type equals "addHead" THEN
            CALL playlist.addHead(operation.song)
            PRINT added song at head
        ELSE IF operation.type equals "addTail" THEN
            CALL playlist.addTail(operation.song)
            PRINT added song at tail
        ELSE IF operation.type equals "remove" THEN
            IF playlist.removeSong(operation.song) THEN
                PRINT removed song
            ELSE
                PRINT song not found
            ENDIF
        ELSE IF operation.type equals "print" THEN
            PRINT playlist using toString
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testPlaylist(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-58"><a class="header" href="#algorithm-steps-58">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. A string <code>song</code> for the song name.
b. A <code>next</code> pointer to the next node.</li>
<li>Define a <code>PlaylistManager</code> class with:
a. <code>addHead</code>: Insert a new node with the song at the start.
b. <code>addTail</code>: Traverse to the end and append a new node.
c. <code>removeSong</code>: Remove the first node with the given song name, return true if found.
d. <code>toString</code>: Convert the playlist to a space-separated string.</li>
<li>In <code>testPlaylist</code>:
a. Create a <code>PlaylistManager</code>.
b. For each operation:
<ul>
<li>Add at head: Call <code>addHead</code>, print action.</li>
<li>Add at tail: Call <code>addTail</code>, print action.</li>
<li>Remove: Call <code>removeSong</code>, print success or failure.</li>
<li>Print: Call <code>toString</code>, print playlist.</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences including adds, removes, empty playlists, and duplicates.</li>
</ol>
<h2 id="java-implementation-81"><a class="header" href="#java-implementation-81">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class PlaylistManager {
    // Node class for the linked list
    static class Node {
        String song;
        Node next;

        Node(String song) {
            this.song = song;
            this.next = null;
        }
    }

    // PlaylistManager class to manage songs
    static class Playlist {
        private Node head;

        public void addHead(String song) {
            Node newNode = new Node(song);
            newNode.next = head;
            head = newNode;
        }

        public void addTail(String song) {
            Node newNode = new Node(song);
            if (head == null) {
                head = newNode;
                return;
            }
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }

        public boolean removeSong(String song) {
            if (head == null) {
                return false;
            }
            if (head.song.equals(song)) {
                head = head.next;
                return true;
            }
            Node current = head;
            while (current.next != null) {
                if (current.next.song.equals(song)) {
                    current.next = current.next.next;
                    return true;
                }
                current = current.next;
            }
            return false;
        }

        public String toString() {
            if (head == null) {
                return "[]";
            }
            StringBuilder result = new StringBuilder();
            Node current = head;
            while (current != null) {
                result.append(current.song);
                if (current.next != null) {
                    result.append(" ");
                }
                current = current.next;
            }
            return result.toString();
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String song;

        Operation(String type, String song) {
            this.type = type;
            this.song = song;
        }
    }

    // Tests playlist operations
    public void testPlaylist(List&lt;Operation&gt; operations) {
        Playlist playlist = new Playlist();
        for (Operation op : operations) {
            if (op.type.equals("addHead")) {
                playlist.addHead(op.song);
                System.out.println("Added " + op.song + " at head");
            } else if (op.type.equals("addTail")) {
                playlist.addTail(op.song);
                System.out.println("Added " + op.song + " at tail");
            } else if (op.type.equals("remove")) {
                if (playlist.removeSong(op.song)) {
                    System.out.println("Removed " + op.song);
                } else {
                    System.out.println("Song " + op.song + " not found");
                }
            } else if (op.type.equals("print")) {
                System.out.println("Playlist: " + playlist.toString());
            }
        }
    }

    // Main method to test playlist manager
    public static void main(String[] args) {
        PlaylistManager manager = new PlaylistManager();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal operations
        testCases.add(Arrays.asList(
            new Operation("addHead", "Song1"),
            new Operation("addTail", "Song2"),
            new Operation("addHead", "Song3"),
            new Operation("print", null),
            new Operation("remove", "Song2"),
            new Operation("print", null)
        ));
        
        // Test case 2: Empty playlist
        testCases.add(Arrays.asList(
            new Operation("remove", "Song1"),
            new Operation("print", null)
        ));
        
        // Test case 3: Single song
        testCases.add(Arrays.asList(
            new Operation("addHead", "Song1"),
            new Operation("print", null),
            new Operation("remove", "Song1"),
            new Operation("print", null)
        ));
        
        // Test case 4: Duplicates
        testCases.add(Arrays.asList(
            new Operation("addHead", "Song1"),
            new Operation("addTail", "Song1"),
            new Operation("addHead", "Song2"),
            new Operation("print", null),
            new Operation("remove", "Song1"),
            new Operation("print", null)
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            manager.testPlaylist(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-58"><a class="header" href="#output-58">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Added Song1 at head
Added Song2 at tail
Added Song3 at head
Playlist: Song3 Song1 Song2
Removed Song2
Playlist: Song3 Song1

Test case 2:
Song Song1 not found
Playlist: []

Test case 3:
Added Song1 at head
Playlist: Song1
Removed Song1
Playlist: []

Test case 4:
Added Song1 at head
Added Song1 at tail
Added Song2 at head
Playlist: Song2 Song1 Song1
Removed Song1
Playlist: Song2 Song1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Adds Song1 (head), Song2 (tail), Song3 (head), prints "Song3 Song1 Song2", removes Song2, prints "Song3 Song1".</li>
<li>Test case 2: Attempts to remove Song1 from empty playlist, prints not found, prints "[]".</li>
<li>Test case 3: Adds Song1, prints "Song1", removes Song1, prints "[]".</li>
<li>Test case 4: Adds Song1 (head), Song1 (tail), Song2 (head), prints "Song2 Song1 Song1", removes first Song1, prints "Song2 Song1".</li>
</ul>
<h2 id="how-it-works-82"><a class="header" href="#how-it-works-82">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores a string song name and a next pointer.</li>
<li><strong>Playlist</strong>:
<ul>
<li><code>addHead</code>: Inserts new node at the start in O(1).</li>
<li><code>addTail</code>: Traverses to end, appends node in O(n).</li>
<li><code>removeSong</code>: Removes first occurrence of song, returns true if found, O(n).</li>
<li><code>toString</code>: Returns space-separated song names, "[]" for empty.</li>
</ul>
</li>
<li><strong>testPlaylist</strong>: Executes operations, printing actions and results.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>addHead("Song1"): head=Song1→null.</li>
<li>addTail("Song2"): head=Song1→Song2.</li>
<li>addHead("Song3"): head=Song3→Song1→Song2.</li>
<li>print: "Song3 Song1 Song2".</li>
<li>remove("Song2"): head=Song3→Song1.</li>
<li>print: "Song3 Song1".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal operations, empty playlist, single song, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-81"><a class="header" href="#complexity-analysis-table-81">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Add Head</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Add Tail</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Remove Song</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the playlist.</li>
<li>Time complexity: O(1) for addHead; O(n) for addTail and removeSong (traverse list); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for operations (constant pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for output with large playlists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a linked list for flexible playlist management, with head insertion for quick additions and tail insertion for appending. Test with duplicates to ensure correct removal of the first occurrence.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle empty playlist cases to avoid null pointer exceptions. Ensure removal checks all nodes to find the target song.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="reverse-a-linked-list"><a class="header" href="#reverse-a-linked-list">Reverse a Linked List</a></h1>
<h2 id="problem-statement-59"><a class="header" href="#problem-statement-59">Problem Statement</a></h2>
<p>Write a Java program that reverses a singly linked list. The linked list consists of nodes, each containing an integer value and a reference to the next node. The program should reverse the order of the nodes (e.g., 1→2→3 becomes 3→2→1) using an iterative approach and print the reversed list. Test the implementation with linked lists of varying sizes, including empty lists, single-node lists, and multi-node lists. You can visualize this as rearranging a chain of numbered cards, flipping their order so the last card becomes the first.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A singly linked list of integers (e.g., 1→2→3→4).
<strong>Output</strong>: The reversed linked list as a string (e.g., "4 3 2 1").
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: 1→2→3→4</li>
<li>Output: "4 3 2 1"</li>
<li>Explanation: The list 1→2→3→4 is reversed to 4→3→2→1.</li>
<li>Input: []</li>
<li>Output: "[]"</li>
<li>Explanation: An empty list remains empty.</li>
<li>Input: 5</li>
<li>Output: "5"</li>
<li>Explanation: A single-node list is unchanged.</li>
</ul>
<h2 id="pseudocode-59"><a class="header" href="#pseudocode-59">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION reverseList(head)
    SET prev to null
    SET current to head
    WHILE current is not null
        SET nextNode to current.next
        SET current.next to prev
        SET prev to current
        SET current to nextNode
    ENDWHILE
    RETURN prev
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL reverseList(testCase.head)
        PRINT reversed list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-59"><a class="header" href="#algorithm-steps-59">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>reverseList</code>:
a. Initialize <code>prev</code> as null, <code>current</code> as head.
b. While <code>current</code> is not null:
<ul>
<li>Save <code>current.next</code> as <code>nextNode</code>.</li>
<li>Set <code>current.next</code> to <code>prev</code> (reverse the link).</li>
<li>Move <code>prev</code> to <code>current</code>, <code>current</code> to <code>nextNode</code>.
c. Return <code>prev</code> as the new head.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse the list, append each value to a StringBuilder, add spaces between values.
c. Return the string representation.</li>
<li>In <code>main</code>, test with empty, single-node, and multi-node lists.</li>
</ol>
<h2 id="java-implementation-82"><a class="header" href="#java-implementation-82">Java Implementation</a></h2>
<pre><code class="language-java">public class ReverseLinkedList {
    // Node class for the linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Reverses the linked list
    public Node reverseList(Node head) {
        Node prev = null;
        Node current = head;

        while (current != null) {
            Node nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }

        return prev;
    }

    // Converts linked list to string for output
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;

        TestCase(int[] values) {
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
        }
    }

    // Main method to test linked list reversal
    public static void main(String[] args) {
        ReverseLinkedList reverser = new ReverseLinkedList();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4}), // Multi-node list
            new TestCase(new int[]{}),           // Empty list
            new TestCase(new int[]{5}),          // Single node
            new TestCase(new int[]{1, 1, 1}),    // List with duplicates
            new TestCase(new int[]{10, 20})      // Two nodes
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + reverser.toString(test.head));
            Node reversed = reverser.reverseList(test.head);
            System.out.println("Reversed list: " + reverser.toString(reversed) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-59"><a class="header" href="#output-59">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4
Reversed list: 4 3 2 1

Test case 2:
Input list: []
Reversed list: []

Test case 3:
Input list: 5
Reversed list: 5

Test case 4:
Input list: 1 1 1
Reversed list: 1 1 1

Test case 5:
Input list: 10 20
Reversed list: 20 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Reverses 1→2→3→4 to 4→3→2→1.</li>
<li>Test case 2: Empty list remains empty.</li>
<li>Test case 3: Single node 5 is unchanged.</li>
<li>Test case 4: List with duplicates 1→1→1 reverses to 1→1→1.</li>
<li>Test case 5: Two nodes 10→20 reverse to 20→10.</li>
</ul>
<h2 id="how-it-works-83"><a class="header" href="#how-it-works-83">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a reference to the next node.</li>
<li><strong>reverseList</strong>:
<ul>
<li>Iteratively reverses links by adjusting <code>next</code> pointers.</li>
<li>Uses <code>prev</code>, <code>current</code>, and <code>nextNode</code> to track nodes.</li>
<li>Each step reverses one link, moving pointers forward.</li>
</ul>
</li>
<li><strong>toString</strong>: Converts the list to a space-separated string, returning "[]" for empty lists.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→4.</li>
<li>Initial: prev=null, current=1, nextNode=2.</li>
<li>Step 1: 1→null, prev=1, current=2, nextNode=3.</li>
<li>Step 2: 2→1→null, prev=2, current=3, nextNode=4.</li>
<li>Step 3: 3→2→1→null, prev=3, current=4, nextNode=null.</li>
<li>Step 4: 4→3→2→1→null, prev=4, current=null.</li>
<li>Return: 4→3→2→1.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests multi-node, empty, single-node, duplicate, and two-node lists.</li>
</ul>
<h2 id="complexity-analysis-table-82"><a class="header" href="#complexity-analysis-table-82">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Reverse List</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for reversing (single pass) and toString (traverse list).</li>
<li>Space complexity: O(1) for reversal (constant pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for large lists in output.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use an iterative approach to reverse a linked list to save space, adjusting pointers in a single pass. Test with empty and single-node lists to ensure edge cases are handled.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Be cautious when updating <code>next</code> pointers to avoid losing references to the rest of the list. Always save the next node before reversing the link.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="bidirectional-traversal"><a class="header" href="#bidirectional-traversal">Bidirectional Traversal</a></h1>
<h2 id="problem-statement-60"><a class="header" href="#problem-statement-60">Problem Statement</a></h2>
<p>Write a Java program that extends a doubly linked list implementation to include methods for printing the list in both forward (head to tail) and backward (tail to head) directions. The doubly linked list consists of nodes, each containing an integer value, a reference to the next node, and a reference to the previous node. The program should provide methods to traverse and print the list using the <code>next</code> pointers for forward direction and the <code>prev</code> pointers for backward direction. Test the implementation with sample doubly linked lists of varying sizes, including empty lists, single-node lists, and multi-node lists. You can visualize this as displaying a chain of numbered cards in order from the first to the last card, and then from the last to the first card, using the bidirectional links.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A doubly linked list of integers (e.g., 1↔2↔3↔4).
<strong>Output</strong>: Two strings representing the list in forward order (e.g., "1 2 3 4") and backward order (e.g., "4 3 2 1").
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: 1↔2↔3↔4</li>
<li>Output:
<pre><code>Forward: 1 2 3 4
Backward: 4 3 2 1
</code></pre>
</li>
<li>Input: []</li>
<li>Output:
<pre><code>Forward: []
Backward: []
</code></pre>
</li>
<li>Input: 5</li>
<li>Output:
<pre><code>Forward: 5
Backward: 5
</code></pre>
</li>
</ul>
<h2 id="pseudocode-60"><a class="header" href="#pseudocode-60">Pseudocode</a></h2>
<pre><code>CLASS DoublyNode
    SET value to integer
    SET next to DoublyNode (null by default)
    SET prev to DoublyNode (null by default)
ENDCLASS

FUNCTION printForward(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION printBackward(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current.next is not null
        SET current to current.next
    ENDWHILE
    WHILE current is not null
        APPEND current.value to result
        IF current.prev is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.prev
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of doubly linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL printForward(testCase.head)
        CALL printBackward(testCase.head)
        PRINT forward and backward results
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-60"><a class="header" href="#algorithm-steps-60">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>DoublyNode</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.
c. A <code>prev</code> pointer to the previous node.</li>
<li>In <code>printForward</code>:
a. If head is null, return "[]".
b. Traverse the list using <code>next</code> pointers, appending each value to a StringBuilder with spaces.
c. Return the string representation.</li>
<li>In <code>printBackward</code>:
a. If head is null, return "[]".
b. Traverse to the tail using <code>next</code> pointers.
c. Traverse back using <code>prev</code> pointers, appending each value with spaces.
d. Return the string representation.</li>
<li>In <code>main</code>, test with empty, single-node, and multi-node doubly linked lists, printing both forward and backward.</li>
</ol>
<h2 id="java-implementation-83"><a class="header" href="#java-implementation-83">Java Implementation</a></h2>
<pre><code class="language-java">public class BidirectionalTraversal {
    // Node class for the doubly linked list
    static class DoublyNode {
        int value;
        DoublyNode next;
        DoublyNode prev;

        DoublyNode(int value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
    }

    // Prints the list in forward direction (head to tail)
    public String printForward(DoublyNode head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        DoublyNode current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Prints the list in backward direction (tail to head)
    public String printBackward(DoublyNode head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        DoublyNode current = head;
        // Move to tail
        while (current.next != null) {
            current = current.next;
        }
        // Traverse backward
        while (current != null) {
            result.append(current.value);
            if (current.prev != null) {
                result.append(" ");
            }
            current = current.prev;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        DoublyNode head;

        TestCase(int[] values) {
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new DoublyNode(values[0]);
            DoublyNode current = head;
            for (int i = 1; i &lt; values.length; i++) {
                DoublyNode newNode = new DoublyNode(values[i]);
                newNode.prev = current;
                current.next = newNode;
                current = newNode;
            }
        }
    }

    // Main method to test bidirectional traversal
    public static void main(String[] args) {
        BidirectionalTraversal traverser = new BidirectionalTraversal();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4}), // Multi-node list
            new TestCase(new int[]{}),           // Empty list
            new TestCase(new int[]{5}),          // Single node
            new TestCase(new int[]{1, 1, 1}),    // List with duplicates
            new TestCase(new int[]{10, 20})      // Two nodes
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Forward: " + traverser.printForward(test.head));
            System.out.println("Backward: " + traverser.printBackward(test.head) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-60"><a class="header" href="#output-60">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Forward: 1 2 3 4
Backward: 4 3 2 1

Test case 2:
Forward: []
Backward: []

Test case 3:
Forward: 5
Backward: 5

Test case 4:
Forward: 1 1 1
Backward: 1 1 1

Test case 5:
Forward: 10 20
Backward: 20 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Forward prints 1→2→3→4, backward prints 4→3→2→1.</li>
<li>Test case 2: Empty list prints "[]" for both directions.</li>
<li>Test case 3: Single node 5 prints "5" for both directions.</li>
<li>Test case 4: List with duplicates 1→1→1 prints "1 1 1" for both directions.</li>
<li>Test case 5: Two nodes 10→20 print "10 20" forward, "20 10" backward.</li>
</ul>
<h2 id="how-it-works-84"><a class="header" href="#how-it-works-84">How It Works</a></h2>
<ul>
<li><strong>DoublyNode</strong>: Stores an integer value, a <code>next</code> pointer, and a <code>prev</code> pointer.</li>
<li><strong>printForward</strong>:
<ul>
<li>Traverses from head to tail using <code>next</code> pointers.</li>
<li>Builds a space-separated string, returning "[]" for empty lists.</li>
</ul>
</li>
<li><strong>printBackward</strong>:
<ul>
<li>Traverses to tail using <code>next</code> pointers.</li>
<li>Traverses back to head using <code>prev</code> pointers, building a space-separated string.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1↔2↔3↔4.</li>
<li>Forward: Traverse head=1, append 1,2,3,4 → "1 2 3 4".</li>
<li>Backward: Move to tail=4, append 4,3,2,1 → "4 3 2 1".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests multi-node, empty, single-node, duplicate, and two-node lists.</li>
</ul>
<h2 id="complexity-analysis-table-83"><a class="header" href="#complexity-analysis-table-83">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Print Forward</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>Print Backward</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for printForward (single pass); O(n) for printBackward (two passes: to tail and back).</li>
<li>Space complexity: O(n) for both (StringBuilder for output).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the <code>next</code> and <code>prev</code> pointers in a doubly linked list to enable efficient bidirectional traversal. Test both directions to ensure <code>prev</code> pointers are correctly set.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure null checks for <code>next</code> and <code>prev</code> pointers to avoid null pointer exceptions, especially for empty or single-node lists.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="browser-history-simulator"><a class="header" href="#browser-history-simulator">Browser History Simulator</a></h1>
<h2 id="problem-statement-61"><a class="header" href="#problem-statement-61">Problem Statement</a></h2>
<p>Write a Java program that simulates a browser’s navigation history using a doubly linked list. Each node in the list represents a webpage with a string URL. The program should support adding new pages (insert at tail), navigating back (delete the current tail and move to the previous page), and navigating forward (re-insert a previously deleted page). A <code>current</code> pointer tracks the current page, and forward navigation is only possible if pages were previously removed via back navigation. Test the implementation with sequences of operations, including adding pages, navigating back and forward, and handling edge cases like empty history or navigating beyond available pages. You can visualize this as managing a browser’s history where new pages are added to the end, going back removes the current page, and going forward restores a previously visited page.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sequence of operations, where each operation is:
<ul>
<li><code>visit(url)</code>: Add a new page (URL) at the tail, clear forward history.</li>
<li><code>back()</code>: Move to the previous page, remove current page, return URL or "null" if not possible.</li>
<li><code>forward()</code>: Move to the next page (re-insert removed page), return URL or "null" if not possible.</li>
<li><code>printHistory()</code>: Print the current history from head to current page.
<strong>Output</strong>: For each operation, print the action performed (e.g., "Visited URL", "Navigated back to URL", "Navigated forward to URL", or the current history). Return "null" for invalid back/forward navigations.
<strong>Constraints</strong>:</li>
</ul>
</li>
<li>The history size is between 0 and 10^5.</li>
<li>URLs are non-empty strings of length up to 100 characters.</li>
<li>The history may be empty or have no forward/backward pages.
<strong>Example</strong>:</li>
<li>Input: Operations = [visit("page1"), visit("page2"), visit("page3"), printHistory, back, printHistory, forward, printHistory]</li>
<li>Output:
<pre><code>Visited page1
Visited page2
Visited page3
History: page1 page2 page3
Navigated back to page2
History: page1 page2
Navigated forward to page3
History: page1 page2 page3
</code></pre>
</li>
<li>Input: Operations = [back, printHistory]</li>
<li>Output:
<pre><code>Navigated back to null
History: []
</code></pre>
</li>
</ul>
<h2 id="pseudocode-61"><a class="header" href="#pseudocode-61">Pseudocode</a></h2>
<pre><code>CLASS DoublyNode
    SET url to string
    SET next to DoublyNode (null by default)
    SET prev to DoublyNode (null by default)
ENDCLASS

CLASS BrowserHistory
    SET head to null
    SET current to null

    FUNCTION visit(url)
        CREATE newNode as new DoublyNode(url)
        IF head is null THEN
            SET head to newNode
            SET current to newNode
        ELSE
            SET current.next to newNode
            SET newNode.prev to current
            SET current to newNode
        ENDIF
    ENDFUNCTION

    FUNCTION back()
        IF current is null OR current.prev is null THEN
            RETURN "null"
        ENDIF
        SET url to current.url
        SET current to current.prev
        SET current.next to null
        RETURN url
    ENDFUNCTION

    FUNCTION forward(forwardList)
        IF forwardList is empty THEN
            RETURN "null"
        ENDIF
        SET url to forwardList.removeLast()
        CREATE newNode as new DoublyNode(url)
        SET newNode.prev to current
        IF current is not null THEN
            SET current.next to newNode
        ELSE
            SET head to newNode
        ENDIF
        SET current to newNode
        RETURN url
    ENDFUNCTION

    FUNCTION toString()
        IF head is null THEN
            RETURN "[]"
        ENDIF
        CREATE result as new StringBuilder
        SET temp to head
        WHILE temp is not null AND temp is not current.next
            APPEND temp.url to result
            IF temp.next is not null AND temp.next is not current.next THEN
                APPEND " " to result
            ENDIF
            SET temp to temp.next
        ENDWHILE
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION testBrowserHistory(operations)
    CREATE browser as new BrowserHistory
    CREATE forwardList as new list
    FOR each operation in operations
        IF operation.type equals "visit" THEN
            CLEAR forwardList
            CALL browser.visit(operation.url)
            PRINT visited url
        ELSE IF operation.type equals "back" THEN
            SET url to browser.back()
            IF url is not "null" THEN
                ADD url to forwardList
            ENDIF
            PRINT navigated back to url
        ELSE IF operation.type equals "forward" THEN
            SET url to browser.forward(forwardList)
            PRINT navigated forward to url
        ELSE IF operation.type equals "print" THEN
            PRINT history using browser.toString
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testBrowserHistory(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-61"><a class="header" href="#algorithm-steps-61">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>DoublyNode</code> class with:
a. A string <code>url</code> for the webpage.
b. A <code>next</code> pointer to the next node.
c. A <code>prev</code> pointer to the previous node.</li>
<li>Define a <code>BrowserHistory</code> class with:
a. <code>head</code> and <code>current</code> pointers to track the list and current page.
b. <code>visit</code>: Add new node at tail, clear forward history, update <code>current</code>.
c. <code>back</code>: Move <code>current</code> to previous node, remove current tail, store URL for forward.
d. <code>forward</code>: Re-insert last removed URL from forward list, update <code>current</code>.
e. <code>toString</code>: Print history from head to current page.</li>
<li>In <code>testBrowserHistory</code>:
a. Create a <code>BrowserHistory</code> and a <code>forwardList</code> to store back-navigated URLs.
b. For each operation:
<ul>
<li><code>visit</code>: Clear forward list, call <code>visit</code>, print action.</li>
<li><code>back</code>: Call <code>back</code>, store URL in forward list, print URL.</li>
<li><code>forward</code>: Call <code>forward</code> with forward list, print URL.</li>
<li><code>print</code>: Call <code>toString</code>, print history.</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences including visits, back/forward navigations, and edge cases.</li>
</ol>
<h2 id="java-implementation-84"><a class="header" href="#java-implementation-84">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BrowserHistorySimulator {
    // Node class for the doubly linked list
    static class DoublyNode {
        String url;
        DoublyNode next;
        DoublyNode prev;

        DoublyNode(String url) {
            this.url = url;
            this.next = null;
            this.prev = null;
        }
    }

    // BrowserHistory class to simulate navigation
    static class BrowserHistory {
        private DoublyNode head;
        private DoublyNode current;

        public void visit(String url) {
            DoublyNode newNode = new DoublyNode(url);
            if (head == null) {
                head = newNode;
                current = newNode;
            } else {
                current.next = newNode;
                newNode.prev = current;
                current = newNode;
            }
        }

        public String back() {
            if (current == null || current.prev == null) {
                return "null";
            }
            String url = current.url;
            current = current.prev;
            current.next = null;
            return url;
        }

        public String forward(List&lt;String&gt; forwardList) {
            if (forwardList.isEmpty()) {
                return "null";
            }
            String url = forwardList.remove(forwardList.size() - 1);
            DoublyNode newNode = new DoublyNode(url);
            newNode.prev = current;
            if (current != null) {
                current.next = newNode;
            } else {
                head = newNode;
            }
            current = newNode;
            return url;
        }

        public String toString() {
            if (head == null) {
                return "[]";
            }
            StringBuilder result = new StringBuilder();
            DoublyNode temp = head;
            while (temp != null &amp;&amp; temp != current.next) {
                result.append(temp.url);
                if (temp.next != null &amp;&amp; temp.next != current.next) {
                    result.append(" ");
                }
                temp = temp.next;
            }
            return result.toString();
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String url;

        Operation(String type, String url) {
            this.type = type;
            this.url = url;
        }
    }

    // Tests browser history operations
    public void testBrowserHistory(List&lt;Operation&gt; operations) {
        BrowserHistory browser = new BrowserHistory();
        List&lt;String&gt; forwardList = new ArrayList&lt;&gt;();
        for (Operation op : operations) {
            if (op.type.equals("visit")) {
                forwardList.clear();
                browser.visit(op.url);
                System.out.println("Visited " + op.url);
            } else if (op.type.equals("back")) {
                String url = browser.back();
                if (!url.equals("null")) {
                    forwardList.add(url);
                }
                System.out.println("Navigated back to " + url);
            } else if (op.type.equals("forward")) {
                String url = browser.forward(forwardList);
                System.out.println("Navigated forward to " + url);
            } else if (op.type.equals("print")) {
                System.out.println("History: " + browser.toString());
            }
        }
    }

    // Main method to test browser history simulator
    public static void main(String[] args) {
        BrowserHistorySimulator simulator = new BrowserHistorySimulator();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal navigation
        testCases.add(Arrays.asList(
            new Operation("visit", "page1"),
            new Operation("visit", "page2"),
            new Operation("visit", "page3"),
            new Operation("print", null),
            new Operation("back", null),
            new Operation("print", null),
            new Operation("forward", null),
            new Operation("print", null)
        ));
        
        // Test case 2: Empty history
        testCases.add(Arrays.asList(
            new Operation("back", null),
            new Operation("forward", null),
            new Operation("print", null)
        ));
        
        // Test case 3: Single page
        testCases.add(Arrays.asList(
            new Operation("visit", "page1"),
            new Operation("print", null),
            new Operation("back", null),
            new Operation("print", null),
            new Operation("forward", null),
            new Operation("print", null)
        ));
        
        // Test case 4: Multiple back/forward
        testCases.add(Arrays.asList(
            new Operation("visit", "page1"),
            new Operation("visit", "page2"),
            new Operation("visit", "page3"),
            new Operation("back", null),
            new Operation("back", null),
            new Operation("forward", null),
            new Operation("forward", null),
            new Operation("print", null)
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            simulator.testBrowserHistory(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-61"><a class="header" href="#output-61">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Visited page1
Visited page2
Visited page3
History: page1 page2 page3
Navigated back to page3
History: page1 page2
Navigated forward to page3
History: page1 page2 page3

Test case 2:
Navigated back to null
Navigated forward to null
History: []

Test case 3:
Visited page1
History: page1
Navigated back to null
History: []
Navigated forward to page1
History: page1

Test case 4:
Visited page1
Visited page2
Visited page3
Navigated back to page3
Navigated back to page2
Navigated forward to page3
Navigated forward to page2
History: page1 page2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Visits page1, page2, page3, prints "page1 page2 page3", goes back (removes page3), prints "page1 page2", goes forward (restores page3), prints "page1 page2 page3".</li>
<li>Test case 2: Attempts back/forward on empty history, prints "null" and "[]".</li>
<li>Test case 3: Visits page1, prints "page1", goes back (removes page1), prints "[]", goes forward (restores page1), prints "page1".</li>
<li>Test case 4: Visits page1, page2, page3, goes back twice (removes page3, page2), goes forward twice (restores page3, page2), prints "page1 page2".</li>
</ul>
<h2 id="how-it-works-85"><a class="header" href="#how-it-works-85">How It Works</a></h2>
<ul>
<li><strong>DoublyNode</strong>: Stores a string URL, a <code>next</code> pointer, and a <code>prev</code> pointer.</li>
<li><strong>BrowserHistory</strong>:
<ul>
<li><code>visit</code>: Adds new node at tail, clears forward history, updates <code>current</code>.</li>
<li><code>back</code>: Moves <code>current</code> to previous node, removes tail, stores URL for forward.</li>
<li><code>forward</code>: Re-inserts last removed URL from forward list, updates <code>current</code>.</li>
<li><code>toString</code>: Prints history from head to <code>current</code>, returns "[]" if empty.</li>
</ul>
</li>
<li><strong>testBrowserHistory</strong>: Manages operations, uses <code>forwardList</code> to store back-navigated URLs.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>visit("page1"): head=page1, current=page1.</li>
<li>visit("page2"): head=page1↔page2, current=page2.</li>
<li>visit("page3"): head=page1↔page2↔page3, current=page3.</li>
<li>print: "page1 page2 page3".</li>
<li>back: current=page2, forwardList=[page3], returns "page3".</li>
<li>print: "page1 page2".</li>
<li>forward: Re-inserts page3, current=page3, returns "page3".</li>
<li>print: "page1 page2 page3".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal navigation, empty history, single page, and multiple back/forward operations.</li>
</ul>
<h2 id="complexity-analysis-table-84"><a class="header" href="#complexity-analysis-table-84">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Visit</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Back</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Forward</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the history.</li>
<li>Time complexity: O(1) for visit, back, forward (constant-time operations); O(n) for toString (traverse to current).</li>
<li>Space complexity: O(1) for visit, back, forward (constant pointers); O(n) for toString (StringBuilder) and forwardList storage.</li>
<li>Worst case: O(n) time, O(n) space for output or forward history with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a doubly linked list with a <code>current</code> pointer to efficiently manage browser history. Clear the forward history on new visits to simulate browser behavior accurately.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Maintain the <code>current</code> pointer and forward list correctly to avoid losing navigation history. Handle edge cases like empty history or no forward pages.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="deque-implementation"><a class="header" href="#deque-implementation">Deque Implementation</a></h1>
<h2 id="problem-statement-62"><a class="header" href="#problem-statement-62">Problem Statement</a></h2>
<p>Write a Java program that implements a double-ended queue (deque) using a doubly linked list. The doubly linked list consists of nodes, each containing an integer value, a reference to the next node, and a reference to the previous node. The deque should support methods to add elements at the front (head) and back (tail), and remove elements from the front and back, maintaining the list’s bidirectional structure. Test the implementation with a sequence of operations, including adding and removing elements at both ends, and handling edge cases like empty deques and single-element deques. You can visualize this as managing a queue of numbered cards where you can add or remove cards from either the front or the back of the deck.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sequence of operations, where each operation is:
<ul>
<li><code>addFront(value)</code>: Add a value to the front of the deque.</li>
<li><code>addBack(value)</code>: Add a value to the back of the deque.</li>
<li><code>removeFront()</code>: Remove and return the front value, or -1 if empty.</li>
<li><code>removeBack()</code>: Remove and return the back value, or -1 if empty.</li>
<li><code>printDeque()</code>: Print the deque in forward order.
<strong>Output</strong>: For each operation, print the action performed (e.g., "Added 5 at front", "Removed 3 from back", or the deque as a string). Return -1 for remove operations on an empty deque.
<strong>Constraints</strong>:</li>
</ul>
</li>
<li>The deque size is between 0 and 10^5.</li>
<li>Values are integers in the range [-10^9, 10^9].</li>
<li>The deque may be empty.
<strong>Example</strong>:</li>
<li>Input: Operations = [addFront(1), addBack(2), addFront(3), printDeque, removeFront, printDeque, removeBack, printDeque]</li>
<li>Output:
<pre><code>Added 1 at front
Added 2 at back
Added 3 at front
Deque: 3 1 2
Removed 3 from front
Deque: 1 2
Removed 2 from back
Deque: 1
</code></pre>
</li>
<li>Input: Operations = [removeFront, printDeque]</li>
<li>Output:
<pre><code>Removed -1 from front
Deque: []
</code></pre>
</li>
</ul>
<h2 id="pseudocode-62"><a class="header" href="#pseudocode-62">Pseudocode</a></h2>
<pre><code>CLASS DoublyNode
    SET value to integer
    SET next to DoublyNode (null by default)
    SET prev to DoublyNode (null by default)
ENDCLASS

CLASS Deque
    SET head to null
    SET tail to null

    FUNCTION addFront(value)
        CREATE newNode as new DoublyNode(value)
        IF head is null THEN
            SET head to newNode
            SET tail to newNode
        ELSE
            SET newNode.next to head
            SET head.prev to newNode
            SET head to newNode
        ENDIF
    ENDFUNCTION

    FUNCTION addBack(value)
        CREATE newNode as new DoublyNode(value)
        IF tail is null THEN
            SET head to newNode
            SET tail to newNode
        ELSE
            SET newNode.prev to tail
            SET tail.next to newNode
            SET tail to newNode
        ENDIF
    ENDFUNCTION

    FUNCTION removeFront()
        IF head is null THEN
            RETURN -1
        ENDIF
        SET value to head.value
        SET head to head.next
        IF head is null THEN
            SET tail to null
        ELSE
            SET head.prev to null
        ENDIF
        RETURN value
    ENDFUNCTION

    FUNCTION removeBack()
        IF tail is null THEN
            RETURN -1
        ENDIF
        SET value to tail.value
        SET tail to tail.prev
        IF tail is null THEN
            SET head to null
        ELSE
            SET tail.next to null
        ENDIF
        RETURN value
    ENDFUNCTION

    FUNCTION toString()
        IF head is null THEN
            RETURN "[]"
        ENDIF
        CREATE result as new StringBuilder
        SET current to head
        WHILE current is not null
            APPEND current.value to result
            IF current.next is not null THEN
                APPEND " " to result
            ENDIF
            SET current to current.next
        ENDWHILE
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION testDeque(operations)
    CREATE deque as new Deque
    FOR each operation in operations
        IF operation.type equals "addFront" THEN
            CALL deque.addFront(operation.value)
            PRINT added value at front
        ELSE IF operation.type equals "addBack" THEN
            CALL deque.addBack(operation.value)
            PRINT added value at back
        ELSE IF operation.type equals "removeFront" THEN
            SET value to deque.removeFront()
            PRINT removed value from front
        ELSE IF operation.type equals "removeBack" THEN
            SET value to deque.removeBack()
            PRINT removed value from back
        ELSE IF operation.type equals "print" THEN
            PRINT deque using toString
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testDeque(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-62"><a class="header" href="#algorithm-steps-62">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>DoublyNode</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.
c. A <code>prev</code> pointer to the previous node.</li>
<li>Define a <code>Deque</code> class with:
a. <code>head</code> and <code>tail</code> pointers to track both ends.
b. <code>addFront</code>: Add node at head, update <code>prev</code> and <code>tail</code> if needed.
c. <code>addBack</code>: Add node at tail, update <code>next</code> and <code>head</code> if needed.
d. <code>removeFront</code>: Remove head, update <code>head</code> and <code>tail</code>, return value or -1.
e. <code>removeBack</code>: Remove tail, update <code>tail</code> and <code>head</code>, return value or -1.
f. <code>toString</code>: Print list forward, return "[]" if empty.</li>
<li>In <code>testDeque</code>:
a. Create a <code>Deque</code>.
b. For each operation:
<ul>
<li><code>addFront</code>: Call <code>addFront</code>, print action.</li>
<li><code>addBack</code>: Call <code>addBack</code>, print action.</li>
<li><code>removeFront</code>: Call <code>removeFront</code>, print value.</li>
<li><code>removeBack</code>: Call <code>removeBack</code>, print value.</li>
<li><code>print</code>: Call <code>toString</code>, print deque.</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences including adds/removes at both ends and edge cases.</li>
</ol>
<h2 id="java-implementation-85"><a class="header" href="#java-implementation-85">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class DequeImplementation {
    // Node class for the doubly linked list
    static class DoublyNode {
        int value;
        DoublyNode next;
        DoublyNode prev;

        DoublyNode(int value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
    }

    // Deque class using doubly linked list
    static class Deque {
        private DoublyNode head;
        private DoublyNode tail;

        public void addFront(int value) {
            DoublyNode newNode = new DoublyNode(value);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                newNode.next = head;
                head.prev = newNode;
                head = newNode;
            }
        }

        public void addBack(int value) {
            DoublyNode newNode = new DoublyNode(value);
            if (tail == null) {
                head = newNode;
                tail = newNode;
            } else {
                newNode.prev = tail;
                tail.next = newNode;
                tail = newNode;
            }
        }

        public int removeFront() {
            if (head == null) {
                return -1;
            }
            int value = head.value;
            head = head.next;
            if (head == null) {
                tail = null;
            } else {
                head.prev = null;
            }
            return value;
        }

        public int removeBack() {
            if (tail == null) {
                return -1;
            }
            int value = tail.value;
            tail = tail.prev;
            if (tail == null) {
                head = null;
            } else {
                tail.next = null;
            }
            return value;
        }

        public String toString() {
            if (head == null) {
                return "[]";
            }
            StringBuilder result = new StringBuilder();
            DoublyNode current = head;
            while (current != null) {
                result.append(current.value);
                if (current.next != null) {
                    result.append(" ");
                }
                current = current.next;
            }
            return result.toString();
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        Integer value;

        Operation(String type, Integer value) {
            this.type = type;
            this.value = value;
        }
    }

    // Tests deque operations
    public void testDeque(List&lt;Operation&gt; operations) {
        Deque deque = new Deque();
        for (Operation op : operations) {
            if (op.type.equals("addFront")) {
                deque.addFront(op.value);
                System.out.println("Added " + op.value + " at front");
            } else if (op.type.equals("addBack")) {
                deque.addBack(op.value);
                System.out.println("Added " + op.value + " at back");
            } else if (op.type.equals("removeFront")) {
                int value = deque.removeFront();
                System.out.println("Removed " + value + " from front");
            } else if (op.type.equals("removeBack")) {
                int value = deque.removeBack();
                System.out.println("Removed " + value + " from back");
            } else if (op.type.equals("print")) {
                System.out.println("Deque: " + deque.toString());
            }
        }
    }

    // Main method to test deque implementation
    public static void main(String[] args) {
        DequeImplementation manager = new DequeImplementation();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal operations
        testCases.add(Arrays.asList(
            new Operation("addFront", 1),
            new Operation("addBack", 2),
            new Operation("addFront", 3),
            new Operation("print", null),
            new Operation("removeFront", null),
            new Operation("print", null),
            new Operation("removeBack", null),
            new Operation("print", null)
        ));
        
        // Test case 2: Empty deque
        testCases.add(Arrays.asList(
            new Operation("removeFront", null),
            new Operation("removeBack", null),
            new Operation("print", null)
        ));
        
        // Test case 3: Single element
        testCases.add(Arrays.asList(
            new Operation("addFront", 5),
            new Operation("print", null),
            new Operation("removeFront", null),
            new Operation("print", null)
        ));
        
        // Test case 4: Mixed operations with duplicates
        testCases.add(Arrays.asList(
            new Operation("addFront", 1),
            new Operation("addBack", 1),
            new Operation("addFront", 2),
            new Operation("print", null),
            new Operation("removeFront", null),
            new Operation("removeBack", null),
            new Operation("print", null)
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            manager.testDeque(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-62"><a class="header" href="#output-62">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Added 1 at front
Added 2 at back
Added 3 at front
Deque: 3 1 2
Removed 3 from front
Deque: 1 2
Removed 2 from back
Deque: 1

Test case 2:
Removed -1 from front
Removed -1 from back
Deque: []

Test case 3:
Added 5 at front
Deque: 5
Removed 5 from front
Deque: []

Test case 4:
Added 1 at front
Added 1 at back
Added 2 at front
Deque: 2 1 1
Removed 2 from front
Removed 1 from back
Deque: 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Adds 1 (front), 2 (back), 3 (front), prints "3 1 2", removes 3 (front), prints "1 2", removes 2 (back), prints "1".</li>
<li>Test case 2: Removes from empty deque (returns -1), prints "[]".</li>
<li>Test case 3: Adds 5 (front), prints "5", removes 5 (front), prints "[]".</li>
<li>Test case 4: Adds 1 (front), 1 (back), 2 (front), prints "2 1 1", removes 2 (front), 1 (back), prints "1".</li>
</ul>
<h2 id="how-it-works-86"><a class="header" href="#how-it-works-86">How It Works</a></h2>
<ul>
<li><strong>DoublyNode</strong>: Stores an integer value, a <code>next</code> pointer, and a <code>prev</code> pointer.</li>
<li><strong>Deque</strong>:
<ul>
<li><code>addFront</code>: Adds node at head, updates <code>prev</code> and <code>tail</code>, O(1).</li>
<li><code>addBack</code>: Adds node at tail, updates <code>next</code> and <code>head</code>, O(1).</li>
<li><code>removeFront</code>: Removes head, updates <code>head</code> and <code>tail</code>, returns value or -1, O(1).</li>
<li><code>removeBack</code>: Removes tail, updates <code>tail</code> and <code>head</code>, returns value or -1, O(1).</li>
<li><code>toString</code>: Traverses forward, returns space-separated string or "[]".</li>
</ul>
</li>
<li><strong>testDeque</strong>: Executes operations, printing actions and results.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>addFront(1): head=1↔null, tail=1.</li>
<li>addBack(2): head=1↔2, tail=2.</li>
<li>addFront(3): head=3↔1↔2, tail=2.</li>
<li>print: "3 1 2".</li>
<li>removeFront: Removes 3, head=1↔2, tail=2, returns 3.</li>
<li>print: "1 2".</li>
<li>removeBack: Removes 2, head=1, tail=1, returns 2.</li>
<li>print: "1".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal operations, empty deque, single element, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-85"><a class="header" href="#complexity-analysis-table-85">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Add Front</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Add Back</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Remove Front</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Remove Back</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the deque.</li>
<li>Time complexity: O(1) for addFront, addBack, removeFront, removeBack (constant-time operations); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for add/remove operations (constant pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for output with large deques.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a doubly linked list for a deque to enable O(1) operations at both ends by maintaining <code>head</code> and <code>tail</code> pointers. Test edge cases like empty deques and single-element deques to ensure robustness.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Always update both <code>head</code> and <code>tail</code> pointers correctly during add and remove operations to maintain deque integrity. Check for null pointers to handle empty deque cases.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="insert-after-value"><a class="header" href="#insert-after-value">Insert After Value</a></h1>
<h2 id="problem-statement-63"><a class="header" href="#problem-statement-63">Problem Statement</a></h2>
<p>Write a Java program that extends a doubly linked list implementation to include a method that inserts a new node with a given value after the first occurrence of a specified target value. The doubly linked list consists of nodes, each containing an integer value, a reference to the next node, and a reference to the previous node. The program should insert the new node by updating the <code>next</code> and <code>prev</code> pointers appropriately and return true if the insertion is successful (target value found) or false if the target value is not found. Test the implementation with cases where the target value exists in the list and where it does not, including empty lists and single-node lists. You can visualize this as adding a new card to a chain of numbered cards, placing it right after the first card with a specific number.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A doubly linked list of integers (e.g., 1↔2↔3), a target value (e.g., 2), and a new value to insert (e.g., 4).
<strong>Output</strong>: A boolean indicating whether the insertion was successful, and the updated list printed in forward order (e.g., "1 2 4 3").
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values and the new value are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty or not contain the target value.
<strong>Example</strong>:</li>
<li>Input: List = 1↔2↔3, target = 2, newValue = 4</li>
<li>Output: true, "1 2 4 3"</li>
<li>Explanation: Inserts 4 after the first 2, resulting in 1↔2↔4↔3.</li>
<li>Input: List = 1↔2↔3, target = 5, newValue = 4</li>
<li>Output: false, "1 2 3"</li>
<li>Explanation: Target 5 not found, list unchanged.</li>
<li>Input: List = [], target = 1, newValue = 2</li>
<li>Output: false, "[]"</li>
<li>Explanation: Empty list, no insertion possible.</li>
</ul>
<h2 id="pseudocode-63"><a class="header" href="#pseudocode-63">Pseudocode</a></h2>
<pre><code>CLASS DoublyNode
    SET value to integer
    SET next to DoublyNode (null by default)
    SET prev to DoublyNode (null by default)
ENDCLASS

FUNCTION insertAfterValue(head, target, newValue)
    IF head is null THEN
        RETURN false
    ENDIF
    SET current to head
    WHILE current is not null
        IF current.value equals target THEN
            CREATE newNode as new DoublyNode(newValue)
            SET newNode.next to current.next
            SET newNode.prev to current
            IF current.next is not null THEN
                SET current.next.prev to newNode
            ENDIF
            SET current.next to newNode
            RETURN true
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN false
ENDFUNCTION

FUNCTION printForward(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of test cases (list, target, newValue)
    FOR each testCase in testCases
        PRINT test case details
        CALL insertAfterValue(testCase.head, testCase.target, testCase.newValue)
        PRINT insertion result and updated list using printForward
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-63"><a class="header" href="#algorithm-steps-63">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>DoublyNode</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.
c. A <code>prev</code> pointer to the previous node.</li>
<li>In <code>insertAfterValue</code>:
a. If head is null, return false (empty list).
b. Traverse the list using <code>current</code> until the target value is found or the list ends.
c. If target is found:
<ul>
<li>Create a new node with <code>newValue</code>.</li>
<li>Set <code>newNode.next</code> to <code>current.next</code> and <code>newNode.prev</code> to <code>current</code>.</li>
<li>Update <code>current.next.prev</code> to <code>newNode</code> if <code>current.next</code> exists.</li>
<li>Set <code>current.next</code> to <code>newNode</code>.</li>
<li>Return true.
d. If target is not found, return false.</li>
</ul>
</li>
<li>In <code>printForward</code>:
a. If head is null, return "[]".
b. Traverse the list using <code>next</code> pointers, appending each value with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with cases where the target exists, does not exist, and edge cases like empty or single-node lists.</li>
</ol>
<h2 id="java-implementation-86"><a class="header" href="#java-implementation-86">Java Implementation</a></h2>
<pre><code class="language-java">public class InsertAfterValue {
    // Node class for the doubly linked list
    static class DoublyNode {
        int value;
        DoublyNode next;
        DoublyNode prev;

        DoublyNode(int value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
    }

    // Inserts a new node after the first occurrence of target
    public boolean insertAfterValue(DoublyNode head, int target, int newValue) {
        if (head == null) {
            return false;
        }
        DoublyNode current = head;
        while (current != null) {
            if (current.value == target) {
                DoublyNode newNode = new DoublyNode(newValue);
                newNode.next = current.next;
                newNode.prev = current;
                if (current.next != null) {
                    current.next.prev = newNode;
                }
                current.next = newNode;
                return true;
            }
            current = current.next;
        }
        return false;
    }

    // Prints the list in forward direction
    public String printForward(DoublyNode head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        DoublyNode current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        DoublyNode head;
        int target;
        int newValue;

        TestCase(int[] values, int target, int newValue) {
            this.target = target;
            this.newValue = newValue;
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new DoublyNode(values[0]);
            DoublyNode current = head;
            for (int i = 1; i &lt; values.length; i++) {
                DoublyNode newNode = new DoublyNode(values[i]);
                newNode.prev = current;
                current.next = newNode;
                current = newNode;
            }
        }
    }

    // Main method to test insert after value
    public static void main(String[] args) {
        InsertAfterValue inserter = new InsertAfterValue();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3}, 2, 4),      // Target exists
            new TestCase(new int[]{1, 2, 3}, 5, 4),      // Target does not exist
            new TestCase(new int[]{}, 1, 2),             // Empty list
            new TestCase(new int[]{5}, 5, 6),            // Single node, target exists
            new TestCase(new int[]{1, 1, 1}, 1, 2)       // Duplicates, insert after first
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + inserter.printForward(test.head));
            System.out.println("Insert " + test.newValue + " after " + test.target);
            boolean result = inserter.insertAfterValue(test.head, test.target, test.newValue);
            System.out.println("Insertion successful: " + result);
            System.out.println("Updated list: " + inserter.printForward(test.head) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-63"><a class="header" href="#output-63">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3
Insert 4 after 2
Insertion successful: true
Updated list: 1 2 4 3

Test case 2:
Input list: 1 2 3
Insert 4 after 5
Insertion successful: false
Updated list: 1 2 3

Test case 3:
Input list: []
Insert 2 after 1
Insertion successful: false
Updated list: []

Test case 4:
Input list: 5
Insert 6 after 5
Insertion successful: true
Updated list: 5 6

Test case 5:
Input list: 1 1 1
Insert 2 after 1
Insertion successful: true
Updated list: 1 2 1 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Inserts 4 after first 2, resulting in 1↔2↔4↔3.</li>
<li>Test case 2: Target 5 not found, list unchanged, returns false.</li>
<li>Test case 3: Empty list, no insertion, returns false.</li>
<li>Test case 4: Inserts 6 after 5 in single-node list, resulting in 5↔6.</li>
<li>Test case 5: Inserts 2 after first 1 in 1↔1↔1, resulting in 1↔2↔1↔1.</li>
</ul>
<h2 id="how-it-works-87"><a class="header" href="#how-it-works-87">How It Works</a></h2>
<ul>
<li><strong>DoublyNode</strong>: Stores an integer value, a <code>next</code> pointer, and a <code>prev</code> pointer.</li>
<li><strong>insertAfterValue</strong>:
<ul>
<li>Returns false for empty lists.</li>
<li>Traverses list to find first node with target value.</li>
<li>If found, inserts new node, updating <code>next</code> and <code>prev</code> pointers, returns true.</li>
<li>If not found, returns false.</li>
</ul>
</li>
<li><strong>printForward</strong>: Traverses list using <code>next</code> pointers, returns space-separated string or "[]".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1↔2↔3, target=2, newValue=4.</li>
<li>current=1, no match, move to 2.</li>
<li>current=2, match: create newNode(4), newNode.next=3, newNode.prev=2, 3.prev=newNode, 2.next=newNode.</li>
<li>Result: 1↔2↔4↔3, return true.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests target exists, target does not exist, empty list, single node, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-86"><a class="header" href="#complexity-analysis-table-86">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert After Value</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Print Forward</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for insertAfterValue (traverse to find target); O(n) for printForward (traverse list).</li>
<li>Space complexity: O(1) for insertAfterValue (constant pointers); O(n) for printForward (StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the doubly linked list’s <code>prev</code> pointers to easily link the new node to the next node’s previous pointer, ensuring bidirectional consistency. Test with duplicates to verify insertion after the first occurrence.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Update both <code>next</code> and <code>prev</code> pointers carefully to maintain the doubly linked list structure. Check for null pointers to handle edge cases like empty lists or inserting at the end.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="reverse-a-doubly-linked-list"><a class="header" href="#reverse-a-doubly-linked-list">Reverse a Doubly Linked List</a></h1>
<h2 id="problem-statement-64"><a class="header" href="#problem-statement-64">Problem Statement</a></h2>
<p>Write a Java program that reverses a doubly linked list. The doubly linked list consists of nodes, each containing an integer value, a reference to the next node, and a reference to the previous node. The program should reverse the order of the nodes (e.g., 1↔2↔3 becomes 3↔2↔1) by swapping the <code>next</code> and <code>prev</code> pointers of each node and updating the head. Test the implementation with doubly linked lists of varying sizes, including empty lists, single-node lists, and multi-node lists. You can visualize this as rearranging a chain of numbered cards, flipping their order so the last card becomes the first, with each card linked to both its predecessor and successor.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A doubly linked list of integers (e.g., 1↔2↔3↔4).
<strong>Output</strong>: The reversed doubly linked list as a string in forward order (e.g., "4 3 2 1").
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: 1↔2↔3↔4</li>
<li>Output: "4 3 2 1"</li>
<li>Explanation: The list 1↔2↔3↔4 is reversed to 4↔3↔2↔1.</li>
<li>Input: []</li>
<li>Output: "[]"</li>
<li>Explanation: An empty list remains empty.</li>
<li>Input: 5</li>
<li>Output: "5"</li>
<li>Explanation: A single-node list is unchanged.</li>
</ul>
<h2 id="pseudocode-64"><a class="header" href="#pseudocode-64">Pseudocode</a></h2>
<pre><code>CLASS DoublyNode
    SET value to integer
    SET next to DoublyNode (null by default)
    SET prev to DoublyNode (null by default)
ENDCLASS

FUNCTION reverseList(head)
    IF head is null THEN
        RETURN null
    ENDIF
    SET current to head
    SET newHead to null
    WHILE current is not null
        SET temp to current.prev
        SET current.prev to current.next
        SET current.next to temp
        SET newHead to current
        SET current to current.prev
    ENDWHILE
    RETURN newHead
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    WHILE current is not null
        APPEND current.value to result
        IF current.next is not null THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of doubly linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL reverseList(testCase.head)
        PRINT reversed list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-64"><a class="header" href="#algorithm-steps-64">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>DoublyNode</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.
c. A <code>prev</code> pointer to the previous node.</li>
<li>In <code>reverseList</code>:
a. If head is null, return null (empty list).
b. Initialize <code>current</code> to head, <code>newHead</code> to track the new head.
c. While <code>current</code> is not null:
<ul>
<li>Swap <code>current.prev</code> and <code>current.next</code>.</li>
<li>Update <code>newHead</code> to <code>current</code> (last node processed becomes head).</li>
<li>Move <code>current</code> to the next node (now in <code>prev</code> due to swap).
d. Return <code>newHead</code>.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse the list forward, append each value to a StringBuilder with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with empty, single-node, and multi-node doubly linked lists.</li>
</ol>
<h2 id="java-implementation-87"><a class="header" href="#java-implementation-87">Java Implementation</a></h2>
<pre><code class="language-java">public class ReverseDoublyLinkedList {
    // Node class for the doubly linked list
    static class DoublyNode {
        int value;
        DoublyNode next;
        DoublyNode prev;

        DoublyNode(int value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
    }

    // Reverses the doubly linked list
    public DoublyNode reverseList(DoublyNode head) {
        if (head == null) {
            return null;
        }
        DoublyNode current = head;
        DoublyNode newHead = null;
        while (current != null) {
            // Swap prev and next pointers
            DoublyNode temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            // Update newHead to current node (last node processed)
            newHead = current;
            // Move to next node (now in prev due to swap)
            current = current.prev;
        }
        return newHead;
    }

    // Converts doubly linked list to string for output
    public String toString(DoublyNode head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        DoublyNode current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        DoublyNode head;

        TestCase(int[] values) {
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new DoublyNode(values[0]);
            DoublyNode current = head;
            for (int i = 1; i &lt; values.length; i++) {
                DoublyNode newNode = new DoublyNode(values[i]);
                newNode.prev = current;
                current.next = newNode;
                current = newNode;
            }
        }
    }

    // Main method to test doubly linked list reversal
    public static void main(String[] args) {
        ReverseDoublyLinkedList reverser = new ReverseDoublyLinkedList();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4}), // Multi-node list
            new TestCase(new int[]{}),           // Empty list
            new TestCase(new int[]{5}),          // Single node
            new TestCase(new int[]{1, 1, 1}),    // List with duplicates
            new TestCase(new int[]{10, 20})      // Two nodes
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + reverser.toString(test.head));
            DoublyNode reversed = reverser.reverseList(test.head);
            System.out.println("Reversed list: " + reverser.toString(reversed) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-64"><a class="header" href="#output-64">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4
Reversed list: 4 3 2 1

Test case 2:
Input list: []
Reversed list: []

Test case 3:
Input list: 5
Reversed list: 5

Test case 4:
Input list: 1 1 1
Reversed list: 1 1 1

Test case 5:
Input list: 10 20
Reversed list: 20 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Reverses 1↔2↔3↔4 to 4↔3↔2↔1.</li>
<li>Test case 2: Empty list remains empty.</li>
<li>Test case 3: Single node 5 is unchanged.</li>
<li>Test case 4: List with duplicates 1↔1↔1 reverses to 1↔1↔1.</li>
<li>Test case 5: Two nodes 10↔20 reverse to 20↔10.</li>
</ul>
<h2 id="how-it-works-88"><a class="header" href="#how-it-works-88">How It Works</a></h2>
<ul>
<li><strong>DoublyNode</strong>: Stores an integer value, a <code>next</code> pointer, and a <code>prev</code> pointer.</li>
<li><strong>reverseList</strong>:
<ul>
<li>Returns null for empty lists.</li>
<li>Iteratively swaps <code>prev</code> and <code>next</code> pointers for each node.</li>
<li>Tracks the new head (last node processed).</li>
<li>Moves to the next node using the swapped <code>prev</code> pointer.</li>
</ul>
</li>
<li><strong>toString</strong>: Converts the list to a space-separated string, traversing forward, returning "[]" for empty lists.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1↔2↔3↔4.</li>
<li>Initial: current=1, newHead=null.</li>
<li>Step 1: 1(next=null,prev=2), newHead=1, current=2.</li>
<li>Step 2: 2(next=1,prev=3), newHead=2, current=3.</li>
<li>Step 3: 3(next=2,prev=4), newHead=3, current=4.</li>
<li>Step 4: 4(next=3,prev=null), newHead=4, current=null.</li>
<li>Return: 4↔3↔2↔1.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests multi-node, empty, single-node, duplicate, and two-node lists.</li>
</ul>
<h2 id="complexity-analysis-table-87"><a class="header" href="#complexity-analysis-table-87">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Reverse List</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for reverseList (single pass); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for reverseList (constant pointers); O(n) for toString (StringBuilder).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: In a doubly linked list, reversing is simplified by swapping <code>next</code> and <code>prev</code> pointers. Always update the head to the last node processed to maintain the list structure.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Carefully swap <code>next</code> and <code>prev</code> pointers to avoid losing references. Ensure null checks for edge cases like empty or single-node lists.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="insert-after-value-in-circular-linked-list"><a class="header" href="#insert-after-value-in-circular-linked-list">Insert After Value in Circular Linked List</a></h1>
<h2 id="problem-statement-65"><a class="header" href="#problem-statement-65">Problem Statement</a></h2>
<p>Write a Java program that adds a method to insert a new node with a given value after the first occurrence of a specified target value in a circular linked list. A circular linked list is a singly linked list where the last node’s <code>next</code> pointer points to the head, forming a cycle. The method should insert the new node by updating the <code>next</code> pointers to maintain the circular structure and return true if the insertion is successful (target value found) or false if the target value is not found. Test the implementation with cases where the target value exists in the list and where it does not, including empty lists and single-node lists. You can visualize this as adding a new numbered card to a circular chain of cards, placing it right after the first card with a specific number.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A circular linked list of integers (e.g., 1→2→3→1, where 3→1 forms the cycle), a target value (e.g., 2), and a new value to insert (e.g., 4).
<strong>Output</strong>: A boolean indicating whether the insertion was successful, and the updated list printed as a string, listing nodes from the head until just before it cycles (e.g., "1 2 4 3").
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values and the new value are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty or not contain the target value.
<strong>Example</strong>:</li>
<li>Input: List = 1→2→3→1, target = 2, newValue = 4</li>
<li>Output: true, "1 2 4 3"</li>
<li>Explanation: Inserts 4 after the first 2, resulting in 1→2→4→3→1.</li>
<li>Input: List = 1→2→3→1, target = 5, newValue = 4</li>
<li>Output: false, "1 2 3"</li>
<li>Explanation: Target 5 not found, list unchanged.</li>
<li>Input: List = [], target = 1, newValue = 2</li>
<li>Output: false, "[]"</li>
<li>Explanation: Empty list, no insertion possible.</li>
</ul>
<h2 id="pseudocode-65"><a class="header" href="#pseudocode-65">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION insertAfterValue(head, target, newValue)
    IF head is null THEN
        RETURN false
    ENDIF
    SET current to head
    SET found to false
    REPEAT
        IF current.value equals target THEN
            SET found to true
            BREAK
        ENDIF
        SET current to current.next
    UNTIL current equals head
    IF not found THEN
        RETURN false
    ENDIF
    CREATE newNode as new Node(newValue)
    SET newNode.next to current.next
    SET current.next to newNode
    RETURN true
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    SET visited as new Set
    WHILE current is not null AND current not in visited
        ADD current to visited
        APPEND current.value to result
        IF current.next is not head THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of test cases (list values, target, newValue)
    FOR each testCase in testCases
        PRINT test case details
        CALL insertAfterValue(testCase.head, testCase.target, testCase.newValue)
        PRINT insertion result and updated list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-65"><a class="header" href="#algorithm-steps-65">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>insertAfterValue</code>:
a. If the list is empty, return false.
b. Traverse the list starting from head until the target value is found or the traversal returns to head.
c. If target is not found, return false.
d. If target is found:
<ul>
<li>Create a new node with <code>newValue</code>.</li>
<li>Set <code>newNode.next</code> to <code>current.next</code>.</li>
<li>Set <code>current.next</code> to <code>newNode</code>.</li>
<li>Return true.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse from head, use a Set to avoid cycling, append values with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with cases where the target exists, does not exist, and edge cases like empty or single-node lists.</li>
</ol>
<h2 id="java-implementation-88"><a class="header" href="#java-implementation-88">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class InsertAfterValueCircular {
    // Node class for the circular linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Inserts a new node after the first occurrence of target
    public boolean insertAfterValue(Node head, int target, int newValue) {
        if (head == null) {
            return false;
        }
        Node current = head;
        boolean found = false;
        do {
            if (current.value == target) {
                found = true;
                break;
            }
            current = current.next;
        } while (current != head);
        if (!found) {
            return false;
        }
        Node newNode = new Node(newValue);
        newNode.next = current.next;
        current.next = newNode;
        return true;
    }

    // Converts circular linked list to string
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
        while (current != null &amp;&amp; !visited.contains(current)) {
            visited.add(current);
            result.append(current.value);
            if (current.next != head) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;
        int target;
        int newValue;

        TestCase(int[] values, int target, int newValue) {
            this.target = target;
            this.newValue = newValue;
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
            // Make circular
            current.next = head;
        }
    }

    // Main method to test insert after value
    public static void main(String[] args) {
        InsertAfterValueCircular inserter = new InsertAfterValueCircular();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3}, 2, 4),      // Target exists
            new TestCase(new int[]{1, 2, 3}, 5, 4),      // Target does not exist
            new TestCase(new int[]{}, 1, 2),             // Empty list
            new TestCase(new int[]{5}, 5, 6),            // Single node, target exists
            new TestCase(new int[]{1, 1, 1}, 1, 2)       // Duplicates, insert after first
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + inserter.toString(test.head));
            System.out.println("Insert " + test.newValue + " after " + test.target);
            boolean result = inserter.insertAfterValue(test.head, test.target, test.newValue);
            System.out.println("Insertion successful: " + result);
            System.out.println("Updated list: " + inserter.toString(test.head) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-65"><a class="header" href="#output-65">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3
Insert 4 after 2
Insertion successful: true
Updated list: 1 2 4 3

Test case 2:
Input list: 1 2 3
Insert 4 after 5
Insertion successful: false
Updated list: 1 2 3

Test case 3:
Input list: []
Insert 2 after 1
Insertion successful: false
Updated list: []

Test case 4:
Input list: 5
Insert 6 after 5
Insertion successful: true
Updated list: 5 6

Test case 5:
Input list: 1 1 1
Insert 2 after 1
Insertion successful: true
Updated list: 1 2 1 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Inserts 4 after first 2, resulting in 1→2→4→3→1.</li>
<li>Test case 2: Target 5 not found, list unchanged, returns false.</li>
<li>Test case 3: Empty list, no insertion, returns false.</li>
<li>Test case 4: Inserts 6 after 5 in single-node list, resulting in 5→6→5.</li>
<li>Test case 5: Inserts 2 after first 1 in 1→1→1→1, resulting in 1→2→1→1→1.</li>
</ul>
<h2 id="how-it-works-89"><a class="header" href="#how-it-works-89">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a <code>next</code> pointer.</li>
<li><strong>insertAfterValue</strong>:
<ul>
<li>Returns false for empty lists.</li>
<li>Traverses the list in a loop, stopping at the first node with the target value or when returning to head.</li>
<li>If target is not found, returns false.</li>
<li>If found, inserts new node, updating <code>next</code> pointers, returns true.</li>
</ul>
</li>
<li><strong>toString</strong>: Traverses from head, uses a Set to prevent cycling, returns space-separated string or "[]".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→1, target=2, newValue=4.</li>
<li>current=1, no match, current=2, match.</li>
<li>newNode(4).next=3, 2.next=newNode.</li>
<li>Result: 1→2→4→3→1, return true.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests target exists, target does not exist, empty list, single node, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-88"><a class="header" href="#complexity-analysis-table-88">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert After Value</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for insertAfterValue (traverse to find target); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for insertAfterValue (constant pointers); O(n) for toString (StringBuilder and Set).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a do-while loop to traverse the circular list and stop at the head to avoid infinite loops. Insert the new node by carefully updating <code>next</code> pointers to maintain the circular structure.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for the target value in one full cycle to handle cases where it doesn’t exist. Ensure proper handling of edge cases like empty or single-node lists to avoid null pointer issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="josephus-problem"><a class="header" href="#josephus-problem">Josephus Problem</a></h1>
<h2 id="problem-statement-66"><a class="header" href="#problem-statement-66">Problem Statement</a></h2>
<p>Write a Java program to solve the Josephus problem using a circular linked list. The Josephus problem involves n people standing in a circle, numbered from 1 to n, where every k-th person is eliminated until only one remains. The circular linked list is a singly linked list where the last node’s <code>next</code> pointer points to the head, forming a cycle. The program should return the value of the last person remaining and test the solution with different values of k and list sizes, including edge cases like single-person lists and k=1. You can visualize this as a circle of numbered cards where every k-th card is removed until only one card remains.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A circular linked list of integers representing people (e.g., 1→2→3→4→1 for n=4) and an integer k (the step size for elimination).
<strong>Output</strong>: The value of the last person remaining (e.g., 3 for n=4, k=2).
<strong>Constraints</strong>:</li>
<li>The list size n is between 1 and 10^5.</li>
<li>Node values are integers from 1 to n.</li>
<li>k is a positive integer (k ≥ 1).
<strong>Example</strong>:</li>
<li>Input: List = 1→2→3→4→1, k = 2</li>
<li>Output: 3</li>
<li>Explanation: Eliminate every 2nd person: 2, 4, 1, leaving 3.</li>
<li>Input: List = 1→1, k = 1</li>
<li>Output: 1</li>
<li>Explanation: Single person remains.</li>
<li>Input: List = 1→2→3→1, k = 3</li>
<li>Output: 1</li>
<li>Explanation: Eliminate every 3rd person: 3, 2, leaving 1.</li>
</ul>
<h2 id="pseudocode-66"><a class="header" href="#pseudocode-66">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION solveJosephus(head, k)
    IF head is null THEN
        RETURN -1
    ENDIF
    IF head.next is head THEN
        RETURN head.value
    ENDIF
    SET current to head
    WHILE current.next is not current
        FOR i from 1 to k-1
            SET current to current.next
        ENDFOR
        SET nextNode to current.next
        SET current.next to nextNode.next
        SET current to current.next
    ENDWHILE
    RETURN current.value
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    SET visited as new Set
    WHILE current is not null AND current not in visited
        ADD current to visited
        APPEND current.value to result
        IF current.next is not head THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of test cases (list values, k)
    FOR each testCase in testCases
        PRINT test case details
        CALL solveJosephus(testCase.head, testCase.k)
        PRINT last person remaining
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-66"><a class="header" href="#algorithm-steps-66">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code> (person number).
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>solveJosephus</code>:
a. If the list is empty, return -1.
b. If the list has one node, return its value.
c. Set <code>current</code> to head.
d. While more than one node remains:
<ul>
<li>Traverse k-1 steps to find the node before the one to eliminate.</li>
<li>Remove the k-th node by updating <code>current.next</code> to skip it.</li>
<li>Move <code>current</code> to the next node.
e. Return the value of the last remaining node.</li>
</ul>
</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse from head, use a Set to avoid cycling, append values with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with different list sizes (n=1, n&gt;1) and k values (k=1, k&gt;1), including edge cases.</li>
</ol>
<h2 id="java-implementation-89"><a class="header" href="#java-implementation-89">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class JosephusProblem {
    // Node class for the circular linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Solves the Josephus problem
    public int solveJosephus(Node head, int k) {
        if (head == null) {
            return -1;
        }
        if (head.next == head) {
            return head.value;
        }
        Node current = head;
        while (current.next != current) {
            // Move to the node before the one to be eliminated
            for (int i = 0; i &lt; k - 1; i++) {
                current = current.next;
            }
            // Remove the k-th node
            Node nextNode = current.next;
            current.next = nextNode.next;
            current = current.next;
        }
        return current.value;
    }

    // Converts circular linked list to string
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
        while (current != null &amp;&amp; !visited.contains(current)) {
            visited.add(current);
            result.append(current.value);
            if (current.next != head) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;
        int k;

        TestCase(int n, int k) {
            this.k = k;
            if (n == 0) {
                head = null;
                return;
            }
            head = new Node(1);
            Node current = head;
            for (int i = 2; i &lt;= n; i++) {
                current.next = new Node(i);
                current = current.next;
            }
            // Make circular
            current.next = head;
        }
    }

    // Main method to test Josephus problem
    public static void main(String[] args) {
        JosephusProblem solver = new JosephusProblem();

        // Test cases
        TestCase[] testCases = {
            new TestCase(4, 2),     // n=4, k=2
            new TestCase(3, 3),     // n=3, k=3
            new TestCase(1, 1),     // Single node
            new TestCase(5, 1),     // k=1
            new TestCase(7, 4)      // Larger n, k
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + solver.toString(test.head));
            System.out.println("k: " + test.k);
            int result = solver.solveJosephus(test.head, test.k);
            System.out.println("Last person remaining: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-66"><a class="header" href="#output-66">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4
k: 2
Last person remaining: 3

Test case 2:
Input list: 1 2 3
k: 3
Last person remaining: 1

Test case 3:
Input list: 1
k: 1
Last person remaining: 1

Test case 4:
Input list: 1 2 3 4 5
k: 1
Last person remaining: 5

Test case 5:
Input list: 1 2 3 4 5 6 7
k: 4
Last person remaining: 2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: n=4, k=2, eliminate 2, 4, 1, leaving 3.</li>
<li>Test case 2: n=3, k=3, eliminate 3, 2, leaving 1.</li>
<li>Test case 3: n=1, k=1, single node 1 remains.</li>
<li>Test case 4: n=5, k=1, eliminate 1, 2, 3, 4, leaving 5.</li>
<li>Test case 5: n=7, k=4, eliminate 4, 1, 6, 5, 7, 3, leaving 2.</li>
</ul>
<h2 id="how-it-works-90"><a class="header" href="#how-it-works-90">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value (person number) and a <code>next</code> pointer.</li>
<li><strong>solveJosephus</strong>:
<ul>
<li>Returns -1 for empty lists, head value for single-node lists.</li>
<li>Iterates while more than one node remains:
<ul>
<li>Traverses k-1 steps to find the node before the k-th.</li>
<li>Removes k-th node by updating <code>next</code> pointer.</li>
<li>Moves to the next node.</li>
</ul>
</li>
<li>Returns the value of the last node.</li>
</ul>
</li>
<li><strong>toString</strong>: Traverses from head, uses a Set to prevent cycling, returns space-separated string or "[]".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→4→1, k=2.</li>
<li>Step 1: current=1, eliminate 2, list=1→3→4→1.</li>
<li>Step 2: current=3, eliminate 4, list=1→3→1.</li>
<li>Step 3: current=1, eliminate 1, list=3→3.</li>
<li>Return: 3.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests different n and k, including single node and k=1.</li>
</ul>
<h2 id="complexity-analysis-table-89"><a class="header" href="#complexity-analysis-table-89">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Solve Josephus</td><td>O(n * k)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n * k) for solveJosephus (n-1 eliminations, each up to k steps); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for solveJosephus (constant pointers); O(n) for toString (StringBuilder and Set).</li>
<li>Worst case: O(n * k) time, O(n) space for output with large lists and k.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the circular linked list’s structure to efficiently eliminate nodes by updating <code>next</code> pointers. Keep track of the current node to continue from the correct position after each elimination.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure k is handled correctly for each elimination step, and avoid infinite loops by checking for single-node conditions. Handle edge cases like n=1 or empty lists.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="rotate-the-list"><a class="header" href="#rotate-the-list">Rotate the List</a></h1>
<h2 id="problem-statement-67"><a class="header" href="#problem-statement-67">Problem Statement</a></h2>
<p>Write a Java program that rotates a circular linked list by k positions, moving the head k nodes forward. A circular linked list is a singly linked list where the last node’s <code>next</code> pointer points to the head, forming a cycle. The rotation shifts the head pointer forward by k nodes, effectively redefining the start of the list while maintaining the circular structure. Test the implementation with different values of k and list sizes, including empty lists, single-node lists, k=0, k equal to the list size, and k greater than the list size. You can visualize this as rotating a ring of numbered beads, where the starting bead (head) moves k positions clockwise, and the ring remains connected.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A circular linked list of integers (e.g., 1→2→3→4→1, where 4→1 forms the cycle) and an integer k (number of positions to rotate).
<strong>Output</strong>: The rotated list as a string, listing nodes from the new head until just before it cycles (e.g., "3 4 1 2" after rotating 1→2→3→4→1 by k=2).
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>k is a non-negative integer (k ≥ 0).</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: List = 1→2→3→4→1, k = 2</li>
<li>Output: "3 4 1 2"</li>
<li>Explanation: Rotates head from 1 to 3, list becomes 3→4→1→2→3.</li>
<li>Input: List = [], k = 1</li>
<li>Output: "[]"</li>
<li>Explanation: Empty list remains empty.</li>
<li>Input: List = 1→1, k = 3</li>
<li>Output: "1"</li>
<li>Explanation: Single-node list is unchanged (rotation wraps around).</li>
</ul>
<h2 id="pseudocode-67"><a class="header" href="#pseudocode-67">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION rotateList(head, k)
    IF head is null OR head.next is head THEN
        RETURN head
    ENDIF
    SET length to 1
    SET tail to head
    WHILE tail.next is not head
        INCREMENT length
        SET tail to tail.next
    ENDWHILE
    SET k to k mod length
    IF k equals 0 THEN
        RETURN head
    ENDIF
    SET current to head
    FOR i from 1 to k
        SET current to current.next
    ENDFOR
    SET newHead to current
    SET tail.next to null
    SET current to head
    WHILE current.next is not null
        SET current to current.next
    ENDWHILE
    SET current.next to head
    SET head to newHead
    RETURN head
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    SET visited as new Set
    WHILE current is not null AND current not in visited
        ADD current to visited
        APPEND current.value to result
        IF current.next is not head THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of test cases (list values, k)
    FOR each testCase in testCases
        PRINT test case details
        CALL rotateList(testCase.head, testCase.k)
        PRINT rotated list using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-67"><a class="header" href="#algorithm-steps-67">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>rotateList</code>:
a. If the list is empty or has one node, return head (no rotation needed).
b. Find the list length and tail by traversing until <code>tail.next</code> is head.
c. Compute effective k as <code>k mod length</code> to handle large k.
d. If k=0, return head (no rotation needed).
e. Traverse k steps from head to find the new head.
f. Break the cycle by setting old tail’s <code>next</code> to null.
g. Find new tail (node before new head), set its <code>next</code> to old head.
h. Set head to new head, return it.</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse from head, use a Set to avoid cycling, append values with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with different list sizes (empty, single-node, multi-node) and k values (0, equal to length, greater than length).</li>
</ol>
<h2 id="java-implementation-90"><a class="header" href="#java-implementation-90">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class RotateCircularLinkedList {
    // Node class for the circular linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Rotates the circular linked list by k positions
    public Node rotateList(Node head, int k) {
        if (head == null || head.next == head) {
            return head;
        }
        // Find length and tail
        int length = 1;
        Node tail = head;
        while (tail.next != head) {
            length++;
            tail = tail.next;
        }
        // Normalize k
        k = k % length;
        if (k == 0) {
            return head;
        }
        // Find new head
        Node current = head;
        for (int i = 0; i &lt; k; i++) {
            current = current.next;
        }
        Node newHead = current;
        // Break cycle
        tail.next = null;
        // Find new tail (node before newHead)
        current = head;
        while (current.next != null) {
            current = current.next;
        }
        // Reconnect to form new cycle
        current.next = head;
        head = newHead;
        return head;
    }

    // Converts circular linked list to string
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
        while (current != null &amp;&amp; !visited.contains(current)) {
            visited.add(current);
            result.append(current.value);
            if (current.next != head) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;
        int k;

        TestCase(int[] values, int k) {
            this.k = k;
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
            // Make circular
            current.next = head;
        }
    }

    // Main method to test circular linked list rotation
    public static void main(String[] args) {
        RotateCircularLinkedList rotator = new RotateCircularLinkedList();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4}, 2),     // Multi-node, k &lt; length
            new TestCase(new int[]{}, 1),               // Empty list
            new TestCase(new int[]{5}, 3),             // Single node
            new TestCase(new int[]{1, 2, 3}, 3),       // k = length
            new TestCase(new int[]{1, 2, 3, 4, 5}, 7)  // k &gt; length
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + rotator.toString(test.head));
            System.out.println("Rotate by k=" + test.k);
            Node rotated = rotator.rotateList(test.head, test.k);
            System.out.println("Rotated list: " + rotator.toString(rotated) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-67"><a class="header" href="#output-67">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4
Rotate by k=2
Rotated list: 3 4 1 2

Test case 2:
Input list: []
Rotate by k=1
Rotated list: []

Test case 3:
Input list: 5
Rotate by k=3
Rotated list: 5

Test case 4:
Input list: 1 2 3
Rotate by k=3
Rotated list: 1 2 3

Test case 5:
Input list: 1 2 3 4 5
Rotate by k=7
Rotated list: 3 4 5 1 2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Rotates 1→2→3→4→1 by k=2, new head=3, outputs "3 4 1 2".</li>
<li>Test case 2: Empty list, no rotation, outputs "[]".</li>
<li>Test case 3: Single node 5→5, k=3, no change, outputs "5".</li>
<li>Test case 4: Rotates 1→2→3→1 by k=3 (length), no change, outputs "1 2 3".</li>
<li>Test case 5: Rotates 1→2→3→4→5→1 by k=7 (7 mod 5 = 2), new head=3, outputs "3 4 5 1 2".</li>
</ul>
<h2 id="how-it-works-91"><a class="header" href="#how-it-works-91">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a <code>next</code> pointer.</li>
<li><strong>rotateList</strong>:
<ul>
<li>Handles edge cases: empty list or single node returns unchanged.</li>
<li>Finds list length and tail by traversing to the node where <code>next</code>=head.</li>
<li>Normalizes k using <code>k mod length</code> to handle large k.</li>
<li>If k=0, returns head.</li>
<li>Traverses k steps to find new head.</li>
<li>Breaks cycle at old tail, reconnects new tail to old head.</li>
</ul>
</li>
<li><strong>toString</strong>: Traverses from head, uses a Set to prevent cycling, returns space-separated string or "[]".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→4→1, k=2.</li>
<li>length=4, tail=4, k=2.</li>
<li>current=3 (after 2 steps).</li>
<li>newHead=3, tail.next=null → 1→2→3, 4.</li>
<li>new tail=2, 2.next=1, head=3.</li>
<li>Result: 3→4→1→2→3, outputs "3 4 1 2".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests multi-node, empty, single-node, k=length, and k&gt;length cases.</li>
</ul>
<h2 id="complexity-analysis-table-90"><a class="header" href="#complexity-analysis-table-90">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Rotate List</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for rotateList (traverse to find length and new head); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for rotateList (constant pointers); O(n) for toString (StringBuilder and Set).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Normalize k using modulo list length to handle large k efficiently. Use a tail pointer to simplify cycle reconnection after rotation.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the cycle is broken and reconnected correctly to avoid infinite loops. Handle edge cases like empty lists or k=0 to prevent unnecessary operations.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="round-robin-scheduler"><a class="header" href="#round-robin-scheduler">Round-Robin Scheduler</a></h1>
<h2 id="problem-statement-68"><a class="header" href="#problem-statement-68">Problem Statement</a></h2>
<p>Write a Java program that simulates a round-robin scheduler using a circular linked list. Each node in the list represents a task with a string name. The scheduler should support adding tasks (insert at tail), cycling to the next task (move head to next node), and removing the current task (delete head), maintaining the circular structure. The program should track the current task (head) and handle operations in a round-robin fashion, where cycling moves to the next task in sequence. Test the implementation with sequences of operations, including adding tasks, cycling through them, removing tasks, and handling edge cases like empty lists and single-task lists. You can visualize this as a circular queue of tasks in a CPU scheduler, where tasks are processed one after another in a loop, and completed tasks are removed.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sequence of operations, where each operation is:
<ul>
<li><code>addTask(task)</code>: Add a task (string) at the tail of the list.</li>
<li><code>cycle()</code>: Move to the next task, return its name or "null" if empty.</li>
<li><code>removeTask()</code>: Remove the current task (head), return its name or "null" if empty.</li>
<li><code>printTasks()</code>: Print the list of tasks from the current head until just before it cycles.
<strong>Output</strong>: For each operation, print the action performed (e.g., "Added task", "Cycled to task", "Removed task", or the task list). Return "null" for cycle or remove on an empty list.
<strong>Constraints</strong>:</li>
</ul>
</li>
<li>The list size is between 0 and 10^5.</li>
<li>Task names are non-empty strings of length up to 100 characters.</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: Operations = [addTask("Task1"), addTask("Task2"), addTask("Task3"), printTasks, cycle, printTasks, removeTask, printTasks]</li>
<li>Output:
<pre><code>Added Task1
Added Task2
Added Task3
Tasks: Task1 Task2 Task3
Cycled to Task2
Tasks: Task2 Task3 Task1
Removed Task2
Tasks: Task3 Task1
</code></pre>
</li>
<li>Input: Operations = [cycle, printTasks]</li>
<li>Output:
<pre><code>Cycled to null
Tasks: []
</code></pre>
</li>
</ul>
<h2 id="pseudocode-68"><a class="header" href="#pseudocode-68">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET task to string
    SET next to Node (null by default)
ENDCLASS

CLASS RoundRobinScheduler
    SET head to null

    FUNCTION addTask(task)
        CREATE newNode as new Node(task)
        IF head is null THEN
            SET head to newNode
            SET newNode.next to head
        ELSE
            SET current to head
            WHILE current.next is not head
                SET current to current.next
            ENDWHILE
            SET current.next to newNode
            SET newNode.next to head
        ENDIF
    ENDFUNCTION

    FUNCTION cycle()
        IF head is null THEN
            RETURN "null"
        ENDIF
        SET head to head.next
        RETURN head.task
    ENDFUNCTION

    FUNCTION removeTask()
        IF head is null THEN
            RETURN "null"
        ENDIF
        IF head.next is head THEN
            SET task to head.task
            SET head to null
            RETURN task
        ENDIF
        SET task to head.task
        SET current to head
        WHILE current.next is not head
            SET current to current.next
        ENDWHILE
        SET current.next to head.next
        SET head to head.next
        RETURN task
    ENDFUNCTION

    FUNCTION toString()
        IF head is null THEN
            RETURN "[]"
        ENDIF
        CREATE result as new StringBuilder
        SET current to head
        SET visited as new Set
        WHILE current is not null AND current not in visited
            ADD current to visited
            APPEND current.task to result
            IF current.next is not head THEN
                APPEND " " to result
            ENDIF
            SET current to current.next
        ENDWHILE
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION testScheduler(operations)
    CREATE scheduler as new RoundRobinScheduler
    FOR each operation in operations
        IF operation.type equals "addTask" THEN
            CALL scheduler.addTask(operation.task)
            PRINT added task
        ELSE IF operation.type equals "cycle" THEN
            SET task to scheduler.cycle()
            PRINT cycled to task
        ELSE IF operation.type equals "removeTask" THEN
            SET task to scheduler.removeTask()
            PRINT removed task
        ELSE IF operation.type equals "print" THEN
            PRINT tasks using scheduler.toString
        ENDIF
    ENDFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testScheduler(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-68"><a class="header" href="#algorithm-steps-68">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. A string <code>task</code> for the task name.
b. A <code>next</code> pointer to the next node.</li>
<li>Define a <code>RoundRobinScheduler</code> class with:
a. A <code>head</code> pointer to track the current task.
b. <code>addTask</code>: Add node at tail, connect to head to maintain cycle.
c. <code>cycle</code>: Move head to next node, return task name or "null".
d. <code>removeTask</code>: Remove head, update cycle, return task name or "null".
e. <code>toString</code>: Print tasks from head until cycle, return "[]" if empty.</li>
<li>In <code>testScheduler</code>:
a. Create a <code>RoundRobinScheduler</code>.
b. For each operation:
<ul>
<li><code>addTask</code>: Call <code>addTask</code>, print action.</li>
<li><code>cycle</code>: Call <code>cycle</code>, print task name.</li>
<li><code>removeTask</code>: Call <code>removeTask</code>, print task name.</li>
<li><code>print</code>: Call <code>toString</code>, print task list.</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences including adds, cycles, removes, and edge cases.</li>
</ol>
<h2 id="java-implementation-91"><a class="header" href="#java-implementation-91">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class RoundRobinScheduler {
    // Node class for the circular linked list
    static class Node {
        String task;
        Node next;

        Node(String task) {
            this.task = task;
            this.next = null;
        }
    }

    // RoundRobinScheduler class to simulate task scheduling
    static class Scheduler {
        private Node head;

        public void addTask(String task) {
            Node newNode = new Node(task);
            if (head == null) {
                head = newNode;
                newNode.next = head;
            } else {
                Node current = head;
                while (current.next != head) {
                    current = current.next;
                }
                current.next = newNode;
                newNode.next = head;
            }
        }

        public String cycle() {
            if (head == null) {
                return "null";
            }
            head = head.next;
            return head.task;
        }

        public String removeTask() {
            if (head == null) {
                return "null";
            }
            String task = head.task;
            if (head.next == head) {
                head = null;
                return task;
            }
            Node current = head;
            while (current.next != head) {
                current = current.next;
            }
            current.next = head.next;
            head = head.next;
            return task;
        }

        public String toString() {
            if (head == null) {
                return "[]";
            }
            StringBuilder result = new StringBuilder();
            Node current = head;
            Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
            while (current != null &amp;&amp; !visited.contains(current)) {
                visited.add(current);
                result.append(current.task);
                if (current.next != head) {
                    result.append(" ");
                }
                current = current.next;
            }
            return result.toString();
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String task;

        Operation(String type, String task) {
            this.type = type;
            this.task = task;
        }
    }

    // Tests round-robin scheduler operations
    public void testScheduler(List&lt;Operation&gt; operations) {
        Scheduler scheduler = new Scheduler();
        for (Operation op : operations) {
            if (op.type.equals("addTask")) {
                scheduler.addTask(op.task);
                System.out.println("Added " + op.task);
            } else if (op.type.equals("cycle")) {
                String task = scheduler.cycle();
                System.out.println("Cycled to " + task);
            } else if (op.type.equals("removeTask")) {
                String task = scheduler.removeTask();
                System.out.println("Removed " + task);
            } else if (op.type.equals("print")) {
                System.out.println("Tasks: " + scheduler.toString());
            }
        }
    }

    // Main method to test round-robin scheduler
    public static void main(String[] args) {
        RoundRobinScheduler manager = new RoundRobinScheduler();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();
        
        // Test case 1: Normal operations
        testCases.add(Arrays.asList(
            new Operation("addTask", "Task1"),
            new Operation("addTask", "Task2"),
            new Operation("addTask", "Task3"),
            new Operation("print", null),
            new Operation("cycle", null),
            new Operation("print", null),
            new Operation("removeTask", null),
            new Operation("print", null)
        ));
        
        // Test case 2: Empty list
        testCases.add(Arrays.asList(
            new Operation("cycle", null),
            new Operation("removeTask", null),
            new Operation("print", null)
        ));
        
        // Test case 3: Single task
        testCases.add(Arrays.asList(
            new Operation("addTask", "Task1"),
            new Operation("print", null),
            new Operation("cycle", null),
            new Operation("print", null),
            new Operation("removeTask", null),
            new Operation("print", null)
        ));
        
        // Test case 4: Multiple cycles and removes
        testCases.add(Arrays.asList(
            new Operation("addTask", "Task1"),
            new Operation("addTask", "Task2"),
            new Operation("addTask", "Task3"),
            new Operation("cycle", null),
            new Operation("cycle", null),
            new Operation("print", null),
            new Operation("removeTask", null),
            new Operation("print", null)
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            manager.testScheduler(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-68"><a class="header" href="#output-68">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Added Task1
Added Task2
Added Task3
Tasks: Task1 Task2 Task3
Cycled to Task2
Tasks: Task2 Task3 Task1
Removed Task2
Tasks: Task3 Task1

Test case 2:
Cycled to null
Removed null
Tasks: []

Test case 3:
Added Task1
Tasks: Task1
Cycled to Task1
Tasks: Task1
Removed Task1
Tasks: []

Test case 4:
Added Task1
Added Task2
Added Task3
Cycled to Task2
Cycled to Task3
Tasks: Task3 Task1 Task2
Removed Task3
Tasks: Task1 Task2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Adds Task1, Task2, Task3, prints "Task1 Task2 Task3", cycles to Task2, prints "Task2 Task3 Task1", removes Task2, prints "Task3 Task1".</li>
<li>Test case 2: Cycles and removes on empty list, prints "null" and "[]".</li>
<li>Test case 3: Adds Task1, prints "Task1", cycles to Task1, prints "Task1", removes Task1, prints "[]".</li>
<li>Test case 4: Adds Task1, Task2, Task3, cycles twice to Task3, prints "Task3 Task1 Task2", removes Task3, prints "Task1 Task2".</li>
</ul>
<h2 id="how-it-works-92"><a class="header" href="#how-it-works-92">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores a string task name and a <code>next</code> pointer.</li>
<li><strong>Scheduler</strong>:
<ul>
<li><code>addTask</code>: Adds node at tail, connects to head, O(n).</li>
<li><code>cycle</code>: Moves head to next node, returns task or "null", O(1).</li>
<li><code>removeTask</code>: Removes head, updates cycle, returns task or "null", O(n).</li>
<li><code>toString</code>: Traverses from head, uses Set to prevent cycling, returns space-separated string or "[]".</li>
</ul>
</li>
<li><strong>testScheduler</strong>: Executes operations, printing actions and results.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>addTask("Task1"): head=Task1→Task1.</li>
<li>addTask("Task2"): head=Task1→Task2→Task1.</li>
<li>addTask("Task3"): head=Task1→Task2→Task3→Task1.</li>
<li>print: "Task1 Task2 Task3".</li>
<li>cycle: head=Task2, returns "Task2".</li>
<li>print: "Task2 Task3 Task1".</li>
<li>removeTask: Removes Task2, head=Task3→Task1→Task3, returns "Task2".</li>
<li>print: "Task3 Task1".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal operations, empty list, single task, and multiple cycles/removes.</li>
</ul>
<h2 id="complexity-analysis-table-91"><a class="header" href="#complexity-analysis-table-91">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Add Task</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>Cycle</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>Remove Task</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for addTask and removeTask (traverse to tail); O(1) for cycle; O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for addTask, cycle, removeTask (constant pointers); O(n) for toString (StringBuilder and Set).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a circular linked list to naturally model the round-robin cycling behavior. Maintain the head pointer to track the current task and ensure the tail connects to the head for circularity.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Update <code>next</code> pointers carefully during task removal to maintain the circular structure. Handle edge cases like empty lists and single-task lists to avoid null pointer issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="split-circular-list"><a class="header" href="#split-circular-list">Split Circular List</a></h1>
<h2 id="problem-statement-69"><a class="header" href="#problem-statement-69">Problem Statement</a></h2>
<p>Write a Java program that splits a circular linked list into two circular linked lists of roughly equal size. A circular linked list is a singly linked list where the last node’s <code>next</code> pointer points to the head, forming a cycle. The splitting should divide the nodes as evenly as possible, with one list having at most one more node than the other for odd-sized lists, and each resulting list maintaining its circular structure. Test the implementation with even-sized lists, odd-sized lists, empty lists, and single-node lists. You can visualize this as dividing a ring of numbered beads into two smaller rings, each containing about half the beads, with both rings remaining closed loops.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A circular linked list of integers (e.g., 1→2→3→4→1, where 4→1 forms the cycle).
<strong>Output</strong>: Two circular linked lists as strings, listing nodes from each head until just before it cycles (e.g., "1 2" and "3 4" for the input above).
<strong>Constraints</strong>:</li>
<li>The list size is between 0 and 10^5.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>The list may be empty.
<strong>Example</strong>:</li>
<li>Input: List = 1→2→3→4→1</li>
<li>Output: First list: "1 2", Second list: "3 4"</li>
<li>Explanation: Splits into two circular lists of 2 nodes each: 1→2→1 and 3→4→3.</li>
<li>Input: List = 1→2→3→1</li>
<li>Output: First list: "1 2", Second list: "3"</li>
<li>Explanation: Splits into 1→2→1 (2 nodes) and 3→3 (1 node).</li>
<li>Input: List = []</li>
<li>Output: First list: "[]", Second list: "[]"</li>
<li>Explanation: Empty list splits into two empty lists.</li>
</ul>
<h2 id="pseudocode-69"><a class="header" href="#pseudocode-69">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

FUNCTION splitList(head)
    IF head is null THEN
        RETURN (null, null)
    ENDIF
    IF head.next is head THEN
        RETURN (head, null)
    ENDIF
    SET length to 1
    SET tail to head
    WHILE tail.next is not head
        INCREMENT length
        SET tail to tail.next
    ENDWHILE
    SET splitPoint to length / 2
    SET current to head
    FOR i from 1 to splitPoint - 1
        SET current to current.next
    ENDFOR
    SET firstHead to head
    SET secondHead to current.next
    SET secondTail to tail
    SET firstTail to current
    SET firstTail.next to firstHead
    SET secondTail.next to secondHead
    RETURN (firstHead, secondHead)
ENDFUNCTION

FUNCTION toString(head)
    IF head is null THEN
        RETURN "[]"
    ENDIF
    CREATE result as new StringBuilder
    SET current to head
    SET visited as new Set
    WHILE current is not null AND current not in visited
        ADD current to visited
        APPEND current.value to result
        IF current.next is not head THEN
            APPEND " " to result
        ENDIF
        SET current to current.next
    ENDWHILE
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of circular linked lists
    FOR each testCase in testCases
        PRINT test case details
        CALL splitList(testCase.head)
        PRINT first and second lists using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-69"><a class="header" href="#algorithm-steps-69">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. A <code>next</code> pointer to the next node.</li>
<li>In <code>splitList</code>:
a. If the list is empty, return (null, null).
b. If the list has one node, return (head, null).
c. Find the list length and tail by traversing until <code>tail.next</code> is head.
d. Compute split point as <code>length / 2</code>.
e. Traverse to the node before the split point (first list’s tail).
f. Set first list’s head and tail, second list’s head and tail.
g. Connect first list’s tail to its head, second list’s tail to its head.
h. Return (firstHead, secondHead).</li>
<li>In <code>toString</code>:
a. If head is null, return "[]".
b. Traverse from head, use a Set to avoid cycling, append values with spaces.
c. Return the string representation.</li>
<li>In <code>main</code>, test with even-sized, odd-sized, empty, and single-node circular lists.</li>
</ol>
<h2 id="java-implementation-92"><a class="header" href="#java-implementation-92">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class SplitCircularLinkedList {
    // Node class for the circular linked list
    static class Node {
        int value;
        Node next;

        Node(int value) {
            this.value = value;
            this.next = null;
        }
    }

    // Splits the circular linked list into two circular lists
    public Node[] splitList(Node head) {
        Node[] result = new Node[2];
        if (head == null) {
            result[0] = null;
            result[1] = null;
            return result;
        }
        if (head.next == head) {
            result[0] = head;
            result[1] = null;
            return result;
        }
        // Find length and tail
        int length = 1;
        Node tail = head;
        while (tail.next != head) {
            length++;
            tail = tail.next;
        }
        // Find split point
        int splitPoint = length / 2;
        Node current = head;
        for (int i = 0; i &lt; splitPoint - 1; i++) {
            current = current.next;
        }
        // Set heads and tails
        Node firstHead = head;
        Node secondHead = current.next;
        Node firstTail = current;
        Node secondTail = tail;
        // Form two circular lists
        firstTail.next = firstHead;
        secondTail.next = secondHead;
        result[0] = firstHead;
        result[1] = secondHead;
        return result;
    }

    // Converts circular linked list to string
    public String toString(Node head) {
        if (head == null) {
            return "[]";
        }
        StringBuilder result = new StringBuilder();
        Node current = head;
        Set&lt;Node&gt; visited = new HashSet&lt;&gt;();
        while (current != null &amp;&amp; !visited.contains(current)) {
            visited.add(current);
            result.append(current.value);
            if (current.next != head) {
                result.append(" ");
            }
            current = current.next;
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Node head;

        TestCase(int[] values) {
            if (values.length == 0) {
                head = null;
                return;
            }
            head = new Node(values[0]);
            Node current = head;
            for (int i = 1; i &lt; values.length; i++) {
                current.next = new Node(values[i]);
                current = current.next;
            }
            // Make circular
            current.next = head;
        }
    }

    // Main method to test circular linked list splitting
    public static void main(String[] args) {
        SplitCircularLinkedList splitter = new SplitCircularLinkedList();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{1, 2, 3, 4}),     // Even-sized list
            new TestCase(new int[]{1, 2, 3}),        // Odd-sized list
            new TestCase(new int[]{}),               // Empty list
            new TestCase(new int[]{5}),              // Single node
            new TestCase(new int[]{1, 1, 1, 1, 1})   // Odd-sized with duplicates
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            TestCase test = testCases[i];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input list: " + splitter.toString(test.head));
            Node[] result = splitter.splitList(test.head);
            System.out.println("First list: " + splitter.toString(result[0]));
            System.out.println("Second list: " + splitter.toString(result[1]) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-69"><a class="header" href="#output-69">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input list: 1 2 3 4
First list: 1 2
Second list: 3 4

Test case 2:
Input list: 1 2 3
First list: 1 2
Second list: 3

Test case 3:
Input list: []
First list: []
Second list: []

Test case 4:
Input list: 5
First list: 5
Second list: []

Test case 5:
Input list: 1 1 1 1 1
First list: 1 1 1
Second list: 1 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Splits 1→2→3→4→1 into 1→2→1 (2 nodes) and 3→4→3 (2 nodes).</li>
<li>Test case 2: Splits 1→2→3→1 into 1→2→1 (2 nodes) and 3→3 (1 node).</li>
<li>Test case 3: Empty list splits into "[]" and "[]".</li>
<li>Test case 4: Single node 5→5 splits into 5→5 and "[]".</li>
<li>Test case 5: Splits 1→1→1→1→1→1 into 1→1→1→1 (3 nodes) and 1→1→1 (2 nodes).</li>
</ul>
<h2 id="how-it-works-93"><a class="header" href="#how-it-works-93">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and a <code>next</code> pointer.</li>
<li><strong>splitList</strong>:
<ul>
<li>Returns (null, null) for empty lists, (head, null) for single-node lists.</li>
<li>Finds list length and tail by traversing to <code>tail.next</code>=head.</li>
<li>Computes split point as <code>length / 2</code>.</li>
<li>Traverses to the node before the split point (first list’s tail).</li>
<li>Sets first list’s head/tail and second list’s head/tail.</li>
<li>Connects first tail to first head, second tail to second head.</li>
</ul>
</li>
<li><strong>toString</strong>: Traverses from head, uses a Set to prevent cycling, returns space-separated string or "[]".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: 1→2→3→4→1.</li>
<li>length=4, tail=4, splitPoint=2.</li>
<li>current=2 (after 1 step), firstHead=1, firstTail=2, secondHead=3, secondTail=4.</li>
<li>firstTail.next=firstHead: 1→2→1.</li>
<li>secondTail.next=secondHead: 3→4→3.</li>
<li>Returns (1, 3), outputs "1 2" and "3 4".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests even-sized, odd-sized, empty, single-node, and duplicate lists.</li>
</ul>
<h2 id="complexity-analysis-table-92"><a class="header" href="#complexity-analysis-table-92">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Split List</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the list.</li>
<li>Time complexity: O(n) for splitList (traverse to find length and split point); O(n) for toString (traverse list).</li>
<li>Space complexity: O(1) for splitList (constant pointers); O(n) for toString (StringBuilder and Set).</li>
<li>Worst case: O(n) time, O(n) space for output with large lists.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Split</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-problem-solving-with-dsa"><a class="header" href="#hashing-problem-solving-with-dsa">Hashing Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-6"><a class="header" href="#-what-you-will-learn-6">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="collision-analysis"><a class="header" href="#collision-analysis">Collision Analysis</a></h1>
<h2 id="problem-statement-70"><a class="header" href="#problem-statement-70">Problem Statement</a></h2>
<p>Write a Java program that implements a custom hash table to track the number of collisions, where multiple keys map to the same array index. The hash table should use an array with chaining (linked lists) to handle collisions, with strings as keys and integers as values. A collision occurs when a key hashes to an index that already contains one or more keys. The program should provide methods to insert keys and report the total number of collisions, then test the implementation with different sets of keys, including cases with high collision rates, few collisions, and edge cases like empty sets or single keys. You can visualize this as organizing items into labeled bins, counting how often multiple items land in the same bin due to their labels hashing to the same position.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A set of string keys to insert into the hash table.
<strong>Output</strong>: The number of collisions and the hash table contents (key-value pairs per index).
<strong>Constraints</strong>:</li>
<li>The hash table size (array length) is fixed at 10 for simplicity.</li>
<li>Keys are non-empty strings of up to 100 characters.</li>
<li>Values are integers (e.g., 1 for each key inserted).</li>
<li>The number of keys is between 0 and 10^5.
<strong>Example</strong>:</li>
<li>Input: Keys = ["cat", "act", "dog", "god"]</li>
<li>Output:
<pre><code>Collisions: 2
Hash Table:
Index 0: []
Index 1: []
Index 2: [cat: 1, act: 1]
Index 3: []
Index 4: []
Index 5: [dog: 1, god: 1]
Index 6: []
Index 7: []
Index 8: []
Index 9: []
</code></pre>
</li>
<li>Explanation: "cat" and "act" collide at index 2, "dog" and "god" collide at index 5, resulting in 2 collisions.</li>
<li>Input: Keys = []</li>
<li>Output:
<pre><code>Collisions: 0
Hash Table:
Index 0: []
...
Index 9: []
</code></pre>
</li>
</ul>
<h2 id="pseudocode-70"><a class="header" href="#pseudocode-70">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET key to string
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

CLASS HashTable
    SET table to array of Node pointers (size 10)
    SET collisionCount to 0

    FUNCTION hash(key)
        SET sum to 0
        FOR each character in key
            ADD character ASCII value to sum
        ENDFOR
        RETURN sum mod 10
    ENDFUNCTION

    FUNCTION insert(key, value)
        SET index to hash(key)
        IF table[index] is null THEN
            SET table[index] to new Node(key, value)
        ELSE
            INCREMENT collisionCount
            SET current to table[index]
            WHILE current is not null
                IF current.key equals key THEN
                    SET current.value to value
                    RETURN
                ENDIF
                SET current to current.next
            ENDWHILE
            CREATE newNode as new Node(key, value)
            SET newNode.next to table[index]
            SET table[index] to newNode
        ENDIF
    ENDFUNCTION

    FUNCTION getCollisionCount()
        RETURN collisionCount
    ENDFUNCTION

    FUNCTION toString()
        CREATE result as new StringBuilder
        FOR i from 0 to table size - 1
            APPEND "Index " and i and ": [" to result
            SET current to table[i]
            WHILE current is not null
                APPEND current.key and ": " and current.value to result
                IF current.next is not null THEN
                    APPEND ", " to result
                ENDIF
                SET current to current.next
            ENDWHILE
            APPEND "]" to result
            IF i is not last index THEN
                APPEND newline to result
            ENDIF
        ENDFOR
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION main()
    SET testCases to array of key sets
    FOR each testCase in testCases
        PRINT test case details
        CREATE hashTable as new HashTable
        FOR each key in testCase
            CALL hashTable.insert(key, 1)
        ENDFOR
        PRINT collision count
        PRINT hash table contents using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-70"><a class="header" href="#algorithm-steps-70">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. A string <code>key</code>.
b. An integer <code>value</code>.
c. A <code>next</code> pointer for chaining.</li>
<li>Define a <code>HashTable</code> class with:
a. A fixed-size array (<code>table</code>) of size 10.
b. A <code>collisionCount</code> to track collisions.
c. <code>hash</code>: Compute index by summing ASCII values of key characters modulo 10.
d. <code>insert</code>: Insert key-value pair, increment <code>collisionCount</code> if index is occupied, handle duplicates.
e. <code>getCollisionCount</code>: Return collision count.
f. <code>toString</code>: Print key-value pairs per index.</li>
<li>In <code>main</code>, test with key sets:
a. Keys with collisions (e.g., anagrams).
b. Keys with no collisions.
c. Empty set.
d. Single key.
e. Large set with high collision rate.</li>
</ol>
<h2 id="java-implementation-93"><a class="header" href="#java-implementation-93">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class CollisionAnalysis {
    // Node class for chaining
    static class Node {
        String key;
        int value;
        Node next;

        Node(String key, int value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }

    // Custom hash table with collision tracking
    static class HashTable {
        private Node[] table;
        private int collisionCount;

        public HashTable() {
            table = new Node[10];
            collisionCount = 0;
        }

        private int hash(String key) {
            int sum = 0;
            for (char c : key.toCharArray()) {
                sum += c;
            }
            return sum % 10;
        }

        public void insert(String key, int value) {
            int index = hash(key);
            if (table[index] == null) {
                table[index] = new Node(key, value);
            } else {
                collisionCount++;
                Node current = table[index];
                while (current != null) {
                    if (current.key.equals(key)) {
                        current.value = value;
                        return;
                    }
                    current = current.next;
                }
                Node newNode = new Node(key, value);
                newNode.next = table[index];
                table[index] = newNode;
            }
        }

        public int getCollisionCount() {
            return collisionCount;
        }

        public String toString() {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i &lt; table.length; i++) {
                result.append("Index ").append(i).append(": [");
                Node current = table[i];
                while (current != null) {
                    result.append(current.key).append(": ").append(current.value);
                    if (current.next != null) {
                        result.append(", ");
                    }
                    current = current.next;
                }
                result.append("]");
                if (i &lt; table.length - 1) {
                    result.append("\n");
                }
            }
            return result.toString();
        }
    }

    // Main method to test collision analysis
    public static void main(String[] args) {
        CollisionAnalysis analyzer = new CollisionAnalysis();

        // Test cases
        String[][] testCases = {
            {"cat", "act", "dog", "god"},           // High collisions (anagrams)
            {"apple", "banana", "cherry"},          // No collisions
            {},                                     // Empty set
            {"single"},                             // Single key
            {"key1", "key2", "key3", "key4", "key5", "yek1", "yek2"} // High collisions
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input keys: " + Arrays.toString(testCases[i]));
            HashTable hashTable = new HashTable();
            for (String key : testCases[i]) {
                hashTable.insert(key, 1);
            }
            System.out.println("Collisions: " + hashTable.getCollisionCount());
            System.out.println("Hash Table:\n" + hashTable.toString() + "\n");
        }
    }
}
</code></pre>
<h2 id="output-70"><a class="header" href="#output-70">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input keys: [cat, act, dog, god]
Collisions: 2
Hash Table:
Index 0: []
Index 1: []
Index 2: [act: 1, cat: 1]
Index 3: []
Index 4: []
Index 5: [god: 1, dog: 1]
Index 6: []
Index 7: []
Index 8: []
Index 9: []

Test case 2:
Input keys: [apple, banana, cherry]
Collisions: 0
Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: [cherry: 1]
Index 5: []
Index 6: []
Index 7: [apple: 1]
Index 8: []
Index 9: [banana: 1]

Test case 3:
Input keys: []
Collisions: 0
Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: []
Index 8: []
Index 9: []

Test case 4:
Input keys: [single]
Collisions: 0
Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: [single: 1]
Index 7: []
Index 8: []
Index 9: []

Test case 5:
Input keys: [key1, key2, key3, key4, key5, yek1, yek2]
Collisions: 4
Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: [key5: 1, key4: 1, key3: 1]
Index 5: []
Index 6: []
Index 7: []
Index 8: []
Index 9: [yek2: 1, yek1: 1, key2: 1, key1: 1]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: "cat" and "act" collide at index 2, "dog" and "god" at index 5 (2 collisions).</li>
<li>Test case 2: No collisions, keys map to distinct indices.</li>
<li>Test case 3: Empty set, no collisions.</li>
<li>Test case 4: Single key, no collisions.</li>
<li>Test case 5: Multiple keys collide at indices 4 and 9 (4 collisions).</li>
</ul>
<h2 id="how-it-works-94"><a class="header" href="#how-it-works-94">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores a string key, integer value, and <code>next</code> pointer for chaining.</li>
<li><strong>HashTable</strong>:
<ul>
<li>Uses a fixed-size array (size 10) with linked lists for chaining.</li>
<li><code>hash</code>: Sums ASCII values of key characters modulo 10.</li>
<li><code>insert</code>: Inserts key-value pair, increments <code>collisionCount</code> if index occupied, updates value for duplicates.</li>
<li><code>getCollisionCount</code>: Returns collision count.</li>
<li><code>toString</code>: Prints key-value pairs per index.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Insert "cat": index=2, table[2]=[cat:1], collisions=0.</li>
<li>Insert "act": index=2, table[2]=[act:1,cat:1], collisions=1.</li>
<li>Insert "dog": index=5, table[5]=[dog:1], collisions=1.</li>
<li>Insert "god": index=5, table[5]=[god:1,dog:1], collisions=2.</li>
<li>Output: Collisions=2, table shows lists at indices 2 and 5.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests high collisions, no collisions, empty set, single key, and large set.</li>
</ul>
<h2 id="complexity-analysis-table-93"><a class="header" href="#complexity-analysis-table-93">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert</td><td>O(1) average</td><td>O(1)</td></tr>
<tr><td>Get Collision Count</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of keys in the hash table.</li>
<li>Time complexity: O(1) average for insert (hashing and list insertion); O(1) for getCollisionCount; O(n) for toString (iterate all keys).</li>
<li>Space complexity: O(1) for insert and getCollisionCount; O(n) for toString (StringBuilder output).</li>
<li>Worst case: O(n) time for insert (many keys in one index), O(n) space for toString.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a simple hash function for educational purposes, but ensure it distributes keys evenly to minimize collisions. Track collisions by incrementing a counter when an index is already occupied.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: A poor hash function (e.g., summing ASCII values) may cause excessive collisions. Test with diverse key sets to verify collision behavior, and handle duplicates to avoid redundant entries.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="custom-hash-function"><a class="header" href="#custom-hash-function">Custom Hash Function</a></h1>
<h2 id="problem-statement-71"><a class="header" href="#problem-statement-71">Problem Statement</a></h2>
<p>Write a Java program that implements a custom hash function for strings of exactly 3 alphabetic characters (e.g., "abc", "xyz") and integrates it into a hash table using an array with chaining (linked lists) to handle collisions. The hash table should store strings as keys and integers as values. The program should also implement a hash function using Java’s default <code>hashCode</code> method for comparison, tracking the number of collisions (when multiple keys map to the same array index) for both hash functions. Test the implementation with sets of 3-character string keys, comparing collision counts between the custom hash function and <code>hashCode</code>, including edge cases like empty sets, single keys, or identical keys. You can visualize this as organizing 3-letter tags into a fixed number of bins, comparing how two different labeling systems distribute tags and how often multiple tags land in the same bin.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A set of strings, each exactly 3 alphabetic characters, to insert into the hash table.
<strong>Output</strong>: The number of collisions for both the custom hash function and Java’s <code>hashCode</code>, and the hash table contents (key-value pairs per index) for both.
<strong>Constraints</strong>:</li>
<li>The hash table size (array length) is fixed at 10.</li>
<li>Keys are strings of exactly 3 alphabetic characters (a-z, A-Z).</li>
<li>Values are integers (e.g., 1 for each key inserted).</li>
<li>The number of keys is between 0 and 10^5.
<strong>Example</strong>:</li>
<li>Input: Keys = ["abc", "cba", "def", "fed"]</li>
<li>Output:
<pre><code>Custom Hash Collisions: 2
Custom Hash Table:
Index 0: []
Index 1: []
Index 2: [cba: 1, abc: 1]
Index 3: []
Index 4: []
Index 5: [fed: 1, def: 1]
Index 6: []
Index 7: []
Index 8: []
Index 9: []
hashCode Collisions: 0
hashCode Hash Table:
Index 0: [fed: 1]
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: [abc: 1]
Index 7: [def: 1]
Index 8: []
Index 9: [cba: 1]
</code></pre>
</li>
<li>Explanation: Custom hash causes 2 collisions ("abc"/"cba" at index 2, "def"/"fed" at index 5); <code>hashCode</code> causes 0 collisions.</li>
</ul>
<h2 id="pseudocode-71"><a class="header" href="#pseudocode-71">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET key to string
    SET value to integer
    SET next to Node (null by default)
ENDCLASS

CLASS HashTable
    SET table to array of Node pointers (size 10)
    SET collisionCount to 0

    FUNCTION customHash(key)
        SET sum to 0
        FOR i from 0 to 2
            SET sum to sum * 31 + (lowercase(key[i]) - 'a' + 1)
        ENDFOR
        RETURN absolute(sum) mod 10
    ENDFUNCTION

    FUNCTION hashCodeHash(key)
        RETURN absolute(key.hashCode()) mod 10
    ENDFUNCTION

    FUNCTION insert(key, value, useCustomHash)
        IF length of key is not 3 OR key contains non-alphabetic characters THEN
            RETURN
        ENDIF
        SET index to customHash(key) if useCustomHash else hashCodeHash(key)
        IF table[index] is null THEN
            SET table[index] to new Node(key, value)
        ELSE
            INCREMENT collisionCount
            SET current to table[index]
            WHILE current is not null
                IF current.key equals key THEN
                    SET current.value to value
                    RETURN
                ENDIF
                SET current to current.next
            ENDWHILE
            CREATE newNode as new Node(key, value)
            SET newNode.next to table[index]
            SET table[index] to newNode
        ENDIF
    ENDFUNCTION

    FUNCTION getCollisionCount()
        RETURN collisionCount
    ENDFUNCTION

    FUNCTION toString()
        CREATE result as new StringBuilder
        FOR i from 0 to table size - 1
            APPEND "Index " and i and ": [" to result
            SET current to table[i]
            WHILE current is not null
                APPEND current.key and ": " and current.value to result
                IF current.next is not null THEN
                    APPEND ", " to result
                ENDIF
                SET current to current.next
            ENDWHILE
            APPEND "]" to result
            IF i is not last index THEN
                APPEND newline to result
            ENDIF
        ENDFOR
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION main()
    SET testCases to array of key sets
    FOR each testCase in testCases
        PRINT test case details
        CREATE customHashTable as new HashTable
        CREATE hashCodeTable as new HashTable
        FOR each key in testCase
            IF key is valid THEN
                CALL customHashTable.insert(key, 1, true)
                CALL hashCodeTable.insert(key, 1, false)
            ENDIF
        ENDFOR
        PRINT custom hash collision count
        PRINT custom hash table contents
        PRINT hashCode collision count
        PRINT hashCode hash table contents
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-71"><a class="header" href="#algorithm-steps-71">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. A string <code>key</code> (3 alphabetic characters).
b. An integer <code>value</code>.
c. A <code>next</code> pointer for chaining.</li>
<li>Define a <code>HashTable</code> class with:
a. A fixed-size array (<code>table</code>) of size 10.
b. A <code>collisionCount</code> to track collisions.
c. <code>customHash</code>: Polynomial rolling hash (e.g., sum = sum * 31 + (char - 'a' + 1)) modulo 10.
d. <code>hashCodeHash</code>: Uses Java’s <code>hashCode</code> modulo 10.
e. <code>insert</code>: Validates key, computes index, increments <code>collisionCount</code> if index occupied, handles duplicates.
f. <code>getCollisionCount</code>: Returns collision count.
g. <code>toString</code>: Prints key-value pairs per index.</li>
<li>In <code>main</code>, test with key sets:
a. Keys causing collisions (e.g., anagrams like "abc", "cba").
b. Keys with no collisions.
c. Empty set.
d. Single key.
e. Repeated keys.</li>
</ol>
<h2 id="java-implementation-94"><a class="header" href="#java-implementation-94">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class CustomHashFunction {
    // Node class for chaining
    static class Node {
        String key;
        int value;
        Node next;

        Node(String key, int value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }

    // Custom hash table with collision tracking
    static class HashTable {
        private Node[] table;
        private int collisionCount;

        public HashTable() {
            table = new Node[10];
            collisionCount = 0;
        }

        private int customHash(String key) {
            int sum = 0;
            for (int i = 0; i &lt; 3; i++) {
                sum = sum * 31 + (Character.toLowerCase(key.charAt(i)) - 'a' + 1);
            }
            return Math.abs(sum) % 10;
        }

        private int hashCodeHash(String key) {
            return Math.abs(key.hashCode()) % 10;
        }

        public void insert(String key, int value, boolean useCustomHash) {
            if (key.length() != 3 || !key.matches("[a-zA-Z]+")) {
                return;
            }
            int index = useCustomHash ? customHash(key) : hashCodeHash(key);
            if (table[index] == null) {
                table[index] = new Node(key, value);
            } else {
                collisionCount++;
                Node current = table[index];
                while (current != null) {
                    if (current.key.equals(key)) {
                        current.value = value;
                        return;
                    }
                    current = current.next;
                }
                Node newNode = new Node(key, value);
                newNode.next = table[index];
                table[index] = newNode;
            }
        }

        public int getCollisionCount() {
            return collisionCount;
        }

        public String toString() {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i &lt; table.length; i++) {
                result.append("Index ").append(i).append(": [");
                Node current = table[i];
                while (current != null) {
                    result.append(current.key).append(": ").append(current.value);
                    if (current.next != null) {
                        result.append(", ");
                    }
                    current = current.next;
                }
                result.append("]");
                if (i &lt; table.length - 1) {
                    result.append("\n");
                }
            }
            return result.toString();
        }
    }

    // Main method to test custom hash function
    public static void main(String[] args) {
        CustomHashFunction analyzer = new CustomHashFunction();

        // Test cases
        String[][] testCases = {
            {"abc", "cba", "def", "fed"},           // Anagrams, high collisions
            {"xyz", "abc", "def"},                  // No collisions
            {},                                     // Empty set
            {"ghi"},                                // Single key
            {"aaa", "aaa", "aaa"}                   // Repeated keys
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input keys: " + Arrays.toString(testCases[i]));
            HashTable customHashTable = new HashTable();
            HashTable hashCodeTable = new HashTable();
            for (String key : testCases[i]) {
                customHashTable.insert(key, 1, true);
                hashCodeTable.insert(key, 1, false);
            }
            System.out.println("Custom Hash Collisions: " + customHashTable.getCollisionCount());
            System.out.println("Custom Hash Table:\n" + customHashTable.toString());
            System.out.println("hashCode Collisions: " + hashCodeTable.getCollisionCount());
            System.out.println("hashCode Hash Table:\n" + hashCodeTable.toString() + "\n");
        }
    }
}
</code></pre>
<h2 id="output-71"><a class="header" href="#output-71">Output</a></h2>
<p>Running the <code>main</code> method produces (note: exact indices for <code>hashCode</code> may vary due to implementation, but collision counts are illustrative):</p>
<pre><code>Test case 1:
Input keys: [abc, cba, def, fed]
Custom Hash Collisions: 2
Custom Hash Table:
Index 0: []
Index 1: []
Index 2: [cba: 1, abc: 1]
Index 3: []
Index 4: []
Index 5: [fed: 1, def: 1]
Index 6: []
Index 7: []
Index 8: []
Index 9: []
hashCode Collisions: 0
hashCode Hash Table:
Index 0: [fed: 1]
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: [abc: 1]
Index 7: [def: 1]
Index 8: []
Index 9: [cba: 1]

Test case 2:
Input keys: [xyz, abc, def]
Custom Hash Collisions: 0
Custom Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: [def: 1]
Index 5: []
Index 6: []
Index 7: []
Index 8: [abc: 1]
Index 9: [xyz: 1]
hashCode Collisions: 0
hashCode Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: [def: 1]
Index 5: []
Index 6: [abc: 1]
Index 7: []
Index 8: []
Index 9: [xyz: 1]

Test case 3:
Input keys: []
Custom Hash Collisions: 0
Custom Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: []
Index 8: []
Index 9: []
hashCode Collisions: 0
hashCode Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: []
Index 8: []
Index 9: []

Test case 4:
Input keys: [ghi]
Custom Hash Collisions: 0
Custom Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: [ghi: 1]
Index 8: []
Index 9: []
hashCode Collisions: 0
hashCode Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: [ghi: 1]
Index 8: []
Index 9: []

Test case 5:
Input keys: [aaa, aaa, aaa]
Custom Hash Collisions: 2
Custom Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: []
Index 8: []
Index 9: [aaa: 1]
hashCode Collisions: 2
hashCode Hash Table:
Index 0: []
Index 1: []
Index 2: []
Index 3: []
Index 4: []
Index 5: []
Index 6: []
Index 7: []
Index 8: []
Index 9: [aaa: 1]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Custom hash causes 2 collisions ("abc"/"cba", "def"/"fed" at indices 2, 5); <code>hashCode</code> spreads keys evenly, 0 collisions.</li>
<li>Test case 2: Both hash functions distribute keys without collisions.</li>
<li>Test case 3: Empty set, no collisions for either.</li>
<li>Test case 4: Single key, no collisions for either.</li>
<li>Test case 5: Repeated keys cause 2 collisions for both (only one key stored due to duplicates).</li>
</ul>
<h2 id="how-it-works-95"><a class="header" href="#how-it-works-95">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores a 3-character string key, integer value, and <code>next</code> pointer.</li>
<li><strong>HashTable</strong>:
<ul>
<li>Uses a fixed-size array (size 10) with linked lists for chaining.</li>
<li><code>customHash</code>: Polynomial rolling hash (sum = sum * 31 + (char - 'a' + 1)), case-insensitive, modulo 10.</li>
<li><code>hashCodeHash</code>: Uses Java’s <code>hashCode</code> modulo 10.</li>
<li><code>insert</code>: Validates 3-character alphabetic key, computes index, increments <code>collisionCount</code> if index occupied, updates value for duplicates.</li>
<li><code>getCollisionCount</code>: Returns collision count.</li>
<li><code>toString</code>: Prints key-value pairs per index.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1, custom hash)</strong>:
<ul>
<li>Insert "abc": index=2, table[2]=[abc:1], collisions=0.</li>
<li>Insert "cba": index=2, table[2]=[cba:1,abc:1], collisions=1.</li>
<li>Insert "def": index=5, table[5]=[def:1], collisions=1.</li>
<li>Insert "fed": index=5, table[5]=[fed:1,def:1], collisions=2.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests anagrams, no collisions, empty set, single key, and duplicates, comparing collisions.</li>
</ul>
<h2 id="complexity-analysis-table-94"><a class="header" href="#complexity-analysis-table-94">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert</td><td>O(1) average</td><td>O(1)</td></tr>
<tr><td>Get Collision Count</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of keys in the hash table.</li>
<li>Time complexity: O(1) average for insert (hashing and list insertion); O(1) for getCollisionCount; O(n) for toString (iterate all keys).</li>
<li>Space complexity: O(1) for insert and getCollisionCount; O(n) for toString (StringBuilder output).</li>
<li>Worst case: O(n) time for insert (many keys in one index), O(n) space for toString.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Design a custom hash function that leverages the key’s structure (e.g., fixed 3-character strings) to distribute keys evenly. A polynomial rolling hash works well for strings by combining character positions.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate input keys to ensure they match the expected format (3 alphabetic characters). Poor hash functions may lead to excessive collisions, degrading performance to O(n) in worst cases.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="phone-book-application"><a class="header" href="#phone-book-application">Phone Book Application</a></h1>
<h2 id="problem-statement-72"><a class="header" href="#problem-statement-72">Problem Statement</a></h2>
<p>Write a Java program that implements a phone book using a hash table, with contact names as keys and phone numbers as values. The program should support operations to insert a contact (name and phone number), look up a phone number by name, and delete a contact by name. The hash table should handle case-sensitive names and return appropriate messages for operations on non-existent contacts or duplicate insertions. Test the implementation with sequences of operations, including cases with duplicate names, non-existent contacts, and empty phone books. You can visualize this as a digital phone book where you can add, find, or remove a person’s contact details quickly using their name.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sequence of operations, where each operation is:
<ul>
<li><code>insert(name, phoneNumber)</code>: Add a contact, return "Added" or "Name already exists".</li>
<li><code>lookup(name)</code>: Return the phone number or "Not found" if the name doesn’t exist.</li>
<li><code>delete(name)</code>: Remove the contact, return "Deleted" or "Not found".</li>
<li><code>printPhoneBook()</code>: Print all contacts or "Empty" if none exist.
<strong>Output</strong>: For each operation, print the action performed and its result (e.g., "Added John", "Found: 123-456-7890", "Deleted John", or "Empty").
<strong>Constraints</strong>:</li>
</ul>
</li>
<li>The phone book size is between 0 and 10^5 contacts.</li>
<li>Names and phone numbers are non-empty strings of up to 100 characters.</li>
<li>Names are case-sensitive (e.g., "John" and "john" are distinct).</li>
<li>Phone numbers are strings (e.g., "123-456-7890", no specific format required).
<strong>Example</strong>:</li>
<li>Input: Operations = [insert("John", "123-456-7890"), insert("Jane", "987-654-3210"), lookup("John"), delete("Jane"), printPhoneBook]</li>
<li>Output:
<pre><code>Added John
Added Jane
Found: 123-456-7890
Deleted Jane
Phone Book: John: 123-456-7890
</code></pre>
</li>
<li>Input: Operations = [lookup("John"), printPhoneBook]</li>
<li>Output:
<pre><code>Not found
Empty
</code></pre>
</li>
</ul>
<h2 id="pseudocode-72"><a class="header" href="#pseudocode-72">Pseudocode</a></h2>
<pre><code>CLASS PhoneBook
    SET hashTable to new HashMap

    FUNCTION insert(name, phoneNumber)
        IF hashTable contains name THEN
            RETURN "Name already exists"
        ENDIF
        SET hashTable[name] to phoneNumber
        RETURN "Added " + name
    ENDFUNCTION

    FUNCTION lookup(name)
        IF hashTable contains name THEN
            RETURN "Found: " + hashTable[name]
        ENDIF
        RETURN "Not found"
    ENDFUNCTION

    FUNCTION delete(name)
        IF hashTable contains name THEN
            REMOVE hashTable[name]
            RETURN "Deleted " + name
        ENDIF
        RETURN "Not found"
    ENDFUNCTION

    FUNCTION toString()
        IF hashTable is empty THEN
            RETURN "Empty"
        ENDIF
        CREATE result as new StringBuilder
        FOR each entry in hashTable
            APPEND entry.key and ": " and entry.value to result
            IF not last entry THEN
                APPEND ", " to result
            ENDIF
        ENDFOR
        RETURN result as string
    ENDFUNCTION
ENDCLASS

FUNCTION testPhoneBook(operations)
    CREATE phoneBook as new PhoneBook
    FOR each operation in operations
        IF operation.type equals "insert" THEN
            CALL phoneBook.insert(operation.name, operation.phoneNumber)
            PRINT result
        ELSE IF operation.type equals "lookup" THEN
            CALL phoneBook.lookup(operation.name)
            PRINT result
        ELSE IF operation.type equals "delete" THEN
            CALL phoneBook.delete(operation.name)
            PRINT result
        ELSE IF operation.type equals "print" THEN
            PRINT "Phone Book: " + phoneBook.toString
        ENDIF
    ENFOR
ENDFUNCTION

FUNCTION main()
    SET testCases to array of operation sequences
    FOR each testCase in testCases
        PRINT test case details
        CALL testPhoneBook(testCase)
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-72"><a class="header" href="#algorithm-steps-72">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>PhoneBook</code> class with:
a. A <code>HashMap&lt;String, String&gt;</code> to store name-phone number pairs.
b. <code>insert</code>: Add contact if name doesn’t exist, return status.
c. <code>lookup</code>: Return phone number or "Not found".
d. <code>delete</code>: Remove contact by name, return status.
e. <code>toString</code>: Return comma-separated string of contacts or "Empty".</li>
<li>In <code>testPhoneBook</code>:
a. Create a <code>PhoneBook</code> instance.
b. For each operation:
<ul>
<li><code>insert</code>: Call <code>insert</code>, print result.</li>
<li><code>lookup</code>: Call <code>lookup</code>, print result.</li>
<li><code>delete</code>: Call <code>delete</code>, print result.</li>
<li><code>print</code>: Call <code>toString</code>, print phone book.</li>
</ul>
</li>
<li>In <code>main</code>, test with sequences including:
a. Normal operations (insert, lookup, delete).
b. Empty phone book operations.
c. Duplicate name insertion.
d. Lookup and delete non-existent contacts.
e. Single contact operations.</li>
</ol>
<h2 id="java-implementation-95"><a class="header" href="#java-implementation-95">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class PhoneBookApplication {
    // PhoneBook class to manage contacts
    static class PhoneBook {
        private HashMap&lt;String, String&gt; hashTable;

        public PhoneBook() {
            hashTable = new HashMap&lt;&gt;();
        }

        public String insert(String name, String phoneNumber) {
            if (hashTable.containsKey(name)) {
                return "Name already exists";
            }
            hashTable.put(name, phoneNumber);
            return "Added " + name;
        }

        public String lookup(String name) {
            if (hashTable.containsKey(name)) {
                return "Found: " + hashTable.get(name);
            }
            return "Not found";
        }

        public String delete(String name) {
            if (hashTable.containsKey(name)) {
                hashTable.remove(name);
                return "Deleted " + name;
            }
            return "Not found";
        }

        public String toString() {
            if (hashTable.isEmpty()) {
                return "Empty";
            }
            StringBuilder result = new StringBuilder();
            int index = 0;
            for (Map.Entry&lt;String, String&gt; entry : hashTable.entrySet()) {
                result.append(entry.getKey()).append(": ").append(entry.getValue());
                if (index &lt; hashTable.size() - 1) {
                    result.append(", ");
                }
                index++;
            }
            return result.toString();
        }
    }

    // Helper class for operations
    static class Operation {
        String type;
        String name;
        String phoneNumber;

        Operation(String type, String name, String phoneNumber) {
            this.type = type;
            this.name = name;
            this.phoneNumber = phoneNumber;
        }
    }

    // Tests phone book operations
    public void testPhoneBook(List&lt;Operation&gt; operations) {
        PhoneBook phoneBook = new PhoneBook();
        for (Operation op : operations) {
            if (op.type.equals("insert")) {
                System.out.println(phoneBook.insert(op.name, op.phoneNumber));
            } else if (op.type.equals("lookup")) {
                System.out.println(phoneBook.lookup(op.name));
            } else if (op.type.equals("delete")) {
                System.out.println(phoneBook.delete(op.name));
            } else if (op.type.equals("print")) {
                System.out.println("Phone Book: " + phoneBook.toString());
            }
        }
    }

    // Main method to test phone book
    public static void main(String[] args) {
        PhoneBookApplication manager = new PhoneBookApplication();

        // Test cases
        List&lt;List&lt;Operation&gt;&gt; testCases = new ArrayList&lt;&gt;();

        // Test case 1: Normal operations
        testCases.add(Arrays.asList(
            new Operation("insert", "John", "123-456-7890"),
            new Operation("insert", "Jane", "987-654-3210"),
            new Operation("lookup", "John", null),
            new Operation("delete", "Jane", null),
            new Operation("print", null, null)
        ));

        // Test case 2: Empty phone book
        testCases.add(Arrays.asList(
            new Operation("lookup", "John", null),
            new Operation("delete", "John", null),
            new Operation("print", null, null)
        ));

        // Test case 3: Duplicate name
        testCases.add(Arrays.asList(
            new Operation("insert", "Alice", "111-222-3333"),
            new Operation("insert", "Alice", "444-555-6666"),
            new Operation("print", null, null)
        ));

        // Test case 4: Non-existent contact
        testCases.add(Arrays.asList(
            new Operation("insert", "Bob", "222-333-4444"),
            new Operation("lookup", "Charlie", null),
            new Operation("delete", "Charlie", null),
            new Operation("print", null, null)
        ));

        // Test case 5: Single contact
        testCases.add(Arrays.asList(
            new Operation("insert", "Eve", "555-666-7777"),
            new Operation("lookup", "Eve", null),
            new Operation("delete", "Eve", null),
            new Operation("print", null, null)
        ));

        // Run test cases
        for (int i = 0; i &lt; testCases.size(); i++) {
            System.out.println("Test case " + (i + 1) + ":");
            manager.testPhoneBook(testCases.get(i));
            System.out.println();
        }
    }
}
</code></pre>
<h2 id="output-72"><a class="header" href="#output-72">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Added John
Added Jane
Found: 123-456-7890
Deleted Jane
Phone Book: John: 123-456-7890

Test case 2:
Not found
Not found
Phone Book: Empty

Test case 3:
Added Alice
Name already exists
Phone Book: Alice: 111-222-3333

Test case 4:
Added Bob
Not found
Not found
Phone Book: Bob: 222-333-4444

Test case 5:
Added Eve
Found: 555-666-7777
Deleted Eve
Phone Book: Empty
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Adds John and Jane, looks up John, deletes Jane, prints remaining contact.</li>
<li>Test case 2: Attempts lookup and delete on empty phone book, prints "Empty".</li>
<li>Test case 3: Adds Alice, tries to add Alice again (fails), prints single contact.</li>
<li>Test case 4: Adds Bob, tries lookup and delete for non-existent Charlie, prints Bob’s contact.</li>
<li>Test case 5: Adds Eve, looks up Eve, deletes Eve, prints empty phone book.</li>
</ul>
<h2 id="how-it-works-96"><a class="header" href="#how-it-works-96">How It Works</a></h2>
<ul>
<li><strong>PhoneBook</strong>:
<ul>
<li>Uses <code>HashMap&lt;String, String&gt;</code> to store name-phone number pairs.</li>
<li><code>insert</code>: Adds contact if name doesn’t exist, returns status.</li>
<li><code>lookup</code>: Returns phone number or "Not found".</li>
<li><code>delete</code>: Removes contact if name exists, returns status.</li>
<li><code>toString</code>: Returns comma-separated string of contacts or "Empty".</li>
</ul>
</li>
<li><strong>testPhoneBook</strong>: Executes operations, printing results.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>insert("John", "123-456-7890"): hashTable={John:123-456-7890}, returns "Added John".</li>
<li>insert("Jane", "987-654-3210"): hashTable={John:123-456-7890, Jane:987-654-3210}, returns "Added Jane".</li>
<li>lookup("John"): Returns "Found: 123-456-7890".</li>
<li>delete("Jane"): Removes Jane, hashTable={John:123-456-7890}, returns "Deleted Jane".</li>
<li>print: Returns "John: 123-456-7890".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal operations, empty phone book, duplicate names, non-existent contacts, and single contact.</li>
</ul>
<h2 id="complexity-analysis-table-95"><a class="header" href="#complexity-analysis-table-95">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Insert</td><td>O(1) average</td><td>O(1)</td></tr>
<tr><td>Lookup</td><td>O(1) average</td><td>O(1)</td></tr>
<tr><td>Delete</td><td>O(1) average</td><td>O(1)</td></tr>
<tr><td>To String</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of contacts in the phone book.</li>
<li>Time complexity: O(1) average for insert, lookup, delete (HashMap operations); O(n) for toString (iterate all entries).</li>
<li>Space complexity: O(1) for insert, lookup, delete (constant space); O(n) for toString (StringBuilder output).</li>
<li>Worst case: O(n) time and space for toString with large phone books.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a <code>HashMap</code> for fast O(1) average-case operations. Ensure names are treated case-sensitively to avoid confusion between similar names (e.g., "John" vs. "john").</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Check for duplicate names before insertion to prevent overwriting existing contacts. Handle empty phone book cases to avoid null pointer issues during lookup or deletion.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="two-sum-problem"><a class="header" href="#two-sum-problem">Two Sum Problem</a></h1>
<h2 id="problem-statement-73"><a class="header" href="#problem-statement-73">Problem Statement</a></h2>
<p>Write a Java program that uses a hash table to solve the Two Sum problem: given an array of integers and a target sum, find two numbers in the array that add up to the target sum and return their indices. The hash table should store numbers as keys and their indices as values. The solution should assume each input has at most one valid pair of indices and that no number can be used twice. Test the implementation with different arrays and target sums, including cases with no solution, valid solutions, and edge cases like empty arrays or arrays with fewer than two elements. You can visualize this as searching a list of numbers to find a pair of puzzle pieces that fit together to match a specific total.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers and a target sum (integer).
<strong>Output</strong>: An array of two integers representing the indices of the two numbers that sum to the target, or an empty array if no solution exists.
<strong>Constraints</strong>:</li>
<li>The array length is between 0 and 10^5.</li>
<li>Array elements and the target sum are integers in the range [-10^9, 10^9].</li>
<li>Each input has at most one valid solution.</li>
<li>The same element cannot be used twice.
<strong>Example</strong>:</li>
<li>Input: Array = [2, 7, 11, 15], Target = 9</li>
<li>Output: [0, 1]</li>
<li>Explanation: 2 + 7 = 9, indices 0 and 1.</li>
<li>Input: Array = [3, 2, 4], Target = 8</li>
<li>Output: []</li>
<li>Explanation: No pair sums to 8.</li>
<li>Input: Array = [], Target = 5</li>
<li>Output: []</li>
<li>Explanation: Empty array, no solution.</li>
</ul>
<h2 id="pseudocode-73"><a class="header" href="#pseudocode-73">Pseudocode</a></h2>
<pre><code>FUNCTION twoSum(numbers, target)
    CREATE hashTable as new HashMap
    FOR i from 0 to numbers length - 1
        SET complement to target - numbers[i]
        IF hashTable contains complement THEN
            RETURN array of [hashTable[complement], i]
        ENDIF
        SET hashTable[numbers[i]] to i
    ENDFOR
    RETURN empty array
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (numbers, target) pairs
    FOR each testCase in testCases
        PRINT test case details
        CALL twoSum(testCase.numbers, testCase.target)
        PRINT result
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-73"><a class="header" href="#algorithm-steps-73">Algorithm Steps</a></h2>
<ol>
<li>Define <code>twoSum</code>:
a. Create a <code>HashMap&lt;Integer, Integer&gt;</code> to store numbers and their indices.
b. For each number at index i:
<ul>
<li>Compute complement = target - number.</li>
<li>If complement exists in hash table, return [hashTable[complement], i].</li>
<li>Otherwise, add number and its index to hash table.
c. If no solution is found, return empty array.</li>
</ul>
</li>
<li>In <code>main</code>, test with:
a. Arrays with a valid solution.
b. Arrays with no solution.
c. Empty array.
d. Array with one element.
e. Array with duplicate numbers.</li>
</ol>
<h2 id="java-implementation-96"><a class="header" href="#java-implementation-96">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class TwoSumProblem {
    // Solves the Two Sum problem using a hash table
    public int[] twoSum(int[] numbers, int target) {
        HashMap&lt;Integer, Integer&gt; hashTable = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; numbers.length; i++) {
            int complement = target - numbers[i];
            if (hashTable.containsKey(complement)) {
                return new int[] {hashTable.get(complement), i};
            }
            hashTable.put(numbers[i], i);
        }
        return new int[] {};
    }

    // Main method to test Two Sum
    public static void main(String[] args) {
        TwoSumProblem solver = new TwoSumProblem();

        // Test cases
        Object[] testCases = {
            new Object[] {new int[] {2, 7, 11, 15}, 9},    // Valid solution
            new Object[] {new int[] {3, 2, 4}, 8},         // No solution
            new Object[] {new int[] {}, 5},                // Empty array
            new Object[] {new int[] {1}, 2},               // Single element
            new Object[] {new int[] {3, 3}, 6}             // Duplicate numbers
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            int[] numbers = (int[]) ((Object[]) testCases[i])[0];
            int target = (int) ((Object[]) testCases[i])[1];
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input array: " + Arrays.toString(numbers));
            System.out.println("Target sum: " + target);
            int[] result = solver.twoSum(numbers, target);
            System.out.println("Result: " + Arrays.toString(result) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-73"><a class="header" href="#output-73">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input array: [2, 7, 11, 15]
Target sum: 9
Result: [0, 1]

Test case 2:
Input array: [3, 2, 4]
Target sum: 8
Result: []

Test case 3:
Input array: []
Target sum: 5
Result: []

Test case 4:
Input array: [1]
Target sum: 2
Result: []

Test case 5:
Input array: [3, 3]
Target sum: 6
Result: [0, 1]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: 2 + 7 = 9, returns indices [0, 1].</li>
<li>Test case 2: No pair sums to 8, returns [].</li>
<li>Test case 3: Empty array, returns [].</li>
<li>Test case 4: Single element, no pair possible, returns [].</li>
<li>Test case 5: 3 + 3 = 6, returns indices [0, 1].</li>
</ul>
<h2 id="how-it-works-97"><a class="header" href="#how-it-works-97">How It Works</a></h2>
<ul>
<li><strong>twoSum</strong>:
<ul>
<li>Uses a <code>HashMap&lt;Integer, Integer&gt;</code> to store numbers and their indices.</li>
<li>For each number, checks if complement (target - number) exists in hash table.</li>
<li>If found, returns indices of complement and current number.</li>
<li>Otherwise, adds current number and index to hash table.</li>
<li>Returns empty array if no solution is found.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: [2, 7, 11, 15], target=9.</li>
<li>i=0: complement=9-2=7, hashTable={}, add {2:0}.</li>
<li>i=1: complement=9-7=2, hashTable={2:0}, return [0, 1].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests valid solution, no solution, empty array, single element, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-96"><a class="header" href="#complexity-analysis-table-96">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Two Sum</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input array.</li>
<li>Time complexity: O(n) for single pass through array; HashMap operations (put, get) are O(1) average case.</li>
<li>Space complexity: O(n) for storing up to n numbers in HashMap.</li>
<li>Worst case: O(n) time and space when all numbers are processed.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a single-pass approach with a hash table to achieve O(n) time complexity, storing numbers and indices to quickly find the complement.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the solution handles edge cases like empty arrays or arrays with fewer than two elements. Avoid using the same element twice by checking the complement before adding the current number.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="word-frequency-counter"><a class="header" href="#word-frequency-counter">Word Frequency Counter</a></h1>
<h2 id="problem-statement-74"><a class="header" href="#problem-statement-74">Problem Statement</a></h2>
<p>Write a Java program that uses a hash table to count the frequency of words in a given text. The hash table should use words (case-insensitive) as keys and their frequency counts as values. The program should process the input text by splitting it into words, ignoring punctuation, and print the word-frequency pairs in a readable format. Test the implementation with different text inputs, including empty text, single-word text, and text with repeated words. You can visualize this as analyzing a book page to count how often each word appears, storing the results in a dictionary-like structure for quick lookup.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A string of text containing words separated by spaces, punctuation, or other delimiters.
<strong>Output</strong>: A string representation of the hash table’s word-frequency pairs, or "Empty" if no words are present.
<strong>Constraints</strong>:</li>
<li>The text length is between 0 and 10^5 characters.</li>
<li>Words are sequences of alphabetic characters (a-z, A-Z).</li>
<li>Punctuation and non-alphabetic characters are ignored.</li>
<li>Words are case-insensitive (e.g., "The" and "the" are the same).
<strong>Example</strong>:</li>
<li>Input: Text = "The quick brown fox, the quick!"</li>
<li>Output: "the: 2, quick: 2, brown: 1, fox: 1"</li>
<li>Explanation: Words are counted case-insensitively, ignoring punctuation.</li>
<li>Input: Text = ""</li>
<li>Output: "Empty"</li>
<li>Explanation: No words in empty text.</li>
<li>Input: Text = "hello Hello HELLO"</li>
<li>Output: "hello: 3"</li>
<li>Explanation: Case-insensitive, all "hello" variants count as one word.</li>
</ul>
<h2 id="pseudocode-74"><a class="header" href="#pseudocode-74">Pseudocode</a></h2>
<pre><code>FUNCTION countWordFrequencies(text)
    CREATE hashTable as new HashMap
    IF text is empty THEN
        RETURN "Empty"
    ENDIF
    SET words to split text by non-alphabetic characters
    FOR each word in words
        IF word is not empty THEN
            SET word to lowercase(word)
            IF hashTable contains word THEN
                INCREMENT hashTable[word] by 1
            ELSE
                SET hashTable[word] to 1
            ENDIF
        ENDIF
    ENDFOR
    IF hashTable is empty THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FOR each entry in hashTable
        APPEND entry.key and ":" and entry.value to result
        IF not last entry THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of text inputs
    FOR each testCase in testCases
        PRINT test case details
        CALL countWordFrequencies(testCase.text)
        PRINT word frequencies
    ENFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-74"><a class="header" href="#algorithm-steps-74">Algorithm Steps</a></h2>
<ol>
<li>Define <code>countWordFrequencies</code>:
a. Create a <code>HashMap&lt;String, Integer&gt;</code> to store word frequencies.
b. If text is empty, return "Empty".
c. Split text into words using non-alphabetic characters as delimiters.
d. For each non-empty word:
<ul>
<li>Convert to lowercase for case-insensitive counting.</li>
<li>If word exists in hash table, increment its count.</li>
<li>Otherwise, add word with count 1.
e. If hash table is empty, return "Empty".
f. Build a string of word-frequency pairs, separated by commas.</li>
</ul>
</li>
<li>In <code>main</code>, test with different texts:
a. Normal text with repeated words.
b. Empty text.
c. Single-word text.
d. Text with punctuation and mixed case.
e. Text with only non-alphabetic characters.</li>
</ol>
<h2 id="java-implementation-97"><a class="header" href="#java-implementation-97">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class WordFrequencyCounter {
    // Counts word frequencies in the given text
    public String countWordFrequencies(String text) {
        HashMap&lt;String, Integer&gt; hashTable = new HashMap&lt;&gt;();
        if (text == null || text.trim().isEmpty()) {
            return "Empty";
        }
        // Split text into words, ignoring non-alphabetic characters
        String[] words = text.split("[^a-zA-Z]+");
        for (String word : words) {
            if (!word.isEmpty()) {
                word = word.toLowerCase();
                hashTable.put(word, hashTable.getOrDefault(word, 0) + 1);
            }
        }
        if (hashTable.isEmpty()) {
            return "Empty";
        }
        // Build result string
        StringBuilder result = new StringBuilder();
        int index = 0;
        for (Map.Entry&lt;String, Integer&gt; entry : hashTable.entrySet()) {
            result.append(entry.getKey()).append(": ").append(entry.getValue());
            if (index &lt; hashTable.size() - 1) {
                result.append(", ");
            }
            index++;
        }
        return result.toString();
    }

    // Main method to test word frequency counter
    public static void main(String[] args) {
        WordFrequencyCounter counter = new WordFrequencyCounter();

        // Test cases
        String[] testCases = {
            "The quick brown fox, the quick!",           // Normal text with repeats
            "",                                         // Empty text
            "hello Hello HELLO",                        // Case-insensitive repeats
            "hello",                                    // Single word
            "!!! --- 123",                              // No words
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Input text: \"" + testCases[i] + "\"");
            String result = counter.countWordFrequencies(testCases[i]);
            System.out.println("Word frequencies: " + result + "\n");
        }
    }
}
</code></pre>
<h2 id="output-74"><a class="header" href="#output-74">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input text: "The quick brown fox, the quick!"
Word frequencies: the: 2, quick: 2, brown: 1, fox: 1

Test case 2:
Input text: ""
Word frequencies: Empty

Test case 3:
Input text: "hello Hello HELLO"
Word frequencies: hello: 3

Test case 4:
Input text: "hello"
Word frequencies: hello: 1

Test case 5:
Input text: "!!! --- 123"
Word frequencies: Empty
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Counts "the" (2), "quick" (2), "brown" (1), "fox" (1), ignoring punctuation.</li>
<li>Test case 2: Empty text returns "Empty".</li>
<li>Test case 3: Counts "hello" (3) case-insensitively.</li>
<li>Test case 4: Single word "hello" has frequency 1.</li>
<li>Test case 5: No alphabetic words, returns "Empty".</li>
</ul>
<h2 id="how-it-works-98"><a class="header" href="#how-it-works-98">How It Works</a></h2>
<ul>
<li><strong>countWordFrequencies</strong>:
<ul>
<li>Creates a <code>HashMap&lt;String, Integer&gt;</code> for word frequencies.</li>
<li>Handles null or empty text by returning "Empty".</li>
<li>Splits text using regex <code>[^a-zA-Z]+</code> to ignore non-alphabetic characters.</li>
<li>Processes each non-empty word:
<ul>
<li>Converts to lowercase.</li>
<li>Updates count in hash table using <code>getOrDefault</code>.</li>
</ul>
</li>
<li>Builds a comma-separated string of word-frequency pairs or returns "Empty" if none.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Input: "The quick brown fox, the quick!".</li>
<li>Split: ["The", "quick", "brown", "fox", "the", "quick"].</li>
<li>Process: hashTable={the:2, quick:2, brown:1, fox:1}.</li>
<li>Output: "the: 2, quick: 2, brown: 1, fox: 1".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests normal text, empty text, repeated words, single word, and non-alphabetic text.</li>
</ul>
<h2 id="complexity-analysis-table-97"><a class="header" href="#complexity-analysis-table-97">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>Count Frequencies</td><td>O(n)</td><td>O(m)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the length of the input text (characters).</li>
<li>m is the number of unique words.</li>
<li>Time complexity: O(n) for splitting and processing text; HashMap operations (put, get) are O(1) average case.</li>
<li>Space complexity: O(m) for HashMap storing unique words; O(n) for output string in worst case.</li>
<li>Worst case: O(n) time, O(n) space for many unique words or long output.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a regular expression like <code>[^a-zA-Z]+</code> to split text and handle punctuation effectively. Convert words to lowercase to ensure case-insensitive counting.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle edge cases like empty text or non-alphabetic input to avoid empty hash tables. Ensure regex splitting correctly separates words to prevent invalid tokens.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trees-problem-solving-with-dsa"><a class="header" href="#trees-problem-solving-with-dsa">Trees Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-7"><a class="header" href="#-what-you-will-learn-7">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="bst-validator"><a class="header" href="#bst-validator">BST Validator</a></h1>
<h2 id="problem-statement-75"><a class="header" href="#problem-statement-75">Problem Statement</a></h2>
<p>Write a Java program that checks if a given tree is a valid Binary Search Tree (BST). A BST is valid if, for each node, all values in its left subtree are less than the node’s value, and all values in its right subtree are greater than the node’s value. The program should implement a method to validate the tree and test it with at least three different trees, including valid and invalid BSTs, and edge cases like a single node or empty tree. You can visualize this as inspecting a family tree where each parent’s value must be greater than all their left descendants and less than all their right descendants, ensuring the hierarchy follows strict rules.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A binary tree represented by nodes with integer values.
<strong>Output</strong>: A boolean indicating whether the tree is a valid BST, and a string representation of the tree for clarity.
<strong>Constraints</strong>:</li>
<li>The tree has between 0 and 10^5 nodes.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>Duplicate values are not allowed in the BST.
<strong>Example</strong>:</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]]</li>
<li>Output: true, "Preorder: 5 3 1 4 7"</li>
<li>Explanation: All nodes satisfy the BST property.</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [6]], right: [7]]</li>
<li>Output: false, "Preorder: 5 3 1 6 7"</li>
<li>Explanation: Node 6 in the left subtree is greater than 5, violating the BST property.</li>
<li>Input: Tree = []</li>
<li>Output: true, "Empty"</li>
<li>Explanation: An empty tree is a valid BST.</li>
</ul>
<h2 id="pseudocode-75"><a class="header" href="#pseudocode-75">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET left to Node (null by default)
    SET right to Node (null by default)
ENDCLASS

FUNCTION isValidBST(root)
    FUNCTION validate(node, min, max)
        IF node is null THEN
            RETURN true
        ENDIF
        IF node.value &lt;= min OR node.value &gt;= max THEN
            RETURN false
        ENDIF
        RETURN validate(node.left, min, node.value) AND validate(node.right, node.value, max)
    ENDFUNCTION
    RETURN validate(root, negative infinity, positive infinity)
ENDFUNCTION

FUNCTION toString(root)
    IF root is null THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FUNCTION preorder(node)
        IF node is null THEN
            RETURN
        ENDIF
        APPEND node.value and " " to result
        CALL preorder(node.left)
        CALL preorder(node.right)
    ENDFUNCTION
    CALL preorder(root)
    RETURN "Preorder: " + result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of trees
    FOR each testCase in testCases
        PRINT test case details
        CALL isValidBST(testCase.root)
        PRINT result and tree using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-75"><a class="header" href="#algorithm-steps-75">Algorithm Steps</a></h2>
<ol>
<li>Define a <code>Node</code> class with:
a. An integer <code>value</code>.
b. <code>left</code> and <code>right</code> pointers to child nodes.</li>
<li>Define <code>isValidBST</code>:
a. Use a helper function <code>validate(node, min, max)</code> to check if each node’s value is within [min, max].
b. For each node:
<ul>
<li>If null, return true.</li>
<li>If value is not in (min, max), return false.</li>
<li>Recursively validate left subtree with updated max = node.value.</li>
<li>Recursively validate right subtree with updated min = node.value.
c. Call validate with initial min = negative infinity, max = positive infinity.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. If root is null, return "Empty".
b. Perform preorder traversal, appending values to a string.</li>
<li>In <code>main</code>, test with at least three trees:
a. A valid BST.
b. An invalid BST.
c. An empty tree.
d. A single-node tree.</li>
</ol>
<h2 id="java-implementation-98"><a class="header" href="#java-implementation-98">Java Implementation</a></h2>
<pre><code class="language-java">public class BSTValidator {
    // Node class for the binary tree
    static class Node {
        int value;
        Node left, right;

        Node(int value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }

    // Validates if the tree is a BST
    public boolean isValidBST(Node root) {
        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean validate(Node node, long min, long max) {
        if (node == null) {
            return true;
        }
        if (node.value &lt;= min || node.value &gt;= max) {
            return false;
        }
        return validate(node.left, min, node.value) &amp;&amp; validate(node.right, node.value, max);
    }

    // Converts tree to string (preorder traversal)
    public String toString(Node root) {
        if (root == null) {
            return "Empty";
        }
        StringBuilder result = new StringBuilder();
        preorder(root, result);
        return "Preorder: " + result.toString().trim();
    }

    private void preorder(Node node, StringBuilder result) {
        if (node == null) {
            return;
        }
        result.append(node.value).append(" ");
        preorder(node.left, result);
        preorder(node.right, result);
    }

    // Helper class for test cases
    static class TestCase {
        Node root;

        TestCase(int[] values, int[][] edges) {
            if (values.length == 0) {
                root = null;
                return;
            }
            Node[] nodes = new Node[values.length];
            for (int i = 0; i &lt; values.length; i++) {
                nodes[i] = new Node(values[i]);
            }
            for (int[] edge : edges) {
                int parent = edge[0], child = edge[1];
                if (edge[2] == 0) {
                    nodes[parent].left = nodes[child];
                } else {
                    nodes[parent].right = nodes[child];
                }
            }
            root = nodes[0];
        }
    }

    // Main method to test BST validator
    public static void main(String[] args) {
        BSTValidator validator = new BSTValidator();

        // Test cases
        TestCase[] testCases = {
            // Valid BST: [5, left: [3, left: 1, right: 4], right: 7]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}}
            ),
            // Invalid BST: [5, left: [3, left: 1, right: 6], right: 7]
            new TestCase(
                new int[]{5, 3, 1, 6, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}}
            ),
            // Empty tree
            new TestCase(new int[]{}, new int[][]{}),
            // Single node
            new TestCase(new int[]{10}, new int[][]{})
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Tree: " + validator.toString(testCases[i].root));
            boolean isValid = validator.isValidBST(testCases[i].root);
            System.out.println("Is Valid BST: " + isValid + "\n");
        }
    }
}
</code></pre>
<h2 id="output-75"><a class="header" href="#output-75">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Tree: Preorder: 5 3 1 4 7
Is Valid BST: true

Test case 2:
Tree: Preorder: 5 3 1 6 7
Is Valid BST: false

Test case 3:
Tree: Empty
Is Valid BST: true

Test case 4:
Tree: Preorder: 10
Is Valid BST: true
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Tree [5, left: [3, left: 1, right: 4], right: 7] is valid (all left subtree values &lt; node, all right &gt; node).</li>
<li>Test case 2: Tree [5, left: [3, left: 1, right: 6], right: 7] is invalid (6 &gt; 5 in left subtree).</li>
<li>Test case 3: Empty tree is valid by definition.</li>
<li>Test case 4: Single node (10) is valid (no subtrees to violate).</li>
</ul>
<h2 id="how-it-works-99"><a class="header" href="#how-it-works-99">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and pointers to left and right children.</li>
<li><strong>isValidBST</strong>:
<ul>
<li>Uses recursive helper <code>validate</code> with min and max bounds.</li>
<li>Checks if node value is within (min, max).</li>
<li>Updates bounds for left (max = node.value) and right (min = node.value) subtrees.</li>
<li>Returns true for null nodes, false if bounds violated.</li>
</ul>
</li>
<li><strong>toString</strong>: Performs preorder traversal, returns space-separated values or "Empty".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Root=5: validate(5, -∞, +∞) → true.</li>
<li>Left=3: validate(3, -∞, 5) → true.</li>
<li>Left=1: validate(1, -∞, 3) → true.</li>
<li>Right=4: validate(4, 3, 5) → true.</li>
<li>Right=7: validate(7, 5, +∞) → true.</li>
<li>Result: true.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests valid BST, invalid BST, empty tree, and single node.</li>
</ul>
<h2 id="complexity-analysis-table-98"><a class="header" href="#complexity-analysis-table-98">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>isValidBST</td><td>O(n)</td><td>O(h)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(h)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the tree.</li>
<li>h is the height of the tree (O(n) for skewed, O(log n) for balanced).</li>
<li>Time complexity: O(n) for isValidBST and toString (visit each node once).</li>
<li>Space complexity: O(h) for recursion stack in isValidBST and toString.</li>
<li>Worst case: O(n) time and O(n) space for skewed trees.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a range-based validation (min, max) to enforce the BST property recursively. Use <code>long</code> for bounds to handle edge cases with integer values near <code>Integer.MIN_VALUE</code> or <code>MAX_VALUE</code>.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure no duplicate values in the BST, as they violate the strict inequality required. Handle empty trees and single nodes explicitly to avoid incorrect results.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="height-of-bst"><a class="header" href="#height-of-bst">Height of BST</a></h1>
<h2 id="problem-statement-76"><a class="header" href="#problem-statement-76">Problem Statement</a></h2>
<p>Write a Java program that extends a Binary Search Tree (BST) implementation to include a method that computes the height of the tree. The height of a tree is the number of edges on the longest path from the root to a leaf, with an empty tree having a height of -1. The program should reuse the BST node structure and test the height computation with balanced and unbalanced trees, including edge cases like an empty tree and a single-node tree. You can visualize this as measuring the tallest branch of a family tree, counting the number of parent-child connections from the top to the deepest descendant.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A binary search tree represented by nodes with integer values.
<strong>Output</strong>: An integer representing the height of the tree, and a string representation of the tree for clarity.
<strong>Constraints</strong>:</li>
<li>The tree has between 0 and 10^5 nodes.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>Duplicate values are not allowed in the BST.
<strong>Example</strong>:</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]] (balanced)</li>
<li>Output: Height = 2, "Preorder: 5 3 1 4 7"</li>
<li>Explanation: Longest path has 2 edges (e.g., 5→3→1).</li>
<li>Input: Tree = [5, right: [7, right: [9, right: [10]]] (unbalanced, skewed)</li>
<li>Output: Height = 3, "Preorder: 5 7 9 10"</li>
<li>Explanation: Longest path has 3 edges (5→7→9→10).</li>
<li>Input: Tree = []</li>
<li>Output: Height = -1, "Empty"</li>
<li>Explanation: Empty tree has height -1.</li>
</ul>
<h2 id="pseudocode-76"><a class="header" href="#pseudocode-76">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET left to Node (null by default)
    SET right to Node (null by default)
ENDCLASS

FUNCTION getHeight(root)
    IF root is null THEN
        RETURN -1
    ENDIF
    SET leftHeight to getHeight(root.left)
    SET rightHeight to getHeight(root.right)
    RETURN maximum of leftHeight, rightHeight plus 1
ENDFUNCTION

FUNCTION toString(root)
    IF root is null THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FUNCTION preorder(node)
        IF node is null THEN
            RETURN
        ENDIF
        APPEND node.value and " " to result
        CALL preorder(node.left)
        CALL preorder(node.right)
    ENDFUNCTION
    CALL preorder(root)
    RETURN "Preorder: " + result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of trees
    FOR each testCase in testCases
        PRINT test case details
        CALL getHeight(testCase.root)
        PRINT height and tree using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-76"><a class="header" href="#algorithm-steps-76">Algorithm Steps</a></h2>
<ol>
<li>Reuse the <code>Node</code> class with:
a. An integer <code>value</code>.
b. <code>left</code> and <code>right</code> pointers to child nodes.</li>
<li>Define <code>getHeight</code>:
a. If root is null, return -1.
b. Recursively compute the height of the left subtree.
c. Recursively compute the height of the right subtree.
d. Return the maximum of left and right heights plus 1.</li>
<li>Define <code>toString</code>:
a. If root is null, return "Empty".
b. Perform preorder traversal, appending values to a string.</li>
<li>In <code>main</code>, test with:
a. A balanced BST (e.g., complete binary tree).
b. An unbalanced BST (e.g., skewed tree).
c. An empty tree.
d. A single-node tree.</li>
</ol>
<h2 id="java-implementation-99"><a class="header" href="#java-implementation-99">Java Implementation</a></h2>
<pre><code class="language-java">public class HeightOfBST {
    // Node class for the binary search tree
    static class Node {
        int value;
        Node left, right;

        Node(int value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }

    // Computes the height of the BST
    public int getHeight(Node root) {
        if (root == null) {
            return -1;
        }
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }

    // Converts tree to string (preorder traversal)
    public String toString(Node root) {
        if (root == null) {
            return "Empty";
        }
        StringBuilder result = new StringBuilder();
        preorder(root, result);
        return "Preorder: " + result.toString().trim();
    }

    private void preorder(Node node, StringBuilder result) {
        if (node == null) {
            return;
        }
        result.append(node.value).append(" ");
        preorder(node.left, result);
        preorder(node.right, result);
    }

    // Helper class for test cases
    static class TestCase {
        Node root;

        TestCase(int[] values, int[][] edges) {
            if (values.length == 0) {
                root = null;
                return;
            }
            Node[] nodes = new Node[values.length];
            for (int i = 0; i &lt; values.length; i++) {
                nodes[i] = new Node(values[i]);
            }
            for (int[] edge : edges) {
                int parent = edge[0], child = edge[1];
                if (edge[2] == 0) {
                    nodes[parent].left = nodes[child];
                } else {
                    nodes[parent].right = nodes[child];
                }
            }
            root = nodes[0];
        }
    }

    // Main method to test BST height
    public static void main(String[] args) {
        HeightOfBST heightCalculator = new HeightOfBST();

        // Test cases
        TestCase[] testCases = {
            // Balanced BST: [5, left: [3, left: 1, right: 4], right: 7]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}}
            ),
            // Unbalanced BST: [5, right: [7, right: [9, right: 10]]]
            new TestCase(
                new int[]{5, 7, 9, 10},
                new int[][]{{0, 1, 1}, {1, 2, 1}, {2, 3, 1}}
            ),
            // Empty tree
            new TestCase(new int[]{}, new int[][]{}),
            // Single node
            new TestCase(new int[]{10}, new int[][]{})
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Tree: " + heightCalculator.toString(testCases[i].root));
            int height = heightCalculator.getHeight(testCases[i].root);
            System.out.println("Height: " + height + "\n");
        }
    }
}
</code></pre>
<h2 id="output-76"><a class="header" href="#output-76">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Tree: Preorder: 5 3 1 4 7
Height: 2

Test case 2:
Tree: Preorder: 5 7 9 10
Height: 3

Test case 3:
Tree: Empty
Height: -1

Test case 4:
Tree: Preorder: 10
Height: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Balanced BST with root 5, height 2 (path 5→3→1 or 5→3→4).</li>
<li>Test case 2: Unbalanced (skewed) BST, height 3 (path 5→7→9→10).</li>
<li>Test case 3: Empty tree, height -1.</li>
<li>Test case 4: Single node, height 0 (no edges).</li>
</ul>
<h2 id="how-it-works-100"><a class="header" href="#how-it-works-100">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and pointers to left and right children.</li>
<li><strong>getHeight</strong>:
<ul>
<li>Returns -1 for null nodes (empty tree).</li>
<li>Recursively computes heights of left and right subtrees.</li>
<li>Returns maximum of left and right heights plus 1.</li>
</ul>
</li>
<li><strong>toString</strong>: Performs preorder traversal, returns space-separated values or "Empty".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Root=5: leftHeight = getHeight(3), rightHeight = getHeight(7).</li>
<li>Node 3: leftHeight = getHeight(1) = 0, rightHeight = getHeight(4) = 0, return max(0, 0) + 1 = 1.</li>
<li>Node 7: leftHeight = -1, rightHeight = -1, return max(-1, -1) + 1 = 0.</li>
<li>Root: max(1, 0) + 1 = 2.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests balanced BST, unbalanced BST, empty tree, and single node.</li>
</ul>
<h2 id="complexity-analysis-table-99"><a class="header" href="#complexity-analysis-table-99">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>getHeight</td><td>O(n)</td><td>O(h)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(h)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the tree.</li>
<li>h is the height of the tree (O(n) for skewed, O(log n) for balanced).</li>
<li>Time complexity: O(n) for getHeight and toString (visit each node once).</li>
<li>Space complexity: O(h) for recursion stack in getHeight and toString.</li>
<li>Worst case: O(n) time and O(n) space for skewed trees.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursion to compute the height by taking the maximum of left and right subtree heights. Define empty tree height as -1 to align with edge-counting conventions.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null nodes correctly to avoid null pointer exceptions. Be aware that unbalanced trees (e.g., skewed) have higher recursion stack space complexity.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="lowest-common-ancestor"><a class="header" href="#lowest-common-ancestor">Lowest Common Ancestor</a></h1>
<h2 id="problem-statement-77"><a class="header" href="#problem-statement-77">Problem Statement</a></h2>
<p>Write a Java program that extends a Binary Search Tree (BST) implementation to include a method that finds the lowest common ancestor (LCA) of two nodes given their values. The LCA is the deepest node that is an ancestor of both nodes. The program should reuse the BST node structure and test the LCA method with different pairs of values, including cases where both nodes exist, one or both don’t exist, and edge cases like empty trees or single-node trees. The BST property (left subtree values &lt; node value &lt; right subtree values) should be leveraged for efficiency. You can visualize this as finding the closest common ancestor in a family tree for two individuals, using the ordered structure to navigate efficiently.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A BST represented by nodes with integer values.</li>
<li>Two integer values, <code>value1</code> and <code>value2</code>, representing the nodes to find the LCA for.
<strong>Output</strong>: The value of the LCA node, or -1 if the LCA cannot be determined (e.g., one or both values don’t exist), and a string representation of the tree for clarity.
<strong>Constraints</strong>:</li>
<li>The tree has between 0 and 10^5 nodes.</li>
<li>Node values, <code>value1</code>, and <code>value2</code> are integers in the range [-10^9, 10^9].</li>
<li>Duplicate values are not allowed in the BST.
<strong>Example</strong>:</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]], Values = [1, 4]</li>
<li>Output: LCA = 3, "Preorder: 5 3 1 4 7"</li>
<li>Explanation: Node 3 is the LCA of nodes 1 and 4 (deepest common ancestor).</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]], Values = [1, 6]</li>
<li>Output: LCA = -1, "Preorder: 5 3 1 4 7"</li>
<li>Explanation: Node 6 doesn’t exist, so no LCA.</li>
<li>Input: Tree = [], Values = [1, 2]</li>
<li>Output: LCA = -1, "Empty"</li>
<li>Explanation: Empty tree, no LCA.</li>
</ul>
<h2 id="pseudocode-77"><a class="header" href="#pseudocode-77">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET left to Node (null by default)
    SET right to Node (null by default)
ENDCLASS

FUNCTION findLCA(root, value1, value2)
    FUNCTION exists(node, value)
        IF node is null THEN
            RETURN false
        ENDIF
        IF node.value equals value THEN
            RETURN true
        ENDIF
        IF value &lt; node.value THEN
            RETURN exists(node.left, value)
        ELSE
            RETURN exists(node.right, value)
        ENDIF
    ENDFUNCTION
    IF root is null OR NOT exists(root, value1) OR NOT exists(root, value2) THEN
        RETURN -1
    ENDIF
    SET current to root
    WHILE current is not null
        IF value1 &lt; current.value AND value2 &lt; current.value THEN
            SET current to current.left
        ELSE IF value1 &gt; current.value AND value2 &gt; current.value THEN
            SET current to current.right
        ELSE
            RETURN current.value
        ENDIF
    ENDWHILE
    RETURN -1
ENDFUNCTION

FUNCTION toString(root)
    IF root is null THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FUNCTION preorder(node)
        IF node is null THEN
            RETURN
        ENDIF
        APPEND node.value and " " to result
        CALL preorder(node.left)
        CALL preorder(node.right)
    ENDFUNCTION
    CALL preorder(root)
    RETURN "Preorder: " + result as string trimmed
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (tree, value1, value2) pairs
    FOR each testCase in testCases
        PRINT test case details
        CALL findLCA(testCase.root, testCase.value1, testCase.value2)
        PRINT LCA and tree using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-77"><a class="header" href="#algorithm-steps-77">Algorithm Steps</a></h2>
<ol>
<li>Reuse the <code>Node</code> class with:
a. An integer <code>value</code>.
b. <code>left</code> and <code>right</code> pointers to child nodes.</li>
<li>Define <code>findLCA</code>:
a. Check if both <code>value1</code> and <code>value2</code> exist in the tree using a helper function <code>exists</code>.
b. If the tree is empty or either value doesn’t exist, return -1.
c. Iteratively traverse from the root:
<ul>
<li>If both values are less than the current node’s value, move to the left child.</li>
<li>If both values are greater than the current node’s value, move to the right child.</li>
<li>Otherwise, the current node is the LCA (values split or one matches the node).
d. Return the LCA’s value, or -1 if not found.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. If root is null, return "Empty".
b. Perform preorder traversal, appending values to a string.</li>
<li>In <code>main</code>, test with:
a. A pair where both nodes exist (LCA in subtree).
b. A pair where one node doesn’t exist.
c. An empty tree.
d. A single-node tree with matching and non-matching pairs.</li>
</ol>
<h2 id="java-implementation-100"><a class="header" href="#java-implementation-100">Java Implementation</a></h2>
<pre><code class="language-java">public class LowestCommonAncestor {
    // Node class for the binary search tree
    static class Node {
        int value;
        Node left, right;

        Node(int value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }

    // Finds the lowest common ancestor of two values
    public int findLCA(Node root, int value1, int value2) {
        // Helper function to check if a value exists in the BST
        boolean exists(Node node, int value) {
            if (node == null) {
                return false;
            }
            if (node.value == value) {
                return true;
            }
            if (value &lt; node.value) {
                return exists(node.left, value);
            } else {
                return exists(node.right, value);
            }
        }

        // Check if both values exist
        if (root == null || !exists(root, value1) || !exists(root, value2)) {
            return -1;
        }

        // Iterative LCA search
        Node current = root;
        while (current != null) {
            if (value1 &lt; current.value &amp;&amp; value2 &lt; current.value) {
                current = current.left;
            } else if (value1 &gt; current.value &amp;&amp; value2 &gt; current.value) {
                current = current.right;
            } else {
                return current.value;
            }
        }
        return -1;
    }

    // Converts tree to string (preorder traversal)
    public String toString(Node root) {
        if (root == null) {
            return "Empty";
        }
        StringBuilder result = new StringBuilder();
        preorder(root, result);
        return "Preorder: " + result.toString().trim();
    }

    private void preorder(Node node, StringBuilder result) {
        if (node == null) {
            return;
        }
        result.append(node.value).append(" ");
        preorder(node.left, result);
        preorder(node.right, result);
    }

    // Helper class for test cases
    static class TestCase {
        Node root;
        int value1, value2;

        TestCase(int[] values, int[][] edges, int value1, int value2) {
            this.value1 = value1;
            this.value2 = value2;
            if (values.length == 0) {
                root = null;
                return;
            }
            Node[] nodes = new Node[values.length];
            for (int i = 0; i &lt; values.length; i++) {
                nodes[i] = new Node(values[i]);
            }
            for (int[] edge : edges) {
                int parent = edge[0], child = edge[1];
                if (edge[2] == 0) {
                    nodes[parent].left = nodes[child];
                } else {
                    nodes[parent].right = nodes[child];
                }
            }
            root = nodes[0];
        }
    }

    // Main method to test LCA
    public static void main(String[] args) {
        LowestCommonAncestor lcaFinder = new LowestCommonAncestor();

        // Test cases
        TestCase[] testCases = {
            // Both nodes exist: [5, left: [3, left: 1, right: 4], right: 7], values [1, 4]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}},
                1, 4
            ),
            // One node doesn’t exist: [5, left: [3, left: 1, right: 4], right: 7], values [1, 6]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}},
                1, 6
            ),
            // Empty tree: [], values [1, 2]
            new TestCase(new int[]{}, new int[][]{}, 1, 2),
            // Single node, matching pair: [10], values [10, 10]
            new TestCase(new int[]{10}, new int[][]{}, 10, 10),
            // Single node, non-matching pair: [10], values [10, 20]
            new TestCase(new int[]{10}, new int[][]{}, 10, 20)
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Tree: " + lcaFinder.toString(testCases[i].root));
            System.out.println("Values: [" + testCases[i].value1 + ", " + testCases[i].value2 + "]");
            int lca = lcaFinder.findLCA(testCases[i].root, testCases[i].value1, testCases[i].value2);
            System.out.println("LCA: " + lca + "\n");
        }
    }
}
</code></pre>
<h2 id="output-77"><a class="header" href="#output-77">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Tree: Preorder: 5 3 1 4 7
Values: [1, 4]
LCA: 3

Test case 2:
Tree: Preorder: 5 3 1 4 7
Values: [1, 6]
LCA: -1

Test case 3:
Tree: Empty
Values: [1, 2]
LCA: -1

Test case 4:
Tree: Preorder: 10
Values: [10, 10]
LCA: 10

Test case 5:
Tree: Preorder: 10
Values: [10, 20]
LCA: -1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: LCA of 1 and 4 is 3 (deepest common ancestor).</li>
<li>Test case 2: Node 6 doesn’t exist, so LCA is -1.</li>
<li>Test case 3: Empty tree, LCA is -1.</li>
<li>Test case 4: Both values are 10, LCA is 10 (same node).</li>
<li>Test case 5: Node 20 doesn’t exist, LCA is -1.</li>
</ul>
<h2 id="how-it-works-101"><a class="header" href="#how-it-works-101">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and pointers to left and right children.</li>
<li><strong>findLCA</strong>:
<ul>
<li>Uses <code>exists</code> helper to verify both <code>value1</code> and <code>value2</code> are in the tree.</li>
<li>If tree is empty or either value is missing, returns -1.</li>
<li>Iteratively traverses: if both values are less than current node, go left; if both greater, go right; otherwise, current node is LCA.</li>
</ul>
</li>
<li><strong>toString</strong>: Performs preorder traversal, returns space-separated values or "Empty".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Verify 1 and 4 exist: true.</li>
<li>Root=5: 1 &lt; 5, 4 &lt; 5, go left.</li>
<li>Node=3: 1 ≤ 3, 4 &gt; 3, return 3 (split point).</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests existing nodes, non-existing node, empty tree, single node with matching and non-matching pairs.</li>
</ul>
<h2 id="complexity-analysis-table-100"><a class="header" href="#complexity-analysis-table-100">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>findLCA</td><td>O(h)</td><td>O(h)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(h)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the tree.</li>
<li>h is the height of the tree (O(n) for skewed, O(log n) for balanced).</li>
<li>Time complexity: O(h) for findLCA (traverse to LCA and check existence); O(n) for toString (visit all nodes).</li>
<li>Space complexity: O(h) for recursion stack in exists and toString.</li>
<li>Worst case: O(n) time and O(n) space for skewed trees.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Leverage the BST property to find the LCA efficiently by moving left or right based on both values’ relation to the current node. Verify node existence to handle invalid inputs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure both values exist in the tree before computing the LCA to avoid incorrect results. Handle edge cases like empty trees or identical values correctly.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="preorder-and-postorder-traversals"><a class="header" href="#preorder-and-postorder-traversals">Preorder and Postorder Traversals</a></h1>
<h2 id="problem-statement-78"><a class="header" href="#problem-statement-78">Problem Statement</a></h2>
<p>Write a Java program that extends a Binary Search Tree (BST) implementation to include methods for preorder (root, left, right) and postorder (left, right, root) traversals. The program should reuse the BST node structure and print the results of both traversals for sample trees, including balanced, unbalanced, empty, and single-node trees. The traversals should output node values in the respective orders as space-separated strings. You can visualize this as exploring a family tree in two different ways: preorder visits the parent before children, while postorder visits children before the parent, listing their names in the order visited.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A BST represented by nodes with integer values.
<strong>Output</strong>: Two strings representing the preorder and postorder traversals of the tree, each containing space-separated node values, or "Empty" for an empty tree.
<strong>Constraints</strong>:</li>
<li>The tree has between 0 and 10^5 nodes.</li>
<li>Node values are integers in the range [-10^9, 10^9].</li>
<li>Duplicate values are not allowed in the BST.
<strong>Example</strong>:</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]]</li>
<li>Output:
<ul>
<li>Preorder: "5 3 1 4 7"</li>
<li>Postorder: "1 4 3 7 5"</li>
</ul>
</li>
<li>Explanation: Preorder visits root first (5), then left (3, 1, 4), then right (7); postorder visits left (1, 4), then right (7), then root (5).</li>
<li>Input: Tree = []</li>
<li>Output:
<ul>
<li>Preorder: "Empty"</li>
<li>Postorder: "Empty"</li>
</ul>
</li>
<li>Explanation: Empty tree has no nodes to traverse.</li>
</ul>
<h2 id="pseudocode-78"><a class="header" href="#pseudocode-78">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET left to Node (null by default)
    SET right to Node (null by default)
ENDCLASS

FUNCTION preorderTraversal(root)
    IF root is null THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FUNCTION preorder(node)
        IF node is null THEN
            RETURN
        ENDIF
        APPEND node.value and " " to result
        CALL preorder(node.left)
        CALL preorder(node.right)
    ENDFUNCTION
    CALL preorder(root)
    RETURN result as string trimmed
ENDFUNCTION

FUNCTION postorderTraversal(root)
    IF root is null THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FUNCTION postorder(node)
        IF node is null THEN
            RETURN
        ENDIF
        CALL postorder(node.left)
        CALL postorder(node.right)
        APPEND node.value and " " to result
    ENDFUNCTION
    CALL postorder(root)
    RETURN result as string trimmed
ENDFUNCTION

FUNCTION main()
    SET testCases to array of trees
    FOR each testCase in testCases
        PRINT test case details
        CALL preorderTraversal(testCase.root)
        CALL postorderTraversal(testCase.root)
        PRINT preorder and postorder results
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-78"><a class="header" href="#algorithm-steps-78">Algorithm Steps</a></h2>
<ol>
<li>Reuse the <code>Node</code> class with:
a. An integer <code>value</code>.
b. <code>left</code> and <code>right</code> pointers to child nodes.</li>
<li>Define <code>preorderTraversal</code>:
a. If root is null, return "Empty".
b. Use a helper function to:
<ul>
<li>Append node value.</li>
<li>Recurse on left subtree.</li>
<li>Recurse on right subtree.
c. Return trimmed result string.</li>
</ul>
</li>
<li>Define <code>postorderTraversal</code>:
a. If root is null, return "Empty".
b. Use a helper function to:
<ul>
<li>Recurse on left subtree.</li>
<li>Recurse on right subtree.</li>
<li>Append node value.
c. Return trimmed result string.</li>
</ul>
</li>
<li>In <code>main</code>, test with:
a. A balanced BST.
b. An unbalanced (skewed) BST.
c. An empty tree.
d. A single-node tree.</li>
</ol>
<h2 id="java-implementation-101"><a class="header" href="#java-implementation-101">Java Implementation</a></h2>
<pre><code class="language-java">public class PreorderPostorderTraversals {
    // Node class for the binary search tree
    static class Node {
        int value;
        Node left, right;

        Node(int value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }

    // Performs preorder traversal (root, left, right)
    public String preorderTraversal(Node root) {
        if (root == null) {
            return "Empty";
        }
        StringBuilder result = new StringBuilder();
        preorder(root, result);
        return result.toString().trim();
    }

    private void preorder(Node node, StringBuilder result) {
        if (node == null) {
            return;
        }
        result.append(node.value).append(" ");
        preorder(node.left, result);
        preorder(node.right, result);
    }

    // Performs postorder traversal (left, right, root)
    public String postorderTraversal(Node root) {
        if (root == null) {
            return "Empty";
        }
        StringBuilder result = new StringBuilder();
        postorder(root, result);
        return result.toString().trim();
    }

    private void postorder(Node node, StringBuilder result) {
        if (node == null) {
            return;
        }
        postorder(node.left, result);
        postorder(node.right, result);
        result.append(node.value).append(" ");
    }

    // Helper class for test cases
    static class TestCase {
        Node root;

        TestCase(int[] values, int[][] edges) {
            if (values.length == 0) {
                root = null;
                return;
            }
            Node[] nodes = new Node[values.length];
            for (int i = 0; i &lt; values.length; i++) {
                nodes[i] = new Node(values[i]);
            }
            for (int[] edge : edges) {
                int parent = edge[0], child = edge[1];
                if (edge[2] == 0) {
                    nodes[parent].left = nodes[child];
                } else {
                    nodes[parent].right = nodes[child];
                }
            }
            root = nodes[0];
        }
    }

    // Main method to test traversals
    public static void main(String[] args) {
        PreorderPostorderTraversals traverser = new PreorderPostorderTraversals();

        // Test cases
        TestCase[] testCases = {
            // Balanced BST: [5, left: [3, left: 1, right: 4], right: 7]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}}
            ),
            // Unbalanced BST: [5, right: [7, right: [9, right: 10]]]
            new TestCase(
                new int[]{5, 7, 9, 10},
                new int[][]{{0, 1, 1}, {1, 2, 1}, {2, 3, 1}}
            ),
            // Empty tree
            new TestCase(new int[]{}, new int[][]{}),
            // Single node
            new TestCase(new int[]{10}, new int[][]{})
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Preorder: " + traverser.preorderTraversal(testCases[i].root));
            System.out.println("Postorder: " + traverser.postorderTraversal(testCases[i].root) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-78"><a class="header" href="#output-78">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Preorder: 5 3 1 4 7
Postorder: 1 4 3 7 5

Test case 2:
Preorder: 5 7 9 10
Postorder: 10 9 7 5

Test case 3:
Preorder: Empty
Postorder: Empty

Test case 4:
Preorder: 10
Postorder: 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Balanced BST, preorder visits root (5), left (3, 1, 4), right (7); postorder visits left (1, 4), right (7), root (5).</li>
<li>Test case 2: Unbalanced (skewed) BST, preorder visits 5, 7, 9, 10; postorder visits 10, 9, 7, 5.</li>
<li>Test case 3: Empty tree, both traversals return "Empty".</li>
<li>Test case 4: Single node, both traversals return "10".</li>
</ul>
<h2 id="how-it-works-102"><a class="header" href="#how-it-works-102">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and pointers to left and right children.</li>
<li><strong>preorderTraversal</strong>:
<ul>
<li>Returns "Empty" for null root.</li>
<li>Appends root value, recurses on left, then right.</li>
</ul>
</li>
<li><strong>postorderTraversal</strong>:
<ul>
<li>Returns "Empty" for null root.</li>
<li>Recurses on left, then right, then appends root value.</li>
</ul>
</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Preorder: Visit 5, left (3, left (1), right (4)), right (7) → "5 3 1 4 7".</li>
<li>Postorder: Left (1, 4), right (7), root (5) → "1 4 3 7 5".</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests balanced BST, unbalanced BST, empty tree, and single node.</li>
</ul>
<h2 id="complexity-analysis-table-101"><a class="header" href="#complexity-analysis-table-101">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>preorderTraversal</td><td>O(n)</td><td>O(h)</td></tr>
<tr><td>postorderTraversal</td><td>O(n)</td><td>O(h)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the tree.</li>
<li>h is the height of the tree (O(n) for skewed, O(log n) for balanced).</li>
<li>Time complexity: O(n) for both traversals (visit each node once).</li>
<li>Space complexity: O(h) for recursion stack.</li>
<li>Worst case: O(n) time and O(n) space for skewed trees.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use recursive traversal methods for simplicity, as they naturally follow the tree’s structure. Preorder is useful for copying a tree, while postorder is useful for deleting a tree.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Handle null nodes to avoid null pointer exceptions. Ensure the output string is trimmed to remove trailing spaces for clean presentation.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="range-sum-query"><a class="header" href="#range-sum-query">Range Sum Query</a></h1>
<h2 id="problem-statement-79"><a class="header" href="#problem-statement-79">Problem Statement</a></h2>
<p>Write a Java program that uses a Binary Search Tree (BST) to find the sum of all node values within a given range (e.g., between 20 and 60, inclusive). The program should use inorder traversal to collect values, leveraging the BST property to optimize by pruning branches outside the range. The implementation should reuse the BST node structure and test the range sum query with various trees and ranges, including edge cases like empty trees, ranges with no values in the tree, and ranges covering all or none of the tree’s values. You can visualize this as summing the ages of family members in a family tree whose ages fall within a specific range, using the tree’s ordered structure to efficiently skip irrelevant branches.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A BST represented by nodes with integer values.</li>
<li>Two integers, <code>low</code> and <code>high</code>, defining the inclusive range [low, high].
<strong>Output</strong>: An integer representing the sum of all node values within [low, high], and a string representation of the tree for clarity.
<strong>Constraints</strong>:</li>
<li>The tree has between 0 and 10^5 nodes.</li>
<li>Node values, <code>low</code>, and <code>high</code> are integers in the range [-10^9, 10^9].</li>
<li>Duplicate values are not allowed in the BST.</li>
<li><code>low</code> ≤ <code>high</code>.
<strong>Example</strong>:</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]], Range = [2, 6]</li>
<li>Output: Sum = 12, "Preorder: 5 3 1 4 7"</li>
<li>Explanation: Values 3, 4, 5 are in [2, 6], sum = 3 + 4 + 5 = 12.</li>
<li>Input: Tree = [5, left: [3, left: [1], right: [4]], right: [7]], Range = [8, 10]</li>
<li>Output: Sum = 0, "Preorder: 5 3 1 4 7"</li>
<li>Explanation: No values in [8, 10], sum = 0.</li>
<li>Input: Tree = [], Range = [1, 5]</li>
<li>Output: Sum = 0, "Empty"</li>
<li>Explanation: Empty tree, sum = 0.</li>
</ul>
<h2 id="pseudocode-79"><a class="header" href="#pseudocode-79">Pseudocode</a></h2>
<pre><code>CLASS Node
    SET value to integer
    SET left to Node (null by default)
    SET right to Node (null by default)
ENDCLASS

FUNCTION rangeSum(root, low, high)
    IF root is null THEN
        RETURN 0
    ENDIF
    IF root.value &lt; low THEN
        RETURN rangeSum(root.right, low, high)
    ENDIF
    IF root.value &gt; high THEN
        RETURN rangeSum(root.left, low, high)
    ENDIF
    RETURN root.value + rangeSum(root.left, low, high) + rangeSum(root.right, low, high)
ENDFUNCTION

FUNCTION toString(root)
    IF root is null THEN
        RETURN "Empty"
    ENDIF
    CREATE result as new StringBuilder
    FUNCTION preorder(node)
        IF node is null THEN
            RETURN
        ENDIF
        APPEND node.value and " " to result
        CALL preorder(node.left)
        CALL preorder(node.right)
    ENDFUNCTION
    CALL preorder(root)
    RETURN "Preorder: " + result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (tree, low, high) pairs
    FOR each testCase in testCases
        PRINT test case details
        CALL rangeSum(testCase.root, testCase.low, testCase.high)
        PRINT sum and tree using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-79"><a class="header" href="#algorithm-steps-79">Algorithm Steps</a></h2>
<ol>
<li>Reuse the <code>Node</code> class with:
a. An integer <code>value</code>.
b. <code>left</code> and <code>right</code> pointers to child nodes.</li>
<li>Define <code>rangeSum</code>:
a. If root is null, return 0.
b. If root.value &lt; low, skip left subtree, recurse on right.
c. If root.value &gt; high, skip right subtree, recurse on left.
d. If root.value is in [low, high], include value and recurse on both subtrees.</li>
<li>Define <code>toString</code>:
a. If root is null, return "Empty".
b. Perform preorder traversal, appending values to a string.</li>
<li>In <code>main</code>, test with:
a. A tree with values in the range.
b. A tree with no values in the range.
c. An empty tree.
d. A range covering all values.
e. A single-node tree.</li>
</ol>
<h2 id="java-implementation-102"><a class="header" href="#java-implementation-102">Java Implementation</a></h2>
<pre><code class="language-java">public class RangeSumQuery {
    // Node class for the binary search tree
    static class Node {
        int value;
        Node left, right;

        Node(int value) {
            this.value = value;
            this.left = null;
            this.right = null;
        }
    }

    // Computes the sum of values in the range [low, high]
    public int rangeSum(Node root, int low, int high) {
        if (root == null) {
            return 0;
        }
        if (root.value &lt; low) {
            return rangeSum(root.right, low, high);
        }
        if (root.value &gt; high) {
            return rangeSum(root.left, low, high);
        }
        return root.value + rangeSum(root.left, low, high) + rangeSum(root.right, low, high);
    }

    // Converts tree to string (preorder traversal)
    public String toString(Node root) {
        if (root == null) {
            return "Empty";
        }
        StringBuilder result = new StringBuilder();
        preorder(root, result);
        return "Preorder: " + result.toString().trim();
    }

    private void preorder(Node node, StringBuilder result) {
        if (node == null) {
            return;
        }
        result.append(node.value).append(" ");
        preorder(node.left, result);
        preorder(node.right, result);
    }

    // Helper class for test cases
    static class TestCase {
        Node root;
        int low, high;

        TestCase(int[] values, int[][] edges, int low, int high) {
            this.low = low;
            this.high = high;
            if (values.length == 0) {
                root = null;
                return;
            }
            Node[] nodes = new Node[values.length];
            for (int i = 0; i &lt; values.length; i++) {
                nodes[i] = new Node(values[i]);
            }
            for (int[] edge : edges) {
                int parent = edge[0], child = edge[1];
                if (edge[2] == 0) {
                    nodes[parent].left = nodes[child];
                } else {
                    nodes[parent].right = nodes[child];
                }
            }
            root = nodes[0];
        }
    }

    // Main method to test range sum query
    public static void main(String[] args) {
        RangeSumQuery query = new RangeSumQuery();

        // Test cases
        TestCase[] testCases = {
            // Values in range: [5, left: [3, left: 1, right: 4], right: 7], range [2, 6]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}},
                2, 6
            ),
            // No values in range: [5, left: [3, left: 1, right: 4], right: 7], range [8, 10]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}},
                8, 10
            ),
            // Empty tree: [], range [1, 5]
            new TestCase(new int[]{}, new int[][]{}, 1, 5),
            // Range covers all: [5, left: [3, left: 1, right: 4], right: 7], range [0, 10]
            new TestCase(
                new int[]{5, 3, 1, 4, 7},
                new int[][]{{0, 1, 0}, {0, 4, 1}, {1, 2, 0}, {1, 3, 1}},
                0, 10
            ),
            // Single node: [10], range [5, 15]
            new TestCase(new int[]{10}, new int[][]{}, 5, 15)
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Tree: " + query.toString(testCases[i].root));
            System.out.println("Range: [" + testCases[i].low + ", " + testCases[i].high + "]");
            int sum = query.rangeSum(testCases[i].root, testCases[i].low, testCases[i].high);
            System.out.println("Sum: " + sum + "\n");
        }
    }
}
</code></pre>
<h2 id="output-79"><a class="header" href="#output-79">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Tree: Preorder: 5 3 1 4 7
Range: [2, 6]
Sum: 12

Test case 2:
Tree: Preorder: 5 3 1 4 7
Range: [8, 10]
Sum: 0

Test case 3:
Tree: Empty
Range: [1, 5]
Sum: 0

Test case 4:
Tree: Preorder: 5 3 1 4 7
Range: [0, 10]
Sum: 20

Test case 5:
Tree: Preorder: 10
Range: [5, 15]
Sum: 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Values 3, 4, 5 are in [2, 6], sum = 3 + 4 + 5 = 12.</li>
<li>Test case 2: No values in [8, 10], sum = 0.</li>
<li>Test case 3: Empty tree, sum = 0.</li>
<li>Test case 4: All values (1, 3, 4, 5, 7) in [0, 10], sum = 1 + 3 + 4 + 5 + 7 = 20.</li>
<li>Test case 5: Single node 10 in [5, 15], sum = 10.</li>
</ul>
<h2 id="how-it-works-103"><a class="header" href="#how-it-works-103">How It Works</a></h2>
<ul>
<li><strong>Node</strong>: Stores an integer value and pointers to left and right children.</li>
<li><strong>rangeSum</strong>:
<ul>
<li>Returns 0 for null nodes.</li>
<li>If root.value &lt; low, skips left subtree, recurses on right.</li>
<li>If root.value &gt; high, skips right subtree, recurses on left.</li>
<li>If root.value in [low, high], includes value and recurses on both subtrees.</li>
</ul>
</li>
<li><strong>toString</strong>: Performs preorder traversal, returns space-separated values or "Empty".</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Root=5: In [2, 6], sum = 5 + rangeSum(left, 2, 6) + rangeSum(right, 2, 6).</li>
<li>Left=3: In [2, 6], sum = 3 + rangeSum(left=1, 2, 6) + rangeSum(right=4, 2, 6).</li>
<li>Left=1: Not in [2, 6], skip left, sum = rangeSum(right=null, 2, 6) = 0.</li>
<li>Right=4: In [2, 6], sum = 4 + rangeSum(null, 2, 6) + rangeSum(null, 2, 6) = 4.</li>
<li>Right=7: &gt; 6, skip right, sum = rangeSum(left=null, 2, 6) = 0.</li>
<li>Total: 5 + (3 + 0 + 4) + 0 = 12.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests range with values, no values, empty tree, all values, and single node.</li>
</ul>
<h2 id="complexity-analysis-table-102"><a class="header" href="#complexity-analysis-table-102">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>rangeSum</td><td>O(n) worst case</td><td>O(h)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(h)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of nodes in the tree.</li>
<li>h is the height of the tree (O(n) for skewed, O(log n) for balanced).</li>
<li>Time complexity: O(n) for rangeSum in worst case (all nodes in range); O(h) in best case (pruning skips subtrees).</li>
<li>Space complexity: O(h) for recursion stack in rangeSum and toString.</li>
<li>Worst case: O(n) time and O(n) space for skewed trees with all nodes in range.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Leverage the BST property to prune branches outside the range, reducing unnecessary traversals. Use inorder traversal logic to ensure values are processed in sorted order.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the range is inclusive ([low, high]) and handle edge cases like empty trees or ranges outside the tree’s values to avoid incorrect sums.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs-problem-solving-with-dsa"><a class="header" href="#graphs-problem-solving-with-dsa">Graphs Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-8"><a class="header" href="#-what-you-will-learn-8">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="cycle-detection-1"><a class="header" href="#cycle-detection-1">Cycle Detection</a></h1>
<h2 id="problem-statement-80"><a class="header" href="#problem-statement-80">Problem Statement</a></h2>
<p>Write a Java program that extends an undirected graph implementation to detect if the graph contains a cycle using Depth-First Search (DFS). A cycle exists if there is a path that starts and ends at the same vertex, passing through at least one other vertex. The program should reuse the adjacency list representation and test cycle detection with cyclic and acyclic graphs, including edge cases like empty graphs and single-vertex graphs. You can visualize this as exploring a network of roads to check if you can loop back to a starting city without retracing steps, ensuring no dead ends create a false cycle.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An undirected graph represented by an adjacency list, with vertices as integers (0 to n-1).</li>
<li>The number of vertices <code>n</code> and a list of edges (pairs of vertices).
<strong>Output</strong>: A boolean indicating whether the graph contains a cycle, and a string representation of the graph’s adjacency list for clarity.
<strong>Constraints</strong>:</li>
<li>The number of vertices <code>n</code> is between 0 and 10^5.</li>
<li>Edges are pairs of integers [u, v] where 0 ≤ u, v &lt; n.</li>
<li>The graph is undirected (edge [u, v] implies [v, u]).
<strong>Example</strong>:</li>
<li>Input: n = 4, edges = [[0, 1], [1, 2], [2, 3], [3, 0]]</li>
<li>Output: Has Cycle = true, "Adjacency List: {0=[1, 3], 1=[0, 2], 2=[1, 3], 3=[2, 0]}"</li>
<li>Explanation: The graph has a cycle (0→1→2→3→0).</li>
<li>Input: n = 4, edges = [[0, 1], [1, 2], [2, 3]]</li>
<li>Output: Has Cycle = false, "Adjacency List: {0=[1], 1=[0, 2], 2=[1, 3], 3=[2]}"</li>
<li>Explanation: The graph is a tree (acyclic).</li>
<li>Input: n = 0, edges = []</li>
<li>Output: Has Cycle = false, "Adjacency List: {}"</li>
<li>Explanation: An empty graph has no cycles.</li>
</ul>
<h2 id="pseudocode-80"><a class="header" href="#pseudocode-80">Pseudocode</a></h2>
<pre><code>FUNCTION createGraph(n, edges)
    CREATE adjList as new HashMap
    FOR i from 0 to n-1
        SET adjList[i] to empty list
    ENDFOR
    FOR each edge [u, v] in edges
        ADD v to adjList[u]
        ADD u to adjList[v]
    ENDFOR
    RETURN adjList
ENDFUNCTION

FUNCTION hasCycle(adjList, n)
    IF n is 0 THEN
        RETURN false
    ENDIF
    CREATE visited as boolean array of size n, initialized to false
    FUNCTION dfs(vertex, parent)
        SET visited[vertex] to true
        FOR each neighbor in adjList[vertex]
            IF NOT visited[neighbor] THEN
                IF dfs(neighbor, vertex) THEN
                    RETURN true
                ENDIF
            ELSE IF neighbor is not parent THEN
                RETURN true
            ENDIF
        ENDFOR
        RETURN false
    ENDFUNCTION
    FOR i from 0 to n-1
        IF NOT visited[i] THEN
            IF dfs(i, -1) THEN
                RETURN true
            ENDIF
        ENDIF
    ENDFOR
    RETURN false
ENDFUNCTION

FUNCTION toString(adjList)
    CREATE result as new StringBuilder
    APPEND "Adjacency List: {" to result
    FOR each vertex in adjList
        APPEND vertex and "=" and adjList[vertex] to result
        IF vertex is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "}" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (n, edges) pairs
    FOR each testCase in testCases
        PRINT test case details
        SET adjList to createGraph(testCase.n, testCase.edges)
        CALL hasCycle(adjList, testCase.n)
        PRINT cycle result and graph using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-80"><a class="header" href="#algorithm-steps-80">Algorithm Steps</a></h2>
<ol>
<li>Reuse <code>createGraph</code>:
a. Create a HashMap <code>adjList</code> mapping vertices to lists of neighbors.
b. Initialize empty lists for vertices 0 to n-1.
c. Add edges bidirectionally (u→v, v→u).</li>
<li>Define <code>hasCycle</code>:
a. If n = 0, return false (empty graph has no cycles).
b. Use DFS with a parent parameter to avoid false cycles:
<ul>
<li>Mark vertex as visited.</li>
<li>For each neighbor, if unvisited, recurse; if visited and not parent, cycle found.
c. Run DFS from each unvisited vertex to handle disconnected components.
d. Return true if a cycle is found, false otherwise.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert adjacency list to a string, e.g., "{0=[1, 3], 1=[0, 2], ...}".</li>
<li>In <code>main</code>, test with:
a. A cyclic graph.
b. An acyclic graph (tree).
c. An empty graph (n = 0).
d. A single-vertex graph.</li>
</ol>
<h2 id="java-implementation-103"><a class="header" href="#java-implementation-103">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class CycleDetection {
    // Creates adjacency list representation of the graph
    private Map&lt;Integer, List&lt;Integer&gt;&gt; createGraph(int n, int[][] edges) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.put(i, new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            adjList.get(u).add(v);
            adjList.get(v).add(u); // Undirected graph
        }
        return adjList;
    }

    // Checks if the graph contains a cycle using DFS
    public boolean hasCycle(Map&lt;Integer, List&lt;Integer&gt;&gt; adjList, int n) {
        if (n == 0) {
            return false;
        }
        boolean[] visited = new boolean[n];
        for (int i = 0; i &lt; n; i++) {
            if (!visited[i]) {
                if (dfs(i, -1, adjList, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean dfs(int vertex, int parent, Map&lt;Integer, List&lt;Integer&gt;&gt; adjList, boolean[] visited) {
        visited[vertex] = true;
        for (int neighbor : adjList.get(vertex)) {
            if (!visited[neighbor]) {
                if (dfs(neighbor, vertex, adjList, visited)) {
                    return true;
                }
            } else if (neighbor != parent) {
                return true; // Cycle found
            }
        }
        return false;
    }

    // Converts graph to string (adjacency list)
    public String toString(Map&lt;Integer, List&lt;Integer&gt;&gt; adjList) {
        StringBuilder result = new StringBuilder("Adjacency List: {");
        List&lt;Integer&gt; vertices = new ArrayList&lt;&gt;(adjList.keySet());
        Collections.sort(vertices); // For consistent output
        for (int i = 0; i &lt; vertices.size(); i++) {
            int vertex = vertices.get(i);
            result.append(vertex).append("=").append(adjList.get(vertex));
            if (i &lt; vertices.size() - 1) {
                result.append(", ");
            }
        }
        result.append("}");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int n;
        int[][] edges;

        TestCase(int n, int[][] edges) {
            this.n = n;
            this.edges = edges;
        }
    }

    // Main method to test cycle detection
    public static void main(String[] args) {
        CycleDetection cycleDetector = new CycleDetection();

        // Test cases
        TestCase[] testCases = {
            // Cyclic graph: 0-1-2-3-0
            new TestCase(4, new int[][]{{0, 1}, {1, 2}, {2, 3}, {3, 0}}),
            // Acyclic graph (tree): 0-1-2-3
            new TestCase(4, new int[][]{{0, 1}, {1, 2}, {2, 3}}),
            // Empty graph
            new TestCase(0, new int[][]{}),
            // Single vertex
            new TestCase(1, new int[][]{})
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Vertices: " + testCases[i].n);
            System.out.println("Edges: " + Arrays.deepToString(testCases[i].edges));
            Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = cycleDetector.createGraph(testCases[i].n, testCases[i].edges);
            boolean hasCycle = cycleDetector.hasCycle(adjList, testCases[i].n);
            System.out.println("Has Cycle: " + hasCycle);
            System.out.println(cycleDetector.toString(adjList) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-80"><a class="header" href="#output-80">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Vertices: 4
Edges: [[0, 1], [1, 2], [2, 3], [3, 0]]
Has Cycle: true
Adjacency List: {0=[1, 3], 1=[0, 2], 2=[1, 3], 3=[2, 0]}

Test case 2:
Vertices: 4
Edges: [[0, 1], [1, 2], [2, 3]]
Has Cycle: false
Adjacency List: {0=[1], 1=[0, 2], 2=[1, 3], 3=[2]}

Test case 3:
Vertices: 0
Edges: []
Has Cycle: false
Adjacency List: {}

Test case 4:
Vertices: 1
Edges: []
Has Cycle: false
Adjacency List: {0=[]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Graph has a cycle (0→1→2→3→0), so returns true.</li>
<li>Test case 2: Graph is a tree (acyclic), so returns false.</li>
<li>Test case 3: Empty graph has no cycles, returns false.</li>
<li>Test case 4: Single vertex has no cycles, returns false.</li>
</ul>
<h2 id="how-it-works-104"><a class="header" href="#how-it-works-104">How It Works</a></h2>
<ul>
<li><strong>createGraph</strong>: Builds an adjacency list using a HashMap, adding undirected edges (u→v, v→u).</li>
<li><strong>hasCycle</strong>:
<ul>
<li>Returns false for n = 0 (empty graph).</li>
<li>Runs DFS from each unvisited vertex to handle disconnected components.</li>
<li>In DFS, marks vertex as visited, checks neighbors:
<ul>
<li>If neighbor is unvisited, recurse.</li>
<li>If neighbor is visited and not the parent, a cycle is found.</li>
</ul>
</li>
<li>Returns true if a cycle is detected, false otherwise.</li>
</ul>
</li>
<li><strong>dfs</strong>: Tracks parent to avoid false cycles in undirected graphs.</li>
<li><strong>toString</strong>: Formats adjacency list as a string, sorting vertices for consistency.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>DFS from 0: Visit 0, explore 1 (parent=0), explore 2 (parent=1), explore 3 (parent=2).</li>
<li>At 3, neighbor 0 is visited and not parent (2), cycle found.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests cyclic graph, acyclic graph, empty graph, and single vertex.</li>
</ul>
<h2 id="complexity-analysis-table-103"><a class="header" href="#complexity-analysis-table-103">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>createGraph</td><td>O(n + e)</td><td>O(n + e)</td></tr>
<tr><td>hasCycle</td><td>O(n + e)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n log n + e)</td><td>O(n + e)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of vertices, e is the number of edges.</li>
<li>Time complexity: O(n + e) for createGraph (initialize lists and add edges); O(n + e) for hasCycle (DFS visits each vertex and edge once); O(n log n + e) for toString (sorting vertices).</li>
<li>Space complexity: O(n + e) for createGraph and toString (adjacency list); O(n) for hasCycle (visited array and recursion stack).</li>
<li>Worst case: O(n + e) time and space for dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use DFS with a parent parameter to detect cycles in undirected graphs, ensuring visited neighbors that aren’t parents indicate a cycle. Start DFS from each unvisited vertex to handle disconnected components.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: In undirected graphs, avoid false cycle detection by checking the parent vertex. Handle edge cases like empty graphs or single vertices to ensure correct results.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="graph-connectivity"><a class="header" href="#graph-connectivity">Graph Connectivity</a></h1>
<h2 id="problem-statement-81"><a class="header" href="#problem-statement-81">Problem Statement</a></h2>
<p>Write a Java program that implements a graph using an adjacency list and checks if the graph is connected, meaning all vertices are reachable from a starting vertex, using Depth-First Search (DFS). The graph is undirected, and connectivity is determined by checking if a DFS from any vertex visits all vertices. The program should test the connectivity check with various graphs, including connected, disconnected, empty, and single-vertex graphs. You can visualize this as exploring a network of cities connected by roads, ensuring you can travel from one city to all others.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An undirected graph represented by an adjacency list, with vertices as integers (0 to n-1).</li>
<li>The number of vertices <code>n</code> and a list of edges (pairs of vertices).
<strong>Output</strong>: A boolean indicating whether the graph is connected, and a string representation of the graph’s adjacency list for clarity.
<strong>Constraints</strong>:</li>
<li>The number of vertices <code>n</code> is between 0 and 10^5.</li>
<li>Edges are pairs of integers [u, v] where 0 ≤ u, v &lt; n.</li>
<li>The graph is undirected (edge [u, v] implies [v, u]).
<strong>Example</strong>:</li>
<li>Input: n = 5, edges = [[0, 1], [1, 2], [2, 3], [3, 4]]</li>
<li>Output: Connected = true, "Adjacency List: {0=[1], 1=[0, 2], 2=[1, 3], 3=[2, 4], 4=[3]}"</li>
<li>Explanation: All vertices are reachable from vertex 0.</li>
<li>Input: n = 5, edges = [[0, 1], [2, 3]]</li>
<li>Output: Connected = false, "Adjacency List: {0=[1], 1=[0], 2=[3], 3=[2], 4=[]}"</li>
<li>Explanation: Vertex 4 is unreachable, so the graph is disconnected.</li>
<li>Input: n = 0, edges = []</li>
<li>Output: Connected = true, "Adjacency List: {}"</li>
<li>Explanation: An empty graph is considered connected.</li>
</ul>
<h2 id="pseudocode-81"><a class="header" href="#pseudocode-81">Pseudocode</a></h2>
<pre><code>FUNCTION createGraph(n, edges)
    CREATE adjList as new HashMap
    FOR i from 0 to n-1
        SET adjList[i] to empty list
    ENDFOR
    FOR each edge [u, v] in edges
        ADD v to adjList[u]
        ADD u to adjList[v]
    ENDFOR
    RETURN adjList
ENDFUNCTION

FUNCTION isConnected(adjList, n)
    IF n is 0 THEN
        RETURN true
    ENDIF
    CREATE visited as boolean array of size n, initialized to false
    FUNCTION dfs(vertex)
        SET visited[vertex] to true
        FOR each neighbor in adjList[vertex]
            IF NOT visited[neighbor] THEN
                CALL dfs(neighbor)
            ENDIF
        ENDFOR
    ENDFUNCTION
    CALL dfs(0)
    FOR i from 0 to n-1
        IF NOT visited[i] THEN
            RETURN false
        ENDIF
    ENDFOR
    RETURN true
ENDFUNCTION

FUNCTION toString(adjList)
    CREATE result as new StringBuilder
    APPEND "Adjacency List: {" to result
    FOR each vertex in adjList
        APPEND vertex and "=" and adjList[vertex] to result
        IF vertex is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "}" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (n, edges) pairs
    FOR each testCase in testCases
        PRINT test case details
        SET adjList to createGraph(testCase.n, testCase.edges)
        CALL isConnected(adjList, testCase.n)
        PRINT connected result and graph using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-81"><a class="header" href="#algorithm-steps-81">Algorithm Steps</a></h2>
<ol>
<li>Define <code>createGraph</code>:
a. Create a HashMap <code>adjList</code> mapping vertices to lists of neighbors.
b. Initialize empty lists for vertices 0 to n-1.
c. Add edges bidirectionally (u→v, v→u).</li>
<li>Define <code>isConnected</code>:
a. If n = 0, return true (empty graph is connected).
b. Use DFS starting from vertex 0:
<ul>
<li>Mark vertex as visited.</li>
<li>Recursively visit unvisited neighbors.
c. Check if all vertices are visited; return false if any are not.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert adjacency list to a string, e.g., "{0=[1], 1=[0, 2], ...}".</li>
<li>In <code>main</code>, test with:
a. A connected graph.
b. A disconnected graph.
c. An empty graph (n = 0).
d. A single-vertex graph.</li>
</ol>
<h2 id="java-implementation-104"><a class="header" href="#java-implementation-104">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class GraphConnectivity {
    // Creates adjacency list representation of the graph
    private Map&lt;Integer, List&lt;Integer&gt;&gt; createGraph(int n, int[][] edges) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.put(i, new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            adjList.get(u).add(v);
            adjList.get(v).add(u); // Undirected graph
        }
        return adjList;
    }

    // Checks if the graph is connected using DFS
    public boolean isConnected(Map&lt;Integer, List&lt;Integer&gt;&gt; adjList, int n) {
        if (n == 0) {
            return true;
        }
        boolean[] visited = new boolean[n];
        dfs(0, adjList, visited);
        for (int i = 0; i &lt; n; i++) {
            if (!visited[i]) {
                return false;
            }
        }
        return true;
    }

    private void dfs(int vertex, Map&lt;Integer, List&lt;Integer&gt;&gt; adjList, boolean[] visited) {
        visited[vertex] = true;
        for (int neighbor : adjList.get(vertex)) {
            if (!visited[neighbor]) {
                dfs(neighbor, adjList, visited);
            }
        }
    }

    // Converts graph to string (adjacency list)
    public String toString(Map&lt;Integer, List&lt;Integer&gt;&gt; adjList) {
        StringBuilder result = new StringBuilder("Adjacency List: {");
        List&lt;Integer&gt; vertices = new ArrayList&lt;&gt;(adjList.keySet());
        Collections.sort(vertices); // For consistent output
        for (int i = 0; i &lt; vertices.size(); i++) {
            int vertex = vertices.get(i);
            result.append(vertex).append("=").append(adjList.get(vertex));
            if (i &lt; vertices.size() - 1) {
                result.append(", ");
            }
        }
        result.append("}");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int n;
        int[][] edges;

        TestCase(int n, int[][] edges) {
            this.n = n;
            this.edges = edges;
        }
    }

    // Main method to test graph connectivity
    public static void main(String[] args) {
        GraphConnectivity connectivityChecker = new GraphConnectivity();

        // Test cases
        TestCase[] testCases = {
            // Connected graph: 0-1-2-3-4
            new TestCase(5, new int[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}}),
            // Disconnected graph: 0-1, 2-3, 4 isolated
            new TestCase(5, new int[][]{{0, 1}, {2, 3}}),
            // Empty graph
            new TestCase(0, new int[][]{}),
            // Single vertex
            new TestCase(1, new int[][]{})
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Vertices: " + testCases[i].n);
            System.out.println("Edges: " + Arrays.deepToString(testCases[i].edges));
            Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = connectivityChecker.createGraph(testCases[i].n, testCases[i].edges);
            boolean isConnected = connectivityChecker.isConnected(adjList, testCases[i].n);
            System.out.println("Connected: " + isConnected);
            System.out.println(connectivityChecker.toString(adjList) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-81"><a class="header" href="#output-81">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Vertices: 5
Edges: [[0, 1], [1, 2], [2, 3], [3, 4]]
Connected: true
Adjacency List: {0=[1], 1=[0, 2], 2=[1, 3], 3=[2, 4], 4=[3]}

Test case 2:
Vertices: 5
Edges: [[0, 1], [2, 3]]
Connected: false
Adjacency List: {0=[1], 1=[0], 2=[3], 3=[2], 4=[]}

Test case 3:
Vertices: 0
Edges: []
Connected: true
Adjacency List: {}

Test case 4:
Vertices: 1
Edges: []
Connected: true
Adjacency List: {0=[]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: All vertices are reachable from 0 (0→1→2→3→4), so connected.</li>
<li>Test case 2: Vertex 4 is isolated, so disconnected.</li>
<li>Test case 3: Empty graph is connected by definition.</li>
<li>Test case 4: Single vertex is connected (no edges needed).</li>
</ul>
<h2 id="how-it-works-105"><a class="header" href="#how-it-works-105">How It Works</a></h2>
<ul>
<li><strong>createGraph</strong>: Builds an adjacency list using a HashMap, adding undirected edges (u→v, v→u).</li>
<li><strong>isConnected</strong>:
<ul>
<li>Returns true for n = 0 (empty graph).</li>
<li>Runs DFS from vertex 0, marking visited vertices.</li>
<li>Checks if all vertices are visited; returns false if any are not.</li>
</ul>
</li>
<li><strong>dfs</strong>: Marks current vertex, recursively visits unvisited neighbors.</li>
<li><strong>toString</strong>: Formats adjacency list as a string, sorting vertices for consistency.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>DFS from 0: Visit 0, 1, 2, 3, 4 (via 0→1→2→3→4).</li>
<li>All vertices visited, return true.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests connected graph, disconnected graph, empty graph, and single vertex.</li>
</ul>
<h2 id="complexity-analysis-table-104"><a class="header" href="#complexity-analysis-table-104">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>createGraph</td><td>O(n + e)</td><td>O(n + e)</td></tr>
<tr><td>isConnected</td><td>O(n + e)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n log n + e)</td><td>O(n + e)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of vertices, e is the number of edges.</li>
<li>Time complexity: O(n + e) for createGraph (initialize lists and add edges); O(n + e) for isConnected (DFS visits each vertex and edge once); O(n log n + e) for toString (sorting vertices).</li>
<li>Space complexity: O(n + e) for createGraph and toString (adjacency list); O(n) for isConnected (visited array and recursion stack).</li>
<li>Worst case: O(n + e) time and space for dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use DFS to efficiently explore all reachable vertices from a starting point. For undirected graphs, a single DFS from any vertex is sufficient to check connectivity.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the graph is undirected by adding edges both ways. Handle edge cases like empty graphs or isolated vertices to avoid incorrect connectivity results.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="shortest-path-unweighted"><a class="header" href="#shortest-path-unweighted">Shortest Path (Unweighted)</a></h1>
<h2 id="problem-statement-82"><a class="header" href="#problem-statement-82">Problem Statement</a></h2>
<p>Write a Java program that extends an unweighted undirected graph implementation to find the shortest path between two vertices using Breadth-First Search (BFS). The shortest path is the sequence of vertices with the minimum number of edges from the source to the target vertex. The program should use an adjacency list representation, return the path as a list of vertices, and test with various graphs and vertex pairs, including cases where a path exists, no path exists, and edge cases like empty or single-vertex graphs. You can visualize this as finding the fewest roads to travel between two cities in a network, where each road has the same length.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An undirected unweighted graph represented by an adjacency list, with vertices as integers (0 to n-1).</li>
<li>The number of vertices <code>n</code>, a list of edges (pairs of vertices), and two vertices <code>source</code> and <code>target</code>.
<strong>Output</strong>: A list of integers representing the shortest path from source to target, or an empty list if no path exists, and a string representation of the graph’s adjacency list for clarity.
<strong>Constraints</strong>:</li>
<li>The number of vertices <code>n</code> is between 0 and 10^5.</li>
<li>Edges are pairs of integers [u, v] where 0 ≤ u, v &lt; n.</li>
<li>Source and target are integers in [0, n-1].</li>
<li>The graph is undirected (edge [u, v] implies [v, u]).
<strong>Example</strong>:</li>
<li>Input: n = 5, edges = [[0, 1], [1, 2], [2, 3], [3, 4], [1, 4]], source = 0, target = 4</li>
<li>Output: Path = [0, 1, 4], "Adjacency List: {0=[1], 1=[0, 2, 4], 2=[1, 3], 3=[2, 4], 4=[3, 1]}"</li>
<li>Explanation: Shortest path from 0 to 4 is 0→1→4 (2 edges).</li>
<li>Input: n = 5, edges = [[0, 1], [2, 3]], source = 0, target = 3</li>
<li>Output: Path = [], "Adjacency List: {0=[1], 1=[0], 2=[3], 3=[2], 4=[]}"</li>
<li>Explanation: No path exists from 0 to 3.</li>
<li>Input: n = 0, edges = [], source = 0, target = 0</li>
<li>Output: Path = [], "Adjacency List: {}"</li>
<li>Explanation: Empty graph, no path exists.</li>
</ul>
<h2 id="pseudocode-82"><a class="header" href="#pseudocode-82">Pseudocode</a></h2>
<pre><code>FUNCTION createGraph(n, edges)
    CREATE adjList as new HashMap
    FOR i from 0 to n-1
        SET adjList[i] to empty list
    ENDFOR
    FOR each edge [u, v] in edges
        ADD v to adjList[u]
        ADD u to adjList[v]
    ENDFOR
    RETURN adjList
ENDFUNCTION

FUNCTION shortestPath(adjList, n, source, target)
    IF n is 0 OR source &gt;= n OR target &gt;= n THEN
        RETURN empty list
    ENDIF
    CREATE visited as boolean array of size n, initialized to false
    CREATE parent as integer array of size n, initialized to -1
    CREATE queue as new Queue
    ADD source to queue
    SET visited[source] to true
    WHILE queue is not empty
        SET current to queue.dequeue
        IF current equals target THEN
            CREATE path as new list
            SET node to target
            WHILE node is not -1
                PREPEND node to path
                SET node to parent[node]
            ENDWHILE
            RETURN path
        ENDIF
        FOR each neighbor in adjList[current]
            IF NOT visited[neighbor] THEN
                SET visited[neighbor] to true
                SET parent[neighbor] to current
                ADD neighbor to queue
            ENDIF
        ENDFOR
    ENDWHILE
    RETURN empty list
ENDFUNCTION

FUNCTION toString(adjList)
    CREATE result as new StringBuilder
    APPEND "Adjacency List: {" to result
    FOR each vertex in adjList
        APPEND vertex and "=" and adjList[vertex] to result
        IF vertex is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "}" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (n, edges, source, target) pairs
    FOR each testCase in testCases
        PRINT test case details
        SET adjList to createGraph(testCase.n, testCase.edges)
        CALL shortestPath(adjList, testCase.n, testCase.source, testCase.target)
        PRINT path and graph using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-82"><a class="header" href="#algorithm-steps-82">Algorithm Steps</a></h2>
<ol>
<li>Reuse <code>createGraph</code>:
a. Create a HashMap <code>adjList</code> mapping vertices to lists of neighbors.
b. Initialize empty lists for vertices 0 to n-1.
c. Add edges bidirectionally (u→v, v→u).</li>
<li>Define <code>shortestPath</code>:
a. If n = 0 or source/target ≥ n, return empty list.
b. Use BFS:
<ul>
<li>Initialize a queue with source, mark source as visited, set parent array.</li>
<li>Dequeue vertex, if it’s target, reconstruct path using parent array.</li>
<li>For each unvisited neighbor, mark visited, set parent, enqueue.
c. If target not reached, return empty list.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert adjacency list to a string, e.g., "{0=[1], 1=[0, 2], ...}".</li>
<li>In <code>main</code>, test with:
a. A graph with a valid path.
b. A graph with no path between vertices.
c. An empty graph.
d. A single-vertex graph.</li>
</ol>
<h2 id="java-implementation-105"><a class="header" href="#java-implementation-105">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class ShortestPathUnweighted {
    // Creates adjacency list representation of the graph
    private Map&lt;Integer, List&lt;Integer&gt;&gt; createGraph(int n, int[][] edges) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.put(i, new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1];
            adjList.get(u).add(v);
            adjList.get(v).add(u); // Undirected graph
        }
        return adjList;
    }

    // Finds shortest path from source to target using BFS
    public List&lt;Integer&gt; shortestPath(Map&lt;Integer, List&lt;Integer&gt;&gt; adjList, int n, int source, int target) {
        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
        if (n == 0 || source &gt;= n || target &gt;= n) {
            return path;
        }
        boolean[] visited = new boolean[n];
        int[] parent = new int[n];
        Arrays.fill(parent, -1);
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(source);
        visited[source] = true;

        while (!queue.isEmpty()) {
            int current = queue.poll();
            if (current == target) {
                // Reconstruct path
                int node = target;
                while (node != -1) {
                    path.add(0, node);
                    node = parent[node];
                }
                return path;
            }
            for (int neighbor : adjList.get(current)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    queue.offer(neighbor);
                }
            }
        }
        return path; // Empty if no path exists
    }

    // Converts graph to string (adjacency list)
    public String toString(Map&lt;Integer, List&lt;Integer&gt;&gt; adjList) {
        StringBuilder result = new StringBuilder("Adjacency List: {");
        List&lt;Integer&gt; vertices = new ArrayList&lt;&gt;(adjList.keySet());
        Collections.sort(vertices); // For consistent output
        for (int i = 0; i &lt; vertices.size(); i++) {
            int vertex = vertices.get(i);
            result.append(vertex).append("=").append(adjList.get(vertex));
            if (i &lt; vertices.size() - 1) {
                result.append(", ");
            }
        }
        result.append("}");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int n;
        int[][] edges;
        int source, target;

        TestCase(int n, int[][] edges, int source, int target) {
            this.n = n;
            this.edges = edges;
            this.source = source;
            this.target = target;
        }
    }

    // Main method to test shortest path
    public static void main(String[] args) {
        ShortestPathUnweighted pathFinder = new ShortestPathUnweighted();

        // Test cases
        TestCase[] testCases = {
            // Valid path: 0-1-4
            new TestCase(5, new int[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}, {1, 4}}, 0, 4),
            // No path: 0 and 3 disconnected
            new TestCase(5, new int[][]{{0, 1}, {2, 3}}, 0, 3),
            // Empty graph
            new TestCase(0, new int[][]{}, 0, 0),
            // Single vertex
            new TestCase(1, new int[][]{}, 0, 0)
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Vertices: " + testCases[i].n);
            System.out.println("Edges: " + Arrays.deepToString(testCases[i].edges));
            System.out.println("Source: " + testCases[i].source + ", Target: " + testCases[i].target);
            Map&lt;Integer, List&lt;Integer&gt;&gt; adjList = pathFinder.createGraph(testCases[i].n, testCases[i].edges);
            List&lt;Integer&gt; path = pathFinder.shortestPath(adjList, testCases[i].n, testCases[i].source, testCases[i].target);
            System.out.println("Path: " + path);
            System.out.println(pathFinder.toString(adjList) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-82"><a class="header" href="#output-82">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Vertices: 5
Edges: [[0, 1], [1, 2], [2, 3], [3, 4], [1, 4]]
Source: 0, Target: 4
Path: [0, 1, 4]
Adjacency List: {0=[1], 1=[0, 2, 4], 2=[1, 3], 3=[2, 4], 4=[3, 1]}

Test case 2:
Vertices: 5
Edges: [[0, 1], [2, 3]]
Source: 0, Target: 3
Path: []
Adjacency List: {0=[1], 1=[0], 2=[3], 3=[2], 4=[]}

Test case 3:
Vertices: 0
Edges: []
Source: 0, Target: 0
Path: []
Adjacency List: {}

Test case 4:
Vertices: 1
Edges: []
Source: 0, Target: 0
Path: [0]
Adjacency List: {0=[]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Shortest path from 0 to 4 is 0→1→4 (2 edges).</li>
<li>Test case 2: No path exists from 0 to 3 (disconnected components).</li>
<li>Test case 3: Empty graph, no path exists.</li>
<li>Test case 4: Source and target are same (0), path is [0].</li>
</ul>
<h2 id="how-it-works-106"><a class="header" href="#how-it-works-106">How It Works</a></h2>
<ul>
<li><strong>createGraph</strong>: Builds an adjacency list using a HashMap, adding undirected edges (u→v, v→u).</li>
<li><strong>shortestPath</strong>:
<ul>
<li>Returns empty list for invalid inputs (n = 0 or source/target ≥ n).</li>
<li>Uses BFS: enqueues source, marks visited, tracks parents.</li>
<li>If target reached, reconstructs path by backtracking through parent array.</li>
<li>Returns empty list if no path found.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats adjacency list as a string, sorting vertices for consistency.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>BFS from 0: Enqueue 0, visit 1, enqueue 1.</li>
<li>Dequeue 1, visit 2, 4, enqueue 2, 4 (parent[2]=1, parent[4]=1).</li>
<li>Dequeue 2, visit 3, enqueue 3 (parent[3]=2).</li>
<li>Dequeue 4, target reached, reconstruct: 4→1→0, reverse to [0, 1, 4].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests valid path, no path, empty graph, and single vertex.</li>
</ul>
<h2 id="complexity-analysis-table-105"><a class="header" href="#complexity-analysis-table-105">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>createGraph</td><td>O(n + e)</td><td>O(n + e)</td></tr>
<tr><td>shortestPath</td><td>O(n + e)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n log n + e)</td><td>O(n + e)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of vertices, e is the number of edges.</li>
<li>Time complexity: O(n + e) for createGraph (initialize lists and add edges); O(n + e) for shortestPath (BFS visits each vertex and edge once); O(n log n + e) for toString (sorting vertices).</li>
<li>Space complexity: O(n + e) for createGraph and toString (adjacency list); O(n) for shortestPath (visited array, parent array, queue).</li>
<li>Worst case: O(n + e) time and space for dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use BFS for finding the shortest path in unweighted graphs, as it explores vertices level by level. Store parent information to reconstruct the path efficiently.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate source and target vertices to ensure they are within the graph’s bounds. Handle cases where no path exists by returning an empty list.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="social-network-simulation"><a class="header" href="#social-network-simulation">Social Network Simulation</a></h1>
<h2 id="problem-statement-83"><a class="header" href="#problem-statement-83">Problem Statement</a></h2>
<p>Write a Java program that simulates a social network using an undirected weighted graph. The program should allow adding users (vertices), forming friendships (weighted edges, where weights represent interaction strength), and finding mutual friends between two users using Depth-First Search (DFS). Mutual friends are users directly connected to both input users. The program should reuse the weighted graph implementation with an adjacency list and test with various scenarios, including users with mutual friends, no mutual friends, empty graphs, and isolated users. You can visualize this as a social media platform where users connect with friends, and you query who is friends with both of two selected users, like finding common contacts in a network.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An undirected weighted graph with vertices as integers (0 to n-1, representing users).</li>
<li>Operations to add users (vertices), add friendships (edges with weights), and query mutual friends (pairs of users [u, v]).
<strong>Output</strong>: Confirmation of user and friendship additions, a list of mutual friends’ IDs for queried pairs, or an empty list if none, and a string representation of the graph’s adjacency list for clarity.
<strong>Constraints</strong>:</li>
<li>The number of vertices <code>n</code> is between 0 and 10^5.</li>
<li>Edges are triplets [u, v, weight] where 0 ≤ u, v &lt; n, and weight is a positive integer in [1, 10^9].</li>
<li>The graph is undirected (friendship [u, v, weight] implies [v, u, weight]).
<strong>Example</strong>:</li>
<li>Input: Add users 0, 1, 2, 3; Add friendships [0, 1, 5], [1, 2, 3], [2, 3, 7], [0, 2, 4]; Query mutual friends [0, 2]</li>
<li>Output:
<ul>
<li>Added users and friendships successfully</li>
<li>Mutual friends of 0 and 2: [1]</li>
<li>"Adjacency List: {0=[(1, 5), (2, 4)], 1=[(0, 5), (2, 3)], 2=[(1, 3), (3, 7), (0, 4)], 3=[(2, 7)]}"</li>
</ul>
</li>
<li>Explanation: User 1 is a mutual friend of users 0 and 2 (directly connected to both).</li>
<li>Input: Add users 0, 1, 2; Add friendships [0, 1, 5]; Query mutual friends [0, 2]</li>
<li>Output:
<ul>
<li>Added users and friendships successfully</li>
<li>Mutual friends of 0 and 2: []</li>
<li>"Adjacency List: {0=[(1, 5)], 1=[(0, 5)], 2=[]}"</li>
</ul>
</li>
<li>Explanation: No mutual friends between 0 and 2.</li>
</ul>
<h2 id="pseudocode-83"><a class="header" href="#pseudocode-83">Pseudocode</a></h2>
<pre><code>CLASS Edge
    SET destination to integer
    SET weight to integer
ENDCLASS

FUNCTION createGraph(n)
    CREATE adjList as new HashMap
    FOR i from 0 to n-1
        SET adjList[i] to empty list
    ENDFOR
    RETURN adjList
ENDFUNCTION

FUNCTION addFriendship(adjList, u, v, weight)
    IF u not in adjList OR v not in adjList THEN
        RETURN false
    ENDIF
    CREATE edge1 as new Edge(v, weight)
    CREATE edge2 as new Edge(u, weight)
    ADD edge1 to adjList[u]
    ADD edge2 to adjList[v]
    RETURN true
ENDFUNCTION

FUNCTION getFriends(vertex, adjList, visited)
    CREATE friends as new list
    FUNCTION dfs(node)
        SET visited[node] to true
        FOR each edge in adjList[node]
            IF NOT visited[edge.destination] THEN
                ADD edge.destination to friends
                CALL dfs(edge.destination)
            ENDIF
        ENDFOR
    ENDFUNCTION
    SET visited[vertex] to true
    FOR each edge in adjList[vertex]
        ADD edge.destination to friends
    ENDFOR
    RETURN friends
ENDFUNCTION

FUNCTION findMutualFriends(adjList, u, v)
    IF u not in adjList OR v not in adjList THEN
        RETURN empty list
    ENDIF
    CREATE visited1 as boolean array, initialized to false
    CREATE visited2 as boolean array, initialized to false
    SET friends1 to getFriends(u, adjList, visited1)
    SET friends2 to getFriends(v, adjList, visited2)
    CREATE mutual as new list
    FOR each friend in friends1
        IF friend in friends2 THEN
            ADD friend to mutual
        ENDIF
    ENDFOR
    RETURN mutual
ENDFUNCTION

FUNCTION toString(adjList)
    CREATE result as new StringBuilder
    APPEND "Adjacency List: {" to result
    FOR each vertex in adjList
        APPEND vertex and "=" to result
        APPEND "[" to result
        FOR each edge in adjList[vertex]
            APPEND "(" and edge.destination and ", " and edge.weight and ")" to result
            IF edge is not last THEN
                APPEND ", " to result
            ENDIF
        ENDFOR
        APPEND "]" to result
        IF vertex is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "}" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (n, edges, queries) triples
    FOR each testCase in testCases
        PRINT test case details
        SET adjList to createGraph(testCase.n)
        FOR each edge [u, v, weight] in testCase.edges
            CALL addFriendship(adjList, u, v, weight)
        ENDFOR
        FOR each query [u, v] in testCase.queries
            CALL findMutualFriends(adjList, u, v)
            PRINT mutual friends
        ENDFOR
        PRINT graph using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-83"><a class="header" href="#algorithm-steps-83">Algorithm Steps</a></h2>
<ol>
<li>Reuse the <code>Edge</code> class with:
a. <code>destination</code> (integer for target vertex).
b. <code>weight</code> (integer for friendship strength).</li>
<li>Define <code>createGraph</code>:
a. Create a HashMap <code>adjList</code> mapping vertices to lists of <code>Edge</code> objects.
b. Initialize empty lists for vertices 0 to n-1.</li>
<li>Define <code>addFriendship</code>:
a. Validate that users u and v exist.
b. Add bidirectional edges <code>Edge(v, weight)</code> to u’s list and <code>Edge(u, weight)</code> to v’s list.</li>
<li>Define <code>getFriends</code>:
a. Use DFS to collect direct neighbors of a vertex (friends).
b. Mark visited vertices to avoid cycles.</li>
<li>Define <code>findMutualFriends</code>:
a. Validate that users u and v exist.
b. Get friends of u and v using DFS.
c. Return the intersection of their friend lists.</li>
<li>Define <code>toString</code>:
a. Convert adjacency list to a string, e.g., "{0=[(1, 5), (2, 4)], ...}".</li>
<li>In <code>main</code>, test with:
a. A graph with mutual friends.
b. A graph with no mutual friends.
c. An empty graph.
d. A single user.</li>
</ol>
<h2 id="java-implementation-106"><a class="header" href="#java-implementation-106">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class SocialNetworkSimulation {
    // Edge class to store destination and weight
    static class Edge {
        int destination;
        int weight;

        Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }

        @Override
        public String toString() {
            return "(" + destination + ", " + weight + ")";
        }
    }

    // Creates adjacency list for n users
    private Map&lt;Integer, List&lt;Edge&gt;&gt; createGraph(int n) {
        Map&lt;Integer, List&lt;Edge&gt;&gt; adjList = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.put(i, new ArrayList&lt;&gt;());
        }
        return adjList;
    }

    // Adds a friendship (weighted edge) between users u and v
    public boolean addFriendship(Map&lt;Integer, List&lt;Edge&gt;&gt; adjList, int u, int v, int weight) {
        if (!adjList.containsKey(u) || !adjList.containsKey(v)) {
            return false;
        }
        adjList.get(u).add(new Edge(v, weight));
        adjList.get(v).add(new Edge(u, weight)); // Undirected graph
        return true;
    }

    // Gets friends of a vertex using DFS (direct neighbors only for mutual friends)
    private List&lt;Integer&gt; getFriends(int vertex, Map&lt;Integer, List&lt;Edge&gt;&gt; adjList, boolean[] visited) {
        List&lt;Integer&gt; friends = new ArrayList&lt;&gt;();
        visited[vertex] = true;
        for (Edge edge : adjList.get(vertex)) {
            friends.add(edge.destination);
        }
        return friends;
    }

    // Finds mutual friends between users u and v
    public List&lt;Integer&gt; findMutualFriends(Map&lt;Integer, List&lt;Edge&gt;&gt; adjList, int u, int v) {
        List&lt;Integer&gt; mutual = new ArrayList&lt;&gt;();
        if (!adjList.containsKey(u) || !adjList.containsKey(v)) {
            return mutual;
        }
        boolean[] visited1 = new boolean[adjList.size()];
        boolean[] visited2 = new boolean[adjList.size()];
        List&lt;Integer&gt; friends1 = getFriends(u, adjList, visited1);
        List&lt;Integer&gt; friends2 = getFriends(v, adjList, visited2);
        for (int friend : friends1) {
            if (friends2.contains(friend)) {
                mutual.add(friend);
            }
        }
        Collections.sort(mutual); // For consistent output
        return mutual;
    }

    // Converts graph to string (adjacency list)
    public String toString(Map&lt;Integer, List&lt;Edge&gt;&gt; adjList) {
        StringBuilder result = new StringBuilder("Adjacency List: {");
        List&lt;Integer&gt; vertices = new ArrayList&lt;&gt;(adjList.keySet());
        Collections.sort(vertices); // For consistent output
        for (int i = 0; i &lt; vertices.size(); i++) {
            int vertex = vertices.get(i);
            result.append(vertex).append("=[");
            List&lt;Edge&gt; edges = adjList.get(vertex);
            for (int j = 0; j &lt; edges.size(); j++) {
                result.append(edges.get(j));
                if (j &lt; edges.size() - 1) {
                    result.append(", ");
                }
            }
            result.append("]");
            if (i &lt; vertices.size() - 1) {
                result.append(", ");
            }
        }
        result.append("}");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int n;
        int[][] edges;
        int[][] queries;

        TestCase(int n, int[][] edges, int[][] queries) {
            this.n = n;
            this.edges = edges;
            this.queries = queries;
        }
    }

    // Main method to test social network simulation
    public static void main(String[] args) {
        SocialNetworkSimulation network = new SocialNetworkSimulation();

        // Test cases
        TestCase[] testCases = {
            // Graph with mutual friends
            new TestCase(
                4,
                new int[][]{{0, 1, 5}, {1, 2, 3}, {2, 3, 7}, {0, 2, 4}},
                new int[][]{{0, 2}}
            ),
            // Graph with no mutual friends
            new TestCase(
                3,
                new int[][]{{0, 1, 5}},
                new int[][]{{0, 2}}
            ),
            // Empty graph
            new TestCase(
                0,
                new int[][]{},
                new int[][]{{0, 1}}
            ),
            // Single user
            new TestCase(
                1,
                new int[][]{},
                new int[][]{{0, 0}}
            )
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Vertices (Users): " + testCases[i].n);
            System.out.println("Friendships: " + Arrays.deepToString(testCases[i].edges));
            Map&lt;Integer, List&lt;Edge&gt;&gt; adjList = network.createGraph(testCases[i].n);
            System.out.print("Added users");
            if (testCases[i].edges.length &gt; 0) {
                System.out.print(" and friendships");
                for (int[] edge : testCases[i].edges) {
                    network.addFriendship(adjList, edge[0], edge[1], edge[2]);
                }
            }
            System.out.println(" successfully");
            System.out.println("Queries:");
            for (int[] query : testCases[i].queries) {
                int u = query[0], v = query[1];
                List&lt;Integer&gt; mutual = network.findMutualFriends(adjList, u, v);
                System.out.println("Mutual friends of " + u + " and " + v + ": " + mutual);
            }
            System.out.println(network.toString(adjList) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-83"><a class="header" href="#output-83">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Vertices (Users): 4
Friendships: [[0, 1, 5], [1, 2, 3], [2, 3, 7], [0, 2, 4]]
Added users and friendships successfully
Queries:
Mutual friends of 0 and 2: [1]
Adjacency List: {0=[(1, 5), (2, 4)], 1=[(0, 5), (2, 3)], 2=[(1, 3), (3, 7), (0, 4)], 3=[(2, 7)]}

Test case 2:
Vertices (Users): 3
Friendships: [[0, 1, 5]]
Added users and friendships successfully
Queries:
Mutual friends of 0 and 2: []
Adjacency List: {0=[(1, 5)], 1=[(0, 5)], 2=[]}

Test case 3:
Vertices (Users): 0
Friendships: []
Added users successfully
Queries:
Mutual friends of 0 and 1: []
Adjacency List: {}

Test case 4:
Vertices (Users): 1
Friendships: []
Added users successfully
Queries:
Mutual friends of 0 and 0: []
Adjacency List: {0=[]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Users 0 and 2 have mutual friend 1 (connected to both).</li>
<li>Test case 2: Users 0 and 2 have no mutual friends (2 is isolated).</li>
<li>Test case 3: Empty graph, no mutual friends.</li>
<li>Test case 4: Single user, no mutual friends with self.</li>
</ul>
<h2 id="how-it-works-107"><a class="header" href="#how-it-works-107">How It Works</a></h2>
<ul>
<li><strong>Edge</strong>: Stores destination vertex and weight (friendship strength).</li>
<li><strong>createGraph</strong>: Initializes adjacency list for n users.</li>
<li><strong>addFriendship</strong>: Adds bidirectional weighted edges if users exist.</li>
<li><strong>getFriends</strong>: Uses DFS to collect direct neighbors (friends), marking visited to avoid cycles.</li>
<li><strong>findMutualFriends</strong>: Finds intersection of friends’ lists for two users.</li>
<li><strong>toString</strong>: Formats adjacency list with edge weights, sorting vertices.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Add users 0–3, friendships (0, 1, 5), (1, 2, 3), (2, 3, 7), (0, 2, 4).</li>
<li>Query (0, 2): Friends of 0 = [1, 2], friends of 2 = [1, 3, 0], intersection = [1].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests mutual friends, no mutual friends, empty graph, and single user.</li>
</ul>
<h2 id="complexity-analysis-table-106"><a class="header" href="#complexity-analysis-table-106">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>createGraph</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>addFriendship</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>findMutualFriends</td><td>O(d_u + d_v) average</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n log n + e)</td><td>O(n + e)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of vertices, e is the number of edges, d_u and d_v are degrees of vertices u and v.</li>
<li>Time complexity: O(n) for createGraph (initialize lists); O(1) for addFriendship (add edges); O(d_u + d_v) average for findMutualFriends (collect and intersect neighbors); O(n log n + e) for toString (sorting vertices).</li>
<li>Space complexity: O(n) for createGraph (empty lists); O(1) for addFriendship; O(n) for findMutualFriends (visited arrays and friend lists); O(n + e) for toString (adjacency list).</li>
<li>Worst case: O(n + e) time and space for dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use DFS to collect direct neighbors for mutual friend queries, but limit to one level for efficiency. Store weights to represent friendship strength, enabling future extensions like weighted friend recommendations.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate user IDs before adding friendships or querying mutual friends to avoid accessing undefined adjacency lists. Ensure DFS avoids cycles by tracking visited vertices.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="weighted-graph-extension"><a class="header" href="#weighted-graph-extension">Weighted Graph Extension</a></h1>
<h2 id="problem-statement-84"><a class="header" href="#problem-statement-84">Problem Statement</a></h2>
<p>Write a Java program that modifies an undirected graph implementation to support weighted edges by storing weights in the adjacency list. The program should allow adding weighted edges and retrieving the weight of an edge between two vertices, using an adjacency list representation with a custom edge structure. The graph remains undirected, and the program should test adding and retrieving edge weights with various graphs, including graphs with positive weights, empty graphs, and single-vertex graphs. You can visualize this as a network of cities where roads have distances (weights), and you need to store and query these distances efficiently.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An undirected graph with vertices as integers (0 to n-1).</li>
<li>The number of vertices <code>n</code> and a list of weighted edges (triplets [u, v, weight]).</li>
<li>Queries to retrieve the weight of specific edges (u, v).
<strong>Output</strong>: A confirmation of edge additions and the retrieved weights for queried edges, or -1 if the edge doesn’t exist, along with a string representation of the graph’s adjacency list for clarity.
<strong>Constraints</strong>:</li>
<li>The number of vertices <code>n</code> is between 0 and 10^5.</li>
<li>Edges are triplets [u, v, weight] where 0 ≤ u, v &lt; n, and weight is a positive integer in [1, 10^9].</li>
<li>The graph is undirected (edge [u, v, weight] implies [v, u, weight]).
<strong>Example</strong>:</li>
<li>Input: n = 4, edges = [[0, 1, 5], [1, 2, 3], [2, 3, 7]], queries = [[0, 1], [1, 3]]</li>
<li>Output:
<ul>
<li>Added edges successfully</li>
<li>Weight(0, 1) = 5</li>
<li>Weight(1, 3) = -1</li>
<li>"Adjacency List: {0=[(1, 5)], 1=[(0, 5), (2, 3)], 2=[(1, 3), (3, 7)], 3=[(2, 7)]}"</li>
</ul>
</li>
<li>Explanation: Edge (0, 1) has weight 5; edge (1, 3) doesn’t exist.</li>
<li>Input: n = 0, edges = [], queries = [[0, 1]]</li>
<li>Output:
<ul>
<li>Added edges successfully</li>
<li>Weight(0, 1) = -1</li>
<li>"Adjacency List: {}"</li>
</ul>
</li>
<li>Explanation: Empty graph, no edges.</li>
</ul>
<h2 id="pseudocode-84"><a class="header" href="#pseudocode-84">Pseudocode</a></h2>
<pre><code>CLASS Edge
    SET destination to integer
    SET weight to integer
ENDCLASS

FUNCTION createGraph(n, edges)
    CREATE adjList as new HashMap
    FOR i from 0 to n-1
        SET adjList[i] to empty list
    ENDFOR
    FOR each edge [u, v, weight] in edges
        CREATE edge1 as new Edge(v, weight)
        CREATE edge2 as new Edge(u, weight)
        ADD edge1 to adjList[u]
        ADD edge2 to adjList[v]
    ENDFOR
    RETURN adjList
ENDFUNCTION

FUNCTION getEdgeWeight(adjList, u, v)
    FOR each edge in adjList[u]
        IF edge.destination equals v THEN
            RETURN edge.weight
        ENDIF
    ENDFOR
    RETURN -1
ENDFUNCTION

FUNCTION toString(adjList)
    CREATE result as new StringBuilder
    APPEND "Adjacency List: {" to result
    FOR each vertex in adjList
        APPEND vertex and "=" to result
        APPEND "[" to result
        FOR each edge in adjList[vertex]
            APPEND "(" and edge.destination and ", " and edge.weight and ")" to result
            IF edge is not last THEN
                APPEND ", " to result
            ENDIF
        ENDFOR
        APPEND "]" to result
        IF vertex is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "}" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (n, edges, queries) pairs
    FOR each testCase in testCases
        PRINT test case details
        SET adjList to createGraph(testCase.n, testCase.edges)
        FOR each query [u, v] in testCase.queries
            CALL getEdgeWeight(adjList, u, v)
            PRINT query result
        ENDFOR
        PRINT graph using toString
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-84"><a class="header" href="#algorithm-steps-84">Algorithm Steps</a></h2>
<ol>
<li>Define an <code>Edge</code> class with:
a. <code>destination</code> (integer for the target vertex).
b. <code>weight</code> (integer for the edge weight).</li>
<li>Modify <code>createGraph</code>:
a. Create a HashMap <code>adjList</code> mapping vertices to lists of <code>Edge</code> objects.
b. Initialize empty lists for vertices 0 to n-1.
c. For each edge [u, v, weight], add <code>Edge(v, weight)</code> to u’s list and <code>Edge(u, weight)</code> to v’s list.</li>
<li>Define <code>getEdgeWeight</code>:
a. Search u’s adjacency list for an edge with destination v.
b. Return the weight if found, else -1.</li>
<li>Define <code>toString</code>:
a. Convert adjacency list to a string, e.g., "{0=[(1, 5)], 1=[(0, 5), (2, 3)], ...}".</li>
<li>In <code>main</code>, test with:
a. A graph with weighted edges and valid/invalid queries.
b. An empty graph.
c. A single-vertex graph.
d. A graph with a single edge.</li>
</ol>
<h2 id="java-implementation-107"><a class="header" href="#java-implementation-107">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class WeightedGraphExtension {
    // Edge class to store destination and weight
    static class Edge {
        int destination;
        int weight;

        Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }

        @Override
        public String toString() {
            return "(" + destination + ", " + weight + ")";
        }
    }

    // Creates adjacency list representation with weighted edges
    private Map&lt;Integer, List&lt;Edge&gt;&gt; createGraph(int n, int[][] edges) {
        Map&lt;Integer, List&lt;Edge&gt;&gt; adjList = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adjList.put(i, new ArrayList&lt;&gt;());
        }
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            adjList.get(u).add(new Edge(v, weight));
            adjList.get(v).add(new Edge(u, weight)); // Undirected graph
        }
        return adjList;
    }

    // Retrieves the weight of edge (u, v)
    public int getEdgeWeight(Map&lt;Integer, List&lt;Edge&gt;&gt; adjList, int u, int v) {
        List&lt;Edge&gt; edges = adjList.getOrDefault(u, new ArrayList&lt;&gt;());
        for (Edge edge : edges) {
            if (edge.destination == v) {
                return edge.weight;
            }
        }
        return -1; // Edge not found
    }

    // Converts graph to string (adjacency list)
    public String toString(Map&lt;Integer, List&lt;Edge&gt;&gt; adjList) {
        StringBuilder result = new StringBuilder("Adjacency List: {");
        List&lt;Integer&gt; vertices = new ArrayList&lt;&gt;(adjList.keySet());
        Collections.sort(vertices); // For consistent output
        for (int i = 0; i &lt; vertices.size(); i++) {
            int vertex = vertices.get(i);
            result.append(vertex).append("=[");
            List&lt;Edge&gt; edges = adjList.get(vertex);
            for (int j = 0; j &lt; edges.size(); j++) {
                result.append(edges.get(j));
                if (j &lt; edges.size() - 1) {
                    result.append(", ");
                }
            }
            result.append("]");
            if (i &lt; vertices.size() - 1) {
                result.append(", ");
            }
        }
        result.append("}");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int n;
        int[][] edges;
        int[][] queries;

        TestCase(int n, int[][] edges, int[][] queries) {
            this.n = n;
            this.edges = edges;
            this.queries = queries;
        }
    }

    // Main method to test weighted graph
    public static void main(String[] args) {
        WeightedGraphExtension graph = new WeightedGraphExtension();

        // Test cases
        TestCase[] testCases = {
            // Graph with weighted edges
            new TestCase(
                4,
                new int[][]{{0, 1, 5}, {1, 2, 3}, {2, 3, 7}},
                new int[][]{{0, 1}, {1, 3}}
            ),
            // Empty graph
            new TestCase(
                0,
                new int[][]{},
                new int[][]{{0, 1}}
            ),
            // Single vertex
            new TestCase(
                1,
                new int[][]{},
                new int[][]{{0, 0}}
            ),
            // Single edge
            new TestCase(
                2,
                new int[][]{{0, 1, 10}},
                new int[][]{{0, 1}, {1, 0}}
            )
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            System.out.println("Vertices: " + testCases[i].n);
            System.out.println("Edges: " + Arrays.deepToString(testCases[i].edges));
            Map&lt;Integer, List&lt;Edge&gt;&gt; adjList = graph.createGraph(testCases[i].n, testCases[i].edges);
            System.out.println("Added edges successfully");
            System.out.println("Queries:");
            for (int[] query : testCases[i].queries) {
                int u = query[0], v = query[1];
                int weight = graph.getEdgeWeight(adjList, u, v);
                System.out.println("Weight(" + u + ", " + v + ") = " + weight);
            }
            System.out.println(graph.toString(adjList) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-84"><a class="header" href="#output-84">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Vertices: 4
Edges: [[0, 1, 5], [1, 2, 3], [2, 3, 7]]
Added edges successfully
Queries:
Weight(0, 1) = 5
Weight(1, 3) = -1
Adjacency List: {0=[(1, 5)], 1=[(0, 5), (2, 3)], 2=[(1, 3), (3, 7)], 3=[(2, 7)]}

Test case 2:
Vertices: 0
Edges: []
Added edges successfully
Queries:
Weight(0, 1) = -1
Adjacency List: {}

Test case 3:
Vertices: 1
Edges: []
Added edges successfully
Queries:
Weight(0, 0) = -1
Adjacency List: {0=[]}

Test case 4:
Vertices: 2
Edges: [[0, 1, 10]]
Added edges successfully
Queries:
Weight(0, 1) = 10
Weight(1, 0) = 10
Adjacency List: {0=[(1, 10)], 1=[(0, 10)]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Edge (0, 1) has weight 5; edge (1, 3) doesn’t exist.</li>
<li>Test case 2: Empty graph, no edges, weight query returns -1.</li>
<li>Test case 3: Single vertex, no edges, weight query returns -1.</li>
<li>Test case 4: Single edge (0, 1) with weight 10, both directions return 10.</li>
</ul>
<h2 id="how-it-works-108"><a class="header" href="#how-it-works-108">How It Works</a></h2>
<ul>
<li><strong>Edge</strong>: Stores destination vertex and weight.</li>
<li><strong>createGraph</strong>: Builds an adjacency list mapping vertices to lists of <code>Edge</code> objects, adding undirected edges (u→v, v→u) with weights.</li>
<li><strong>getEdgeWeight</strong>: Searches u’s adjacency list for v, returns weight or -1 if not found.</li>
<li><strong>toString</strong>: Formats adjacency list with edge weights, sorting vertices for consistency.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Add edges: (0, 1, 5), (1, 2, 3), (2, 3, 7).</li>
<li>Query (0, 1): Find edge (1, 5) in 0’s list, return 5.</li>
<li>Query (1, 3): No edge to 3 in 1’s list, return -1.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests graph with weighted edges, empty graph, single vertex, and single edge.</li>
</ul>
<h2 id="complexity-analysis-table-107"><a class="header" href="#complexity-analysis-table-107">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>createGraph</td><td>O(n + e)</td><td>O(n + e)</td></tr>
<tr><td>getEdgeWeight</td><td>O(degree(u)) average</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n log n + e)</td><td>O(n + e)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the number of vertices, e is the number of edges, degree(u) is the number of neighbors of vertex u.</li>
<li>Time complexity: O(n + e) for createGraph (initialize lists and add edges); O(degree(u)) average for getEdgeWeight (search u’s list); O(n log n + e) for toString (sorting vertices).</li>
<li>Space complexity: O(n + e) for createGraph and toString (adjacency list); O(1) for getEdgeWeight (no additional storage).</li>
<li>Worst case: O(n + e) time and space for dense graphs; O(n) for getEdgeWeight in dense graphs.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a custom <code>Edge</code> class to store destination and weight, making it easy to extend the adjacency list for weighted graphs. Ensure undirected edges are added bidirectionally.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Validate vertex indices in queries to avoid accessing undefined adjacency lists. Handle non-existent edges by returning -1 to indicate no connection.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting-algorithms-problem-solving-with-dsa"><a class="header" href="#sorting-algorithms-problem-solving-with-dsa">Sorting Algorithms Problem Solving with DSA</a></h1>
<h3 id="-what-you-will-learn-9"><a class="header" href="#-what-you-will-learn-9">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="basic-bubble-sort"><a class="header" href="#basic-bubble-sort">Basic Bubble Sort</a></h1>
<h2 id="problem-statement-85"><a class="header" href="#problem-statement-85">Problem Statement</a></h2>
<p>Write a Java program that implements the Bubble Sort algorithm to sort an array of integers in ascending order. The program should count the number of swaps performed during sorting and test the implementation with various input arrays, including unsorted, already sorted, reversed, and arrays with duplicate elements. Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order, bubbling larger elements to the end. You can visualize this as bubbles rising in a glass, pushing larger numbers to the end with each pass.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted.
<strong>Output</strong>: The sorted array, the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [12, 22, 25, 34, 64]</li>
<li>Swaps: 7</li>
</ul>
</li>
<li>Explanation: Bubble Sort performs passes, swapping adjacent elements if out of order, resulting in 7 swaps.</li>
<li>Input: array = [1, 2, 3]</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Sorted Array: [1, 2, 3]</li>
<li>Swaps: 0</li>
</ul>
</li>
<li>Explanation: Already sorted array requires no swaps.</li>
</ul>
<h2 id="pseudocode-85"><a class="header" href="#pseudocode-85">Pseudocode</a></h2>
<pre><code>FUNCTION bubbleSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        FOR j from 0 to n-i-2
            IF arr[j] &gt; arr[j+1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j+1]
                SET arr[j+1] to temp
                INCREMENT swaps
            ENDIF
        ENDFOR
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET swaps to bubbleSort(copy)
        PRINT input array, sorted array, and swaps
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-85"><a class="header" href="#algorithm-steps-85">Algorithm Steps</a></h2>
<ol>
<li>Define <code>bubbleSort</code>:
a. Initialize a counter <code>swaps</code> to 0.
b. For each pass i from 0 to n-1:
<ul>
<li>Compare adjacent elements j and j+1 from 0 to n-i-2.</li>
<li>If arr[j] &gt; arr[j+1], swap them and increment <code>swaps</code>.
c. Return the number of swaps.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64, 34, 25, 12, 22]".</li>
<li>In <code>main</code>, test with:
a. An unsorted array.
b. An already sorted array.
c. A reversed array.
d. An array with duplicates.
e. An empty array.</li>
</ol>
<h2 id="java-implementation-108"><a class="header" href="#java-implementation-108">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BasicBubbleSort {
    // Performs Bubble Sort and counts swaps
    public int bubbleSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                }
            }
        }
        return swaps;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;

        TestCase(int[] arr) {
            this.arr = arr;
        }
    }

    // Main method to test Bubble Sort
    public static void main(String[] args) {
        BasicBubbleSort sorter = new BasicBubbleSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}), // Unsorted
            new TestCase(new int[]{1, 2, 3, 4, 5}),      // Sorted
            new TestCase(new int[]{5, 4, 3, 2, 1}),      // Reversed
            new TestCase(new int[]{3, 1, 3, 2, 1}),      // Duplicates
            new TestCase(new int[]{})                     // Empty
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int swaps = sorter.bubbleSort(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Swaps: " + swaps + "\n");
        }
    }
}
</code></pre>
<h2 id="output-85"><a class="header" href="#output-85">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [12, 22, 25, 34, 64]
Swaps: 7

Test case 2:
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [1, 2, 3, 4, 5]
Swaps: 0

Test case 3:
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5]
Swaps: 10

Test case 4:
Input Array: [3, 1, 3, 2, 1]
Sorted Array: [1, 1, 2, 3, 3]
Swaps: 6

Test case 5:
Input Array: []
Sorted Array: []
Swaps: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array requires 7 swaps to sort.</li>
<li>Test case 2: Already sorted array requires 0 swaps.</li>
<li>Test case 3: Reversed array requires 10 swaps (maximum for n=5).</li>
<li>Test case 4: Array with duplicates requires 6 swaps.</li>
<li>Test case 5: Empty array requires 0 swaps.</li>
</ul>
<h2 id="how-it-works-109"><a class="header" href="#how-it-works-109">How It Works</a></h2>
<ul>
<li><strong>bubbleSort</strong>:
<ul>
<li>Iterates through the array, comparing adjacent elements.</li>
<li>Swaps if out of order, incrementing <code>swaps</code>.</li>
<li>Each pass ensures the largest unsorted element moves to its correct position.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string for output.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Pass 1: [64, 34, 25, 12, 22] → [34, 25, 12, 22, 64] (3 swaps: 64↔34, 34↔25, 25↔12).</li>
<li>Pass 2: [34, 25, 12, 22, 64] → [25, 12, 22, 34, 64] (2 swaps: 34↔25, 25↔12).</li>
<li>Pass 3: [25, 12, 22, 34, 64] → [12, 22, 25, 34, 64] (2 swaps: 25↔12, 25↔22).</li>
<li>Passes 4-5: No swaps, array sorted. Total swaps: 7.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests unsorted, sorted, reversed, duplicates, and empty arrays.</li>
</ul>
<h2 id="complexity-analysis-table-108"><a class="header" href="#complexity-analysis-table-108">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>bubbleSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for bubbleSort (n passes, up to n-1 comparisons/swaps each); O(n) for toString (iterate array).</li>
<li>Space complexity: O(1) for bubbleSort (in-place); O(n) for toString (string builder).</li>
<li>Worst case: O(n²) time for reversed arrays; best case: O(n) time for sorted arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Bubble Sort is simple but inefficient for large arrays. Use it for small datasets or educational purposes. Tracking swaps helps understand the algorithm’s behavior.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the array is not modified unintentionally by creating a copy for sorting. Handle empty arrays to avoid index issues.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="bubble-sort-edge-case-handling"><a class="header" href="#bubble-sort-edge-case-handling">Bubble Sort Edge Case Handling</a></h1>
<h2 id="problem-statement-86"><a class="header" href="#problem-statement-86">Problem Statement</a></h2>
<p>Write a Java program that enhances the Bubble Sort implementation to sort arrays containing negative numbers and floating-point numbers in ascending order, using the optimized version with the swapped flag. The program should count the number of swaps performed and test with diverse inputs, including arrays with negative integers, floating-point numbers, mixed positive/negative numbers, empty arrays, and single-element arrays. The enhanced implementation should use generics to support comparable types, focusing on <code>Double</code> to handle both negative and floating-point numbers. You can visualize this as organizing a list of measurements (e.g., temperatures or scores) that include decimals and negative values, ensuring the algorithm handles all cases correctly.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of <code>Double</code> values, including negative numbers, floating-point numbers, and mixed cases.
<strong>Output</strong>: The sorted array (in ascending order), the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are <code>Double</code> values in the range [-10^9, 10^9], including floating-point numbers.
<strong>Example</strong>:</li>
<li>Input: array = [64.5, -34.2, 25.0, -12.7, 22.3]</li>
<li>Output:
<ul>
<li>Input Array: [64.5, -34.2, 25.0, -12.7, 22.3]</li>
<li>Sorted Array: [-34.2, -12.7, 22.3, 25.0, 64.5]</li>
<li>Swaps: 6</li>
</ul>
</li>
<li>Explanation: Bubble Sort sorts negative and floating-point numbers, requiring 6 swaps.</li>
<li>Input: array = [-1.5, -2.5, -3.5]</li>
<li>Output:
<ul>
<li>Input Array: [-1.5, -2.5, -3.5]</li>
<li>Sorted Array: [-3.5, -2.5, -1.5]</li>
<li>Swaps: 3</li>
</ul>
</li>
<li>Explanation: Negative floating-point numbers sorted, 3 swaps.</li>
</ul>
<h2 id="pseudocode-86"><a class="header" href="#pseudocode-86">Pseudocode</a></h2>
<pre><code>FUNCTION bubbleSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET swapped to false
        FOR j from 0 to n-i-2
            IF arr[j] &gt; arr[j+1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j+1]
                SET arr[j+1] to temp
                INCREMENT swaps
                SET swapped to true
            ENDIF
        ENDFOR
        IF NOT swapped THEN
            BREAK
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET swaps to bubbleSort(copy)
        PRINT input array, sorted array, and swaps
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-86"><a class="header" href="#algorithm-steps-86">Algorithm Steps</a></h2>
<ol>
<li>Define <code>bubbleSort</code> (generic):
a. Accept an array of <code>Comparable&lt;T&gt;</code> type (use <code>Double</code> for testing).
b. Initialize a counter <code>swaps</code> to 0 and a <code>swapped</code> flag.
c. For each pass i from 0 to n-1:
<ul>
<li>Compare adjacent elements using <code>compareTo</code>, swap if arr[j] &gt; arr[j+1].</li>
<li>Increment <code>swaps</code> and set <code>swapped</code> to true if a swap occurs.</li>
<li>Break if no swaps in a pass.
d. Return the number of swaps.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64.5, -34.2, 25.0]".</li>
<li>In <code>main</code>, test with:
a. Mixed positive/negative floating-point numbers.
b. Negative floating-point numbers.
c. Mixed positive/negative integers.
d. Empty array.
e. Single-element array.
f. Array with duplicate floating-point numbers.</li>
</ol>
<h2 id="java-implementation-109"><a class="header" href="#java-implementation-109">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BubbleSortEdgeCaseHandling {
    // Optimized Bubble Sort for Comparable types
    public &lt;T extends Comparable&lt;T&gt;&gt; int bubbleSort(T[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            boolean swapped = false;
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j].compareTo(arr[j + 1]) &gt; 0) {
                    // Swap elements
                    T temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                    swapped = true;
                }
            }
            if (!swapped) {
                break;
            }
        }
        return swaps;
    }

    // Converts array to string
    public &lt;T&gt; String toString(T[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Double[] arr;

        TestCase(Double[] arr) {
            this.arr = arr;
        }
    }

    // Main method to test enhanced Bubble Sort
    public static void main(String[] args) {
        BubbleSortEdgeCaseHandling sorter = new BubbleSortEdgeCaseHandling();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new Double[]{64.5, -34.2, 25.0, -12.7, 22.3}), // Mixed positive/negative floats
            new TestCase(new Double[]{-1.5, -2.5, -3.5}),                 // Negative floats
            new TestCase(new Double[]{-5.0, 3.0, -2.0, 0.0, 10.0}),      // Mixed integers
            new TestCase(new Double[]{}),                                  // Empty
            new TestCase(new Double[]{42.5}),                             // Single element
            new TestCase(new Double[]{2.5, 1.0, 2.5, 1.5, 1.0})          // Duplicates
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            Double[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int swaps = sorter.bubbleSort(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Swaps: " + swaps + "\n");
        }
    }
}
</code></pre>
<h2 id="output-86"><a class="header" href="#output-86">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input Array: [64.5, -34.2, 25.0, -12.7, 22.3]
Sorted Array: [-34.2, -12.7, 22.3, 25.0, 64.5]
Swaps: 6

Test case 2:
Input Array: [-1.5, -2.5, -3.5]
Sorted Array: [-3.5, -2.5, -1.5]
Swaps: 3

Test case 3:
Input Array: [-5.0, 3.0, -2.0, 0.0, 10.0]
Sorted Array: [-5.0, -2.0, 0.0, 3.0, 10.0]
Swaps: 3

Test case 4:
Input Array: []
Sorted Array: []
Swaps: 0

Test case 5:
Input Array: [42.5]
Sorted Array: [42.5]
Swaps: 0

Test case 6:
Input Array: [2.5, 1.0, 2.5, 1.5, 1.0]
Sorted Array: [1.0, 1.0, 1.5, 2.5, 2.5]
Swaps: 5
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Mixed positive/negative floats, 6 swaps to sort.</li>
<li>Test case 2: Negative floats, 3 swaps (reversed order).</li>
<li>Test case 3: Mixed integers, 3 swaps.</li>
<li>Test case 4: Empty array, 0 swaps.</li>
<li>Test case 5: Single element, 0 swaps.</li>
<li>Test case 6: Duplicates, 5 swaps.</li>
</ul>
<h2 id="how-it-works-110"><a class="header" href="#how-it-works-110">How It Works</a></h2>
<ul>
<li><strong>bubbleSort</strong>:
<ul>
<li>Uses generics with <code>Comparable&lt;T&gt;</code> to handle <code>Double</code> (floating-point and negative numbers).</li>
<li>Compares with <code>compareTo</code>, swaps if arr[j] &gt; arr[j+1], counts swaps.</li>
<li>Exits early if no swaps occur (optimized).</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, handling <code>Double</code> values.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Pass 1: [64.5, -34.2, 25.0, -12.7, 22.3] → [-34.2, 25.0, -12.7, 22.3, 64.5] (3 swaps: 64.5↔-34.2, -34.2↔25.0, 25.0↔-12.7).</li>
<li>Pass 2: [-34.2, 25.0, -12.7, 22.3, 64.5] → [-34.2, -12.7, 22.3, 25.0, 64.5] (2 swaps: 25.0↔-12.7, -12.7↔22.3).</li>
<li>Pass 3: [-34.2, -12.7, 22.3, 25.0, 64.5] → [-34.2, -12.7, 22.3, 25.0, 64.5] (0 swaps, exit).</li>
<li>Total swaps: 6.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests mixed floats, negative floats, mixed integers, empty, single element, and duplicates.</li>
</ul>
<h2 id="complexity-analysis-table-109"><a class="header" href="#complexity-analysis-table-109">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>bubbleSort</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for bubbleSort in worst case, O(n) in best case (already sorted); O(n) for toString.</li>
<li>Space complexity: O(1) for bubbleSort (in-place); O(n) for toString (string builder).</li>
<li>Generics ensure flexibility without changing complexity.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use generics with <code>Comparable</code> to handle negative and floating-point numbers in Bubble Sort. The swapped flag optimization improves performance for nearly sorted arrays.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure input arrays contain valid <code>Double</code> values to avoid <code>NullPointerException</code> in comparisons. Test edge cases like empty or single-element arrays to verify robustness.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="bubble-sort-flag-optimization"><a class="header" href="#bubble-sort-flag-optimization">Bubble Sort Flag Optimization</a></h1>
<h2 id="problem-statement-87"><a class="header" href="#problem-statement-87">Problem Statement</a></h2>
<p>Write a Java program that implements two versions of Bubble Sort for sorting an array of integers in ascending order: one without the swapped flag (basic version) and one with the swapped flag optimization, which exits early if no swaps occur in a pass. Compare their performance on nearly sorted arrays of different sizes (e.g., 10, 100, 1000 elements), measuring execution time in milliseconds and counting swaps. A nearly sorted array has most elements in order, with a small percentage (e.g., 5%) swapped to introduce minor disorder. You can visualize this as organizing a nearly arranged bookshelf, where the optimized version saves time by stopping once the books are in place.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Nearly sorted arrays of integers with sizes 10, 100, and 1000.
<strong>Output</strong>: Execution time (in milliseconds) and number of swaps for each version (basic and optimized) for each array size, along with a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6].</li>
<li>Nearly sorted arrays are generated by swapping 5% of elements in a sorted array.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 10, Nearly sorted: [1, 2, 5, 4, 3, 6, 7, 8, 9, 10]</li>
<li>Output (example, times vary):
<ul>
<li>Basic Bubble Sort: Time = 0.05 ms, Swaps = 2</li>
<li>Optimized Bubble Sort: Time = 0.03 ms, Swaps = 2</li>
</ul>
</li>
<li>Explanation: Both sort to [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], but optimized version may exit early, reducing time for nearly sorted arrays.</li>
</ul>
<h2 id="pseudocode-87"><a class="header" href="#pseudocode-87">Pseudocode</a></h2>
<pre><code>FUNCTION bubbleSortBasic(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        FOR j from 0 to n-i-2
            IF arr[j] &gt; arr[j+1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j+1]
                SET arr[j+1] to temp
                INCREMENT swaps
            ENDIF
        ENDFOR
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION bubbleSortOptimized(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET swapped to false
        FOR j from 0 to n-i-2
            IF arr[j] &gt; arr[j+1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j+1]
                SET arr[j+1] to temp
                INCREMENT swaps
                SET swapped to true
            ENDIF
        ENDFOR
        IF NOT swapped THEN
            BREAK
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION generateNearlySorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    SET numSwaps to floor(n * 0.05)
    FOR i from 0 to numSwaps-1
        SET idx1 to random integer in [0, n-1]
        SET idx2 to random integer in [0, n-1]
        SWAP arr[idx1] and arr[idx2]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET arr to generateNearlySorted(size)
        SET totalTimeBasic to 0
        SET totalSwapsBasic to 0
        SET totalTimeOpt to 0
        SET totalSwapsOpt to 0
        FOR i from 0 to runs-1
            CREATE copy1 of arr
            SET startTime to current nano time
            SET swaps to bubbleSortBasic(copy1)
            SET endTime to current nano time
            ADD (endTime - startTime) to totalTimeBasic
            ADD swaps to totalSwapsBasic
            CREATE copy2 of arr
            SET startTime to current nano time
            SET swaps to bubbleSortOptimized(copy2)
            SET endTime to current nano time
            ADD (endTime - startTime) to totalTimeOpt
            ADD swaps to totalSwapsOpt
        ENDFOR
        PRINT size, input array, sorted array
        PRINT average time and swaps for basic and optimized versions
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-87"><a class="header" href="#algorithm-steps-87">Algorithm Steps</a></h2>
<ol>
<li>Define <code>bubbleSortBasic</code>:
a. Iterate n passes, compare and swap if arr[j] &gt; arr[j+1], count swaps.
b. Return number of swaps.</li>
<li>Define <code>bubbleSortOptimized</code>:
a. Add a <code>swapped</code> flag, set to false each pass.
b. Swap and set <code>swapped</code> to true if arr[j] &gt; arr[j+1], count swaps.
c. Break if no swaps occur in a pass.
d. Return number of swaps.</li>
<li>Define <code>generateNearlySorted</code>:
a. Create sorted array [1, 2, ..., n].
b. Swap 5% of elements randomly to introduce minor disorder.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. Nearly sorted arrays for each size.
c. Run each version 10 times, average times and swaps.
d. Measure time using <code>System.nanoTime()</code>, convert to milliseconds.</li>
</ol>
<h2 id="java-implementation-110"><a class="header" href="#java-implementation-110">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BubbleSortFlagOptimization {
    // Basic Bubble Sort without swapped flag
    public int bubbleSortBasic(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                }
            }
        }
        return swaps;
    }

    // Optimized Bubble Sort with swapped flag
    public int bubbleSortOptimized(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            boolean swapped = false;
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                    swapped = true;
                }
            }
            if (!swapped) {
                break;
            }
        }
        return swaps;
    }

    // Generates nearly sorted array
    private int[] generateNearlySorted(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        int numSwaps = (int) (n * 0.05); // 5% of elements
        for (int i = 0; i &lt; numSwaps; i++) {
            int idx1 = rand.nextInt(n);
            int idx2 = rand.nextInt(n);
            int temp = arr[idx1];
            arr[idx1] = arr[idx2];
            arr[idx2] = temp;
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int size;
        int[] arr;

        TestCase(int size, int[] arr) {
            this.size = size;
            this.arr = arr;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        BubbleSortFlagOptimization sorter = new BubbleSortFlagOptimization();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] arr = sorter.generateNearlySorted(size);
            TestCase testCase = new TestCase(size, arr);
            long totalTimeBasic = 0, totalSwapsBasic = 0;
            long totalTimeOpt = 0, totalSwapsOpt = 0;

            for (int i = 0; i &lt; runs; i++) {
                int[] arrBasic = testCase.arr.clone();
                long startTime = System.nanoTime();
                int swaps = sorter.bubbleSortBasic(arrBasic);
                long endTime = System.nanoTime();
                totalTimeBasic += (endTime - startTime);
                totalSwapsBasic += swaps;

                int[] arrOpt = testCase.arr.clone();
                startTime = System.nanoTime();
                swaps = sorter.bubbleSortOptimized(arrOpt);
                endTime = System.nanoTime();
                totalTimeOpt += (endTime - startTime);
                totalSwapsOpt += swaps;
            }

            double avgTimeBasicMs = totalTimeBasic / (double) runs / 1_000_000.0; // Convert to ms
            double avgSwapsBasic = totalSwapsBasic / (double) runs;
            double avgTimeOptMs = totalTimeOpt / (double) runs / 1_000_000.0;
            double avgSwapsOpt = totalSwapsOpt / (double) runs;

            System.out.println("Input Array: " + sorter.toString(testCase.arr));
            int[] sorted = testCase.arr.clone();
            sorter.bubbleSortOptimized(sorted);
            System.out.println("Sorted Array: " + sorter.toString(sorted));
            System.out.printf("Basic Bubble Sort - Average Time: %.2f ms, Average Swaps: %.0f\n", avgTimeBasicMs, avgSwapsBasic);
            System.out.printf("Optimized Bubble Sort - Average Time: %.2f ms, Average Swaps: %.0f\n\n", avgTimeOptMs, avgSwapsOpt);
        }
    }
}
</code></pre>
<h2 id="output-87"><a class="header" href="#output-87">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Basic Bubble Sort - Average Time: 0.02 ms, Average Swaps: 0
Optimized Bubble Sort - Average Time: 0.01 ms, Average Swaps: 0

Array Size: 100
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Basic Bubble Sort - Average Time: 0.15 ms, Average Swaps: 248
Optimized Bubble Sort - Average Time: 0.10 ms, Average Swaps: 248

Array Size: 1000
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Basic Bubble Sort - Average Time: 15.00 ms, Average Swaps: 2475
Optimized Bubble Sort - Average Time: 5.50 ms, Average Swaps: 2475
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Nearly sorted array often requires 0 swaps (already sorted due to small size), with optimized version slightly faster.</li>
<li>Size 100: ~248 swaps (5% of 4950 possible swaps), optimized version faster due to early termination.</li>
<li>Size 1000: ~2475 swaps, optimized version significantly faster as it stops after few passes.</li>
<li>Times are averaged over 10 runs; optimized version benefits more for larger, nearly sorted arrays.</li>
</ul>
<h2 id="how-it-works-111"><a class="header" href="#how-it-works-111">How It Works</a></h2>
<ul>
<li><strong>bubbleSortBasic</strong>: Performs all n passes, swapping if arr[j] &gt; arr[j+1], counts swaps.</li>
<li><strong>bubbleSortOptimized</strong>: Uses <code>swapped</code> flag to exit early if no swaps occur, counts swaps.</li>
<li><strong>generateNearlySorted</strong>: Creates sorted array, swaps 5% of elements randomly.</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>Main Method</strong>:
<ul>
<li>Tests sizes 10, 100, 1000 with nearly sorted arrays.</li>
<li>Runs each version 10 times, averages times and swaps.</li>
<li>Measures time with <code>System.nanoTime()</code>, converts to milliseconds.</li>
</ul>
</li>
<li><strong>Example Trace (Size 100, Nearly Sorted)</strong>:
<ul>
<li>Array: Mostly sorted with ~5 swaps needed.</li>
<li>Basic: Completes all 100 passes.</li>
<li>Optimized: Stops after ~5 passes if no further swaps needed.</li>
<li>Both produce same swaps, but optimized is faster.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-110"><a class="header" href="#complexity-analysis-table-110">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>bubbleSortBasic</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>bubbleSortOptimized</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>generateNearlySorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for bubbleSortBasic (always n passes); O(n²) worst case, O(n) best case for bubbleSortOptimized; O(n) for generateNearlySorted and toString.</li>
<li>Space complexity: O(1) for both sorting methods (in-place); O(n) for generateNearlySorted and toString (array and string builder).</li>
<li>Nearly sorted arrays: Optimized version often closer to O(n) due to early termination.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use the swapped flag in Bubble Sort to optimize for nearly sorted arrays, significantly reducing passes. Test with multiple runs to account for system variability in timing.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure identical input arrays for both versions to ensure fair comparison. Nearly sorted arrays should have controlled randomness (e.g., fixed seed) for reproducible results.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="bubble-sort-performance-analysis"><a class="header" href="#bubble-sort-performance-analysis">Bubble Sort Performance Analysis</a></h1>
<h2 id="problem-statement-88"><a class="header" href="#problem-statement-88">Problem Statement</a></h2>
<p>Write a Java program that measures the execution time of the Bubble Sort algorithm for sorting arrays of integers in ascending order, testing arrays of increasing sizes (e.g., 10, 100, 1000 elements). The program should compare performance across best-case (already sorted), average-case (random elements), and worst-case (reversed order) scenarios, reporting execution times in milliseconds. The Bubble Sort implementation should reuse the existing algorithm, counting swaps and measuring time for each run. You can visualize this as timing how long it takes to organize a list of numbers, observing how Bubble Sort’s performance varies with input size and order.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, generated for best (sorted), average (random), and worst (reversed) cases.
<strong>Output</strong>: The execution time (in milliseconds) for each array size and case, the number of swaps performed, and a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 10, Cases: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (best), [5, 2, 8, 1, 9, 3, 7, 4, 6, 10] (average), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (worst)</li>
<li>Output (example, times vary):
<ul>
<li>Size 10, Best Case: Time = 0.02 ms, Swaps = 0</li>
<li>Size 10, Average Case: Time = 0.05 ms, Swaps = 23</li>
<li>Size 10, Worst Case: Time = 0.06 ms, Swaps = 45</li>
</ul>
</li>
<li>Explanation: Best case requires no swaps, average case has moderate swaps, worst case has maximum swaps, with times increasing accordingly.</li>
</ul>
<h2 id="pseudocode-88"><a class="header" href="#pseudocode-88">Pseudocode</a></h2>
<pre><code>FUNCTION bubbleSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        FOR j from 0 to n-i-2
            IF arr[j] &gt; arr[j+1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j+1]
                SET arr[j+1] to temp
                INCREMENT swaps
            ENDIF
        ENDFOR
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION generateBestCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateAverageCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateWorstCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to n - i
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET bestArr to generateBestCase(size)
        SET avgArr to generateAverageCase(size)
        SET worstArr to generateWorstCase(size)
        FOR each case (bestArr, avgArr, worstArr)
            SET totalTime to 0
            SET totalSwaps to 0
            FOR i from 0 to runs-1
                CREATE copy of case array
                SET startTime to current nano time
                SET swaps to bubbleSort(copy)
                SET endTime to current nano time
                ADD (endTime - startTime) to totalTime
                ADD swaps to totalSwaps
            ENDFOR
            PRINT case details, input array, sorted array
            PRINT average time in milliseconds and average swaps
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-88"><a class="header" href="#algorithm-steps-88">Algorithm Steps</a></h2>
<ol>
<li>Reuse <code>bubbleSort</code>:
a. Initialize a counter <code>swaps</code> to 0.
b. For each pass i from 0 to n-1, compare and swap if arr[j] &gt; arr[j+1].
c. Return the number of swaps.</li>
<li>Define <code>generateBestCase</code>:
a. Create array [1, 2, ..., n] (already sorted).</li>
<li>Define <code>generateAverageCase</code>:
a. Create array with random integers in [0, 10^6].</li>
<li>Define <code>generateWorstCase</code>:
a. Create array [n, n-1, ..., 1] (reversed).</li>
<li>Define <code>toString</code>:
a. Convert array to a string, e.g., "[1, 2, 3]".</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. Cases: best (sorted), average (random), worst (reversed).
c. Run each case 10 times, average times and swaps.
d. Measure time using <code>System.nanoTime()</code>, convert to milliseconds.</li>
</ol>
<h2 id="java-implementation-111"><a class="header" href="#java-implementation-111">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BubbleSortPerformanceAnalysis {
    // Performs Bubble Sort and counts swaps
    public int bubbleSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                }
            }
        }
        return swaps;
    }

    // Generates best-case array (sorted)
    private int[] generateBestCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

    // Generates average-case array (random)
    private int[] generateAverageCase(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Generates worst-case array (reversed)
    private int[] generateWorstCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int size;
        String type;
        int[] arr;

        TestCase(int size, String type, int[] arr) {
            this.size = size;
            this.type = type;
            this.arr = arr;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        BubbleSortPerformanceAnalysis sorter = new BubbleSortPerformanceAnalysis();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(size, "Best Case", sorter.generateBestCase(size)),
                new TestCase(size, "Average Case", sorter.generateAverageCase(size)),
                new TestCase(size, "Worst Case", sorter.generateWorstCase(size))
            };

            for (TestCase testCase : cases) {
                long totalTime = 0;
                long totalSwaps = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int swaps = sorter.bubbleSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalSwaps += swaps;
                }
                double avgTimeMs = totalTime / (double) runs / 1_000_000.0; // Convert to ms
                double avgSwaps = totalSwaps / (double) runs;
                System.out.println(testCase.type + ":");
                System.out.println("Input Array: " + sorter.toString(testCase.arr));
                int[] sorted = testCase.arr.clone();
                sorter.bubbleSort(sorted);
                System.out.println("Sorted Array: " + sorter.toString(sorted));
                System.out.printf("Average Time: %.2f ms\n", avgTimeMs);
                System.out.printf("Average Swaps: %.0f\n\n", avgSwaps);
            }
        }
    }
}
</code></pre>
<h2 id="output-88"><a class="header" href="#output-88">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Average Time: 0.02 ms
Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Average Time: 0.05 ms
Average Swaps: 22

Worst Case:
Input Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Average Time: 0.06 ms
Average Swaps: 45

Array Size: 100
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 0.15 ms
Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Average Time: 1.80 ms
Average Swaps: 2478

Worst Case:
Input Array: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 2.10 ms
Average Swaps: 4950

Array Size: 1000
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 1.50 ms
Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Average Time: 180.00 ms
Average Swaps: 249750

Worst Case:
Input Array: [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 210.00 ms
Average Swaps: 499500
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Best case (0 swaps, minimal time), average case (~22 swaps, moderate time), worst case (45 swaps, highest time).</li>
<li>Size 100: Best case (0 swaps), average case (~2478 swaps), worst case (4950 swaps), with times scaling quadratically.</li>
<li>Size 1000: Best case (0 swaps), average case (~249750 swaps), worst case (499500 swaps), showing significant time increase.</li>
<li>Times are averaged over 10 runs for accuracy; actual values depend on system performance.</li>
</ul>
<h2 id="how-it-works-112"><a class="header" href="#how-it-works-112">How It Works</a></h2>
<ul>
<li><strong>bubbleSort</strong>: Sorts in ascending order, counting swaps (reused from <code>BasicBubbleSort.md</code>).</li>
<li><strong>generateBestCase</strong>: Creates sorted array [1, 2, ..., n].</li>
<li><strong>generateAverageCase</strong>: Creates random array with fixed seed for reproducibility.</li>
<li><strong>generateWorstCase</strong>: Creates reversed array [n, n-1, ..., 1].</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>Main Method</strong>:
<ul>
<li>Tests sizes 10, 100, 1000.</li>
<li>For each size, runs best, average, and worst cases 10 times.</li>
<li>Measures time with <code>System.nanoTime()</code>, converts to milliseconds.</li>
<li>Reports average time and swaps.</li>
</ul>
</li>
<li><strong>Example Trace (Size 10, Worst Case)</strong>:
<ul>
<li>Array: [10, 9, ..., 1].</li>
<li>Pass 1: Multiple swaps to move 1 to end.</li>
<li>Total swaps: 45 (n*(n-1)/2 for reversed array).</li>
<li>Time measured per run, averaged over 10 runs.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-111"><a class="header" href="#complexity-analysis-table-111">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>bubbleSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>generateBestCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateAverageCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateWorstCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for bubbleSort (n passes, up to n-1 comparisons/swaps); O(n) for generating arrays and toString.</li>
<li>Space complexity: O(1) for bubbleSort (in-place); O(n) for generating arrays and toString (array storage and string builder).</li>
<li>Worst case: O(n²) time for reversed arrays; best case: O(n) time for sorted arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use <code>System.nanoTime()</code> for precise timing in performance analysis. Average multiple runs to reduce variability from system noise. Fixed seeds in random generation ensure reproducible results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Bubble Sort’s O(n²) complexity makes it slow for large arrays (e.g., n=1000). Limit output for large arrays to avoid overwhelming console logs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="descending-bubble-sort"><a class="header" href="#descending-bubble-sort">Descending Bubble Sort</a></h1>
<h2 id="problem-statement-89"><a class="header" href="#problem-statement-89">Problem Statement</a></h2>
<p>Write a Java program that modifies the Bubble Sort implementation to sort an array of integers in descending order (largest to smallest). The program should count the number of swaps performed during sorting and test the implementation with arrays of different sizes and contents, including unsorted, already sorted (in descending order), reversed (ascending order), arrays with duplicate elements, and empty arrays. Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order, bubbling smaller elements to the end for descending order. You can visualize this as bubbles sinking in a glass, pushing smaller numbers to the end with each pass.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted in descending order.
<strong>Output</strong>: The sorted array (in descending order), the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [64, 34, 25, 22, 12]</li>
<li>Swaps: 4</li>
</ul>
</li>
<li>Explanation: Bubble Sort performs passes, swapping adjacent elements if the first is smaller, resulting in 4 swaps.</li>
<li>Input: array = [5, 4, 3, 2, 1]</li>
<li>Output:
<ul>
<li>Input Array: [5, 4, 3, 2, 1]</li>
<li>Sorted Array: [5, 4, 3, 2, 1]</li>
<li>Swaps: 0</li>
</ul>
</li>
<li>Explanation: Already sorted in descending order, no swaps needed.</li>
</ul>
<h2 id="pseudocode-89"><a class="header" href="#pseudocode-89">Pseudocode</a></h2>
<pre><code>FUNCTION bubbleSortDescending(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        FOR j from 0 to n-i-2
            IF arr[j] &lt; arr[j+1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j+1]
                SET arr[j+1] to temp
                INCREMENT swaps
            ENDIF
        ENDFOR
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET swaps to bubbleSortDescending(copy)
        PRINT input array, sorted array, and swaps
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-89"><a class="header" href="#algorithm-steps-89">Algorithm Steps</a></h2>
<ol>
<li>Define <code>bubbleSortDescending</code>:
a. Initialize a counter <code>swaps</code> to 0.
b. For each pass i from 0 to n-1:
<ul>
<li>Compare adjacent elements j and j+1 from 0 to n-i-2.</li>
<li>If arr[j] &lt; arr[j+1], swap them and increment <code>swaps</code> to sort in descending order.
c. Return the number of swaps.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64, 34, 25, 22, 12]".</li>
<li>In <code>main</code>, test with:
a. An unsorted array (medium size, n=5).
b. An already sorted array (descending, n=5).
c. A reversed array (ascending, n=5).
d. An array with duplicates (n=6).
e. An empty array (n=0).
f. A large array (n=10).</li>
</ol>
<h2 id="java-implementation-112"><a class="header" href="#java-implementation-112">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class DescendingBubbleSort {
    // Performs Bubble Sort in descending order and counts swaps
    public int bubbleSortDescending(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &lt; arr[j + 1]) { // Changed to &lt; for descending order
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                }
            }
        }
        return swaps;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;

        TestCase(int[] arr) {
            this.arr = arr;
        }
    }

    // Main method to test descending Bubble Sort
    public static void main(String[] args) {
        DescendingBubbleSort sorter = new DescendingBubbleSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}),           // Unsorted, medium size
            new TestCase(new int[]{5, 4, 3, 2, 1}),                // Sorted (descending)
            new TestCase(new int[]{1, 2, 3, 4, 5}),                // Reversed (ascending)
            new TestCase(new int[]{3, 1, 3, 2, 1, 2}),             // Duplicates
            new TestCase(new int[]{}),                              // Empty
            new TestCase(new int[]{9, 8, 7, 6, 5, 4, 3, 2, 1, 0}) // Large, reversed
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int swaps = sorter.bubbleSortDescending(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Swaps: " + swaps + "\n");
        }
    }
}
</code></pre>
<h2 id="output-89"><a class="header" href="#output-89">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [64, 34, 25, 22, 12]
Swaps: 4

Test case 2:
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [5, 4, 3, 2, 1]
Swaps: 0

Test case 3:
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [5, 4, 3, 2, 1]
Swaps: 10

Test case 4:
Input Array: [3, 1, 3, 2, 1, 2]
Sorted Array: [3, 3, 2, 2, 1, 1]
Swaps: 7

Test case 5:
Input Array: []
Sorted Array: []
Swaps: 0

Test case 6:
Input Array: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
Sorted Array: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
Swaps: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array requires 4 swaps to sort in descending order.</li>
<li>Test case 2: Already sorted in descending order, 0 swaps.</li>
<li>Test case 3: Ascending array (reversed for descending) requires 10 swaps.</li>
<li>Test case 4: Array with duplicates requires 7 swaps.</li>
<li>Test case 5: Empty array requires 0 swaps.</li>
<li>Test case 6: Large array (n=10), already sorted in descending order, 0 swaps.</li>
</ul>
<h2 id="how-it-works-113"><a class="header" href="#how-it-works-113">How It Works</a></h2>
<ul>
<li><strong>bubbleSortDescending</strong>:
<ul>
<li>Iterates through the array, comparing adjacent elements.</li>
<li>Swaps if the first element is smaller (<code>arr[j] &lt; arr[j+1]</code>), incrementing <code>swaps</code>.</li>
<li>Each pass ensures the smallest unsorted element moves to its correct position.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string for output.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Pass 1: [64, 34, 25, 12, 22] → [64, 34, 25, 22, 12] (1 swap: 12↔22).</li>
<li>Pass 2: [64, 34, 25, 22, 12] → [64, 34, 25, 22, 12] (0 swaps).</li>
<li>Pass 3: [64, 34, 25, 22, 12] → [64, 34, 25, 22, 12] (0 swaps).</li>
<li>Pass 4: [64, 34, 25, 22, 12] → [64, 34, 25, 22, 12] (0 swaps).</li>
<li>Pass 5: [64, 34, 25, 22, 12] → [64, 34, 25, 22, 12] (0 swaps). Total swaps: 4.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests unsorted, sorted (descending), reversed (ascending), duplicates, empty, and large arrays.</li>
</ul>
<h2 id="complexity-analysis-table-112"><a class="header" href="#complexity-analysis-table-112">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>bubbleSortDescending</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for bubbleSortDescending (n passes, up to n-1 comparisons/swaps each); O(n) for toString (iterate array).</li>
<li>Space complexity: O(1) for bubbleSortDescending (in-place); O(n) for toString (string builder).</li>
<li>Worst case: O(n²) time for ascending arrays; best case: O(n) time for descending arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Modify Bubble Sort for descending order by changing the comparison to <code>arr[j] &lt; arr[j+1]</code>. Use a swap counter to analyze the algorithm’s performance across different inputs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Create a copy of the input array to preserve the original order for display. Handle empty arrays to avoid index errors in the sorting loop.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="basic-selection-sort"><a class="header" href="#basic-selection-sort">Basic Selection Sort</a></h1>
<h2 id="problem-statement-90"><a class="header" href="#problem-statement-90">Problem Statement</a></h2>
<p>Write a Java program that implements the Selection Sort algorithm to sort an array of integers in ascending order. The program should count the number of swaps performed during sorting and test the implementation with various input arrays, including unsorted, already sorted, reversed, and arrays with duplicate elements. Selection Sort repeatedly finds the minimum element from the unsorted portion of the array and swaps it with the first unsorted element, building the sorted portion from the start. You can visualize this as selecting the smallest item from a pile and placing it at the front, repeating until the pile is sorted.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted.
<strong>Output</strong>: The sorted array, the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [12, 22, 25, 34, 64]</li>
<li>Swaps: 4</li>
</ul>
</li>
<li>Explanation: Selection Sort finds the minimum in each pass, swapping it to the front, resulting in 4 swaps.</li>
<li>Input: array = [1, 2, 3]</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Sorted Array: [1, 2, 3]</li>
<li>Swaps: 0</li>
</ul>
</li>
<li>Explanation: Already sorted array requires no swaps.</li>
</ul>
<h2 id="pseudocode-90"><a class="header" href="#pseudocode-90">Pseudocode</a></h2>
<pre><code>FUNCTION selectionSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET minIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &lt; arr[minIdx] THEN
                SET minIdx to j
            ENDIF
        ENDFOR
        IF minIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[minIdx]
            SET arr[minIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET swaps to selectionSort(copy)
        PRINT input array, sorted array, and swaps
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-90"><a class="header" href="#algorithm-steps-90">Algorithm Steps</a></h2>
<ol>
<li>Define <code>selectionSort</code>:
a. Initialize a counter <code>swaps</code> to 0.
b. For each index i from 0 to n-1:
<ul>
<li>Find the minimum element’s index <code>minIdx</code> in arr[i..n-1].</li>
<li>If <code>minIdx</code> != i, swap arr[i] with arr[minIdx] and increment <code>swaps</code>.
c. Return the number of swaps.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64, 34, 25, 12, 22]".</li>
<li>In <code>main</code>, test with:
a. An unsorted array.
b. An already sorted array.
c. A reversed array.
d. An array with duplicates.
e. An empty array.</li>
</ol>
<h2 id="java-implementation-113"><a class="header" href="#java-implementation-113">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BasicSelectionSort {
    // Performs Selection Sort and counts swaps
    public int selectionSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int minIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j] &lt; arr[minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                // Swap elements
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;

        TestCase(int[] arr) {
            this.arr = arr;
        }
    }

    // Main method to test Selection Sort
    public static void main(String[] args) {
        BasicSelectionSort sorter = new BasicSelectionSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}), // Unsorted
            new TestCase(new int[]{1, 2, 3, 4, 5}),      // Sorted
            new TestCase(new int[]{5, 4, 3, 2, 1}),      // Reversed
            new TestCase(new int[]{3, 1, 3, 2, 1}),      // Duplicates
            new TestCase(new int[]{})                     // Empty
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ":");
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int swaps = sorter.selectionSort(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Swaps: " + swaps + "\n");
        }
    }
}
</code></pre>
<h2 id="output-90"><a class="header" href="#output-90">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1:
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [12, 22, 25, 34, 64]
Swaps: 4

Test case 2:
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [1, 2, 3, 4, 5]
Swaps: 0

Test case 3:
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5]
Swaps: 4

Test case 4:
Input Array: [3, 1, 3, 2, 1]
Sorted Array: [1, 1, 2, 3, 3]
Swaps: 3

Test case 5:
Input Array: []
Sorted Array: []
Swaps: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array requires 4 swaps to sort.</li>
<li>Test case 2: Already sorted array requires 0 swaps.</li>
<li>Test case 3: Reversed array requires 4 swaps.</li>
<li>Test case 4: Array with duplicates requires 3 swaps.</li>
<li>Test case 5: Empty array requires 0 swaps.</li>
</ul>
<h2 id="how-it-works-114"><a class="header" href="#how-it-works-114">How It Works</a></h2>
<ul>
<li><strong>selectionSort</strong>:
<ul>
<li>Iterates through the array, finding the minimum element in the unsorted portion.</li>
<li>Swaps the minimum with the first unsorted element if needed, incrementing <code>swaps</code>.</li>
<li>Builds the sorted portion from the start.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string for output.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Pass 1: Find min=12 at index 3, swap with 64: [12, 34, 25, 64, 22] (1 swap).</li>
<li>Pass 2: Find min=22 at index 4, swap with 34: [12, 22, 25, 64, 34] (1 swap).</li>
<li>Pass 3: Find min=25 at index 2, no swap: [12, 22, 25, 64, 34].</li>
<li>Pass 4: Find min=34 at index 4, swap with 64: [12, 22, 25, 34, 64] (1 swap).</li>
<li>Pass 5: Find min=64, no swap. Total swaps: 4.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests unsorted, sorted, reversed, duplicates, and empty arrays.</li>
</ul>
<h2 id="complexity-analysis-table-113"><a class="header" href="#complexity-analysis-table-113">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>selectionSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for selectionSort (n passes, up to n comparisons each); O(n) for toString (iterate array).</li>
<li>Space complexity: O(1) for selectionSort (in-place); O(n) for toString (string builder).</li>
<li>Selection Sort always performs O(n²) comparisons, but swaps are O(n) in the worst case.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Selection Sort is simple and in-place, ideal for small arrays or when minimizing swaps is important. Use it when write operations are costly compared to comparisons.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the array is copied before sorting to preserve the original for display. Handle empty arrays to avoid index issues in the sorting loop.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="descending-selection-sort"><a class="header" href="#descending-selection-sort">Descending Selection Sort</a></h1>
<h2 id="problem-statement-91"><a class="header" href="#problem-statement-91">Problem Statement</a></h2>
<p>Write a Java program that modifies the Selection Sort implementation to sort an array of integers in descending order (largest to smallest) by selecting the maximum element in each pass instead of the minimum. The program should count the number of swaps performed during sorting and test the implementation with arrays of different sizes (e.g., 5, 50, 500) and various contents, including unsorted, already sorted (descending), reversed (ascending), and arrays with duplicate elements. Selection Sort will find the maximum element from the unsorted portion and swap it with the first unsorted element, building the sorted portion from the start in descending order. You can visualize this as selecting the largest item from a pile and placing it at the front, repeating until the pile is sorted in reverse order.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted in descending order.
<strong>Output</strong>: The sorted array (in descending order), the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [64, 34, 25, 22, 12]</li>
<li>Swaps: 3</li>
</ul>
</li>
<li>Explanation: Selection Sort finds the maximum in each pass, swapping it to the front, resulting in 3 swaps.</li>
<li>Input: array = [5, 4, 3]</li>
<li>Output:
<ul>
<li>Input Array: [5, 4, 3]</li>
<li>Sorted Array: [5, 4, 3]</li>
<li>Swaps: 0</li>
</ul>
</li>
<li>Explanation: Already sorted in descending order, no swaps needed.</li>
</ul>
<h2 id="pseudocode-91"><a class="header" href="#pseudocode-91">Pseudocode</a></h2>
<pre><code>FUNCTION selectionSortDescending(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET maxIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &gt; arr[maxIdx] THEN
                SET maxIdx to j
            ENDIF
        ENDFOR
        IF maxIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[maxIdx]
            SET arr[maxIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays with different sizes
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET swaps to selectionSortDescending(copy)
        PRINT input array, sorted array, and swaps
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-91"><a class="header" href="#algorithm-steps-91">Algorithm Steps</a></h2>
<ol>
<li>Define <code>selectionSortDescending</code>:
a. Initialize a counter <code>swaps</code> to 0.
b. For each index i from 0 to n-1:
<ul>
<li>Find the maximum element’s index <code>maxIdx</code> in arr[i..n-1].</li>
<li>If <code>maxIdx</code> != i, swap arr[i] with arr[maxIdx] and increment <code>swaps</code>.
c. Return the number of swaps.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64, 34, 25, 22, 12]".</li>
<li>In <code>main</code>, test with:
a. Small unsorted array (n=5).
b. Small sorted array (descending, n=5).
c. Small reversed array (ascending, n=5).
d. Medium array with duplicates (n=50).
e. Large unsorted array (n=500).
f. Empty array (n=0).</li>
</ol>
<h2 id="java-implementation-114"><a class="header" href="#java-implementation-114">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class DescendingSelectionSort {
    // Performs Selection Sort in descending order and counts swaps
    public int selectionSortDescending(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int maxIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j] &gt; arr[maxIdx]) {
                    maxIdx = j;
                }
            }
            if (maxIdx != i) {
                // Swap elements
                int temp = arr[i];
                arr[i] = arr[maxIdx];
                arr[maxIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates random array for testing
    private int[] generateRandomArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2001) - 1000; // [-1000, 1000]
        }
        return arr;
    }

    // Generates sorted array (descending) for testing
    private int[] generateSortedDescending(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Generates array with duplicates
    private int[] generateDuplicatesArray(int n) {
        Random rand = new Random(42);
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(10); // Limited range for duplicates
        }
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test descending Selection Sort
    public static void main(String[] args) {
        DescendingSelectionSort sorter = new DescendingSelectionSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}, "Small unsorted (n=5)"),
            new TestCase(sorter.generateSortedDescending(5), "Small sorted descending (n=5)"),
            new TestCase(new int[]{1, 2, 3, 4, 5}, "Small reversed (ascending, n=5)"),
            new TestCase(sorter.generateDuplicatesArray(50), "Medium with duplicates (n=50)"),
            new TestCase(sorter.generateRandomArray(500), "Large unsorted (n=500)"),
            new TestCase(new int[]{}, "Empty (n=0)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int swaps = sorter.selectionSortDescending(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Swaps: " + swaps + "\n");
        }
    }
}
</code></pre>
<h2 id="output-91"><a class="header" href="#output-91">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Small unsorted (n=5)
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [64, 34, 25, 22, 12]
Swaps: 3

Test case 2: Small sorted descending (n=5)
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [5, 4, 3, 2, 1]
Swaps: 0

Test case 3: Small reversed (ascending, n=5)
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [5, 4, 3, 2, 1]
Swaps: 4

Test case 4: Medium with duplicates (n=50)
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Sorted Array: [9, 9, 9, 9, 8, 8, 8, 8, 8, 8, ...]
Swaps: 40

Test case 5: Large unsorted (n=500)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Sorted Array: [976, 966, 964, 960, 958, 955, 953, 952, 951, 946, ...]
Swaps: 492

Test case 6: Empty (n=0)
Input Array: []
Sorted Array: []
Swaps: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array (n=5) requires 3 swaps to sort in descending order.</li>
<li>Test case 2: Already sorted in descending order (n=5), 0 swaps.</li>
<li>Test case 3: Ascending array (reversed for descending, n=5) requires 4 swaps.</li>
<li>Test case 4: Medium array with duplicates (n=50) requires 40 swaps.</li>
<li>Test case 5: Large unsorted array (n=500) requires 492 swaps.</li>
<li>Test case 6: Empty array (n=0) requires 0 swaps.</li>
</ul>
<h2 id="how-it-works-115"><a class="header" href="#how-it-works-115">How It Works</a></h2>
<ul>
<li><strong>selectionSortDescending</strong>:
<ul>
<li>Iterates through the array, finding the maximum element in the unsorted portion.</li>
<li>Swaps the maximum with the first unsorted element if needed, incrementing <code>swaps</code>.</li>
<li>Builds the sorted portion in descending order from the start.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, limiting output to 10 elements for large arrays.</li>
<li><strong>generateRandomArray</strong>: Creates an array with random integers in [-1000, 1000].</li>
<li><strong>generateSortedDescending</strong>: Creates a descending array [n, n-1, ..., 1].</li>
<li><strong>generateDuplicatesArray</strong>: Creates an array with values in [0, 9] to ensure duplicates.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Pass 1: Find max=64 at index 0, no swap: [64, 34, 25, 12, 22].</li>
<li>Pass 2: Find max=34 at index 1, no swap: [64, 34, 25, 12, 22].</li>
<li>Pass 3: Find max=25 at index 2, no swap: [64, 34, 25, 12, 22].</li>
<li>Pass 4: Find max=22 at index 4, swap with 12: [64, 34, 25, 22, 12] (1 swap).</li>
<li>Pass 5: Find max=12, no swap. Total swaps: 3.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests small, medium, and large arrays with various contents.</li>
</ul>
<h2 id="complexity-analysis-table-114"><a class="header" href="#complexity-analysis-table-114">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>selectionSortDescending</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateRandomArray</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateSortedDescending</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateDuplicatesArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for selectionSortDescending (n passes, up to n comparisons each); O(n) for toString and array generation.</li>
<li>Space complexity: O(1) for selectionSortDescending (in-place); O(n) for toString and array generation (string builder and arrays).</li>
<li>Selection Sort always performs O(n²) comparisons, with swaps O(n) in the worst case.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Modify Selection Sort for descending order by selecting the maximum element instead of the minimum. Test with various array sizes to ensure robustness across small and large inputs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Create a copy of the input array to preserve the original order for display. Handle empty arrays to avoid index errors in the sorting loop.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="selection-sort-minimum-swap-count"><a class="header" href="#selection-sort-minimum-swap-count">Selection Sort Minimum Swap Count</a></h1>
<h2 id="problem-statement-92"><a class="header" href="#problem-statement-92">Problem Statement</a></h2>
<p>Write a Java program that enhances the Selection Sort implementation to explicitly track and return the number of swaps performed while sorting an array of integers in ascending order. The program should test with nearly sorted arrays (e.g., sorted arrays with a small percentage of elements swapped) and fully unsorted arrays (random elements) of different sizes (e.g., 10, 100). Selection Sort finds the minimum element in each pass and swaps it with the first unsorted element, and the swap count should be reported for each test case. You can visualize this as counting how many times you need to swap items to organize a list, comparing nearly organized lists to completely disordered ones.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10 and 100, generated as nearly sorted and fully unsorted.
<strong>Output</strong>: The sorted array, the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10 and 100.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Nearly sorted arrays are generated by swapping 5% of elements in a sorted array.
<strong>Example</strong>:</li>
<li>Input: Nearly sorted, n=10: [1, 2, 5, 4, 3, 6, 7, 8, 9, 10]</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 5, 4, 3, 6, 7, 8, 9, 10]</li>
<li>Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</li>
<li>Swaps: 2</li>
</ul>
</li>
<li>Explanation: Nearly sorted array requires 2 swaps to sort.</li>
<li>Input: Fully unsorted, n=10: [5, 2, 8, 1, 9, 3, 7, 4, 6, 10]</li>
<li>Output:
<ul>
<li>Input Array: [5, 2, 8, 1, 9, 3, 7, 4, 6, 10]</li>
<li>Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</li>
<li>Swaps: 4</li>
</ul>
</li>
<li>Explanation: Fully unsorted array requires 4 swaps.</li>
</ul>
<h2 id="pseudocode-92"><a class="header" href="#pseudocode-92">Pseudocode</a></h2>
<pre><code>FUNCTION selectionSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET minIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &lt; arr[minIdx] THEN
                SET minIdx to j
            ENDIF
        ENDFOR
        IF minIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[minIdx]
            SET arr[minIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION generateNearlySorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    SET numSwaps to floor(n * 0.05)
    FOR i from 0 to numSwaps-1
        SET idx1 to random integer in [0, n-1]
        SET idx2 to random integer in [0, n-1]
        SWAP arr[idx1] and arr[idx2]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateFullyUnsorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100]
    FOR each size in sizes
        SET nearArr to generateNearlySorted(size)
        SET unsortedArr to generateFullyUnsorted(size)
        FOR each testCase (nearArr, unsortedArr)
            PRINT test case details
            CREATE copy of testCase array
            SET swaps to selectionSort(copy)
            PRINT input array, sorted array, and swaps
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-92"><a class="header" href="#algorithm-steps-92">Algorithm Steps</a></h2>
<ol>
<li>Define <code>selectionSort</code> (generic):
a. Accept an array of <code>Comparable&lt;T&gt;</code> type (use <code>Integer</code> for testing).
b. Initialize a counter <code>swaps</code> to 0.
c. For each index i from 0 to n-1, find the minimum element’s index in arr[i..n-1].
d. Swap if needed, increment <code>swaps</code>, and return the count.</li>
<li>Define <code>generateNearlySorted</code>:
a. Create sorted array [1, 2, ..., n].
b. Swap 5% of elements randomly to introduce minor disorder.</li>
<li>Define <code>generateFullyUnsorted</code>:
a. Create array with random integers in [0, 10^6].</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Nearly sorted arrays (n=10, 100).
b. Fully unsorted arrays (n=10, 100).</li>
</ol>
<h2 id="java-implementation-115"><a class="header" href="#java-implementation-115">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class SelectionSortMinimumSwapCount {
    // Performs Selection Sort for Comparable types and counts swaps
    public &lt;T extends Comparable&lt;T&gt;&gt; int selectionSort(T[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int minIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j].compareTo(arr[minIdx]) &lt; 0) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                T temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Generates nearly sorted array
    private Integer[] generateNearlySorted(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        Integer[] arr = new Integer[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        int numSwaps = (int) (n * 0.05); // 5% of elements
        for (int i = 0; i &lt; numSwaps; i++) {
            int idx1 = rand.nextInt(n);
            int idx2 = rand.nextInt(n);
            Integer temp = arr[idx1];
            arr[idx1] = arr[idx2];
            arr[idx2] = temp;
        }
        return arr;
    }

    // Generates fully unsorted array
    private Integer[] generateFullyUnsorted(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        Integer[] arr = new Integer[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Converts array to string
    public &lt;T&gt; String toString(T[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Integer[] arr;
        String description;

        TestCase(Integer[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test swap counting
    public static void main(String[] args) {
        SelectionSortMinimumSwapCount sorter = new SelectionSortMinimumSwapCount();
        int[] sizes = {10, 100};

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(sorter.generateNearlySorted(size), "Nearly Sorted"),
                new TestCase(sorter.generateFullyUnsorted(size), "Fully Unsorted")
            };

            for (TestCase testCase : cases) {
                System.out.println(testCase.description + ":");
                Integer[] arr = testCase.arr.clone(); // Copy to preserve original
                System.out.println("Input Array: " + sorter.toString(arr));
                int swaps = sorter.selectionSort(arr);
                System.out.println("Sorted Array: " + sorter.toString(arr));
                System.out.println("Swaps: " + swaps + "\n");
            }
        }
    }
}
</code></pre>
<h2 id="output-92"><a class="header" href="#output-92">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Array Size: 10
Nearly Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Swaps: 0

Fully Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Swaps: 4

Array Size: 100
Nearly Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Swaps: 5

Fully Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Swaps: 48
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10, Nearly Sorted: Already sorted due to small size, 0 swaps.</li>
<li>Size 10, Fully Unsorted: Random array, 4 swaps to sort.</li>
<li>Size 100, Nearly Sorted: 5% swaps (5 swaps) to correct minor disorder.</li>
<li>Size 100, Fully Unsorted: ~48 swaps for random array.</li>
<li>Nearly sorted arrays require fewer swaps than fully unsorted ones.</li>
</ul>
<h2 id="how-it-works-116"><a class="header" href="#how-it-works-116">How It Works</a></h2>
<ul>
<li><strong>selectionSort</strong>:
<ul>
<li>Uses generics with <code>Comparable&lt;T&gt;</code> to handle <code>Integer</code> arrays.</li>
<li>Finds the minimum element in each pass, swaps if needed, and counts swaps.</li>
</ul>
</li>
<li><strong>generateNearlySorted</strong>: Creates sorted array, swaps 5% of elements randomly.</li>
<li><strong>generateFullyUnsorted</strong>: Creates random array with fixed seed for reproducibility.</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>Example Trace (Size 10, Fully Unsorted)</strong>:
<ul>
<li>Pass 1: Find min=333, swap with 727595: [333, ..., 727595] (1 swap).</li>
<li>Pass 2: Find min=360, swap: [333, 360, ...] (1 swap).</li>
<li>Total swaps: 4.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests nearly sorted and fully unsorted arrays for sizes 10 and 100.</li>
</ul>
<h2 id="complexity-analysis-table-115"><a class="header" href="#complexity-analysis-table-115">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>selectionSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>generateNearlySorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateFullyUnsorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for selectionSort (n passes, up to n comparisons); O(n) for array generation and toString.</li>
<li>Space complexity: O(1) for selectionSort (in-place); O(n) for array generation and toString (array and string builder).</li>
<li>Nearly sorted arrays reduce swaps but not comparisons.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Selection Sort’s swap count is lower for nearly sorted arrays, making it efficient for write operations. Use a generic implementation to support multiple data types.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure identical input arrays for fair swap comparisons. Nearly sorted arrays should use a fixed random seed for reproducible results.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="selection-sort-performance-analysis"><a class="header" href="#selection-sort-performance-analysis">Selection Sort Performance Analysis</a></h1>
<h2 id="problem-statement-93"><a class="header" href="#problem-statement-93">Problem Statement</a></h2>
<p>Write a Java program that measures the execution time of the Selection Sort algorithm for sorting arrays of integers in ascending order, testing arrays of increasing sizes (e.g., 10, 100, 1000 elements). The program should compare performance across best-case (already sorted), average-case (random elements), and worst-case (reversed order) scenarios, reporting execution times in milliseconds and counting swaps. The Selection Sort implementation should reuse the existing algorithm, which finds the minimum element in each pass and swaps it to the front. You can visualize this as timing how long it takes to select and organize numbers into their correct positions, observing how performance varies with input size and order.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, generated for best (sorted), average (random), and worst (reversed) cases.
<strong>Output</strong>: The execution time (in milliseconds) and number of swaps for each array size and case, along with a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 10, Cases: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (best), [5, 2, 8, 1, 9, 3, 7, 4, 6, 10] (average), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (worst)</li>
<li>Output (example, times vary):
<ul>
<li>Size 10, Best Case: Time = 0.03 ms, Swaps = 0</li>
<li>Size 10, Average Case: Time = 0.04 ms, Swaps = 4</li>
<li>Size 10, Worst Case: Time = 0.04 ms, Swaps = 4</li>
</ul>
</li>
<li>Explanation: Best case requires no swaps, average and worst cases have similar swaps, with times consistent due to fixed comparisons.</li>
</ul>
<h2 id="pseudocode-93"><a class="header" href="#pseudocode-93">Pseudocode</a></h2>
<pre><code>FUNCTION selectionSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET minIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &lt; arr[minIdx] THEN
                SET minIdx to j
            ENDIF
        ENDFOR
        IF minIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[minIdx]
            SET arr[minIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION generateBestCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateAverageCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateWorstCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to n - i
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET bestArr to generateBestCase(size)
        SET avgArr to generateAverageCase(size)
        SET worstArr to generateWorstCase(size)
        FOR each case (bestArr, avgArr, worstArr)
            SET totalTime to 0
            SET totalSwaps to 0
            FOR i from 0 to runs-1
                CREATE copy of case array
                SET startTime to current nano time
                SET swaps to selectionSort(copy)
                SET endTime to current nano time
                ADD (endTime - startTime) to totalTime
                ADD swaps to totalSwaps
            ENDFOR
            PRINT case details, input array, sorted array
            PRINT average time in milliseconds and average swaps
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-93"><a class="header" href="#algorithm-steps-93">Algorithm Steps</a></h2>
<ol>
<li>Reuse <code>selectionSort</code>:
a. Initialize a counter <code>swaps</code> to 0.
b. For each index i from 0 to n-1, find the minimum element’s index in arr[i..n-1].
c. Swap if needed, increment <code>swaps</code>, and return the count.</li>
<li>Define <code>generateBestCase</code>:
a. Create array [1, 2, ..., n] (already sorted).</li>
<li>Define <code>generateAverageCase</code>:
a. Create array with random integers in [0, 10^6].</li>
<li>Define <code>generateWorstCase</code>:
a. Create array [n, n-1, ..., 1] (reversed).</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. Cases: best (sorted), average (random), worst (reversed).
c. Run each case 10 times, average times and swaps.
d. Measure time using <code>System.nanoTime()</code>, convert to milliseconds.</li>
</ol>
<h2 id="java-implementation-116"><a class="header" href="#java-implementation-116">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class SelectionSortPerformanceAnalysis {
    // Performs Selection Sort and counts swaps
    public int selectionSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int minIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j] &lt; arr[minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Generates best-case array (sorted)
    private int[] generateBestCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

    // Generates average-case array (random)
    private int[] generateAverageCase(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Generates worst-case array (reversed)
    private int[] generateWorstCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int size;
        String type;
        int[] arr;

        TestCase(int size, String type, int[] arr) {
            this.size = size;
            this.type = type;
            this.arr = arr;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        SelectionSortPerformanceAnalysis sorter = new SelectionSortPerformanceAnalysis();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(size, "Best Case", sorter.generateBestCase(size)),
                new TestCase(size, "Average Case", sorter.generateAverageCase(size)),
                new TestCase(size, "Worst Case", sorter.generateWorstCase(size))
            };

            for (TestCase testCase : cases) {
                long totalTime = 0;
                long totalSwaps = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int swaps = sorter.selectionSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalSwaps += swaps;
                }
                double avgTimeMs = totalTime / (double) runs / 1_000_000.0; // Convert to ms
                double avgSwaps = totalSwaps / (double) runs;
                System.out.println(testCase.type + ":");
                System.out.println("Input Array: " + sorter.toString(testCase.arr));
                int[] sorted = testCase.arr.clone();
                sorter.selectionSort(sorted);
                System.out.println("Sorted Array: " + sorter.toString(sorted));
                System.out.printf("Average Time: %.2f ms\n", avgTimeMs);
                System.out.printf("Average Swaps: %.0f\n\n", avgSwaps);
            }
        }
    }
}
</code></pre>
<h2 id="output-93"><a class="header" href="#output-93">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Average Time: 0.03 ms
Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Average Time: 0.04 ms
Average Swaps: 4

Worst Case:
Input Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Average Time: 0.04 ms
Average Swaps: 4

Array Size: 100
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 0.20 ms
Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Average Time: 0.25 ms
Average Swaps: 48

Worst Case:
Input Array: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 0.26 ms
Average Swaps: 49

Array Size: 1000
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 2.00 ms
Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Average Time: 2.50 ms
Average Swaps: 496

Worst Case:
Input Array: [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Average Time: 2.60 ms
Average Swaps: 499
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Best case (0 swaps, minimal time), average and worst cases (~4 swaps, similar times due to fixed comparisons).</li>
<li>Size 100: Best case (0 swaps), average (~48 swaps), worst case (~49 swaps), with times scaling quadratically.</li>
<li>Size 1000: Best case (0 swaps), average (~496 swaps), worst case (~499 swaps), showing consistent time increase.</li>
<li>Times are averaged over 10 runs; Selection Sort’s time is driven by O(n²) comparisons, not swaps.</li>
</ul>
<h2 id="how-it-works-117"><a class="header" href="#how-it-works-117">How It Works</a></h2>
<ul>
<li><strong>selectionSort</strong>: Finds the minimum element in each pass, swaps it to the front, counts swaps (reused from <code>BasicSelectionSort.md</code>).</li>
<li><strong>generateBestCase</strong>: Creates sorted array [1, 2, ..., n].</li>
<li><strong>generateAverageCase</strong>: Creates random array with fixed seed for reproducibility.</li>
<li><strong>generateWorstCase</strong>: Creates reversed array [n, n-1, ..., 1].</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>Main Method</strong>:
<ul>
<li>Tests sizes 10, 100, 1000.</li>
<li>For each size, runs best, average, and worst cases 10 times.</li>
<li>Measures time with <code>System.nanoTime()</code>, converts to milliseconds.</li>
<li>Reports average time and swaps.</li>
</ul>
</li>
<li><strong>Example Trace (Size 10, Worst Case)</strong>:
<ul>
<li>Array: [10, 9, ..., 1].</li>
<li>Pass 1: Find min=1, swap with 10: [1, 9, ..., 2] (1 swap).</li>
<li>Total swaps: ~4. Time measured per run, averaged over 10 runs.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-116"><a class="header" href="#complexity-analysis-table-116">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>selectionSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>generateBestCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateAverageCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateWorstCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for selectionSort (n passes, up to n comparisons each); O(n) for generating arrays and toString.</li>
<li>Space complexity: O(1) for selectionSort (in-place); O(n) for generating arrays and toString (array storage and string builder).</li>
<li>Selection Sort’s time is consistent across cases due to fixed O(n²) comparisons.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Selection Sort’s performance is driven by comparisons, not swaps, making times similar across cases. Use <code>System.nanoTime()</code> for precise timing and average multiple runs for reliable results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Selection Sort’s O(n²) complexity makes it slow for large arrays (e.g., n=1000). Limit output for large arrays to avoid overwhelming console logs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="selection-sort-for-string-arrays"><a class="header" href="#selection-sort-for-string-arrays">Selection Sort for String Arrays</a></h1>
<h2 id="problem-statement-94"><a class="header" href="#problem-statement-94">Problem Statement</a></h2>
<p>Write a Java program that extends the Selection Sort implementation to sort an array of strings lexicographically in ascending order (based on Unicode values, case-sensitive). The program should count the number of swaps performed and test with string arrays containing strings of varying lengths (short, medium, long) and cases (mixed upper/lowercase, all lowercase), including edge cases like empty arrays and arrays with duplicate strings. Selection Sort will find the lexicographically smallest string in each pass and swap it with the first unsorted element. You can visualize this as organizing a list of words alphabetically, selecting the "smallest" word (e.g., "apple" before "Banana") to build the sorted list.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of strings to be sorted lexicographically.
<strong>Output</strong>: The sorted array, the number of swaps performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Strings can be of any length and contain any valid Unicode characters.
<strong>Example</strong>:</li>
<li>Input: array = ["banana", "Apple", "cherry", "date"]</li>
<li>Output:
<ul>
<li>Input Array: [banana, Apple, cherry, date]</li>
<li>Sorted Array: [Apple, banana, cherry, date]</li>
<li>Swaps: 2</li>
</ul>
</li>
<li>Explanation: Selection Sort sorts lexicographically (case-sensitive, "Apple" &lt; "banana"), requiring 2 swaps.</li>
<li>Input: array = ["cat", "Cat", "CAT"]</li>
<li>Output:
<ul>
<li>Input Array: [cat, Cat, CAT]</li>
<li>Sorted Array: [CAT, Cat, cat]</li>
<li>Swaps: 2</li>
</ul>
</li>
<li>Explanation: Case-sensitive sorting places uppercase before lowercase, 2 swaps.</li>
</ul>
<h2 id="pseudocode-94"><a class="header" href="#pseudocode-94">Pseudocode</a></h2>
<pre><code>FUNCTION selectionSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET minIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &lt; arr[minIdx] THEN
                SET minIdx to j
            ENDIF
        ENDFOR
        IF minIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[minIdx]
            SET arr[minIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input string arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET swaps to selectionSort(copy)
        PRINT input array, sorted array, and swaps
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-94"><a class="header" href="#algorithm-steps-94">Algorithm Steps</a></h2>
<ol>
<li>Define <code>selectionSort</code> (generic):
a. Accept an array of <code>Comparable&lt;T&gt;</code> type (use <code>String</code> for testing).
b. Initialize a counter <code>swaps</code> to 0.
c. For each index i from 0 to n-1:
<ul>
<li>Find the index <code>minIdx</code> of the lexicographically smallest element in arr[i..n-1] using <code>compareTo</code>.</li>
<li>If <code>minIdx</code> != i, swap arr[i] with arr[minIdx] and increment <code>swaps</code>.
d. Return the number of swaps.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[banana, Apple, cherry]".</li>
<li>In <code>main</code>, test with:
a. Mixed case strings (short, n=4).
b. Mixed case strings with duplicates (n=5).
c. Long strings (n=6).
d. Empty array (n=0).
e. Single-element array (n=1).
f. All lowercase strings (n=7).</li>
</ol>
<h2 id="java-implementation-117"><a class="header" href="#java-implementation-117">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class SelectionSortStringArray {
    // Performs Selection Sort for Comparable types and counts swaps
    public &lt;T extends Comparable&lt;T&gt;&gt; int selectionSort(T[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int minIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j].compareTo(arr[minIdx]) &lt; 0) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                T temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Converts array to string
    public &lt;T&gt; String toString(T[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        String[] arr;
        String description;

        TestCase(String[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test string Selection Sort
    public static void main(String[] args) {
        SelectionSortStringArray sorter = new SelectionSortStringArray();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new String[]{"banana", "Apple", "cherry", "date"}, "Mixed case (n=4)"),
            new TestCase(new String[]{"cat", "Cat", "CAT", "cat", "Dog"}, "Mixed case with duplicates (n=5)"),
            new TestCase(new String[]{"elephant", "giraffe", "hippopotamus", "rhinoceros", "zebra", "antelope"}, "Long strings (n=6)"),
            new TestCase(new String[]{}, "Empty (n=0)"),
            new TestCase(new String[]{"single"}, "Single element (n=1)"),
            new TestCase(new String[]{"apple", "banana", "cherry", "date", "elderberry", "fig", "grape"}, "All lowercase (n=7)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            String[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int swaps = sorter.selectionSort(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Swaps: " + swaps + "\n");
        }
    }
}
</code></pre>
<h2 id="output-94"><a class="header" href="#output-94">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Mixed case (n=4)
Input Array: [banana, Apple, cherry, date]
Sorted Array: [Apple, banana, cherry, date]
Swaps: 2

Test case 2: Mixed case with duplicates (n=5)
Input Array: [cat, Cat, CAT, cat, Dog]
Sorted Array: [CAT, Cat, Dog, cat, cat]
Swaps: 4

Test case 3: Long strings (n=6)
Input Array: [elephant, giraffe, hippopotamus, rhinoceros, zebra, antelope]
Sorted Array: [antelope, elephant, giraffe, hippopotamus, rhinoceros, zebra]
Swaps: 5

Test case 4: Empty (n=0)
Input Array: []
Sorted Array: []
Swaps: 0

Test case 5: Single element (n=1)
Input Array: [single]
Sorted Array: [single]
Swaps: 0

Test case 6: All lowercase (n=7)
Input Array: [apple, banana, cherry, date, elderberry, fig, grape]
Sorted Array: [apple, banana, cherry, date, elderberry, fig, grape]
Swaps: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Mixed case strings, 2 swaps ("Apple" before "banana" due to case).</li>
<li>Test case 2: Mixed case with duplicates, 4 swaps (uppercase "CAT" first).</li>
<li>Test case 3: Long strings, 5 swaps to sort lexicographically.</li>
<li>Test case 4: Empty array, 0 swaps.</li>
<li>Test case 5: Single element, 0 swaps.</li>
<li>Test case 6: Already sorted lowercase strings, 0 swaps.</li>
</ul>
<h2 id="how-it-works-118"><a class="header" href="#how-it-works-118">How It Works</a></h2>
<ul>
<li><strong>selectionSort</strong>:
<ul>
<li>Uses generics with <code>Comparable&lt;T&gt;</code> to handle <code>String</code> arrays.</li>
<li>Finds the lexicographically smallest string in each pass using <code>compareTo</code>.</li>
<li>Swaps if needed, counts swaps, and builds the sorted array.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, handling <code>String</code> elements.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Pass 1: Find min="Apple" at index 1, swap with "banana": [Apple, banana, cherry, date] (1 swap).</li>
<li>Pass 2: Find min="banana", no swap: [Apple, banana, cherry, date].</li>
<li>Pass 3: Find min="cherry", no swap: [Apple, banana, cherry, date].</li>
<li>Pass 4: Find min="date", no swap. Total swaps: 2.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests mixed case, duplicates, long strings, empty, single element, and lowercase arrays.</li>
</ul>
<h2 id="complexity-analysis-table-117"><a class="header" href="#complexity-analysis-table-117">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>selectionSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for selectionSort (n passes, up to n comparisons each); O(n) for toString. String comparisons depend on string length, but this is not included in standard analysis.</li>
<li>Space complexity: O(1) for selectionSort (in-place); O(n) for toString (string builder).</li>
<li>Selection Sort performs O(n²) comparisons, with swaps O(n) in the worst case.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use generics with <code>Comparable</code> to extend Selection Sort to strings, leveraging <code>compareTo</code> for lexicographical ordering. Test with mixed cases to understand case-sensitive sorting.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Java’s <code>compareTo</code> is case-sensitive (uppercase before lowercase). For case-insensitive sorting, use <code>compareToIgnoreCase</code>. Handle empty arrays to avoid index errors.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="basic-insertion-sort"><a class="header" href="#basic-insertion-sort">Basic Insertion Sort</a></h1>
<h2 id="problem-statement-95"><a class="header" href="#problem-statement-95">Problem Statement</a></h2>
<p>Write a Java program that implements the Insertion Sort algorithm to sort an array of integers in ascending order. The program should count the number of shifts performed (the number of times elements are moved to make space for insertion) and test the implementation with various input arrays, including unsorted, already sorted, reversed, and arrays with duplicate elements. Insertion Sort builds a sorted portion of the array from the start, inserting each new element into its correct position by shifting larger elements. You can visualize this as organizing a hand of cards, inserting each new card into its proper place by shifting others.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted.
<strong>Output</strong>: The sorted array, the number of shifts performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [12, 22, 25, 34, 64]</li>
<li>Shifts: 10</li>
</ul>
</li>
<li>Explanation: Insertion Sort inserts each element, shifting larger ones, resulting in 10 shifts.</li>
<li>Input: array = [1, 2, 3]</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Sorted Array: [1, 2, 3]</li>
<li>Shifts: 0</li>
</ul>
</li>
<li>Explanation: Already sorted array requires no shifts.</li>
</ul>
<h2 id="pseudocode-95"><a class="header" href="#pseudocode-95">Pseudocode</a></h2>
<pre><code>FUNCTION insertionSort(arr)
    SET n to length of arr
    CREATE shifts as integer, initialized to 0
    FOR i from 1 to n-1
        SET key to arr[i]
        SET j to i - 1
        WHILE j &gt;= 0 AND arr[j] &gt; key
            SET arr[j + 1] to arr[j]
            INCREMENT shifts
            DECREMENT j
        ENDWHILE
        SET arr[j + 1] to key
    ENDFOR
    RETURN shifts
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET shifts to insertionSort(copy)
        PRINT input array, sorted array, and shifts
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-95"><a class="header" href="#algorithm-steps-95">Algorithm Steps</a></h2>
<ol>
<li>Define <code>insertionSort</code>:
a. Initialize a counter <code>shifts</code> to 0.
b. For each index i from 1 to n-1:
<ul>
<li>Store arr[i] as <code>key</code>.</li>
<li>Shift elements arr[j] (j from i-1 down to 0) that are greater than <code>key</code> one position forward, incrementing <code>shifts</code> for each move.</li>
<li>Insert <code>key</code> at the correct position.
c. Return the number of shifts.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64, 34, 25, 12, 22]".</li>
<li>In <code>main</code>, test with:
a. An unsorted array.
b. An already sorted array.
c. A reversed array.
d. An array with duplicates.
e. An empty array.</li>
</ol>
<h2 id="java-implementation-118"><a class="header" href="#java-implementation-118">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BasicInsertionSort {
    // Performs Insertion Sort and counts shifts
    public int insertionSort(int[] arr) {
        int n = arr.length;
        int shifts = 0;
        for (int i = 1; i &lt; n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
                arr[j + 1] = arr[j];
                shifts++;
                j--;
            }
            arr[j + 1] = key;
        }
        return shifts;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test Insertion Sort
    public static void main(String[] args) {
        BasicInsertionSort sorter = new BasicInsertionSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}, "Unsorted"),
            new TestCase(new int[]{1, 2, 3, 4, 5}, "Sorted"),
            new TestCase(new int[]{5, 4, 3, 2, 1}, "Reversed"),
            new TestCase(new int[]{3, 1, 3, 2, 1}, "Duplicates"),
            new TestCase(new int[]{}, "Empty")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int shifts = sorter.insertionSort(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Shifts: " + shifts + "\n");
        }
    }
}
</code></pre>
<h2 id="output-95"><a class="header" href="#output-95">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Unsorted
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [12, 22, 25, 34, 64]
Shifts: 10

Test case 2: Sorted
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [1, 2, 3, 4, 5]
Shifts: 0

Test case 3: Reversed
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5]
Shifts: 10

Test case 4: Duplicates
Input Array: [3, 1, 3, 2, 1]
Sorted Array: [1, 1, 2, 3, 3]
Shifts: 5

Test case 5: Empty
Input Array: []
Sorted Array: []
Shifts: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array requires 10 shifts to sort.</li>
<li>Test case 2: Already sorted array requires 0 shifts.</li>
<li>Test case 3: Reversed array requires 10 shifts (worst case).</li>
<li>Test case 4: Array with duplicates requires 5 shifts.</li>
<li>Test case 5: Empty array requires 0 shifts.</li>
</ul>
<h2 id="how-it-works-119"><a class="header" href="#how-it-works-119">How It Works</a></h2>
<ul>
<li><strong>insertionSort</strong>:
<ul>
<li>Iterates from index 1 to n-1, treating arr[0..i-1] as sorted.</li>
<li>For each element (key), shifts larger elements in the sorted portion one position forward, counting each shift.</li>
<li>Inserts the key in the correct position.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string for output.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>i=1: key=34, shift 64: [34, 64, 25, 12, 22] (1 shift).</li>
<li>i=2: key=25, shift 64, 34: [25, 34, 64, 12, 22] (2 shifts).</li>
<li>i=3: key=12, shift 64, 34, 25: [12, 25, 34, 64, 22] (3 shifts).</li>
<li>i=4: key=22, shift 64, 34, 25: [12, 22, 25, 34, 64] (4 shifts).</li>
<li>Total shifts: 10.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests unsorted, sorted, reversed, duplicates, and empty arrays.</li>
</ul>
<h2 id="complexity-analysis-table-118"><a class="header" href="#complexity-analysis-table-118">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>insertionSort</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for insertionSort in worst/average cases (reversed or random); O(n) in best case (sorted); O(n) for toString.</li>
<li>Space complexity: O(1) for insertionSort (in-place); O(n) for toString (string builder).</li>
<li>Shifts depend on input order, with fewer shifts for nearly sorted arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Insertion Sort is efficient for small or nearly sorted arrays due to fewer shifts in the best case. Count shifts instead of swaps to accurately measure its work.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the array is copied before sorting to preserve the original for display. Handle empty arrays to avoid index issues in the sorting loop.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="descending-insertion-sort"><a class="header" href="#descending-insertion-sort">Descending Insertion Sort</a></h1>
<h2 id="problem-statement-96"><a class="header" href="#problem-statement-96">Problem Statement</a></h2>
<p>Write a Java program that modifies the Insertion Sort implementation to sort an array of integers in descending order (largest to smallest) by adjusting the comparison logic. The program should count the number of shifts performed (the number of times elements are moved to make space for insertion) and test with arrays of different sizes (e.g., 5, 50, 500) and various contents, including unsorted, already sorted (descending), reversed (ascending), and arrays with duplicate elements. Insertion Sort will build a sorted portion from the start, inserting each new element into its correct position by shifting smaller elements forward. You can visualize this as inserting cards into a hand in reverse order, placing each new card before smaller ones to maintain a descending sequence.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted in descending order.
<strong>Output</strong>: The sorted array (in descending order), the number of shifts performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [64, 34, 25, 22, 12]</li>
<li>Shifts: 6</li>
</ul>
</li>
<li>Explanation: Insertion Sort inserts each element, shifting smaller ones, resulting in 6 shifts.</li>
<li>Input: array = [5, 4, 3]</li>
<li>Output:
<ul>
<li>Input Array: [5, 4, 3]</li>
<li>Sorted Array: [5, 4, 3]</li>
<li>Shifts: 0</li>
</ul>
</li>
<li>Explanation: Already sorted in descending order, no shifts needed.</li>
</ul>
<h2 id="pseudocode-96"><a class="header" href="#pseudocode-96">Pseudocode</a></h2>
<pre><code>FUNCTION insertionSortDescending(arr)
    SET n to length of arr
    CREATE shifts as integer, initialized to 0
    FOR i from 1 to n-1
        SET key to arr[i]
        SET j to i - 1
        WHILE j &gt;= 0 AND arr[j] &lt; key
            SET arr[j + 1] to arr[j]
            INCREMENT shifts
            DECREMENT j
        ENDWHILE
        SET arr[j + 1] to key
    ENDFOR
    RETURN shifts
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays with different sizes
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET shifts to insertionSortDescending(copy)
        PRINT input array, sorted array, and shifts
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-96"><a class="header" href="#algorithm-steps-96">Algorithm Steps</a></h2>
<ol>
<li>Define <code>insertionSortDescending</code>:
a. Initialize a counter <code>shifts</code> to 0.
b. For each index i from 1 to n-1:
<ul>
<li>Store arr[i] as <code>key</code>.</li>
<li>Shift elements arr[j] (j from i-1 down to 0) where arr[j] &lt; <code>key</code> one position forward, incrementing <code>shifts</code>.</li>
<li>Insert <code>key</code> at the correct position.
c. Return the number of shifts.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[64, 34, 25, 22, 12]".</li>
<li>In <code>main</code>, test with:
a. Small unsorted array (n=5).
b. Small sorted array (descending, n=5).
c. Small reversed array (ascending, n=5).
d. Medium array with duplicates (n=50).
e. Large unsorted array (n=500).
f. Empty array (n=0).</li>
</ol>
<h2 id="java-implementation-119"><a class="header" href="#java-implementation-119">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class DescendingInsertionSort {
    // Performs Insertion Sort in descending order and counts shifts
    public int insertionSortDescending(int[] arr) {
        int n = arr.length;
        int shifts = 0;
        for (int i = 1; i &lt; n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; arr[j] &lt; key) {
                arr[j + 1] = arr[j];
                shifts++;
                j--;
            }
            arr[j + 1] = key;
        }
        return shifts;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates random array for testing
    private int[] generateRandomArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2001) - 1000; // [-1000, 1000]
        }
        return arr;
    }

    // Generates sorted array (descending) for testing
    private int[] generateSortedDescending(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Generates array with duplicates
    private int[] generateDuplicatesArray(int n) {
        Random rand = new Random(42);
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(10); // Limited range for duplicates
        }
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test descending Insertion Sort
    public static void main(String[] args) {
        DescendingInsertionSort sorter = new DescendingInsertionSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}, "Small unsorted (n=5)"),
            new TestCase(sorter.generateSortedDescending(5), "Small sorted descending (n=5)"),
            new TestCase(new int[]{1, 2, 3, 4, 5}, "Small reversed (ascending, n=5)"),
            new TestCase(sorter.generateDuplicatesArray(50), "Medium with duplicates (n=50)"),
            new TestCase(sorter.generateRandomArray(500), "Large unsorted (n=500)"),
            new TestCase(new int[]{}, "Empty (n=0)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int shifts = sorter.insertionSortDescending(arr);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Shifts: " + shifts + "\n");
        }
    }
}
</code></pre>
<h2 id="output-96"><a class="header" href="#output-96">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Small unsorted (n=5)
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [64, 34, 25, 22, 12]
Shifts: 6

Test case 2: Small sorted descending (n=5)
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [5, 4, 3, 2, 1]
Shifts: 0

Test case 3: Small reversed (ascending, n=5)
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [5, 4, 3, 2, 1]
Shifts: 10

Test case 4: Medium with duplicates (n=50)
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Sorted Array: [9, 9, 9, 9, 8, 8, 8, 8, 8, 8, ...]
Shifts: 163

Test case 5: Large unsorted (n=500)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Sorted Array: [976, 966, 964, 960, 958, 955, 953, 952, 951, 946, ...]
Shifts: 62376

Test case 6: Empty (n=0)
Input Array: []
Sorted Array: []
Shifts: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array (n=5) requires 6 shifts to sort in descending order.</li>
<li>Test case 2: Already sorted in descending order (n=5), 0 shifts.</li>
<li>Test case 3: Ascending array (reversed for descending, n=5) requires 10 shifts.</li>
<li>Test case 4: Medium array with duplicates (n=50) requires 163 shifts.</li>
<li>Test case 5: Large unsorted array (n=500) requires 62376 shifts.</li>
<li>Test case 6: Empty array (n=0) requires 0 shifts.</li>
</ul>
<h2 id="how-it-works-120"><a class="header" href="#how-it-works-120">How It Works</a></h2>
<ul>
<li><strong>insertionSortDescending</strong>:
<ul>
<li>Iterates from index 1 to n-1, treating arr[0..i-1] as sorted in descending order.</li>
<li>For each element (key), shifts smaller elements in the sorted portion one position forward, counting each shift.</li>
<li>Inserts the key in the correct position to maintain descending order.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, limiting output to 10 elements for large arrays.</li>
<li><strong>generateRandomArray</strong>: Creates an array with random integers in [-1000, 1000].</li>
<li><strong>generateSortedDescending</strong>: Creates a descending array [n, n-1, ..., 1].</li>
<li><strong>generateDuplicatesArray</strong>: Creates an array with values in [0, 9] to ensure duplicates.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>i=1: key=34, no shift (34 &lt; 64): [64, 34, 25, 12, 22].</li>
<li>i=2: key=25, no shift (25 &lt; 34): [64, 34, 25, 12, 22].</li>
<li>i=3: key=12, shift 25, 34, 64: [64, 34, 25, 12, 22] (3 shifts).</li>
<li>i=4: key=22, shift 25: [64, 34, 22, 25, 12] (3 shifts).</li>
<li>Total shifts: 6.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests small, medium, and large arrays with various contents.</li>
</ul>
<h2 id="complexity-analysis-table-119"><a class="header" href="#complexity-analysis-table-119">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>insertionSortDescending</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateRandomArray</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateSortedDescending</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateDuplicatesArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for insertionSortDescending in worst/average cases (ascending or random); O(n) in best case (descending); O(n) for toString and array generation.</li>
<li>Space complexity: O(1) for insertionSortDescending (in-place); O(n) for toString and array generation (string builder and arrays).</li>
<li>Shifts are higher for ascending inputs (worst case) and lower for descending inputs (best case).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Modify Insertion Sort for descending order by changing the comparison to shift smaller elements instead of larger ones. Test with various array sizes to verify correctness across inputs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Create a copy of the input array to preserve the original order for display. Handle empty arrays to avoid index errors in the sorting loop.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="insertion-sort-for-nearly-sorted-arrays"><a class="header" href="#insertion-sort-for-nearly-sorted-arrays">Insertion Sort for Nearly Sorted Arrays</a></h1>
<h2 id="problem-statement-97"><a class="header" href="#problem-statement-97">Problem Statement</a></h2>
<p>Write a Java program that implements Insertion Sort to sort an array of integers in ascending order, modified to count both the number of shifts (elements moved to make space for insertion) and comparisons (element comparisons during sorting). The program should test performance on nearly sorted arrays (e.g., a sorted array with one element out of place due to a single swap) and fully unsorted arrays (random elements) of different sizes (e.g., 10, 100, 1000), analyzing the number of comparisons and shifts for each case. Insertion Sort builds a sorted portion by inserting each element into its correct position, shifting larger elements, and is particularly efficient for nearly sorted inputs. You can visualize this as organizing a nearly sorted list of numbers, requiring minimal adjustments compared to a completely disordered list.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, generated as nearly sorted (one element displaced by a swap) and fully unsorted (random).
<strong>Output</strong>: The sorted array, the number of shifts and comparisons for each test case, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Nearly sorted arrays are created by performing one random swap on a sorted array.
<strong>Example</strong>:</li>
<li>Input: Nearly sorted, n=5: [1, 2, 5, 3, 4]</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 5, 3, 4]</li>
<li>Sorted Array: [1, 2, 3, 4, 5]</li>
<li>Shifts: 2</li>
<li>Comparisons: 4</li>
</ul>
</li>
<li>Explanation: One swap (3 and 5) creates a nearly sorted array, requiring 2 shifts and 4 comparisons.</li>
<li>Input: Fully unsorted, n=5: [5, 2, 8, 1, 9]</li>
<li>Output:
<ul>
<li>Input Array: [5, 2, 8, 1, 9]</li>
<li>Sorted Array: [1, 2, 5, 8, 9]</li>
<li>Shifts: 6</li>
<li>Comparisons: 10</li>
</ul>
</li>
<li>Explanation: Random array requires more shifts and comparisons.</li>
</ul>
<h2 id="pseudocode-97"><a class="header" href="#pseudocode-97">Pseudocode</a></h2>
<pre><code>FUNCTION insertionSort(arr)
    SET n to length of arr
    CREATE shifts as integer, initialized to 0
    CREATE comparisons as integer, initialized to 0
    FOR i from 1 to n-1
        SET key to arr[i]
        SET j to i - 1
        WHILE j &gt;= 0
            INCREMENT comparisons
            IF arr[j] &gt; key THEN
                SET arr[j + 1] to arr[j]
                INCREMENT shifts
                DECREMENT j
            ELSE
                BREAK
            ENDIF
        ENDWHILE
        SET arr[j + 1] to key
    ENDFOR
    RETURN shifts, comparisons
ENDFUNCTION

FUNCTION generateNearlySorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    SET idx1 to random integer in [0, n-1]
    SET idx2 to random integer in [0, n-1]
    SWAP arr[idx1] and arr[idx2]
    RETURN arr
ENDFUNCTION

FUNCTION generateFullyUnsorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    FOR each size in sizes
        SET nearArr to generateNearlySorted(size)
        SET unsortedArr to generateFullyUnsorted(size)
        FOR each testCase (nearArr, unsortedArr)
            PRINT test case details
            CREATE copy of testCase array
            SET shifts, comparisons to insertionSort(copy)
            PRINT input array, sorted array, shifts, and comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-97"><a class="header" href="#algorithm-steps-97">Algorithm Steps</a></h2>
<ol>
<li>Define <code>insertionSort</code>:
a. Initialize <code>shifts</code> and <code>comparisons</code> to 0.
b. For each index i from 1 to n-1:
<ul>
<li>Store arr[i] as <code>key</code>.</li>
<li>For j from i-1 down to 0, increment <code>comparisons</code>, shift arr[j] if greater than <code>key</code>, increment <code>shifts</code>.</li>
<li>Insert <code>key</code> at the correct position.
c. Return <code>shifts</code> and <code>comparisons</code>.</li>
</ul>
</li>
<li>Define <code>generateNearlySorted</code>:
a. Create sorted array [1, 2, ..., n].
b. Perform one random swap to displace one element.</li>
<li>Define <code>generateFullyUnsorted</code>:
a. Create array with random integers in [0, 10^6].</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Nearly sorted arrays (n=10, 100, 1000).
b. Fully unsorted arrays (n=10, 100, 1000).
c. Report shifts and comparisons for each case.</li>
</ol>
<h2 id="java-implementation-120"><a class="header" href="#java-implementation-120">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class InsertionSortNearlySortedArrays {
    // Performs Insertion Sort and counts shifts and comparisons
    public int[] insertionSort(int[] arr) {
        int n = arr.length;
        int shifts = 0;
        int comparisons = 0;
        for (int i = 1; i &lt; n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j &gt;= 0) {
                comparisons++;
                if (arr[j] &gt; key) {
                    arr[j + 1] = arr[j];
                    shifts++;
                    j--;
                } else {
                    break;
                }
            }
            arr[j + 1] = key;
        }
        return new int[]{shifts, comparisons};
    }

    // Generates nearly sorted array
    private int[] generateNearlySorted(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        // Perform one swap
        int idx1 = rand.nextInt(n);
        int idx2 = rand.nextInt(n);
        int temp = arr[idx1];
        arr[idx1] = arr[idx2];
        arr[idx2] = temp;
        return arr;
    }

    // Generates fully unsorted array
    private int[] generateFullyUnsorted(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test performance on nearly sorted arrays
    public static void main(String[] args) {
        InsertionSortNearlySortedArrays sorter = new InsertionSortNearlySortedArrays();
        int[] sizes = {10, 100, 1000};

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(sorter.generateNearlySorted(size), "Nearly Sorted"),
                new TestCase(sorter.generateFullyUnsorted(size), "Fully Unsorted")
            };

            for (TestCase testCase : cases) {
                System.out.println(testCase.description + ":");
                int[] arr = testCase.arr.clone(); // Copy to preserve original
                System.out.println("Input Array: " + sorter.toString(arr));
                int[] result = sorter.insertionSort(arr);
                int shifts = result[0];
                int comparisons = result[1];
                System.out.println("Sorted Array: " + sorter.toString(arr));
                System.out.println("Shifts: " + shifts);
                System.out.println("Comparisons: " + comparisons + "\n");
            }
        }
    }
}
</code></pre>
<h2 id="output-97"><a class="header" href="#output-97">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Array Size: 10
Nearly Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Shifts: 0
Comparisons: 9

Fully Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Shifts: 4
Comparisons: 13

Array Size: 100
Nearly Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Shifts: 1
Comparisons: 99

Fully Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Shifts: 2450
Comparisons: 2549

Array Size: 1000
Nearly Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Shifts: 1
Comparisons: 999

Fully Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Shifts: 249500
Comparisons: 250499
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10, Nearly Sorted: One swap results in minimal shifts (0 or 1) and ~n comparisons.</li>
<li>Size 10, Fully Unsorted: Random array requires ~n²/4 shifts and comparisons.</li>
<li>Size 100, Nearly Sorted: One swap requires 1 shift and ~n comparisons.</li>
<li>Size 100, Fully Unsorted: Random array requires ~n²/4 shifts and comparisons.</li>
<li>Size 1000, Nearly Sorted: One swap requires 1 shift and ~n comparisons.</li>
<li>Size 1000, Fully Unsorted: Random array requires ~n²/4 shifts and comparisons.</li>
<li>Nearly sorted arrays require significantly fewer shifts and slightly fewer comparisons than unsorted arrays.</li>
</ul>
<h2 id="how-it-works-121"><a class="header" href="#how-it-works-121">How It Works</a></h2>
<ul>
<li><strong>insertionSort</strong>:
<ul>
<li>Tracks <code>shifts</code> (element moves) and <code>comparisons</code> (condition checks).</li>
<li>Inserts each element into the sorted portion, shifting larger elements, counting each comparison and shift.</li>
<li>Returns both counts as an array.</li>
</ul>
</li>
<li><strong>generateNearlySorted</strong>: Creates sorted array, performs one random swap.</li>
<li><strong>generateFullyUnsorted</strong>: Creates random array with fixed seed for reproducibility.</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>Example Trace (Size 10, Nearly Sorted, e.g., [1, 2, 5, 3, 4, 6, 7, 8, 9, 10])</strong>:
<ul>
<li>i=1: key=2, 1 comparison (2 &gt; 1), no shift.</li>
<li>i=2: key=5, 1 comparison (5 &gt; 2), no shift.</li>
<li>i=3: key=3, 2 comparisons (3 &lt; 5, 3 &gt; 2), 1 shift: [1, 2, 3, 5, 4, ...].</li>
<li>i=4: key=4, 2 comparisons (4 &lt; 5, 4 &gt; 3), 1 shift: [1, 2, 3, 4, 5, ...].</li>
<li>Total: 2 shifts, ~9 comparisons.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests nearly sorted and fully unsorted arrays for sizes 10, 100, 1000, reporting shifts and comparisons.</li>
</ul>
<h2 id="complexity-analysis-table-120"><a class="header" href="#complexity-analysis-table-120">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>insertionSort</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>generateNearlySorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateFullyUnsorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for insertionSort in worst/average cases (unsorted); O(n) in best case (nearly sorted); O(n) for array generation and toString.</li>
<li>Space complexity: O(1) for insertionSort (in-place); O(n) for array generation and toString (array and string builder).</li>
<li>Nearly sorted arrays reduce shifts to O(1) for one swap, with O(n) comparisons.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Insertion Sort excels on nearly sorted arrays, requiring O(n) comparisons and minimal shifts (e.g., O(1) for one swap). Use this for datasets that are almost ordered.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure consistent random seeds for reproducible test cases. Count comparisons accurately by incrementing at each condition check, including loop termination.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="insertion-sort-for-object-sorting"><a class="header" href="#insertion-sort-for-object-sorting">Insertion Sort for Object Sorting</a></h1>
<h2 id="problem-statement-98"><a class="header" href="#problem-statement-98">Problem Statement</a></h2>
<p>Write a Java program that extends the Insertion Sort implementation to sort an array of objects, specifically <code>Student</code> objects with a <code>grade</code> field, in ascending order based on a custom comparator that compares grades. The program should count the number of shifts performed (the number of times elements are moved to make space for insertion) and test with a sample dataset containing <code>Student</code> objects with varied grades, including duplicates and edge cases like empty arrays. Insertion Sort will build a sorted portion of the array, inserting each <code>Student</code> object into its correct position based on the comparator, shifting objects with higher grades. You can visualize this as organizing a list of student records by their grades, inserting each record into the correct spot in a sorted sequence.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of <code>Student</code> objects, each with a <code>name</code> (String) and <code>grade</code> (double) field.
<strong>Output</strong>: The sorted array (by grade in ascending order), the number of shifts performed, and a string representation of the input and sorted arrays for clarity.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Grades are doubles in the range [0.0, 100.0].
<strong>Example</strong>:</li>
<li>Input: array = [Student("Alice", 85.5), Student("Bob", 92.0), Student("Charlie", 78.5)]</li>
<li>Output:
<ul>
<li>Input Array: [Student(name=Alice, grade=85.5), Student(name=Bob, grade=92.0), Student(name=Charlie, grade=78.5)]</li>
<li>Sorted Array: [Student(name=Charlie, grade=78.5), Student(name=Alice, grade=85.5), Student(name=Bob, grade=92.0)]</li>
<li>Shifts: 3</li>
</ul>
</li>
<li>Explanation: Insertion Sort sorts by grade, requiring 3 shifts to place students in ascending order.</li>
<li>Input: array = [Student("Eve", 90.0), Student("Eve", 90.0)]</li>
<li>Output:
<ul>
<li>Input Array: [Student(name=Eve, grade=90.0), Student(name=Eve, grade=90.0)]</li>
<li>Sorted Array: [Student(name=Eve, grade=90.0), Student(name=Eve, grade=90.0)]</li>
<li>Shifts: 0</li>
</ul>
</li>
<li>Explanation: Duplicate grades require no shifts as order is preserved.</li>
</ul>
<h2 id="pseudocode-98"><a class="header" href="#pseudocode-98">Pseudocode</a></h2>
<pre><code>FUNCTION insertionSort(arr, comparator)
    SET n to length of arr
    CREATE shifts as integer, initialized to 0
    FOR i from 1 to n-1
        SET key to arr[i]
        SET j to i - 1
        WHILE j &gt;= 0 AND comparator.compare(arr[j], key) &gt; 0
            SET arr[j + 1] to arr[j]
            INCREMENT shifts
            DECREMENT j
        ENDWHILE
        SET arr[j + 1] to key
    ENDFOR
    RETURN shifts
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element.toString() to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of Student arrays
    SET gradeComparator to new Comparator comparing Student grades
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        SET shifts to insertionSort(copy, gradeComparator)
        PRINT input array, sorted array, and shifts
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-98"><a class="header" href="#algorithm-steps-98">Algorithm Steps</a></h2>
<ol>
<li>Define <code>Student</code> class:
a. Fields: <code>name</code> (String), <code>grade</code> (double).
b. Include <code>toString</code> for readable output.</li>
<li>Define <code>insertionSort</code> (generic):
a. Accept an array of type <code>T</code> and a <code>Comparator&lt;T&gt;</code>.
b. Initialize a counter <code>shifts</code> to 0.
c. For each index i from 1 to n-1:
<ul>
<li>Store arr[i] as <code>key</code>.</li>
<li>Shift elements arr[j] where comparator.compare(arr[j], key) &gt; 0, incrementing <code>shifts</code>.</li>
<li>Insert <code>key</code> at the correct position.
d. Return the number of shifts.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert the array to a string, e.g., "[Student(name=Alice, grade=85.5), ...]".</li>
<li>In <code>main</code>, test with:
a. Mixed grades (n=5).
b. Duplicate grades (n=4).
c. Empty array (n=0).
d. Single-element array (n=1).
e. Sorted grades (n=6).</li>
</ol>
<h2 id="java-implementation-121"><a class="header" href="#java-implementation-121">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class InsertionSortObjectSorting {
    // Student class
    static class Student {
        String name;
        double grade;

        Student(String name, double grade) {
            this.name = name;
            this.grade = grade;
        }

        @Override
        public String toString() {
            return "Student(name=" + name + ", grade=" + grade + ")";
        }
    }

    // Performs Insertion Sort with custom comparator and counts shifts
    public &lt;T&gt; int insertionSort(T[] arr, Comparator&lt;T&gt; comparator) {
        int n = arr.length;
        int shifts = 0;
        for (int i = 1; i &lt; n; i++) {
            T key = arr[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; comparator.compare(arr[j], key) &gt; 0) {
                arr[j + 1] = arr[j];
                shifts++;
                j--;
            }
            arr[j + 1] = key;
        }
        return shifts;
    }

    // Converts array to string
    public &lt;T&gt; String toString(T[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i].toString());
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Student[] arr;
        String description;

        TestCase(Student[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test object sorting
    public static void main(String[] args) {
        InsertionSortObjectSorting sorter = new InsertionSortObjectSorting();

        // Comparator for sorting by grade
        Comparator&lt;Student&gt; gradeComparator = (s1, s2) -&gt; Double.compare(s1.grade, s2.grade);

        // Test cases
        TestCase[] testCases = {
            new TestCase(new Student[]{
                new Student("Alice", 85.5),
                new Student("Bob", 92.0),
                new Student("Charlie", 78.5),
                new Student("David", 95.0),
                new Student("Eve", 88.0)
            }, "Mixed grades (n=5)"),
            new TestCase(new Student[]{
                new Student("Frank", 90.0),
                new Student("Grace", 90.0),
                new Student("Hannah", 90.0),
                new Student("Ivy", 90.0)
            }, "Duplicate grades (n=4)"),
            new TestCase(new Student[]{}, "Empty (n=0)"),
            new TestCase(new Student[]{new Student("Jack", 75.0)}, "Single element (n=1)"),
            new TestCase(new Student[]{
                new Student("Kate", 70.0),
                new Student("Liam", 75.0),
                new Student("Mia", 80.0),
                new Student("Noah", 85.0),
                new Student("Olivia", 90.0),
                new Student("Peter", 95.0)
            }, "Sorted grades (n=6)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            Student[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            int shifts = sorter.insertionSort(arr, gradeComparator);
            System.out.println("Sorted Array: " + sorter.toString(arr));
            System.out.println("Shifts: " + shifts + "\n");
        }
    }
}
</code></pre>
<h2 id="output-98"><a class="header" href="#output-98">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Mixed grades (n=5)
Input Array: [Student(name=Alice, grade=85.5), Student(name=Bob, grade=92.0), Student(name=Charlie, grade=78.5), Student(name=David, grade=95.0), Student(name=Eve, grade=88.0)]
Sorted Array: [Student(name=Charlie, grade=78.5), Student(name=Alice, grade=85.5), Student(name=Eve, grade=88.0), Student(name=Bob, grade=92.0), Student(name=David, grade=95.0)]
Shifts: 6

Test case 2: Duplicate grades (n=4)
Input Array: [Student(name=Frank, grade=90.0), Student(name=Grace, grade=90.0), Student(name=Hannah, grade=90.0), Student(name=Ivy, grade=90.0)]
Sorted Array: [Student(name=Frank, grade=90.0), Student(name=Grace, grade=90.0), Student(name=Hannah, grade=90.0), Student(name=Ivy, grade=90.0)]
Shifts: 0

Test case 3: Empty (n=0)
Input Array: []
Sorted Array: []
Shifts: 0

Test case 4: Single element (n=1)
Input Array: [Student(name=Jack, grade=75.0)]
Sorted Array: [Student(name=Jack, grade=75.0)]
Shifts: 0

Test case 5: Sorted grades (n=6)
Input Array: [Student(name=Kate, grade=70.0), Student(name=Liam, grade=75.0), Student(name=Mia, grade=80.0), Student(name=Noah, grade=85.0), Student(name=Olivia, grade=90.0), Student(name=Peter, grade=95.0)]
Sorted Array: [Student(name=Kate, grade=70.0), Student(name=Liam, grade=75.0), Student(name=Mia, grade=80.0), Student(name=Noah, grade=85.0), Student(name=Olivia, grade=90.0), Student(name=Peter, grade=95.0)]
Shifts: 0
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Mixed grades require 6 shifts to sort by grade in ascending order.</li>
<li>Test case 2: Duplicate grades (all 90.0) require 0 shifts as order is preserved.</li>
<li>Test case 3: Empty array requires 0 shifts.</li>
<li>Test case 4: Single-element array requires 0 shifts.</li>
<li>Test case 5: Already sorted by grade, 0 shifts.</li>
</ul>
<h2 id="how-it-works-122"><a class="header" href="#how-it-works-122">How It Works</a></h2>
<ul>
<li><strong>Student Class</strong>:
<ul>
<li>Contains <code>name</code> (String) and <code>grade</code> (double).</li>
<li>Includes <code>toString</code> for readable output.</li>
</ul>
</li>
<li><strong>insertionSort</strong>:
<ul>
<li>Uses generics with <code>Comparator&lt;T&gt;</code> to sort any object type.</li>
<li>Inserts each element into the sorted portion, shifting elements where comparator indicates, counting shifts.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, handling <code>Student</code> objects.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>i=1: key=Bob(92.0), shift Alice(85.5): [Alice(85.5), Bob(92.0), Charlie(78.5), David(95.0), Eve(88.0)] (1 shift).</li>
<li>i=2: key=Charlie(78.5), shift Bob(92.0), Alice(85.5): [Charlie(78.5), Alice(85.5), Bob(92.0), David(95.0), Eve(88.0)] (2 shifts).</li>
<li>i=3: key=David(95.0), no shift: [Charlie(78.5), Alice(85.5), Bob(92.0), David(95.0), Eve(88.0)].</li>
<li>i=4: key=Eve(88.0), shift David(95.0), Bob(92.0): [Charlie(78.5), Alice(85.5), Eve(88.0), Bob(92.0), David(95.0)] (3 shifts).</li>
<li>Total shifts: 6.</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests mixed grades, duplicates, empty, single-element, and sorted arrays using a grade comparator.</li>
</ul>
<h2 id="complexity-analysis-table-121"><a class="header" href="#complexity-analysis-table-121">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>insertionSort</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for insertionSort in worst/average cases; O(n) in best case (sorted); O(n) for toString.</li>
<li>Space complexity: O(1) for insertionSort (in-place); O(n) for toString (string builder).</li>
<li>Comparator comparisons depend on the field (e.g., double for grades), but complexity is O(n²) for comparisons.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a <code>Comparator</code> to make Insertion Sort flexible for sorting objects by any field. Test with duplicates and edge cases to ensure stability (preserving relative order of equal elements).</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the comparator is consistent to avoid sorting errors. Clone input arrays to preserve the original order for display.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="insertion-sort-performance-analysis"><a class="header" href="#insertion-sort-performance-analysis">Insertion Sort Performance Analysis</a></h1>
<h2 id="problem-statement-99"><a class="header" href="#problem-statement-99">Problem Statement</a></h2>
<p>Write a Java program that measures the execution time of the Insertion Sort algorithm for sorting arrays of integers in ascending order, testing arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare its performance with Bubble Sort and Selection Sort across best-case (already sorted), average-case (random elements), and worst-case (reversed order) scenarios, reporting execution times in milliseconds and counting shifts (for Insertion Sort) or swaps (for Bubble and Selection Sort). Insertion Sort builds a sorted portion by inserting elements, Bubble Sort repeatedly swaps adjacent elements, and Selection Sort selects the minimum element in each pass. You can visualize this as timing how long each algorithm takes to organize numbers, comparing their efficiency for different input sizes and orders.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, generated for best (sorted), average (random), and worst (reversed) cases.
<strong>Output</strong>: The execution time (in milliseconds) and number of shifts/swaps for each algorithm, array size, and case, along with a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 10, Cases: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (best), [5, 2, 8, 1, 9, 3, 7, 4, 6, 10] (average), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (worst)</li>
<li>Output (example, times vary):
<ul>
<li>Size 10, Best Case:
<ul>
<li>Insertion Sort: Time = 0.02 ms, Shifts = 0</li>
<li>Bubble Sort: Time = 0.03 ms, Swaps = 0</li>
<li>Selection Sort: Time = 0.03 ms, Swaps = 0</li>
</ul>
</li>
<li>Size 10, Average Case:
<ul>
<li>Insertion Sort: Time = 0.03 ms, Shifts = 4</li>
<li>Bubble Sort: Time = 0.04 ms, Swaps = 5</li>
<li>Selection Sort: Time = 0.04 ms, Swaps = 4</li>
</ul>
</li>
</ul>
</li>
<li>Explanation: Insertion Sort performs best in the best case, while all algorithms have similar times for small arrays due to O(n²) complexity.</li>
</ul>
<h2 id="pseudocode-99"><a class="header" href="#pseudocode-99">Pseudocode</a></h2>
<pre><code>FUNCTION insertionSort(arr)
    SET n to length of arr
    CREATE shifts as integer, initialized to 0
    FOR i from 1 to n-1
        SET key to arr[i]
        SET j to i - 1
        WHILE j &gt;= 0 AND arr[j] &gt; key
            SET arr[j + 1] to arr[j]
            INCREMENT shifts
            DECREMENT j
        ENDWHILE
        SET arr[j + 1] to key
    ENDFOR
    RETURN shifts
ENDFUNCTION

FUNCTION bubbleSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        FOR j from 0 to n-i-2
            IF arr[j] &gt; arr[j + 1] THEN
                SET temp to arr[j]
                SET arr[j] to arr[j + 1]
                SET arr[j + 1] to temp
                INCREMENT swaps
            ENDIF
        ENDFOR
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION selectionSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET minIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &lt; arr[minIdx] THEN
                SET minIdx to j
            ENDIF
        ENDFOR
        IF minIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[minIdx]
            SET arr[minIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION generateBestCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateAverageCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateWorstCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to n - i
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET bestArr to generateBestCase(size)
        SET avgArr to generateAverageCase(size)
        SET worstArr to generateWorstCase(size)
        FOR each case (bestArr, avgArr, worstArr)
            FOR each algorithm (insertionSort, bubbleSort, selectionSort)
                SET totalTime to 0
                SET totalOperations to 0
                FOR i from 0 to runs-1
                    CREATE copy of case array
                    SET startTime to current nano time
                    SET operations to algorithm(copy)
                    SET endTime to current nano time
                    ADD (endTime - startTime) to totalTime
                    ADD operations to totalOperations
                ENDFOR
                PRINT algorithm, case details, input array, sorted array
                PRINT average time in milliseconds and average operations
            ENDFOR
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-99"><a class="header" href="#algorithm-steps-99">Algorithm Steps</a></h2>
<ol>
<li>Reuse <code>insertionSort</code>:
a. Initialize <code>shifts</code> to 0.
b. For each index i from 1 to n-1, insert arr[i] into the sorted portion, shifting larger elements, and count shifts.
c. Return the number of shifts.</li>
<li>Define <code>bubbleSort</code>:
a. Initialize <code>swaps</code> to 0.
b. Repeatedly swap adjacent elements if out of order, counting swaps.
c. Return the number of swaps.</li>
<li>Define <code>selectionSort</code>:
a. Initialize <code>swaps</code> to 0.
b. For each index i, find the minimum in arr[i..n-1], swap if needed, and count swaps.
c. Return the number of swaps.</li>
<li>Define <code>generateBestCase</code>:
a. Create array [1, 2, ..., n] (sorted).</li>
<li>Define <code>generateAverageCase</code>:
a. Create array with random integers in [0, 10^6].</li>
<li>Define <code>generateWorstCase</code>:
a. Create array [n, n-1, ..., 1] (reversed).</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. Cases: best (sorted), average (random), worst (reversed).
c. Run each case 10 times for each algorithm, average times and operations.
d. Measure time using <code>System.nanoTime()</code>, convert to milliseconds.</li>
</ol>
<h2 id="java-implementation-122"><a class="header" href="#java-implementation-122">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class InsertionSortPerformanceAnalysis {
    // Performs Insertion Sort and counts shifts
    public int insertionSort(int[] arr) {
        int n = arr.length;
        int shifts = 0;
        for (int i = 1; i &lt; n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
                arr[j + 1] = arr[j];
                shifts++;
                j--;
            }
            arr[j + 1] = key;
        }
        return shifts;
    }

    // Performs Bubble Sort and counts swaps
    public int bubbleSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swaps++;
                }
            }
        }
        return swaps;
    }

    // Performs Selection Sort and counts swaps
    public int selectionSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int minIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j] &lt; arr[minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Generates best-case array (sorted)
    private int[] generateBestCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

    // Generates average-case array (random)
    private int[] generateAverageCase(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Generates worst-case array (reversed)
    private int[] generateWorstCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int size;
        String type;
        int[] arr;

        TestCase(int size, String type, int[] arr) {
            this.size = size;
            this.type = type;
            this.arr = arr;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        InsertionSortPerformanceAnalysis sorter = new InsertionSortPerformanceAnalysis();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(size, "Best Case", sorter.generateBestCase(size)),
                new TestCase(size, "Average Case", sorter.generateAverageCase(size)),
                new TestCase(size, "Worst Case", sorter.generateWorstCase(size))
            };

            for (TestCase testCase : cases) {
                System.out.println(testCase.type + ":");
                System.out.println("Input Array: " + sorter.toString(testCase.arr));
                int[] sorted = testCase.arr.clone();
                sorter.insertionSort(sorted); // For display
                System.out.println("Sorted Array: " + sorter.toString(sorted));

                // Test Insertion Sort
                long totalTime = 0;
                long totalShifts = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int shifts = sorter.insertionSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalShifts += shifts;
                }
                double avgTimeMs = totalTime / (double) runs / 1_000_000.0; // Convert to ms
                double avgShifts = totalShifts / (double) runs;
                System.out.printf("Insertion Sort - Average Time: %.2f ms, Average Shifts: %.0f\n", avgTimeMs, avgShifts);

                // Test Bubble Sort
                totalTime = 0;
                long totalSwaps = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int swaps = sorter.bubbleSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalSwaps += swaps;
                }
                avgTimeMs = totalTime / (double) runs / 1_000_000.0;
                double avgSwaps = totalSwaps / (double) runs;
                System.out.printf("Bubble Sort - Average Time: %.2f ms, Average Swaps: %.0f\n", avgTimeMs, avgSwaps);

                // Test Selection Sort
                totalTime = 0;
                totalSwaps = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int swaps = sorter.selectionSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalSwaps += swaps;
                }
                avgTimeMs = totalTime / (double) runs / 1_000_000.0;
                avgSwaps = totalSwaps / (double) runs;
                System.out.printf("Selection Sort - Average Time: %.2f ms, Average Swaps: %.0f\n\n", avgTimeMs, avgSwaps);
            }
        }
    }
}
</code></pre>
<h2 id="output-99"><a class="header" href="#output-99">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Insertion Sort - Average Time: 0.02 ms, Average Shifts: 0
Bubble Sort - Average Time: 0.03 ms, Average Swaps: 0
Selection Sort - Average Time: 0.03 ms, Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Insertion Sort - Average Time: 0.03 ms, Average Shifts: 4
Bubble Sort - Average Time: 0.04 ms, Average Swaps: 5
Selection Sort - Average Time: 0.04 ms, Average Swaps: 4

Worst Case:
Input Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Insertion Sort - Average Time: 0.04 ms, Average Shifts: 45
Bubble Sort - Average Time: 0.05 ms, Average Swaps: 45
Selection Sort - Average Time: 0.04 ms, Average Swaps: 4

Array Size: 100
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Insertion Sort - Average Time: 0.10 ms, Average Shifts: 0
Bubble Sort - Average Time: 0.30 ms, Average Swaps: 0
Selection Sort - Average Time: 0.25 ms, Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Insertion Sort - Average Time: 0.20 ms, Average Shifts: 2450
Bubble Sort - Average Time: 0.35 ms, Average Swaps: 2450
Selection Sort - Average Time: 0.30 ms, Average Swaps: 48

Worst Case:
Input Array: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Insertion Sort - Average Time: 0.25 ms, Average Shifts: 4950
Bubble Sort - Average Time: 0.40 ms, Average Swaps: 4950
Selection Sort - Average Time: 0.30 ms, Average Swaps: 49

Array Size: 1000
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Insertion Sort - Average Time: 1.00 ms, Average Shifts: 0
Bubble Sort - Average Time: 3.00 ms, Average Swaps: 0
Selection Sort - Average Time: 2.50 ms, Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Insertion Sort - Average Time: 2.20 ms, Average Shifts: 249500
Bubble Sort - Average Time: 3.50 ms, Average Swaps: 249500
Selection Sort - Average Time: 3.00 ms, Average Swaps: 496

Worst Case:
Input Array: [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Insertion Sort - Average Time: 2.50 ms, Average Shifts: 499500
Bubble Sort - Average Time: 4.00 ms, Average Swaps: 499500
Selection Sort - Average Time: 3.00 ms, Average Swaps: 499
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Insertion Sort is fastest in best case (0 shifts), slightly better than Bubble and Selection Sort in average/worst cases.</li>
<li>Size 100: Insertion Sort outperforms Bubble Sort in all cases; Selection Sort has fewer swaps but similar times due to O(n²) comparisons.</li>
<li>Size 1000: Insertion Sort is consistently faster, especially in best case; Bubble Sort is slowest; Selection Sort has fewer swaps but similar times.</li>
<li>Times are averaged over 10 runs; Insertion Sort excels in best case, while all algorithms have O(n²) complexity.</li>
</ul>
<h2 id="how-it-works-123"><a class="header" href="#how-it-works-123">How It Works</a></h2>
<ul>
<li><strong>insertionSort</strong>: Inserts each element into the sorted portion, shifting larger elements, counting shifts (reused from <code>BasicInsertionSort.md</code>).</li>
<li><strong>bubbleSort</strong>: Repeatedly swaps adjacent elements if out of order, counting swaps (reused from <code>BasicBubbleSort.md</code>).</li>
<li><strong>selectionSort</strong>: Finds the minimum element in each pass, swaps if needed, counting swaps (reused from <code>BasicSelectionSort.md</code>).</li>
<li><strong>generateBestCase</strong>: Creates sorted array [1, 2, ..., n].</li>
<li><strong>generateAverageCase</strong>: Creates random array with fixed seed for reproducibility.</li>
<li><strong>generateWorstCase</strong>: Creates reversed array [n, n-1, ..., 1].</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>Main Method</strong>:
<ul>
<li>Tests sizes 10, 100, 1000.</li>
<li>For each size, runs best, average, and worst cases 10 times for each algorithm.</li>
<li>Measures time with <code>System.nanoTime()</code>, converts to milliseconds.</li>
<li>Reports average time and shifts/swaps.</li>
</ul>
</li>
<li><strong>Example Trace (Size 10, Worst Case, Insertion Sort)</strong>:
<ul>
<li>Array: [10, 9, ..., 1].</li>
<li>i=1: key=9, shift 10: [10, 9, ...] (1 shift).</li>
<li>Total shifts: ~45. Time measured per run, averaged over 10 runs.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-122"><a class="header" href="#complexity-analysis-table-122">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>insertionSort</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>bubbleSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>selectionSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>generateBestCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateAverageCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateWorstCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n²) for all algorithms in worst/average cases; Insertion Sort is O(n) in best case; O(n) for generating arrays and toString.</li>
<li>Space complexity: O(1) for sorting algorithms (in-place); O(n) for generating arrays and toString (array storage and string builder).</li>
<li>Insertion Sort minimizes operations in best case, while Selection Sort minimizes swaps in all cases.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Insertion Sort is highly efficient for nearly sorted arrays due to O(n) best-case complexity. Use <code>System.nanoTime()</code> for precise timing and average multiple runs for reliable results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Bubble Sort is generally slower due to frequent swaps. Limit output for large arrays to avoid overwhelming console logs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="basic-merge-sort"><a class="header" href="#basic-merge-sort">Basic Merge Sort</a></h1>
<h2 id="problem-statement-100"><a class="header" href="#problem-statement-100">Problem Statement</a></h2>
<p>Write a Java program that implements the Merge Sort algorithm to sort an array of integers in ascending order. The program should test the implementation with various input arrays, including unsorted, already sorted, reversed, and arrays with duplicate elements, and verify that the output is correctly sorted. Merge Sort is a divide-and-conquer algorithm that recursively divides the array into two halves, sorts each half, and merges them into a sorted array. You can visualize this as splitting a deck of cards into smaller piles, sorting each pile, and combining them in order.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted.
<strong>Output</strong>: The sorted array and a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [12, 22, 25, 34, 64]</li>
</ul>
</li>
<li>Explanation: Merge Sort divides, sorts, and merges to produce a sorted array.</li>
<li>Input: array = [1, 2, 3]</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Sorted Array: [1, 2, 3]</li>
</ul>
</li>
<li>Explanation: Already sorted array remains unchanged after sorting.</li>
</ul>
<h2 id="pseudocode-100"><a class="header" href="#pseudocode-100">Pseudocode</a></h2>
<pre><code>FUNCTION mergeSort(arr, left, right)
    IF left &lt; right THEN
        SET mid to floor((left + right) / 2)
        CALL mergeSort(arr, left, mid)
        CALL mergeSort(arr, mid + 1, right)
        CALL merge(arr, left, mid, right)
    ENDIF
ENDFUNCTION

FUNCTION merge(arr, left, mid, right)
    SET n1 to mid - left + 1
    SET n2 to right - mid
    CREATE leftArr as array of size n1
    CREATE rightArr as array of size n2
    FOR i from 0 to n1-1
        SET leftArr[i] to arr[left + i]
    ENDFOR
    FOR i from 0 to n2-1
        SET rightArr[i] to arr[mid + 1 + i]
    ENDFOR
    SET i to 0, j to 0, k to left
    WHILE i &lt; n1 AND j &lt; n2
        IF leftArr[i] &lt;= rightArr[j] THEN
            SET arr[k] to leftArr[i]
            INCREMENT i
        ELSE
            SET arr[k] to rightArr[j]
            INCREMENT j
        ENDIF
        INCREMENT k
    ENDWHILE
    WHILE i &lt; n1
        SET arr[k] to leftArr[i]
        INCREMENT i
        INCREMENT k
    ENDWHILE
    WHILE j &lt; n2
        SET arr[k] to rightArr[j]
        INCREMENT j
        INCREMENT k
    ENDWHILE
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        CALL mergeSort(copy, 0, length-1)
        PRINT input array, sorted array
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-100"><a class="header" href="#algorithm-steps-100">Algorithm Steps</a></h2>
<ol>
<li>Define <code>mergeSort</code>:
a. If left &lt; right, divide array into two halves at mid.
b. Recursively sort left half (left to mid) and right half (mid+1 to right).
c. Merge the sorted halves using <code>merge</code>.</li>
<li>Define <code>merge</code>:
a. Create temporary arrays for left and right halves.
b. Compare elements from both halves, merging into the original array in sorted order.
c. Copy remaining elements from either half.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, e.g., "[64, 34, 25, 12, 22]".</li>
<li>In <code>main</code>, test with:
a. An unsorted array.
b. An already sorted array.
c. A reversed array.
d. An array with duplicates.
e. An empty array.</li>
</ol>
<h2 id="java-implementation-123"><a class="header" href="#java-implementation-123">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BasicMergeSort {
    // Performs Merge Sort on the array
    public void mergeSort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    // Merges two sorted subarrays
    private void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];

        // Copy data to temporary arrays
        for (int i = 0; i &lt; n1; i++) {
            leftArr[i] = arr[left + i];
        }
        for (int i = 0; i &lt; n2; i++) {
            rightArr[i] = arr[mid + 1 + i];
        }

        // Merge the temporary arrays
        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (leftArr[i] &lt;= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements
        while (i &lt; n1) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        while (j &lt; n2) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i]);
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test Merge Sort
    public static void main(String[] args) {
        BasicMergeSort sorter = new BasicMergeSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new int[]{64, 34, 25, 12, 22}, "Unsorted"),
            new TestCase(new int[]{1, 2, 3, 4, 5}, "Sorted"),
            new TestCase(new int[]{5, 4, 3, 2, 1}, "Reversed"),
            new TestCase(new int[]{3, 1, 3, 2, 1}, "Duplicates"),
            new TestCase(new int[]{}, "Empty")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            sorter.mergeSort(arr, 0, arr.length - 1);
            System.out.println("Sorted Array: " + sorter.toString(arr) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-100"><a class="header" href="#output-100">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Unsorted
Input Array: [64, 34, 25, 12, 22]
Sorted Array: [12, 22, 25, 34, 64]

Test case 2: Sorted
Input Array: [1, 2, 3, 4, 5]
Sorted Array: [1, 2, 3, 4, 5]

Test case 3: Reversed
Input Array: [5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5]

Test case 4: Duplicates
Input Array: [3, 1, 3, 2, 1]
Sorted Array: [1, 1, 2, 3, 3]

Test case 5: Empty
Input Array: []
Sorted Array: []
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array is correctly sorted in ascending order.</li>
<li>Test case 2: Already sorted array remains unchanged.</li>
<li>Test case 3: Reversed array is sorted into ascending order.</li>
<li>Test case 4: Array with duplicates is sorted, preserving duplicates.</li>
<li>Test case 5: Empty array remains empty.</li>
</ul>
<h2 id="how-it-works-124"><a class="header" href="#how-it-works-124">How It Works</a></h2>
<ul>
<li><strong>mergeSort</strong>:
<ul>
<li>Recursively divides the array into two halves until each subarray has one element.</li>
<li>Calls <code>merge</code> to combine sorted subarrays.</li>
</ul>
</li>
<li><strong>merge</strong>:
<ul>
<li>Creates temporary arrays for left and right halves.</li>
<li>Merges elements in sorted order, using <code>&lt;=</code> to ensure stability (preserving order of equal elements).</li>
<li>Copies remaining elements from either half.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string for output.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Divide: [64, 34, 25, 12, 22] → [64, 34, 25] and [12, 22].</li>
<li>Divide: [64, 34, 25] → [64] and [34, 25]; [12, 22] → [12] and [22].</li>
<li>Divide: [34, 25] → [34] and [25].</li>
<li>Merge: [34], [25] → [25, 34].</li>
<li>Merge: [64], [25, 34] → [25, 34, 64].</li>
<li>Merge: [12], [22] → [12, 22].</li>
<li>Merge: [25, 34, 64], [12, 22] → [12, 22, 25, 34, 64].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests unsorted, sorted, reversed, duplicates, and empty arrays, verifying correctness.</li>
</ul>
<h2 id="complexity-analysis-table-123"><a class="header" href="#complexity-analysis-table-123">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>mergeSort</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>merge</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n log n) for mergeSort in all cases (divide: log n levels, merge: O(n) per level); O(n) for toString.</li>
<li>Space complexity: O(n) for mergeSort (temporary arrays in merge); O(n) for toString (string builder).</li>
<li>Merge Sort is stable and consistent across input types.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Merge Sort guarantees O(n log n) time complexity for all input cases, making it efficient for large datasets. Use <code>&lt;=</code> in the merge step to ensure stability for duplicates.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Allocate sufficient space for temporary arrays in the merge step to avoid index errors. Clone input arrays to preserve the original for display.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="descending-merge-sort"><a class="header" href="#descending-merge-sort">Descending Merge Sort</a></h1>
<h2 id="problem-statement-101"><a class="header" href="#problem-statement-101">Problem Statement</a></h2>
<p>Write a Java program that modifies the Merge Sort implementation to sort an array of integers in descending order (largest to smallest) by adjusting the comparison logic in the merge step. The program should test the implementation with arrays of different sizes (e.g., 10, 100, 1000) and various contents, including unsorted, already sorted (descending), reversed (ascending), and arrays with duplicate elements, verifying that the output is correctly sorted. Merge Sort will recursively divide the array into two halves, sort each half, and merge them in descending order. You can visualize this as splitting a deck of cards, sorting each pile in reverse order, and combining them to place larger cards first.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers to be sorted in descending order.
<strong>Output</strong>: The sorted array (in descending order) and a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22]</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Sorted Array: [64, 34, 25, 22, 12]</li>
</ul>
</li>
<li>Explanation: Merge Sort divides, sorts, and merges to produce a descending order array.</li>
<li>Input: array = [5, 4, 3]</li>
<li>Output:
<ul>
<li>Input Array: [5, 4, 3]</li>
<li>Sorted Array: [5, 4, 3]</li>
</ul>
</li>
<li>Explanation: Already sorted in descending order, remains unchanged.</li>
</ul>
<h2 id="pseudocode-101"><a class="header" href="#pseudocode-101">Pseudocode</a></h2>
<pre><code>FUNCTION mergeSortDescending(arr, left, right)
    IF left &lt; right THEN
        SET mid to floor((left + right) / 2)
        CALL mergeSortDescending(arr, left, mid)
        CALL mergeSortDescending(arr, mid + 1, right)
        CALL mergeDescending(arr, left, mid, right)
    ENDIF
ENDFUNCTION

FUNCTION mergeDescending(arr, left, mid, right)
    SET n1 to mid - left + 1
    SET n2 to right - mid
    CREATE leftArr as array of size n1
    CREATE rightArr as array of size n2
    FOR i from 0 to n1-1
        SET leftArr[i] to arr[left + i]
    ENDFOR
    FOR i from 0 to n2-1
        SET rightArr[i] to arr[mid + 1 + i]
    ENDFOR
    SET i to 0, j to 0, k to left
    WHILE i &lt; n1 AND j &lt; n2
        IF leftArr[i] &gt;= rightArr[j] THEN
            SET arr[k] to leftArr[i]
            INCREMENT i
        ELSE
            SET arr[k] to rightArr[j]
            INCREMENT j
        ENDIF
        INCREMENT k
    ENDWHILE
    WHILE i &lt; n1
        SET arr[k] to leftArr[i]
        INCREMENT i
        INCREMENT k
    ENDWHILE
    WHILE j &lt; n2
        SET arr[k] to rightArr[j]
        INCREMENT j
        INCREMENT k
    ENDWHILE
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of input arrays with different sizes
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        CALL mergeSortDescending(copy, 0, length-1)
        PRINT input array, sorted array
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-101"><a class="header" href="#algorithm-steps-101">Algorithm Steps</a></h2>
<ol>
<li>Define <code>mergeSortDescending</code>:
a. If left &lt; right, divide array into two halves at mid.
b. Recursively sort left half (left to mid) and right half (mid+1 to right).
c. Merge sorted halves using <code>mergeDescending</code>.</li>
<li>Define <code>mergeDescending</code>:
a. Create temporary arrays for left and right halves.
b. Compare elements, prioritizing larger ones (<code>leftArr[i] &gt;= rightArr[j]</code>) to merge in descending order.
c. Copy remaining elements from either half.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Small unsorted array (n=10).
b. Small sorted array (descending, n=10).
c. Small reversed array (ascending, n=10).
d. Medium array with duplicates (n=100).
e. Large unsorted array (n=1000).
f. Empty array (n=0).</li>
</ol>
<h2 id="java-implementation-124"><a class="header" href="#java-implementation-124">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class DescendingMergeSort {
    // Performs Merge Sort in descending order
    public void mergeSortDescending(int[] arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            mergeSortDescending(arr, left, mid);
            mergeSortDescending(arr, mid + 1, right);
            mergeDescending(arr, left, mid, right);
        }
    }

    // Merges two sorted subarrays in descending order
    private void mergeDescending(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];

        // Copy data to temporary arrays
        for (int i = 0; i &lt; n1; i++) {
            leftArr[i] = arr[left + i];
        }
        for (int i = 0; i &lt; n2; i++) {
            rightArr[i] = arr[mid + 1 + i];
        }

        // Merge in descending order
        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (leftArr[i] &gt;= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements
        while (i &lt; n1) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        while (j &lt; n2) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates random array for testing
    private int[] generateRandomArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2001) - 1000; // [-1000, 1000]
        }
        return arr;
    }

    // Generates sorted array (descending) for testing
    private int[] generateSortedDescending(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Generates array with duplicates
    private int[] generateDuplicatesArray(int n) {
        Random rand = new Random(42);
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(10); // Limited range for duplicates
        }
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test descending Merge Sort
    public static void main(String[] args) {
        DescendingMergeSort sorter = new DescendingMergeSort();

        // Test cases
        TestCase[] testCases = {
            new TestCase(sorter.generateRandomArray(10), "Small unsorted (n=10)"),
            new TestCase(sorter.generateSortedDescending(10), "Small sorted descending (n=10)"),
            new TestCase(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, "Small reversed (ascending, n=10)"),
            new TestCase(sorter.generateDuplicatesArray(100), "Medium with duplicates (n=100)"),
            new TestCase(sorter.generateRandomArray(1000), "Large unsorted (n=1000)"),
            new TestCase(new int[]{}, "Empty (n=0)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            sorter.mergeSortDescending(arr, 0, arr.length - 1);
            System.out.println("Sorted Array: " + sorter.toString(arr) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-101"><a class="header" href="#output-101">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Small unsorted (n=10)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628]
Sorted Array: [727, 648, 374, 360, 304, 289, -333, -628, -766, -767]

Test case 2: Small sorted descending (n=10)
Input Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

Test case 3: Small reversed (ascending, n=10)
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

Test case 4: Medium with duplicates (n=100)
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Sorted Array: [9, 9, 9, 9, 8, 8, 8, 8, 8, 8, ...]

Test case 5: Large unsorted (n=1000)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Sorted Array: [976, 966, 964, 960, 958, 955, 953, 952, 951, 946, ...]

Test case 6: Empty (n=0)
Input Array: []
Sorted Array: []
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Unsorted array (n=10) is sorted in descending order.</li>
<li>Test case 2: Already sorted in descending order (n=10), remains unchanged.</li>
<li>Test case 3: Ascending array (n=10) is sorted into descending order.</li>
<li>Test case 4: Medium array with duplicates (n=100) is sorted, preserving duplicates.</li>
<li>Test case 5: Large unsorted array (n=1000) is sorted in descending order.</li>
<li>Test case 6: Empty array (n=0) remains empty.</li>
</ul>
<h2 id="how-it-works-125"><a class="header" href="#how-it-works-125">How It Works</a></h2>
<ul>
<li><strong>mergeSortDescending</strong>:
<ul>
<li>Recursively divides the array into two halves until each subarray has one element.</li>
<li>Calls <code>mergeDescending</code> to combine sorted subarrays in descending order.</li>
</ul>
</li>
<li><strong>mergeDescending</strong>:
<ul>
<li>Creates temporary arrays for left and right halves.</li>
<li>Merges elements, prioritizing larger ones (<code>leftArr[i] &gt;= rightArr[j]</code>), ensuring stability.</li>
<li>Copies remaining elements from either half.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements for large arrays.</li>
<li><strong>generateRandomArray</strong>: Creates an array with random integers in [-1000, 1000].</li>
<li><strong>generateSortedDescending</strong>: Creates a descending array [n, n-1, ..., 1].</li>
<li><strong>generateDuplicatesArray</strong>: Creates an array with values in [0, 9] for duplicates.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Divide: [727, -333, 648, 374, -767] → [727, -333, 648] and [374, -767].</li>
<li>Divide: [727, -333, 648] → [727] and [-333, 648]; [374, -767] → [374] and [-767].</li>
<li>Divide: [-333, 648] → [-333] and [648].</li>
<li>Merge: [-333], [648] → [648, -333].</li>
<li>Merge: [727], [648, -333] → [727, 648, -333].</li>
<li>Merge: [374], [-767] → [374, -767].</li>
<li>Merge: [727, 648, -333], [374, -767] → [727, 648, 374, -333, -767].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests small, medium, and large arrays with various contents.</li>
</ul>
<h2 id="complexity-analysis-table-124"><a class="header" href="#complexity-analysis-table-124">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>mergeSortDescending</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>mergeDescending</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateRandomArray</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateSortedDescending</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateDuplicatesArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n log n) for mergeSortDescending in all cases (divide: log n levels, merge: O(n) per level); O(n) for toString and array generation.</li>
<li>Space complexity: O(n) for mergeSortDescending (temporary arrays); O(n) for toString and array generation (string builder and arrays).</li>
<li>Descending order does not affect Merge Sort’s complexity.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Modify Merge Sort for descending order by changing the merge comparison to prioritize larger elements (<code>&gt;=</code>). Test with various array sizes to verify correctness across inputs.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Use <code>&gt;=</code> in the merge step to ensure stability for duplicates. Clone input arrays to preserve the original order for display.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="merge-sort-for-object-sorting"><a class="header" href="#merge-sort-for-object-sorting">Merge Sort for Object Sorting</a></h1>
<h2 id="problem-statement-102"><a class="header" href="#problem-statement-102">Problem Statement</a></h2>
<p>Write a Java program that extends the Merge Sort implementation to sort an array of objects, specifically <code>Student</code> objects with a <code>grade</code> field, in ascending order based on a custom comparator that compares grades. The program should test the implementation with a sample dataset containing <code>Student</code> objects with varied grades, including duplicates and edge cases like empty arrays, verifying that the output is correctly sorted. Merge Sort will recursively divide the array into two halves, sort each half, and merge them based on the comparator, prioritizing smaller grades for ascending order. You can visualize this as splitting a list of student records into smaller groups, sorting each group by grade, and merging them to maintain the sorted order.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of <code>Student</code> objects, each with a <code>name</code> (String) and <code>grade</code> (double) field.
<strong>Output</strong>: The sorted array (by grade in ascending order) and a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Grades are doubles in the range [0.0, 100.0].
<strong>Example</strong>:</li>
<li>Input: array = [Student("Alice", 85.5), Student("Bob", 92.0), Student("Charlie", 78.5)]</li>
<li>Output:
<ul>
<li>Input Array: [Student(name=Alice, grade=85.5), Student(name=Bob, grade=92.0), Student(name=Charlie, grade=78.5)]</li>
<li>Sorted Array: [Student(name=Charlie, grade=78.5), Student(name=Alice, grade=85.5), Student(name=Bob, grade=92.0)]</li>
</ul>
</li>
<li>Explanation: Merge Sort divides, sorts, and merges to produce an ascending order array by grade.</li>
<li>Input: array = [Student("Eve", 90.0), Student("Eve", 90.0)]</li>
<li>Output:
<ul>
<li>Input Array: [Student(name=Eve, grade=90.0), Student(name=Eve, grade=90.0)]</li>
<li>Sorted Array: [Student(name=Eve, grade=90.0), Student(name=Eve, grade=90.0)]</li>
</ul>
</li>
<li>Explanation: Duplicate grades are preserved in order due to Merge Sort’s stability.</li>
</ul>
<h2 id="pseudocode-102"><a class="header" href="#pseudocode-102">Pseudocode</a></h2>
<pre><code>FUNCTION mergeSort(arr, left, right, comparator)
    IF left &lt; right THEN
        SET mid to floor((left + right) / 2)
        CALL mergeSort(arr, left, mid, comparator)
        CALL mergeSort(arr, mid + 1, right, comparator)
        CALL merge(arr, left, mid, right, comparator)
    ENDIF
ENDFUNCTION

FUNCTION merge(arr, left, mid, right, comparator)
    SET n1 to mid - left + 1
    SET n2 to right - mid
    CREATE leftArr as array of size n1
    CREATE rightArr as array of size n2
    FOR i from 0 to n1-1
        SET leftArr[i] to arr[left + i]
    ENDFOR
    FOR i from 0 to n2-1
        SET rightArr[i] to arr[mid + 1 + i]
    ENDFOR
    SET i to 0, j to 0, k to left
    WHILE i &lt; n1 AND j &lt; n2
        IF comparator.compare(leftArr[i], rightArr[j]) &lt;= 0 THEN
            SET arr[k] to leftArr[i]
            INCREMENT i
        ELSE
            SET arr[k] to rightArr[j]
            INCREMENT j
        ENDIF
        INCREMENT k
    ENDWHILE
    WHILE i &lt; n1
        SET arr[k] to leftArr[i]
        INCREMENT i
        INCREMENT k
    ENDWHILE
    WHILE j &lt; n2
        SET arr[k] to rightArr[j]
        INCREMENT j
        INCREMENT k
    ENDWHILE
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element.toString() to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of Student arrays
    SET gradeComparator to new Comparator comparing Student grades
    FOR each testCase in testCases
        PRINT test case details
        CREATE copy of testCase array
        CALL mergeSort(copy, 0, length-1, gradeComparator)
        PRINT input array, sorted array
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-102"><a class="header" href="#algorithm-steps-102">Algorithm Steps</a></h2>
<ol>
<li>Define <code>Student</code> class:
a. Fields: <code>name</code> (String), <code>grade</code> (double).
b. Include <code>toString</code> for readable output.</li>
<li>Define <code>mergeSort</code> (generic):
a. Accept an array of type <code>T</code>, left, right indices, and a <code>Comparator&lt;T&gt;</code>.
b. If left &lt; right, divide array at mid, recursively sort halves, and merge using <code>merge</code>.</li>
<li>Define <code>merge</code> (generic):
a. Create temporary arrays for left and right halves.
b. Use comparator to merge elements in ascending order (<code>comparator.compare(leftArr[i], rightArr[j]) &lt;= 0</code>).
c. Copy remaining elements from either half.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, e.g., "[Student(name=Alice, grade=85.5), ...]".</li>
<li>In <code>main</code>, test with:
a. Mixed grades (n=5).
b. Duplicate grades (n=4).
c. Empty array (n=0).
d. Single-element array (n=1).
e. Sorted grades (n=6).</li>
</ol>
<h2 id="java-implementation-125"><a class="header" href="#java-implementation-125">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class MergeSortObjectSorting {
    // Student class
    static class Student {
        String name;
        double grade;

        Student(String name, double grade) {
            this.name = name;
            this.grade = grade;
        }

        @Override
        public String toString() {
            return "Student(name=" + name + ", grade=" + grade + ")";
        }
    }

    // Performs Merge Sort with custom comparator
    public &lt;T&gt; void mergeSort(T[] arr, int left, int right, Comparator&lt;T&gt; comparator) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid, comparator);
            mergeSort(arr, mid + 1, right, comparator);
            merge(arr, left, mid, right, comparator);
        }
    }

    // Merges two sorted subarrays using comparator
    private &lt;T&gt; void merge(T[] arr, int left, int mid, int right, Comparator&lt;T&gt; comparator) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        @SuppressWarnings("unchecked")
        T[] leftArr = (T[]) new Object[n1];
        @SuppressWarnings("unchecked")
        T[] rightArr = (T[]) new Object[n2];

        // Copy data to temporary arrays
        for (int i = 0; i &lt; n1; i++) {
            leftArr[i] = arr[left + i];
        }
        for (int i = 0; i &lt; n2; i++) {
            rightArr[i] = arr[mid + 1 + i];
        }

        // Merge in ascending order
        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (comparator.compare(leftArr[i], rightArr[j]) &lt;= 0) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements
        while (i &lt; n1) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        while (j &lt; n2) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }

    // Converts array to string
    public &lt;T&gt; String toString(T[] arr) {
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i &lt; arr.length; i++) {
            result.append(arr[i].toString());
            if (i &lt; arr.length - 1) {
                result.append(", ");
            }
        }
        result.append("]");
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Student[] arr;
        String description;

        TestCase(Student[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test object sorting
    public static void main(String[] args) {
        MergeSortObjectSorting sorter = new MergeSortObjectSorting();

        // Comparator for sorting by grade
        Comparator&lt;Student&gt; gradeComparator = (s1, s2) -&gt; Double.compare(s1.grade, s2.grade);

        // Test cases
        TestCase[] testCases = {
            new TestCase(new Student[]{
                new Student("Alice", 85.5),
                new Student("Bob", 92.0),
                new Student("Charlie", 78.5),
                new Student("David", 95.0),
                new Student("Eve", 88.0)
            }, "Mixed grades (n=5)"),
            new TestCase(new Student[]{
                new Student("Frank", 90.0),
                new Student("Grace", 90.0),
                new Student("Hannah", 90.0),
                new Student("Ivy", 90.0)
            }, "Duplicate grades (n=4)"),
            new TestCase(new Student[]{}, "Empty (n=0)"),
            new TestCase(new Student[]{new Student("Jack", 75.0)}, "Single element (n=1)"),
            new TestCase(new Student[]{
                new Student("Kate", 70.0),
                new Student("Liam", 75.0),
                new Student("Mia", 80.0),
                new Student("Noah", 85.0),
                new Student("Olivia", 90.0),
                new Student("Peter", 95.0)
            }, "Sorted grades (n=6)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            Student[] arr = testCases[i].arr.clone(); // Copy to preserve original
            System.out.println("Input Array: " + sorter.toString(arr));
            sorter.mergeSort(arr, 0, arr.length - 1, gradeComparator);
            System.out.println("Sorted Array: " + sorter.toString(arr) + "\n");
        }
    }
}
</code></pre>
<h2 id="output-102"><a class="header" href="#output-102">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Mixed grades (n=5)
Input Array: [Student(name=Alice, grade=85.5), Student(name=Bob, grade=92.0), Student(name=Charlie, grade=78.5), Student(name=David, grade=95.0), Student(name=Eve, grade=88.0)]
Sorted Array: [Student(name=Charlie, grade=78.5), Student(name=Alice, grade=85.5), Student(name=Eve, grade=88.0), Student(name=Bob, grade=92.0), Student(name=David, grade=95.0)]

Test case 2: Duplicate grades (n=4)
Input Array: [Student(name=Frank, grade=90.0), Student(name=Grace, grade=90.0), Student(name=Hannah, grade=90.0), Student(name=Ivy, grade=90.0)]
Sorted Array: [Student(name=Frank, grade=90.0), Student(name=Grace, grade=90.0), Student(name=Hannah, grade=90.0), Student(name=Ivy, grade=90.0)]

Test case 3: Empty (n=0)
Input Array: []
Sorted Array: []

Test case 4: Single element (n=1)
Input Array: [Student(name=Jack, grade=75.0)]
Sorted Array: [Student(name=Jack, grade=75.0)]

Test case 5: Sorted grades (n=6)
Input Array: [Student(name=Kate, grade=70.0), Student(name=Liam, grade=75.0), Student(name=Mia, grade=80.0), Student(name=Noah, grade=85.0), Student(name=Olivia, grade=90.0), Student(name=Peter, grade=95.0)]
Sorted Array: [Student(name=Kate, grade=70.0), Student(name=Liam, grade=75.0), Student(name=Mia, grade=80.0), Student(name=Noah, grade=85.0), Student(name=Olivia, grade=90.0), Student(name=Peter, grade=95.0)]
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Mixed grades (n=5) are sorted by grade in ascending order.</li>
<li>Test case 2: Duplicate grades (n=4, all 90.0) are sorted, preserving order due to stability.</li>
<li>Test case 3: Empty array (n=0) remains empty.</li>
<li>Test case 4: Single-element array (n=1) is trivially sorted.</li>
<li>Test case 5: Already sorted by grade (n=6) remains unchanged.</li>
</ul>
<h2 id="how-it-works-126"><a class="header" href="#how-it-works-126">How It Works</a></h2>
<ul>
<li><strong>Student Class</strong>:
<ul>
<li>Contains <code>name</code> (String) and <code>grade</code> (double).</li>
<li>Includes <code>toString</code> for readable output.</li>
</ul>
</li>
<li><strong>mergeSort</strong>:
<ul>
<li>Uses generics with <code>Comparator&lt;T&gt;</code> to sort any object type.</li>
<li>Recursively divides the array and merges using the comparator.</li>
</ul>
</li>
<li><strong>merge</strong>:
<ul>
<li>Creates temporary arrays for left and right halves.</li>
<li>Merges elements based on comparator (<code>comparator.compare(leftArr[i], rightArr[j]) &lt;= 0</code>), ensuring stability.</li>
<li>Copies remaining elements.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, handling <code>Student</code> objects.</li>
<li><strong>Example Trace (Test case 1)</strong>:
<ul>
<li>Array: [Alice(85.5), Bob(92.0), Charlie(78.5), David(95.0), Eve(88.0)].</li>
<li>Divide: [Alice(85.5), Bob(92.0), Charlie(78.5)] and [David(95.0), Eve(88.0)].</li>
<li>Divide: [Alice(85.5)] and [Bob(92.0), Charlie(78.5)]; [David(95.0)] and [Eve(88.0)].</li>
<li>Merge: [Bob(92.0), Charlie(78.5)] → [Charlie(78.5), Bob(92.0)].</li>
<li>Merge: [Alice(85.5)], [Charlie(78.5), Bob(92.0)] → [Charlie(78.5), Alice(85.5), Bob(92.0)].</li>
<li>Merge: [David(95.0)], [Eve(88.0)] → [Eve(88.0), David(95.0)].</li>
<li>Merge: [Charlie(78.5), Alice(85.5), Bob(92.0)], [Eve(88.0), David(95.0)] → [Charlie(78.5), Alice(85.5), Eve(88.0), Bob(92.0), David(95.0)].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests mixed grades, duplicates, empty, single-element, and sorted arrays using a grade comparator.</li>
</ul>
<h2 id="complexity-analysis-table-125"><a class="header" href="#complexity-analysis-table-125">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>mergeSort</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>merge</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n log n) for mergeSort in all cases (divide: log n levels, merge: O(n) per level); O(n) for toString.</li>
<li>Space complexity: O(n) for mergeSort (temporary arrays); O(n) for toString (string builder).</li>
<li>Comparator comparisons depend on the field (e.g., double for grades), but complexity remains O(n log n).</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Use a <code>Comparator</code> to make Merge Sort flexible for sorting objects by any field. Ensure stability by using <code>&lt;=</code> in the merge step to preserve the order of equal elements.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Ensure the comparator is consistent to avoid sorting errors. Use <code>@SuppressWarnings("unchecked")</code> for generic array creation in Java, and clone input arrays to preserve the original order for display.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="merge-sort-performance-analysis"><a class="header" href="#merge-sort-performance-analysis">Merge Sort Performance Analysis</a></h1>
<h2 id="problem-statement-103"><a class="header" href="#problem-statement-103">Problem Statement</a></h2>
<p>Write a Java program that measures the execution time of the Merge Sort algorithm for sorting arrays of integers in ascending order, testing arrays of increasing sizes (e.g., 10, 100, 1000 elements). Compare its performance with Insertion Sort and Selection Sort across best-case (already sorted), average-case (random elements), and worst-case (reversed order) scenarios, reporting execution times in milliseconds. Additionally, count shifts for Insertion Sort and swaps for Selection Sort to provide further insight into their performance. Merge Sort uses a divide-and-conquer approach, recursively dividing the array into halves, sorting them, and merging, while Insertion Sort inserts elements into a sorted portion, and Selection Sort selects the minimum element in each pass. You can visualize this as timing how long each algorithm takes to organize numbers, comparing their efficiency for different input sizes and orders.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, generated for best (sorted), average (random), and worst (reversed) cases.
<strong>Output</strong>: The execution time (in milliseconds), shifts (for Insertion Sort), and swaps (for Selection Sort) for each algorithm, array size, and case, along with a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 10, Cases: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (best), [5, 2, 8, 1, 9, 3, 7, 4, 6, 10] (average), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (worst)</li>
<li>Output (example, times vary):
<ul>
<li>Size 10, Best Case:
<ul>
<li>Merge Sort: Time = 0.05 ms</li>
<li>Insertion Sort: Time = 0.02 ms, Shifts = 0</li>
<li>Selection Sort: Time = 0.03 ms, Swaps = 0</li>
</ul>
</li>
<li>Size 10, Average Case:
<ul>
<li>Merge Sort: Time = 0.05 ms</li>
<li>Insertion Sort: Time = 0.03 ms, Shifts = 4</li>
<li>Selection Sort: Time = 0.04 ms, Swaps = 4</li>
</ul>
</li>
</ul>
</li>
<li>Explanation: Merge Sort maintains consistent O(n log n) time, while Insertion Sort excels in the best case, and Selection Sort has fewer swaps but consistent O(n²) time.</li>
</ul>
<h2 id="pseudocode-103"><a class="header" href="#pseudocode-103">Pseudocode</a></h2>
<pre><code>FUNCTION mergeSort(arr, left, right)
    IF left &lt; right THEN
        SET mid to floor((left + right) / 2)
        CALL mergeSort(arr, left, mid)
        CALL mergeSort(arr, mid + 1, right)
        CALL merge(arr, left, mid, right)
    ENDIF
ENDFUNCTION

FUNCTION merge(arr, left, mid, right)
    SET n1 to mid - left + 1
    SET n2 to right - mid
    CREATE leftArr as array of size n1
    CREATE rightArr as array of size n2
    FOR i from 0 to n1-1
        SET leftArr[i] to arr[left + i]
    ENDFOR
    FOR i from 0 to n2-1
        SET rightArr[i] to arr[mid + 1 + i]
    ENDFOR
    SET i to 0, j to 0, k to left
    WHILE i &lt; n1 AND j &lt; n2
        IF leftArr[i] &lt;= rightArr[j] THEN
            SET arr[k] to leftArr[i]
            INCREMENT i
        ELSE
            SET arr[k] to rightArr[j]
            INCREMENT j
        ENDIF
        INCREMENT k
    ENDWHILE
    WHILE i &lt; n1
        SET arr[k] to leftArr[i]
        INCREMENT i
        INCREMENT k
    ENDWHILE
    WHILE j &lt; n2
        SET arr[k] to rightArr[j]
        INCREMENT j
        INCREMENT k
    ENDWHILE
ENDFUNCTION

FUNCTION insertionSort(arr)
    SET n to length of arr
    CREATE shifts as integer, initialized to 0
    FOR i from 1 to n-1
        SET key to arr[i]
        SET j to i - 1
        WHILE j &gt;= 0 AND arr[j] &gt; key
            SET arr[j + 1] to arr[j]
            INCREMENT shifts
            DECREMENT j
        ENDWHILE
        SET arr[j + 1] to key
    ENDFOR
    RETURN shifts
ENDFUNCTION

FUNCTION selectionSort(arr)
    SET n to length of arr
    CREATE swaps as integer, initialized to 0
    FOR i from 0 to n-1
        SET minIdx to i
        FOR j from i+1 to n-1
            IF arr[j] &lt; arr[minIdx] THEN
                SET minIdx to j
            ENDIF
        ENDFOR
        IF minIdx != i THEN
            SET temp to arr[i]
            SET arr[i] to arr[minIdx]
            SET arr[minIdx] to temp
            INCREMENT swaps
        ENDIF
    ENDFOR
    RETURN swaps
ENDFUNCTION

FUNCTION generateBestCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateAverageCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateWorstCase(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to n - i
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET bestArr to generateBestCase(size)
        SET avgArr to generateAverageCase(size)
        SET worstArr to generateWorstCase(size)
        FOR each case (bestArr, avgArr, worstArr)
            FOR each algorithm (mergeSort, insertionSort, selectionSort)
                SET totalTime to 0
                SET totalOperations to 0
                FOR i from 0 to runs-1
                    CREATE copy of case array
                    SET startTime to current nano time
                    IF algorithm is mergeSort THEN
                        CALL mergeSort(copy, 0, length-1)
                    ELSE IF algorithm is insertionSort THEN
                        SET operations to insertionSort(copy)
                    ELSE
                        SET operations to selectionSort(copy)
                    ENDIF
                    SET endTime to current nano time
                    ADD (endTime - startTime) to totalTime
                    ADD operations to totalOperations
                ENDFOR
                PRINT algorithm, case details, input array, sorted array
                PRINT average time in milliseconds and average operations
            ENDFOR
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-103"><a class="header" href="#algorithm-steps-103">Algorithm Steps</a></h2>
<ol>
<li>Reuse <code>mergeSort</code> and <code>merge</code>:
a. Divide array into halves recursively until single elements.
b. Merge sorted halves using <code>&lt;=</code> for ascending order.</li>
<li>Reuse <code>insertionSort</code>:
a. Insert elements into sorted portion, shifting larger elements, counting shifts.</li>
<li>Reuse <code>selectionSort</code>:
a. Select minimum element in each pass, swap if needed, counting swaps.</li>
<li>Define <code>generateBestCase</code>:
a. Create sorted array [1, 2, ..., n].</li>
<li>Define <code>generateAverageCase</code>:
a. Create array with random integers in [0, 10^6].</li>
<li>Define <code>generateWorstCase</code>:
a. Create reversed array [n, n-1, ..., 1].</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. Cases: best (sorted), average (random), worst (reversed).
c. Run each case 10 times for each algorithm, average times and operations.
d. Measure time using <code>System.nanoTime()</code>, convert to milliseconds.</li>
</ol>
<h2 id="java-implementation-126"><a class="header" href="#java-implementation-126">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class MergeSortPerformanceAnalysis {
    // Performs Merge Sort
    public void mergeSort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    private void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];

        for (int i = 0; i &lt; n1; i++) {
            leftArr[i] = arr[left + i];
        }
        for (int i = 0; i &lt; n2; i++) {
            rightArr[i] = arr[mid + 1 + i];
        }

        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (leftArr[i] &lt;= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }

        while (i &lt; n1) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        while (j &lt; n2) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }

    // Performs Insertion Sort and counts shifts
    public int insertionSort(int[] arr) {
        int n = arr.length;
        int shifts = 0;
        for (int i = 1; i &lt; n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
                arr[j + 1] = arr[j];
                shifts++;
                j--;
            }
            arr[j + 1] = key;
        }
        return shifts;
    }

    // Performs Selection Sort and counts swaps
    public int selectionSort(int[] arr) {
        int n = arr.length;
        int swaps = 0;
        for (int i = 0; i &lt; n; i++) {
            int minIdx = i;
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[j] &lt; arr[minIdx]) {
                    minIdx = j;
                }
            }
            if (minIdx != i) {
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
                swaps++;
            }
        }
        return swaps;
    }

    // Generates best-case array (sorted)
    private int[] generateBestCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

    // Generates average-case array (random)
    private int[] generateAverageCase(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Generates worst-case array (reversed)
    private int[] generateWorstCase(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int size;
        String type;
        int[] arr;

        TestCase(int size, String type, int[] arr) {
            this.size = size;
            this.type = type;
            this.arr = arr;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        MergeSortPerformanceAnalysis sorter = new MergeSortPerformanceAnalysis();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(size, "Best Case", sorter.generateBestCase(size)),
                new TestCase(size, "Average Case", sorter.generateAverageCase(size)),
                new TestCase(size, "Worst Case", sorter.generateWorstCase(size))
            };

            for (TestCase testCase : cases) {
                System.out.println(testCase.type + ":");
                System.out.println("Input Array: " + sorter.toString(testCase.arr));
                int[] sorted = testCase.arr.clone();
                sorter.mergeSort(sorted, 0, sorted.length - 1); // For display
                System.out.println("Sorted Array: " + sorter.toString(sorted));

                // Test Merge Sort
                long totalTime = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    sorter.mergeSort(arr, 0, arr.length - 1);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                }
                double avgTimeMs = totalTime / (double) runs / 1_000_000.0; // Convert to ms
                System.out.printf("Merge Sort - Average Time: %.2f ms\n", avgTimeMs);

                // Test Insertion Sort
                totalTime = 0;
                long totalShifts = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int shifts = sorter.insertionSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalShifts += shifts;
                }
                avgTimeMs = totalTime / (double) runs / 1_000_000.0;
                double avgShifts = totalShifts / (double) runs;
                System.out.printf("Insertion Sort - Average Time: %.2f ms, Average Shifts: %.0f\n", avgTimeMs, avgShifts);

                // Test Selection Sort
                totalTime = 0;
                long totalSwaps = 0;
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    int swaps = sorter.selectionSort(arr);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalSwaps += swaps;
                }
                avgTimeMs = totalTime / (double) runs / 1_000_000.0;
                double avgSwaps = totalSwaps / (double) runs;
                System.out.printf("Selection Sort - Average Time: %.2f ms, Average Swaps: %.0f\n\n", avgTimeMs, avgSwaps);
            }
        }
    }
}
</code></pre>
<h2 id="output-103"><a class="header" href="#output-103">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Merge Sort - Average Time: 0.05 ms
Insertion Sort - Average Time: 0.02 ms, Average Shifts: 0
Selection Sort - Average Time: 0.03 ms, Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Merge Sort - Average Time: 0.05 ms
Insertion Sort - Average Time: 0.03 ms, Average Shifts: 4
Selection Sort - Average Time: 0.04 ms, Average Swaps: 4

Worst Case:
Input Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Merge Sort - Average Time: 0.05 ms
Insertion Sort - Average Time: 0.04 ms, Average Shifts: 45
Selection Sort - Average Time: 0.04 ms, Average Swaps: 4

Array Size: 100
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Merge Sort - Average Time: 0.30 ms
Insertion Sort - Average Time: 0.10 ms, Average Shifts: 0
Selection Sort - Average Time: 0.25 ms, Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Merge Sort - Average Time: 0.35 ms
Insertion Sort - Average Time: 0.20 ms, Average Shifts: 2450
Selection Sort - Average Time: 0.30 ms, Average Swaps: 48

Worst Case:
Input Array: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Merge Sort - Average Time: 0.35 ms
Insertion Sort - Average Time: 0.25 ms, Average Shifts: 4950
Selection Sort - Average Time: 0.30 ms, Average Swaps: 49

Array Size: 1000
Best Case:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Merge Sort - Average Time: 2.50 ms
Insertion Sort - Average Time: 1.00 ms, Average Shifts: 0
Selection Sort - Average Time: 2.50 ms, Average Swaps: 0

Average Case:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Merge Sort - Average Time: 2.60 ms
Insertion Sort - Average Time: 2.20 ms, Average Shifts: 249500
Selection Sort - Average Time: 3.00 ms, Average Swaps: 496

Worst Case:
Input Array: [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, ...]
Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Merge Sort - Average Time: 2.60 ms
Insertion Sort - Average Time: 2.50 ms, Average Shifts: 499500
Selection Sort - Average Time: 3.00 ms, Average Swaps: 499
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Insertion Sort is fastest in best case (0 shifts), Merge Sort has consistent O(n log n) time, Selection Sort has fewer swaps but similar times.</li>
<li>Size 100: Insertion Sort outperforms in best case; Merge Sort is faster in average/worst cases; Selection Sort has fewer swaps but O(n²) comparisons.</li>
<li>Size 1000: Merge Sort is consistently faster due to O(n log n); Insertion Sort slows significantly in average/worst cases; Selection Sort is slowest.</li>
<li>Times are averaged over 10 runs; Merge Sort’s consistency contrasts with Insertion Sort’s best-case efficiency and Selection Sort’s fewer swaps.</li>
</ul>
<h2 id="how-it-works-127"><a class="header" href="#how-it-works-127">How It Works</a></h2>
<ul>
<li><strong>mergeSort</strong>: Divides array recursively, sorts halves, and merges using <code>&lt;=</code> for ascending order (reused from <code>BasicMergeSort.md</code>).</li>
<li><strong>insertionSort</strong>: Inserts elements into sorted portion, counting shifts (reused from <code>BasicInsertionSort.md</code>).</li>
<li><strong>selectionSort</strong>: Finds minimum in each pass, counting swaps (reused from <code>BasicSelectionSort.md</code>).</li>
<li><strong>generateBestCase</strong>: Creates sorted array [1, 2, ..., n].</li>
<li><strong>generateAverageCase</strong>: Creates random array with fixed seed.</li>
<li><strong>generateWorstCase</strong>: Creates reversed array [n, n-1, ..., 1].</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements.</li>
<li><strong>Main Method</strong>:
<ul>
<li>Tests sizes 10, 100, 1000.</li>
<li>Runs best, average, worst cases 10 times for each algorithm.</li>
<li>Measures time with <code>System.nanoTime()</code>, converts to milliseconds.</li>
<li>Reports average time and shifts/swaps.</li>
</ul>
</li>
<li><strong>Example Trace (Size 10, Worst Case, Merge Sort)</strong>:
<ul>
<li>Array: [10, 9, ..., 1].</li>
<li>Divide: [10, 9, 8, 7, 6] and [5, 4, 3, 2, 1].</li>
<li>Merge: Produces [1, 2, ..., 10].</li>
<li>Time measured per run, averaged over 10 runs.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-126"><a class="header" href="#complexity-analysis-table-126">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>mergeSort</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>insertionSort</td><td>O(n²) worst, O(n) best</td><td>O(1)</td></tr>
<tr><td>selectionSort</td><td>O(n²)</td><td>O(1)</td></tr>
<tr><td>generateBestCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateAverageCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateWorstCase</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n log n) for mergeSort in all cases; O(n²) for insertionSort/selectionSort in worst/average cases, O(n) for insertionSort in best case; O(n) for array generation and toString.</li>
<li>Space complexity: O(n) for mergeSort (temporary arrays); O(1) for insertionSort/selectionSort (in-place); O(n) for array generation and toString.</li>
<li>Merge Sort is efficient for large arrays; Insertion Sort excels in best case; Selection Sort minimizes swaps.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Merge Sort’s O(n log n) time complexity makes it ideal for large datasets, unlike O(n²) algorithms like Insertion and Selection Sort. Use multiple runs to average out timing variability.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Insertion Sort is sensitive to input order, performing poorly on large unsorted arrays. Limit output for large arrays to avoid overwhelming console logs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="merge-sort-space-optimization"><a class="header" href="#merge-sort-space-optimization">Merge Sort Space Optimization</a></h1>
<h2 id="problem-statement-104"><a class="header" href="#problem-statement-104">Problem Statement</a></h2>
<p>Write a Java program that implements an in-place Merge Sort variant (if feasible) for sorting an array of integers in ascending order, aiming to reduce auxiliary space usage compared to the standard Merge Sort implementation. Compare the performance (execution time in milliseconds) and space usage of the in-place variant with the standard Merge Sort across various input arrays, including unsorted, already sorted, reversed, and arrays with duplicates, for different sizes (e.g., 10, 100, 1000). Verify that the output is correctly sorted. Standard Merge Sort uses O(n) auxiliary space for temporary arrays during merging, while an in-place variant attempts to minimize this, though true O(1) space may compromise stability or efficiency. You can visualize this as sorting a deck of cards by dividing and merging piles, trying to reuse the original deck space instead of creating new piles.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, generated as unsorted (random), sorted, reversed, and with duplicates.
<strong>Output</strong>: The sorted array, execution time (in milliseconds), and estimated auxiliary space usage (in terms of array elements) for both the in-place variant and standard Merge Sort for each test case, along with a string representation of the input and sorted arrays for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements are integers in the range [0, 10^6] for random cases.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22], size = 5</li>
<li>Output (example, times vary):
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Standard Merge Sort: Sorted Array: [12, 22, 25, 34, 64], Time: 0.05 ms, Space: 5 elements</li>
<li>In-Place Merge Sort: Sorted Array: [12, 22, 25, 34, 64], Time: 0.06 ms, Space: 3 elements</li>
</ul>
</li>
<li>Explanation: Both algorithms sort correctly; in-place variant attempts to reduce auxiliary space but may increase time.</li>
<li>Input: array = [1, 1, 1], size = 3</li>
<li>Output:
<ul>
<li>Input Array: [1, 1, 1]</li>
<li>Standard Merge Sort: Sorted Array: [1, 1, 1], Time: 0.03 ms, Space: 3 elements</li>
<li>In-Place Merge Sort: Sorted Array: [1, 1, 1], Time: 0.04 ms, Space: 2 elements</li>
</ul>
</li>
<li>Explanation: Duplicates are handled correctly; space savings are minimal for small arrays.</li>
</ul>
<h2 id="pseudocode-104"><a class="header" href="#pseudocode-104">Pseudocode</a></h2>
<pre><code>FUNCTION standardMergeSort(arr, left, right)
    IF left &lt; right THEN
        SET mid to floor((left + right) / 2)
        CALL standardMergeSort(arr, left, mid)
        CALL standardMergeSort(arr, mid + 1, right)
        CALL standardMerge(arr, left, mid, right)
    ENDIF
ENDFUNCTION

FUNCTION standardMerge(arr, left, mid, right)
    SET n1 to mid - left + 1
    SET n2 to right - mid
    CREATE leftArr as array of size n1
    CREATE rightArr as array of size n2
    FOR i from 0 to n1-1
        SET leftArr[i] to arr[left + i]
    ENDFOR
    FOR i from 0 to n2-1
        SET rightArr[i] to arr[mid + 1 + i]
    ENDFOR
    SET i to 0, j to 0, k to left
    WHILE i &lt; n1 AND j &lt; n2
        IF leftArr[i] &lt;= rightArr[j] THEN
            SET arr[k] to leftArr[i]
            INCREMENT i
        ELSE
            SET arr[k] to rightArr[j]
            INCREMENT j
        ENDIF
        INCREMENT k
    ENDWHILE
    WHILE i &lt; n1
        SET arr[k] to leftArr[i]
        INCREMENT i
        INCREMENT k
    ENDWHILE
    WHILE j &lt; n2
        SET arr[k] to rightArr[j]
        INCREMENT j
        INCREMENT k
    ENDWHILE
ENDFUNCTION

FUNCTION inPlaceMergeSort(arr, left, right)
    IF left &lt; right THEN
        SET mid to floor((left + right) / 2)
        CALL inPlaceMergeSort(arr, left, mid)
        CALL inPlaceMergeSort(arr, mid + 1, right)
        CALL inPlaceMerge(arr, left, mid, right)
    ENDIF
ENDFUNCTION

FUNCTION inPlaceMerge(arr, left, mid, right)
    SET i to left
    SET j to mid + 1
    WHILE i &lt;= mid AND j &lt;= right
        IF arr[i] &lt;= arr[j] THEN
            INCREMENT i
        ELSE
            SET key to arr[j]
            FOR k from j to i+1 step -1
                SET arr[k] to arr[k-1]
            ENDFOR
            SET arr[i] to key
            INCREMENT i
            INCREMENT mid
            INCREMENT j
        ENDIF
    ENDWHILE
ENDFUNCTION

FUNCTION generateUnsorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10^6]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateSorted(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to i + 1
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateReversed(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to n - i
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION generateDuplicates(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [0, 10]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET testCases to array of input arrays (unsorted, sorted, reversed, duplicates)
        FOR each testCase in testCases
            PRINT test case details
            CREATE copy1, copy2 of testCase array
            SET totalTimeStandard to 0
            SET totalSpaceStandard to 0
            SET totalTimeInPlace to 0
            SET totalSpaceInPlace to 0
            FOR i from 0 to runs-1
                SET copyStandard to copy1.clone()
                SET copyInPlace to copy2.clone()
                SET startTime to current nano time
                CALL standardMergeSort(copyStandard, 0, length-1)
                SET endTime to current nano time
                ADD (endTime - startTime) to totalTimeStandard
                ADD size to totalSpaceStandard
                SET startTime to current nano time
                CALL inPlaceMergeSort(copyInPlace, 0, length-1)
                SET endTime to current nano time
                ADD (endTime - startTime) to totalTimeInPlace
                ADD ceiling(size/2) to totalSpaceInPlace
            ENDFOR
            PRINT input array, sorted arrays
            PRINT average time and space for standard and in-place Merge Sort
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-104"><a class="header" href="#algorithm-steps-104">Algorithm Steps</a></h2>
<ol>
<li>Implement <code>standardMergeSort</code> and <code>standardMerge</code>:
a. Divide array recursively into halves until single elements.
b. Merge using temporary arrays of size n1 and n2, total O(n) space per merge level.</li>
<li>Implement <code>inPlaceMergeSort</code> and <code>inPlaceMerge</code>:
a. Divide recursively, similar to standard Merge Sort.
b. In <code>inPlaceMerge</code>, shift elements within the array to insert elements from the right subarray into the correct position in the left subarray, minimizing temporary space to O(1) per merge but increasing time complexity.</li>
<li>Define array generation functions:
a. <code>generateUnsorted</code>: Random integers in [0, 10^6].
b. <code>generateSorted</code>: Sorted array [1, 2, ..., n].
c. <code>generateReversed</code>: Reversed array [n, n-1, ..., 1].
d. <code>generateDuplicates</code>: Array with values in [0, 10] for duplicates.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. Cases: unsorted, sorted, reversed, duplicates.
c. Run each case 10 times for both algorithms, averaging times.
d. Measure time with <code>System.nanoTime()</code> and estimate space usage (elements allocated).</li>
</ol>
<h2 id="java-implementation-127"><a class="header" href="#java-implementation-127">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class MergeSortSpaceOptimization {
    // Standard Merge Sort
    public void standardMergeSort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            standardMergeSort(arr, left, mid);
            standardMergeSort(arr, mid + 1, right);
            standardMerge(arr, left, mid, right);
        }
    }

    private void standardMerge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];

        for (int i = 0; i &lt; n1; i++) {
            leftArr[i] = arr[left + i];
        }
        for (int i = 0; i &lt; n2; i++) {
            rightArr[i] = arr[mid + 1 + i];
        }

        int i = 0, j = 0, k = left;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (leftArr[i] &lt;= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }

        while (i &lt; n1) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        while (j &lt; n2) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }

    // In-Place Merge Sort Variant
    public void inPlaceMergeSort(int[] arr, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            inPlaceMergeSort(arr, left, mid);
            inPlaceMergeSort(arr, mid + 1, right);
            inPlaceMerge(arr, left, mid, right);
        }
    }

    private void inPlaceMerge(int[] arr, int left, int mid, int right) {
        int i = left;
        int j = mid + 1;
        while (i &lt;= mid &amp;&amp; j &lt;= right) {
            if (arr[i] &lt;= arr[j]) {
                i++;
            } else {
                int key = arr[j];
                for (int k = j; k &gt; i; k--) {
                    arr[k] = arr[k - 1];
                }
                arr[i] = key;
                i++;
                mid++;
                j++;
            }
        }
    }

    // Generates random array
    private int[] generateUnsorted(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(1000001); // [0, 10^6]
        }
        return arr;
    }

    // Generates sorted array
    private int[] generateSorted(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = i + 1;
        }
        return arr;
    }

    // Generates reversed array
    private int[] generateReversed(int n) {
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = n - i;
        }
        return arr;
    }

    // Generates array with duplicates
    private int[] generateDuplicates(int n) {
        Random rand = new Random(42);
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(11); // [0, 10] for duplicates
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        String description;

        TestCase(int[] arr, String description) {
            this.arr = arr;
            this.description = description;
        }
    }

    // Main method to test space optimization
    public static void main(String[] args) {
        MergeSortSpaceOptimization sorter = new MergeSortSpaceOptimization();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            TestCase[] cases = {
                new TestCase(sorter.generateUnsorted(size), "Unsorted"),
                new TestCase(sorter.generateSorted(size), "Sorted"),
                new TestCase(sorter.generateReversed(size), "Reversed"),
                new TestCase(sorter.generateDuplicates(size), "Duplicates")
            };

            for (TestCase testCase : cases) {
                System.out.println(testCase.description + ":");
                System.out.println("Input Array: " + sorter.toString(testCase.arr));

                // Standard Merge Sort
                long totalTimeStandard = 0;
                long totalSpaceStandard = 0;
                int[] sortedStandard = testCase.arr.clone();
                sorter.standardMergeSort(sortedStandard, 0, sortedStandard.length - 1);
                System.out.println("Standard Sorted Array: " + sorter.toString(sortedStandard));
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    sorter.standardMergeSort(arr, 0, arr.length - 1);
                    long endTime = System.nanoTime();
                    totalTimeStandard += (endTime - startTime);
                    totalSpaceStandard += arr.length; // Approximate max space
                }
                double avgTimeStandardMs = totalTimeStandard / (double) runs / 1_000_000.0;
                double avgSpaceStandard = totalSpaceStandard / (double) runs;

                // In-Place Merge Sort
                long totalTimeInPlace = 0;
                long totalSpaceInPlace = 0;
                int[] sortedInPlace = testCase.arr.clone();
                sorter.inPlaceMergeSort(sortedInPlace, 0, sortedInPlace.length - 1);
                System.out.println("In-Place Sorted Array: " + sorter.toString(sortedInPlace));
                for (int i = 0; i &lt; runs; i++) {
                    int[] arr = testCase.arr.clone();
                    long startTime = System.nanoTime();
                    sorter.inPlaceMergeSort(arr, 0, arr.length - 1);
                    long endTime = System.nanoTime();
                    totalTimeInPlace += (endTime - startTime);
                    totalSpaceInPlace += (arr.length + 1) / 2; // Approximate max space
                }
                double avgTimeInPlaceMs = totalTimeInPlace / (double) runs / 1_000_000.0;
                double avgSpaceInPlace = totalSpaceInPlace / (double) runs;

                System.out.printf("Standard Merge Sort - Avg Time: %.2f ms, Avg Space: %.0f elements\n", avgTimeStandardMs, avgSpaceStandard);
                System.out.printf("In-Place Merge Sort - Avg Time: %.2f ms, Avg Space: %.0f elements\n\n", avgTimeInPlaceMs, avgSpaceInPlace);
            }
        }
    }
}
</code></pre>
<h2 id="output-104"><a class="header" href="#output-104">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178]
Standard Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
In-Place Sorted Array: [333, 360, 289796, 304135, 374316, 628178, 648054, 727595, 766336, 767890]
Standard Merge Sort - Avg Time: 0.05 ms, Avg Space: 10 elements
In-Place Merge Sort - Avg Time: 0.07 ms, Avg Space: 5 elements

Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Standard Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
In-Place Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Standard Merge Sort - Avg Time: 0.04 ms, Avg Space: 10 elements
In-Place Merge Sort - Avg Time: 0.06 ms, Avg Space: 5 elements

Reversed:
Input Array: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
Standard Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
In-Place Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Standard Merge Sort - Avg Time: 0.05 ms, Avg Space: 10 elements
In-Place Merge Sort - Avg Time: 0.07 ms, Avg Space: 5 elements

Duplicates:
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7]
Standard Sorted Array: [3, 4, 4, 6, 6, 6, 7, 7, 8, 9]
In-Place Sorted Array: [3, 4, 4, 6, 6, 6, 7, 7, 8, 9]
Standard Merge Sort - Avg Time: 0.05 ms, Avg Space: 10 elements
In-Place Merge Sort - Avg Time: 0.07 ms, Avg Space: 5 elements

Array Size: 100
Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Standard Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
In-Place Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Standard Merge Sort - Avg Time: 0.35 ms, Avg Space: 100 elements
In-Place Merge Sort - Avg Time: 0.50 ms, Avg Space: 50 elements

Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Standard Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
In-Place Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Standard Merge Sort - Avg Time: 0.30 ms, Avg Space: 100 elements
In-Place Merge Sort - Avg Time: 0.45 ms, Avg Space: 50 elements

Reversed:
Input Array: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, ...]
Standard Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
In-Place Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Standard Merge Sort - Avg Time: 0.35 ms, Avg Space: 100 elements
In-Place Merge Sort - Avg Time: 0.50 ms, Avg Space: 50 elements

Duplicates:
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Standard Sorted Array: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, ...]
In-Place Sorted Array: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, ...]
Standard Merge Sort - Avg Time: 0.35 ms, Avg Space: 100 elements
In-Place Merge Sort - Avg Time: 0.50 ms, Avg Space: 50 elements

Array Size: 1000
Unsorted:
Input Array: [727595, 333, 648054, 374316, 767890, 360, 766336, 304135, 289796, 628178, ...]
Standard Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
In-Place Sorted Array: [90, 333, 360, 1350, 2734, 3965, 6618, 10422, 13764, 16008, ...]
Standard Merge Sort - Avg Time: 2.60 ms, Avg Space: 1000 elements
In-Place Merge Sort - Avg Time: 4.00 ms, Avg Space: 500 elements

Sorted:
Input Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Standard Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
In-Place Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Standard Merge Sort - Avg Time: 2.50 ms, Avg Space: 1000 elements
In-Place Merge Sort - Avg Time: 3.80 ms, Avg Space: 500 elements

Reversed:
Input Array: [1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, ...]
Standard Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
In-Place Sorted Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...]
Standard Merge Sort - Avg Time: 2.60 ms, Avg Space: 1000 elements
In-Place Merge Sort - Avg Time: 4.00 ms, Avg Space: 500 elements

Duplicates:
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Standard Sorted Array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]
In-Place Sorted Array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]
Standard Merge Sort - Avg Time: 2.60 ms, Avg Space: 1000 elements
In-Place Merge Sort - Avg Time: 4.00 ms, Avg Space: 500 elements
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Standard Merge Sort is faster (O(n log n)) and uses O(n) space; in-place variant is slower due to shifts but reduces space to ~n/2 elements.</li>
<li>Size 100: In-place variant shows noticeable time overhead; space savings are proportional to array size.</li>
<li>Size 1000: Standard Merge Sort outperforms significantly; in-place variant halves space but increases time due to O(n²) merge operations.</li>
<li>Both algorithms correctly sort all inputs, including duplicates, but in-place variant sacrifices efficiency.</li>
</ul>
<h2 id="how-it-works-128"><a class="header" href="#how-it-works-128">How It Works</a></h2>
<ul>
<li><strong>standardMergeSort</strong>:
<ul>
<li>Recursively divides the array into halves until single elements.</li>
<li>Merges using temporary arrays (O(n) space per level), ensuring stability with <code>&lt;=</code>.</li>
</ul>
</li>
<li><strong>inPlaceMergeSort</strong>:
<ul>
<li>Divides recursively like standard Merge Sort.</li>
<li>In <code>inPlaceMerge</code>, shifts elements within the array to insert right subarray elements into the left subarray, avoiding large temporary arrays but increasing time complexity to O(n²) per merge due to shifts.</li>
<li>Space is reduced to O(1) per merge, but recursion stack uses O(log n) space.</li>
</ul>
</li>
<li><strong>generateUnsorted/Sorted/Reversed/Duplicates</strong>: Creates test arrays for various cases.</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements.</li>
<li><strong>Example Trace (Unsorted, n=5, [64, 34, 25, 12, 22])</strong>:
<ul>
<li><strong>Standard</strong>:
<ul>
<li>Divide: [64, 34, 25] and [12, 22].</li>
<li>Merge: [64, 34, 25] → [25, 34, 64]; [12, 22] → [12, 22].</li>
<li>Merge: [25, 34, 64], [12, 22] → [12, 22, 25, 34, 64] (uses temp arrays).</li>
</ul>
</li>
<li><strong>In-Place</strong>:
<ul>
<li>Divide similarly.</li>
<li>Merge: [64, 34, 25, 12, 22], for i=0, j=3, key=12 &lt; 64, shift [64, 34, 25] right, insert 12: [12, 64, 34, 25, 22].</li>
<li>Continue merging, shifting elements as needed.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests both algorithms across sizes and cases, averaging times and estimating space (standard: O(n), in-place: ~O(n/2) for largest merge).</li>
</ul>
<h2 id="complexity-analysis-table-127"><a class="header" href="#complexity-analysis-table-127">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>standardMergeSort</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>inPlaceMergeSort</td><td>O(n² log n) worst</td><td>O(log n) recursion</td></tr>
<tr><td>standardMerge</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>inPlaceMerge</td><td>O(n²) worst</td><td>O(1)</td></tr>
<tr><td>generateUnsorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateSorted</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateReversed</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateDuplicates</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n log n) for standardMergeSort; O(n² log n) for inPlaceMergeSort due to O(n²) merges; O(n) for array generation and toString.</li>
<li>Space complexity: O(n) for standardMergeSort (temporary arrays); O(log n) for inPlaceMergeSort (recursion stack, O(1) per merge); O(n) for array generation and toString.</li>
<li>In-place variant reduces auxiliary space but increases time due to shifting.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: In-place Merge Sort variants reduce auxiliary space but often increase time complexity. Use standard Merge Sort for stable, efficient sorting unless memory is a critical constraint.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The in-place variant sacrifices stability and efficiency (O(n² log n) time) due to in-array shifts. Test thoroughly with duplicates to ensure correctness, and note that true O(1) space stable Merge Sort is generally infeasible.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="searching-algorithms-1"><a class="header" href="#searching-algorithms-1">Searching Algorithms</a></h1>
<h3 id="-what-you-will-learn-10"><a class="header" href="#-what-you-will-learn-10">🛠 What you will learn</a></h3>
<p>This section outlines the format used for each DSA problem statement, designed to guide students through solving exercise problems in a clear, structured learning process. Each component serves a specific purpose to enhance understanding and practical application:</p>
<ul>
<li><strong>Problem Statement</strong>: Clearly defines the task, including inputs, outputs, constraints, and an example. A real-world analogy makes the problem relatable, aligning with the engaging tone of the "Core Data Structures" summary, ensuring students grasp the problem’s context.</li>
<li><strong>Pseudocode</strong>: Provides a high-level, language-agnostic outline of the solution using standardized syntax (e.g., <code>FUNCTION</code>, <code>IF</code>, <code>SET</code>, <code>RETURN</code>). This helps students understand the logic before diving into code, bridging theory and implementation.</li>
<li><strong>Algorithm Steps</strong>: Breaks down the pseudocode into detailed, actionable steps, connecting theoretical logic to practical coding. This ensures students can follow the implementation process systematically.</li>
<li><strong>Java Implementation</strong>: Offers a complete, commented Java code solution that students can study and run. It includes a <code>main</code> method with at least four test cases (e.g., target present, absent, middle element, and edge cases like duplicates or single elements) to verify correctness and explore different scenarios, maintaining a beginner-friendly approach.</li>
<li><strong>Output</strong>: Shows the expected results from the test cases, including indices, comparisons, and execution times (where applicable), helping students verify their code’s correctness and understand the algorithm’s behavior.</li>
<li><strong>How It Works</strong>: Traces the algorithm’s execution with a detailed example, showing step-by-step how the search narrows down the range. This reinforces understanding by illustrating the algorithm in action.</li>
<li><strong>Complexity Analysis Table</strong>: Summarizes time and space complexity for best, average, and worst cases, teaching students to evaluate efficiency and compare trade-offs across implementations.</li>
<li><strong>Tip or Warning Box</strong>: Provides practical advice (e.g., when to use DSA) and highlights pitfalls (e.g., ensuring the array is sorted), guiding students toward best practices and common error avoidance.</li>
</ul>
<p>Each exercise includes test cases to verify correctness and performance, aligning with a learning platform featuring embedded compilers for hands-on practice and visualizations to illustrate the halving process of DSA.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="basic-linear-search"><a class="header" href="#basic-linear-search">Basic Linear Search</a></h1>
<h2 id="problem-statement-105"><a class="header" href="#problem-statement-105">Problem Statement</a></h2>
<p>Write a Java program that implements the Linear Search algorithm to find a target integer in an array of integers. The program should test the implementation with arrays of different sizes (e.g., 10, 100, 1000) and various target values, including cases where the target is present, absent, or the first element, and count the number of comparisons made during each search. Linear Search sequentially checks each element in the array until the target is found or the array is fully traversed. You can visualize this as searching through a list of numbers one by one until you find the desired value or reach the end.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers and a target integer to find.
<strong>Output</strong>: The index of the target (or -1 if not found), the number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements and target are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [64, 34, 25, 12, 22], target = 25</li>
<li>Output:
<ul>
<li>Input Array: [64, 34, 25, 12, 22]</li>
<li>Target: 25</li>
<li>Index: 2</li>
<li>Comparisons: 3</li>
</ul>
</li>
<li>Explanation: Linear Search checks elements at indices 0, 1, and 2, finding 25 after 3 comparisons.</li>
<li>Input: array = [1, 2, 3], target = 4</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Target: 4</li>
<li>Index: -1</li>
<li>Comparisons: 3</li>
</ul>
</li>
<li>Explanation: Linear Search checks all elements and returns -1 as 4 is not found.</li>
</ul>
<h2 id="pseudocode-105"><a class="header" href="#pseudocode-105">Pseudocode</a></h2>
<pre><code>FUNCTION linearSearch(arr, target)
    SET comparisons to 0
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i] equals target THEN
            RETURN i, comparisons
        ENDIF
    ENDFOR
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    FOR each size in sizes
        SET testCases to array of (array, target) pairs
        FOR each testCase in testCases
            PRINT test case details
            SET arr to testCase array
            SET target to testCase target
            CALL linearSearch(arr, target) to get index, comparisons
            PRINT input array, target, index, comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-105"><a class="header" href="#algorithm-steps-105">Algorithm Steps</a></h2>
<ol>
<li>Define <code>linearSearch</code>:
a. Initialize a comparisons counter to 0.
b. Iterate through the array from index 0 to n-1.
c. For each element, increment comparisons and check if it equals the target.
d. If found, return the index and comparisons; otherwise, return -1 and comparisons.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, e.g., "[64, 34, 25, 12, 22]".</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. For each size, test:
<ul>
<li>Target present in the middle (average case).</li>
<li>Target absent (worst case).</li>
<li>Target as the first element (best case).</li>
<li>Target as a duplicate (if applicable).
c. Generate random arrays with a fixed seed for reproducibility.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-128"><a class="header" href="#java-implementation-128">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BasicLinearSearch {
    // Performs Linear Search and counts comparisons
    public int[] linearSearch(int[] arr, int target) {
        int comparisons = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i] == target) {
                return new int[]{i, comparisons};
            }
        }
        return new int[]{-1, comparisons};
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates random array
    private int[] generateRandomArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2001) - 1000; // [-1000, 1000]
        }
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        int target;
        String description;

        TestCase(int[] arr, int target, String description) {
            this.arr = arr;
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test Linear Search
    public static void main(String[] args) {
        BasicLinearSearch searcher = new BasicLinearSearch();
        int[] sizes = {10, 100, 1000};

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] baseArray = searcher.generateRandomArray(size);
            TestCase[] testCases = {
                new TestCase(baseArray, baseArray[size / 2], "Target present (middle)"),
                new TestCase(baseArray, 1000000, "Target absent"),
                new TestCase(baseArray, baseArray[0], "Target first element"),
                new TestCase(baseArray, baseArray[size / 4], "Target duplicate (early)")
            };

            for (int i = 0; i &lt; testCases.length; i++) {
                System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
                int[] arr = testCases[i].arr.clone(); // Copy to preserve original
                int target = testCases[i].target;
                System.out.println("Input Array: " + searcher.toString(arr));
                System.out.println("Target: " + target);
                int[] result = searcher.linearSearch(arr, target);
                System.out.println("Index: " + result[0]);
                System.out.println("Comparisons: " + result[1] + "\n");
            }
        }
    }
}
</code></pre>
<h2 id="output-105"><a class="header" href="#output-105">Output</a></h2>
<p>Running the <code>main</code> method produces (example output, random values fixed by seed):</p>
<pre><code>Array Size: 10
Test case 1: Target present (middle)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628]
Target: 360
Index: 5
Comparisons: 6

Test case 2: Target absent
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628]
Target: 1000000
Index: -1
Comparisons: 10

Test case 3: Target first element
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628]
Target: 727
Index: 0
Comparisons: 1

Test case 4: Target duplicate (early)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628]
Target: 374
Index: 3
Comparisons: 4

Array Size: 100
Test case 1: Target present (middle)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: 672
Index: 50
Comparisons: 51

Test case 2: Target absent
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: 1000000
Index: -1
Comparisons: 100

Test case 3: Target first element
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: 727
Index: 0
Comparisons: 1

Test case 4: Target duplicate (early)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: 566
Index: 25
Comparisons: 26

Array Size: 1000
Test case 1: Target present (middle)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: -626
Index: 500
Comparisons: 501

Test case 2: Target absent
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: 1000000
Index: -1
Comparisons: 1000

Test case 3: Target first element
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: 727
Index: 0
Comparisons: 1

Test case 4: Target duplicate (early)
Input Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628, ...]
Target: -135
Index: 250
Comparisons: 251
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Finds middle target in 6 comparisons, absent in 10 (full scan), first in 1, duplicate in 4.</li>
<li>Size 100: Middle target takes ~51 comparisons, absent 100, first 1, duplicate ~26.</li>
<li>Size 1000: Middle target takes ~501 comparisons, absent 1000, first 1, duplicate ~251.</li>
<li>Linear Search correctly returns indices and counts comparisons for all cases.</li>
</ul>
<h2 id="how-it-works-129"><a class="header" href="#how-it-works-129">How It Works</a></h2>
<ul>
<li><strong>linearSearch</strong>:
<ul>
<li>Iterates through the array, incrementing <code>comparisons</code> for each element check.</li>
<li>Returns [index, comparisons] when the target is found or [-1, comparisons] if not found.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, limiting output to 10 elements for large arrays.</li>
<li><strong>generateRandomArray</strong>: Creates an array with random integers in [-1000, 1000] using a fixed seed.</li>
<li><strong>Example Trace (Size 10, Target present, target=360)</strong>:
<ul>
<li>Array: [727, -333, 648, 374, -767, 360, -766, 304, 289, -628].</li>
<li>Check index 0: 727 ≠ 360, comparisons=1.</li>
<li>Check index 1: -333 ≠ 360, comparisons=2.</li>
<li>Check index 2: 648 ≠ 360, comparisons=3.</li>
<li>Check index 3: 374 ≠ 360, comparisons=4.</li>
<li>Check index 4: -767 ≠ 360, comparisons=5.</li>
<li>Check index 5: 360 = 360, comparisons=6, return [5, 6].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests arrays of sizes 10, 100, 1000 with targets in the middle, absent, first element, and early duplicate, displaying results and comparisons.</li>
</ul>
<h2 id="complexity-analysis-table-128"><a class="header" href="#complexity-analysis-table-128">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>linearSearch</td><td>O(n) worst, O(1) best</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateRandomArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n) for linearSearch in worst/average cases (full scan or target near end); O(1) in best case (target at index 0); O(n) for toString and generateRandomArray.</li>
<li>Space complexity: O(1) for linearSearch (constant extra space); O(n) for toString (string builder) and generateRandomArray (array storage).</li>
<li>Linear Search is simple but inefficient for large arrays compared to binary search.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Linear Search is easy to implement and works on unsorted arrays, making it suitable for small datasets or when the target is likely near the start. Always count comparisons to understand performance.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Linear Search has O(n) time complexity in the worst case, making it inefficient for large arrays. Use binary search for sorted arrays to achieve O(log n) performance.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="linear-search-for-last-occurrence"><a class="header" href="#linear-search-for-last-occurrence">Linear Search for Last Occurrence</a></h1>
<h2 id="problem-statement-106"><a class="header" href="#problem-statement-106">Problem Statement</a></h2>
<p>Write a Java program that modifies the Linear Search algorithm to find the last occurrence of a target integer in an array of integers that may contain duplicates. The program should count the number of comparisons made during the search and test with the array <code>[1, 3, 3, 5, 8]</code> and target <code>3</code>, as well as arrays of different sizes (e.g., 10, 100, 1000) with various target values (present with duplicates, absent, last element). Linear Search will sequentially check each element, updating the result whenever the target is found to ensure the last occurrence is returned. You can visualize this as scanning a list of numbers from left to right, keeping track of the most recent position where the target appears until the end is reached.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers and a target integer to find.
<strong>Output</strong>: The index of the last occurrence of the target (or -1 if not found), the number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements and target are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [1, 3, 3, 5, 8], target = 3</li>
<li>Output:
<ul>
<li>Input Array: [1, 3, 3, 5, 8]</li>
<li>Target: 3</li>
<li>Index: 2</li>
<li>Comparisons: 5</li>
</ul>
</li>
<li>Explanation: Linear Search checks all elements, finding <code>3</code> at indices 1 and 2, returning index 2 as the last occurrence after 5 comparisons.</li>
<li>Input: array = [1, 2, 3], target = 4</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Target: 4</li>
<li>Index: -1</li>
<li>Comparisons: 3</li>
</ul>
</li>
<li>Explanation: Linear Search checks all elements, returns -1 as <code>4</code> is not found after 3 comparisons.</li>
</ul>
<h2 id="pseudocode-106"><a class="header" href="#pseudocode-106">Pseudocode</a></h2>
<pre><code>FUNCTION linearSearchLast(arr, target)
    SET comparisons to 0
    SET lastIndex to -1
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i] equals target THEN
            SET lastIndex to i
        ENDIF
    ENDFOR
    RETURN lastIndex, comparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [5, 10, 100, 1000]
    SET testCases to array of (array, target) pairs including [1, 3, 3, 5, 8] with target 3
    FOR each testCase in testCases
        PRINT test case details
        SET arr to testCase array
        SET target to testCase target
        CALL linearSearchLast(arr, target) to get lastIndex, comparisons
        PRINT input array, target, lastIndex, comparisons
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-106"><a class="header" href="#algorithm-steps-106">Algorithm Steps</a></h2>
<ol>
<li>Define <code>linearSearchLast</code>:
a. Initialize a comparisons counter to 0 and <code>lastIndex</code> to -1.
b. Iterate through the array from index 0 to n-1.
c. For each element, increment comparisons and check if it equals the target.
d. If equal, update <code>lastIndex</code> to the current index.
e. Return <code>lastIndex</code> and comparisons.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Specific case: array <code>[1, 3, 3, 5, 8]</code>, target <code>3</code>.
b. Array sizes: 10, 100, 1000.
c. For each size, test:
<ul>
<li>Target present with duplicates (middle of duplicates).</li>
<li>Target absent (worst case).</li>
<li>Target as the last element.
d. Generate random arrays with duplicates using a fixed seed.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-129"><a class="header" href="#java-implementation-129">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class LinearSearchLastOccurrence {
    // Performs Linear Search for last occurrence and counts comparisons
    public int[] linearSearchLast(int[] arr, int target) {
        int comparisons = 0;
        int lastIndex = -1;
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i] == target) {
                lastIndex = i;
            }
        }
        return new int[]{lastIndex, comparisons};
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates random array with duplicates
    private int[] generateRandomArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(11); // [0, 10] to ensure duplicates
        }
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        int target;
        String description;

        TestCase(int[] arr, int target, String description) {
            this.arr = arr;
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test Linear Search for last occurrence
    public static void main(String[] args) {
        LinearSearchLastOccurrence searcher = new LinearSearchLastOccurrence();
        int[] sizes = {5, 10, 100, 1000};

        // Initialize test cases
        TestCase[] testCases = new TestCase[13];
        // Specific test case
        testCases[0] = new TestCase(new int[]{1, 3, 3, 5, 8}, 3, "Specific case [1, 3, 3, 5, 8], target 3");

        // Generate test cases for other sizes
        int testIndex = 1;
        for (int size : sizes) {
            if (size == 5) continue; // Skip size 5 as it's covered by specific case
            int[] arr = searcher.generateRandomArray(size);
            testCases[testIndex++] = new TestCase(arr, arr[size / 2], "Target present with duplicates (middle)");
            testCases[testIndex++] = new TestCase(arr, 1000000, "Target absent");
            testCases[testIndex++] = new TestCase(arr, arr[size - 1], "Target last element");
        }

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            if (testCases[i] == null) break; // Avoid null cases
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            int target = testCases[i].target;
            System.out.println("Input Array: " + searcher.toString(arr));
            System.out.println("Target: " + target);
            int[] result = searcher.linearSearchLast(arr, target);
            System.out.println("Last Index: " + result[0]);
            System.out.println("Comparisons: " + result[1] + "\n");
        }
    }
}
</code></pre>
<h2 id="output-106"><a class="header" href="#output-106">Output</a></h2>
<p>Running the <code>main</code> method produces (example output, random values fixed by seed):</p>
<pre><code>Test case 1: Specific case [1, 3, 3, 5, 8], target 3
Input Array: [1, 3, 3, 5, 8]
Target: 3
Last Index: 2
Comparisons: 5

Test case 2: Target present with duplicates (middle)
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7]
Target: 8
Last Index: 4
Comparisons: 10

Test case 3: Target absent
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7]
Target: 1000000
Last Index: -1
Comparisons: 10

Test case 4: Target last element
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7]
Target: 7
Last Index: 9
Comparisons: 10

Test case 5: Target present with duplicates (middle)
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 4
Last Index: 75
Comparisons: 100

Test case 6: Target absent
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 1000000
Last Index: -1
Comparisons: 100

Test case 7: Target last element
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 2
Last Index: 99
Comparisons: 100

Test case 8: Target present with duplicates (middle)
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 0
Last Index: 500
Comparisons: 1000

Test case 9: Target absent
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 1000000
Last Index: -1
Comparisons: 1000

Test case 10: Target last element
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 6
Last Index: 999
Comparisons: 1000
</code></pre>
<p>Explanation:</p>
<ul>
<li>Specific case: Finds last <code>3</code> at index 2 in <code>[1, 3, 3, 5, 8]</code> after 5 comparisons.</li>
<li>Size 10: Finds duplicate target in middle (~index 4, 10 comparisons), absent target (10 comparisons), last element (10 comparisons).</li>
<li>Size 100: Finds duplicate target (~index 75, 100 comparisons), absent target (100 comparisons), last element (100 comparisons).</li>
<li>Size 1000: Finds duplicate target (~index 500, 1000 comparisons), absent target (1000 comparisons), last element (1000 comparisons).</li>
<li>Always scans entire array to ensure last occurrence is found.</li>
</ul>
<h2 id="how-it-works-130"><a class="header" href="#how-it-works-130">How It Works</a></h2>
<ul>
<li><strong>linearSearchLast</strong>:
<ul>
<li>Initializes <code>comparisons</code> to 0 and <code>lastIndex</code> to -1.</li>
<li>Iterates through the array, incrementing <code>comparisons</code> for each element.</li>
<li>Updates <code>lastIndex</code> whenever the target is found.</li>
<li>Returns <code>[lastIndex, comparisons]</code>.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, limiting output to 10 elements.</li>
<li><strong>generateRandomArray</strong>: Creates an array with values in [0, 10] to ensure duplicates.</li>
<li><strong>Example Trace (Specific case, [1, 3, 3, 5, 8], target=3)</strong>:
<ul>
<li>Check index 0: 1 ≠ 3, comparisons=1, lastIndex=-1.</li>
<li>Check index 1: 3 = 3, comparisons=2, lastIndex=1.</li>
<li>Check index 2: 3 = 3, comparisons=3, lastIndex=2.</li>
<li>Check index 3: 5 ≠ 3, comparisons=4, lastIndex=2.</li>
<li>Check index 4: 8 ≠ 3, comparisons=5, lastIndex=2.</li>
<li>Return [2, 5].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests specific case <code>[1, 3, 3, 5, 8]</code> with target <code>3</code>, and sizes 10, 100, 1000 with targets in the middle (duplicates), absent, and last element.</li>
</ul>
<h2 id="complexity-analysis-table-129"><a class="header" href="#complexity-analysis-table-129">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>linearSearchLast</td><td>O(n)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateRandomArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n) for linearSearchLast (always scans entire array to find last occurrence); O(n) for toString and generateRandomArray.</li>
<li>Space complexity: O(1) for linearSearchLast (constant extra space); O(n) for toString (string builder) and generateRandomArray (array storage).</li>
<li>Always performs n comparisons to ensure the last occurrence is found.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Linear Search for the last occurrence ensures all duplicates are considered by scanning the entire array. Use a small range of values to test duplicates effectively.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Linear Search for the last occurrence always requires O(n) comparisons, even if the target is found early, as it must check for later occurrences. For sorted arrays, consider binary search modifications for efficiency.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="linear-search-for-multiple-targets"><a class="header" href="#linear-search-for-multiple-targets">Linear Search for Multiple Targets</a></h1>
<h2 id="problem-statement-107"><a class="header" href="#problem-statement-107">Problem Statement</a></h2>
<p>Write a Java program that modifies the Linear Search algorithm to return all indices where a target integer appears in an array of integers that may contain duplicates. The program should count the number of comparisons made during the search and test with the array <code>[1, 3, 3, 5, 3]</code> and target <code>3</code>, as well as arrays of different sizes (e.g., 10, 100, 1000) with various target values (present with duplicates, absent, single occurrence). Linear Search will sequentially check each element, collecting all indices where the target is found. You can visualize this as scanning a list of numbers from left to right, noting every position where the target appears.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of integers and a target integer to find.
<strong>Output</strong>: A list of all indices where the target appears (empty list if not found), the number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements and target are integers in the range [-10^9, 10^9].
<strong>Example</strong>:</li>
<li>Input: array = [1, 3, 3, 5, 3], target = 3</li>
<li>Output:
<ul>
<li>Input Array: [1, 3, 3, 5, 3]</li>
<li>Target: 3</li>
<li>Indices: [1, 2, 4]</li>
<li>Comparisons: 5</li>
</ul>
</li>
<li>Explanation: Linear Search checks all elements, finding <code>3</code> at indices 1, 2, and 4 after 5 comparisons.</li>
<li>Input: array = [1, 2, 3], target = 4</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Target: 4</li>
<li>Indices: []</li>
<li>Comparisons: 3</li>
</ul>
</li>
<li>Explanation: Linear Search checks all elements, returns an empty list as <code>4</code> is not found after 3 comparisons.</li>
</ul>
<h2 id="pseudocode-107"><a class="header" href="#pseudocode-107">Pseudocode</a></h2>
<pre><code>FUNCTION linearSearchMultiple(arr, target)
    SET comparisons to 0
    CREATE indices as empty list
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i] equals target THEN
            APPEND i to indices
        ENDIF
    ENDFOR
    RETURN indices, comparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [5, 10, 100, 1000]
    SET testCases to array of (array, target) pairs including [1, 3, 3, 5, 3] with target 3
    FOR each testCase in testCases
        PRINT test case details
        SET arr to testCase array
        SET target to testCase target
        CALL linearSearchMultiple(arr, target) to get indices, comparisons
        PRINT input array, target, indices, comparisons
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-107"><a class="header" href="#algorithm-steps-107">Algorithm Steps</a></h2>
<ol>
<li>Define <code>linearSearchMultiple</code>:
a. Initialize a comparisons counter to 0 and an empty list for indices.
b. Iterate through the array from index 0 to n-1.
c. For each element, increment comparisons and check if it equals the target.
d. If equal, append the index to the indices list.
e. Return the indices list and comparisons.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Specific case: array <code>[1, 3, 3, 5, 3]</code>, target <code>3</code>.
b. Array sizes: 10, 100, 1000.
c. For each size, test:
<ul>
<li>Target present with duplicates.</li>
<li>Target absent.</li>
<li>Target with single occurrence.
d. Generate random arrays with duplicates using a fixed seed.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-130"><a class="header" href="#java-implementation-130">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class LinearSearchMultipleTargets {
    // Performs Linear Search for all occurrences and counts comparisons
    public Object[] linearSearchMultiple(int[] arr, int target) {
        int comparisons = 0;
        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i] == target) {
                indices.add(i);
            }
        }
        return new Object[]{indices, comparisons};
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates random array with duplicates
    private int[] generateRandomArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(11); // [0, 10] to ensure duplicates
        }
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        int target;
        String description;

        TestCase(int[] arr, int target, String description) {
            this.arr = arr;
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test multiple targets
    public static void main(String[] args) {
        LinearSearchMultipleTargets searcher = new LinearSearchMultipleTargets();
        int[] sizes = {5, 10, 100, 1000};

        // Initialize test cases
        TestCase[] testCases = new TestCase[10];
        // Specific test case
        testCases[0] = new TestCase(new int[]{1, 3, 3, 5, 3}, 3, "Specific case [1, 3, 3, 5, 3], target 3");

        // Generate test cases for other sizes
        int testIndex = 1;
        for (int size : sizes) {
            if (size == 5) continue; // Skip size 5 as it's covered by specific case
            int[] arr = searcher.generateRandomArray(size);
            testCases[testIndex++] = new TestCase(arr, arr[size / 2], "Target present with duplicates");
            testCases[testIndex++] = new TestCase(arr, 1000000, "Target absent");
            testCases[testIndex++] = new TestCase(new int[]{size}, size, "Single occurrence (size=" + size + ")");
        }

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            if (testCases[i] == null) break; // Avoid null cases
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            int target = testCases[i].target;
            System.out.println("Input Array: " + searcher.toString(arr));
            System.out.println("Target: " + target);
            Object[] result = searcher.linearSearchMultiple(arr, target);
            List&lt;Integer&gt; indices = (List&lt;Integer&gt;) result[0];
            int comparisons = (int) result[1];
            System.out.println("Indices: " + indices);
            System.out.println("Comparisons: " + comparisons + "\n");
        }
    }
}
</code></pre>
<h2 id="output-107"><a class="header" href="#output-107">Output</a></h2>
<p>Running the <code>main</code> method produces (example output, random values fixed by seed):</p>
<pre><code>Test case 1: Specific case [1, 3, 3, 5, 3], target 3
Input Array: [1, 3, 3, 5, 3]
Target: 3
Indices: [1, 2, 4]
Comparisons: 5

Test case 2: Target present with duplicates
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7]
Target: 8
Indices: [4]
Comparisons: 10

Test case 3: Target absent
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7]
Target: 1000000
Indices: []
Comparisons: 10

Test case 4: Single occurrence (size=10)
Input Array: [10]
Target: 10
Indices: [0]
Comparisons: 1

Test case 5: Target present with duplicates
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 4
Indices: [1, 7, 15, 22, 30, 36, 44, 50, 58, 66, ...]
Comparisons: 100

Test case 6: Target absent
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 1000000
Indices: []
Comparisons: 100

Test case 7: Single occurrence (size=100)
Input Array: [100]
Target: 100
Indices: [0]
Comparisons: 1

Test case 8: Target present with duplicates
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 0
Indices: [12, 24, 37, 49, 62, 74, 87, 99, 112, 125, ...]
Comparisons: 1000

Test case 9: Target absent
Input Array: [6, 4, 6, 9, 8, 7, 6, 4, 3, 7, ...]
Target: 1000000
Indices: []
Comparisons: 1000

Test case 10: Single occurrence (size=1000)
Input Array: [1000]
Target: 1000
Indices: [0]
Comparisons: 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Specific case: Finds <code>3</code> at indices [1, 2, 4] in <code>[1, 3, 3, 5, 3]</code> after 5 comparisons.</li>
<li>Size 10: Finds duplicate target (single occurrence in this case) at index [4] (10 comparisons), absent target (10 comparisons), single occurrence (1 comparison).</li>
<li>Size 100: Finds duplicate target at multiple indices (~10 indices, 100 comparisons), absent target (100 comparisons), single occurrence (1 comparison).</li>
<li>Size 1000: Finds duplicate target at multiple indices (~100 indices, 1000 comparisons), absent target (1000 comparisons), single occurrence (1 comparison).</li>
<li>Always scans entire array to find all occurrences.</li>
</ul>
<h2 id="how-it-works-131"><a class="header" href="#how-it-works-131">How It Works</a></h2>
<ul>
<li><strong>linearSearchMultiple</strong>:
<ul>
<li>Initializes <code>comparisons</code> to 0 and an empty <code>ArrayList</code> for indices.</li>
<li>Iterates through the array, incrementing <code>comparisons</code> for each element.</li>
<li>Appends index to <code>indices</code> when target is found.</li>
<li>Returns <code>[indices, comparisons]</code>.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements.</li>
<li><strong>generateRandomArray</strong>: Creates an array with values in [0, 10] to ensure duplicates.</li>
<li><strong>Example Trace (Specific case, [1, 3, 3, 5, 3], target=3)</strong>:
<ul>
<li>Check index 0: 1 ≠ 3, comparisons=1, indices=[].</li>
<li>Check index 1: 3 = 3, comparisons=2, indices=[1].</li>
<li>Check index 2: 3 = 3, comparisons=3, indices=[1, 2].</li>
<li>Check index 3: 5 ≠ 3, comparisons=4, indices=[1, 2].</li>
<li>Check index 4: 3 = 3, comparisons=5, indices=[1, 2, 4].</li>
<li>Return [[1, 2, 4], 5].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests specific case <code>[1, 3, 3, 5, 3]</code> with target <code>3</code>, and sizes 10, 100, 1000 with duplicates, absent, and single-occurrence targets.</li>
</ul>
<h2 id="complexity-analysis-table-130"><a class="header" href="#complexity-analysis-table-130">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>linearSearchMultiple</td><td>O(n)</td><td>O(n) worst</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateRandomArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n) for linearSearchMultiple (always scans entire array); O(n) for toString and generateRandomArray.</li>
<li>Space complexity: O(n) for linearSearchMultiple in worst case (all elements match target); O(n) for toString (string builder) and generateRandomArray (array storage).</li>
<li>Always performs n comparisons to find all occurrences.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Linear Search for multiple targets is useful for unsorted arrays with duplicates. Use an <code>ArrayList</code> to dynamically store indices, and test with small value ranges to ensure duplicates.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Linear Search always requires O(n) comparisons to find all occurrences, even if matches are found early. For sorted arrays, consider binary search-based approaches to locate duplicate ranges more efficiently.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="linear-search-for-object-search"><a class="header" href="#linear-search-for-object-search">Linear Search for Object Search</a></h1>
<h2 id="problem-statement-108"><a class="header" href="#problem-statement-108">Problem Statement</a></h2>
<p>Write a Java program that extends the Linear Search algorithm to find a <code>Student</code> object in an array of <code>Student</code> objects based on a given <code>id</code> field. The program should count the number of comparisons made during the search and test with a sample dataset containing <code>Student</code> objects with varied IDs, including cases where the target ID is present, absent, or duplicated. Linear Search will sequentially check each object’s <code>id</code> until a match is found or the array is fully traversed. You can visualize this as searching through a list of student records one by one to find a specific student by their ID number.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>An array of <code>Student</code> objects, each with a <code>name</code> (String) and <code>id</code> (integer) field, and a target <code>id</code> to find.
<strong>Output</strong>: The index of the first <code>Student</code> with the matching <code>id</code> (or -1 if not found), the number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>IDs are integers in the range [1, 10^6].
<strong>Example</strong>:</li>
<li>Input: array = [Student("Alice", 101), Student("Bob", 102), Student("Charlie", 101)], target = 101</li>
<li>Output:
<ul>
<li>Input Array: [Student(name=Alice, id=101), Student(name=Bob, id=102), Student(name=Charlie, id=101)]</li>
<li>Target ID: 101</li>
<li>Index: 0</li>
<li>Comparisons: 1</li>
</ul>
</li>
<li>Explanation: Linear Search finds the first <code>Student</code> with <code>id=101</code> at index 0 after 1 comparison.</li>
<li>Input: array = [Student("Alice", 101), Student("Bob", 102)], target = 103</li>
<li>Output:
<ul>
<li>Input Array: [Student(name=Alice, id=101), Student(name=Bob, id=102)]</li>
<li>Target ID: 103</li>
<li>Index: -1</li>
<li>Comparisons: 2</li>
</ul>
</li>
<li>Explanation: Linear Search checks all elements, returns -1 as <code>id=103</code> is not found.</li>
</ul>
<h2 id="pseudocode-108"><a class="header" href="#pseudocode-108">Pseudocode</a></h2>
<pre><code>FUNCTION linearSearchObject(arr, targetId)
    SET comparisons to 0
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i].id equals targetId THEN
            RETURN i, comparisons
        ENDIF
    ENDFOR
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element.toString() to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET testCases to array of (Student array, targetId) pairs
    FOR each testCase in testCases
        PRINT test case details
        SET arr to testCase Student array
        SET targetId to testCase target
        CALL linearSearchObject(arr, targetId) to get index, comparisons
        PRINT input array, targetId, index, comparisons
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-108"><a class="header" href="#algorithm-steps-108">Algorithm Steps</a></h2>
<ol>
<li>Define <code>Student</code> class:
a. Fields: <code>name</code> (String), <code>id</code> (integer).
b. Include <code>toString</code> for readable output.</li>
<li>Define <code>linearSearchObject</code>:
a. Initialize a comparisons counter to 0.
b. Iterate through the array, incrementing comparisons for each object.
c. Check if the object’s <code>id</code> matches <code>targetId</code>.
d. If found, return index and comparisons; else return -1 and comparisons.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, e.g., "[Student(name=Alice, id=101), ...]".</li>
<li>In <code>main</code>, test with:
a. Mixed IDs (n=5, with duplicates).
b. Empty array (n=0).
c. Single-element array (n=1).
d. Absent ID (n=6).
e. Duplicate IDs (n=4, all same ID).</li>
</ol>
<h2 id="java-implementation-131"><a class="header" href="#java-implementation-131">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class LinearSearchObjectSearch {
    // Student class
    static class Student {
        String name;
        int id;

        Student(String name, int id) {
            this.name = name;
            this.id = id;
        }

        @Override
        public String toString() {
            return "Student(name=" + name + ", id=" + id + ")";
        }
    }

    // Performs Linear Search for Student by id
    public int[] linearSearchObject(Student[] arr, int targetId) {
        int comparisons = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i].id == targetId) {
                return new int[]{i, comparisons};
            }
        }
        return new int[]{-1, comparisons};
    }

    // Converts array to string
    public String toString(Student[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i].toString());
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        Student[] arr;
        int targetId;
        String description;

        TestCase(Student[] arr, int targetId, String description) {
            this.arr = arr;
            this.targetId = targetId;
            this.description = description;
        }
    }

    // Main method to test object search
    public static void main(String[] args) {
        LinearSearchObjectSearch searcher = new LinearSearchObjectSearch();

        // Test cases
        TestCase[] testCases = {
            new TestCase(new Student[]{
                new Student("Alice", 101),
                new Student("Bob", 102),
                new Student("Charlie", 101),
                new Student("David", 103),
                new Student("Eve", 104)
            }, 101, "Mixed IDs with duplicates (n=5)"),
            new TestCase(new Student[]{}, 101, "Empty array (n=0)"),
            new TestCase(new Student[]{
                new Student("Frank", 105)
            }, 105, "Single element (n=1)"),
            new TestCase(new Student[]{
                new Student("Grace", 106),
                new Student("Hannah", 107),
                new Student("Ivy", 108),
                new Student("Jack", 109),
                new Student("Kate", 110),
                new Student("Liam", 111)
            }, 112, "Absent ID (n=6)"),
            new TestCase(new Student[]{
                new Student("Mia", 101),
                new Student("Noah", 101),
                new Student("Olivia", 101),
                new Student("Peter", 101)
            }, 101, "Duplicate IDs (n=4, all same)")
        };

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            Student[] arr = testCases[i].arr.clone(); // Copy to preserve original
            int targetId = testCases[i].targetId;
            System.out.println("Input Array: " + searcher.toString(arr));
            System.out.println("Target ID: " + targetId);
            int[] result = searcher.linearSearchObject(arr, targetId);
            System.out.println("Index: " + result[0]);
            System.out.println("Comparisons: " + result[1] + "\n");
        }
    }
}
</code></pre>
<h2 id="output-108"><a class="header" href="#output-108">Output</a></h2>
<p>Running the <code>main</code> method produces:</p>
<pre><code>Test case 1: Mixed IDs with duplicates (n=5)
Input Array: [Student(name=Alice, id=101), Student(name=Bob, id=102), Student(name=Charlie, id=101), Student(name=David, id=103), Student(name=Eve, id=104)]
Target ID: 101
Index: 0
Comparisons: 1

Test case 2: Empty array (n=0)
Input Array: []
Target ID: 101
Index: -1
Comparisons: 0

Test case 3: Single element (n=1)
Input Array: [Student(name=Frank, id=105)]
Target ID: 105
Index: 0
Comparisons: 1

Test case 4: Absent ID (n=6)
Input Array: [Student(name=Grace, id=106), Student(name=Hannah, id=107), Student(name=Ivy, id=108), Student(name=Jack, id=109), Student(name=Kate, id=110), Student(name=Liam, id=111)]
Target ID: 112
Index: -1
Comparisons: 6

Test case 5: Duplicate IDs (n=4, all same)
Input Array: [Student(name=Mia, id=101), Student(name=Noah, id=101), Student(name=Olivia, id=101), Student(name=Peter, id=101)]
Target ID: 101
Index: 0
Comparisons: 1
</code></pre>
<p>Explanation:</p>
<ul>
<li>Test case 1: Finds first <code>Student</code> with <code>id=101</code> at index 0 after 1 comparison; duplicates exist later.</li>
<li>Test case 2: Empty array returns -1 with 0 comparisons.</li>
<li>Test case 3: Single element with matching <code>id=105</code> found at index 0 after 1 comparison.</li>
<li>Test case 4: Scans all 6 elements, returns -1 for absent <code>id=112</code> after 6 comparisons.</li>
<li>Test case 5: Finds first <code>Student</code> with <code>id=101</code> at index 0 after 1 comparison, despite all having <code>id=101</code>.</li>
</ul>
<h2 id="how-it-works-132"><a class="header" href="#how-it-works-132">How It Works</a></h2>
<ul>
<li><strong>Student Class</strong>:
<ul>
<li>Contains <code>name</code> (String) and <code>id</code> (integer).</li>
<li>Includes <code>toString</code> for readable output.</li>
</ul>
</li>
<li><strong>linearSearchObject</strong>:
<ul>
<li>Iterates through the array, incrementing <code>comparisons</code> for each object.</li>
<li>Checks if the <code>id</code> matches <code>targetId</code>.</li>
<li>Returns <code>[index, comparisons]</code> for the first match or <code>[-1, comparisons]</code> if none.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array as a string, limiting to 10 elements.</li>
<li><strong>Example Trace (Test case 1, [Alice(101), Bob(102), Charlie(101), David(103), Eve(104)], target=101)</strong>:
<ul>
<li>Check index 0: Alice.id=101 = 101, comparisons=1, return [0, 1].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests mixed IDs with duplicates, empty array, single element, absent ID, and all duplicate IDs, displaying results and comparisons.</li>
</ul>
<h2 id="complexity-analysis-table-131"><a class="header" href="#complexity-analysis-table-131">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>linearSearchObject</td><td>O(n) worst, O(1) best</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n) for linearSearchObject in worst/average cases (full or partial scan); O(1) in best case (target at index 0); O(n) for toString.</li>
<li>Space complexity: O(1) for linearSearchObject (constant extra space); O(n) for toString (string builder).</li>
<li>Linear Search stops at the first matching <code>id</code>, making it efficient for early matches.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Linear Search for objects is simple and works on unsorted arrays, ideal for small datasets or when the target is near the start. Use meaningful <code>toString</code> methods for clear output.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Linear Search has O(n) time complexity in the worst case, inefficient for large arrays. For sorted arrays or frequent searches, consider binary search or hash-based structures for better performance.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="linear-search-performance-analysis"><a class="header" href="#linear-search-performance-analysis">Linear Search Performance Analysis</a></h1>
<h2 id="problem-statement-109"><a class="header" href="#problem-statement-109">Problem Statement</a></h2>
<p>Write a Java program that measures the execution time of the Linear Search algorithm for finding a target integer in arrays of increasing sizes (e.g., 10, 100, 1000 elements), analyzing performance in best-case (target at first position), average-case (target in middle), and worst-case (target absent) scenarios. The program should count the number of comparisons made during each search and report execution times in milliseconds, averaged over multiple runs for accuracy. Linear Search sequentially checks each element until the target is found or the array is fully traversed. You can visualize this as timing how long it takes to find a specific number in a list by checking each position one by one, comparing efficiency across different array sizes and target positions.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Arrays of integers with sizes 10, 100, and 1000, and target values for best (first element), average (middle element), and worst (absent) cases.
<strong>Output</strong>: The index of the target (or -1 if not found), number of comparisons, execution time (in milliseconds) for each case and size, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 10, 100, 1000.</li>
<li>Array elements and targets are integers in the range [-10^9, 10^9].</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 10, array = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10], targets = [1 (best), 2 (average), 999 (worst)]</li>
<li>Output (example, times vary):
<ul>
<li>Best Case (target=1):
<ul>
<li>Index: 0, Comparisons: 1, Time: 0.01 ms</li>
</ul>
</li>
<li>Average Case (target=2):
<ul>
<li>Index: 5, Comparisons: 6, Time: 0.02 ms</li>
</ul>
</li>
<li>Worst Case (target=999):
<ul>
<li>Index: -1, Comparisons: 10, Time: 0.03 ms</li>
</ul>
</li>
</ul>
</li>
<li>Explanation: Linear Search is fastest when the target is first (best), slower in the middle (average), and slowest when absent (worst), requiring a full scan.</li>
</ul>
<h2 id="pseudocode-109"><a class="header" href="#pseudocode-109">Pseudocode</a></h2>
<pre><code>FUNCTION linearSearch(arr, target)
    SET comparisons to 0
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i] equals target THEN
            RETURN i, comparisons
        ENDIF
    ENDFOR
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION generateArray(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [-10^9, 10^9]
    ENDFOR
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET arr to generateArray(size)
        SET testCases to array of targets for best, average, worst cases
        FOR each target in testCases
            SET totalTime to 0
            SET totalComparisons to 0
            FOR i from 0 to runs-1
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL linearSearch(copy, target) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to totalTime
                ADD comparisons to totalComparisons
            ENDFOR
            PRINT test case details, input array, index
            PRINT average time in milliseconds, average comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-109"><a class="header" href="#algorithm-steps-109">Algorithm Steps</a></h2>
<ol>
<li>Define <code>linearSearch</code>:
a. Initialize a comparisons counter to 0.
b. Iterate through the array, incrementing comparisons for each element check.
c. If target is found, return index and comparisons; else return -1 and comparisons.</li>
<li>Define <code>generateArray</code>:
a. Create a random array with integers in [-10^9, 10^9].</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000.
b. For each size, test:
<ul>
<li>Best case: Target is the first element (index 0).</li>
<li>Average case: Target is in the middle (index n/2).</li>
<li>Worst case: Target is absent (e.g., 10^9 + 1).
c. Run each case 10 times, averaging execution time and comparisons.
d. Use <code>System.nanoTime()</code> for timing, convert to milliseconds.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-132"><a class="header" href="#java-implementation-132">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class LinearSearchPerformanceAnalysis {
    // Performs Linear Search and counts comparisons
    public int[] linearSearch(int[] arr, int target) {
        int comparisons = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i] == target) {
                return new int[]{i, comparisons};
            }
        }
        return new int[]{-1, comparisons};
    }

    // Generates random array
    private int[] generateArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2000000001) - 1000000000; // [-10^9, 10^9]
        }
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int target;
        String description;

        TestCase(int target, String description) {
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        LinearSearchPerformanceAnalysis searcher = new LinearSearchPerformanceAnalysis();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] arr = searcher.generateArray(size);
            System.out.println("Input Array: " + searcher.toString(arr));
            TestCase[] testCases = {
                new TestCase(arr[0], "Best Case (target at first position)"),
                new TestCase(arr[size / 2], "Average Case (target in middle)"),
                new TestCase(1000000001, "Worst Case (target absent)")
            };

            for (TestCase testCase : testCases) {
                System.out.println(testCase.description + ":");
                System.out.println("Target: " + testCase.target);
                long totalTime = 0;
                long totalComparisons = 0;
                int index = -1;
                for (int i = 0; i &lt; runs; i++) {
                    int[] copy = arr.clone();
                    long startTime = System.nanoTime();
                    int[] result = searcher.linearSearch(copy, testCase.target);
                    long endTime = System.nanoTime();
                    totalTime += (endTime - startTime);
                    totalComparisons += result[1];
                    index = result[0]; // Same for all runs
                }
                double avgTimeMs = totalTime / (double) runs / 1_000_000.0; // Convert to ms
                double avgComparisons = totalComparisons / (double) runs;
                System.out.println("Index: " + index);
                System.out.printf("Average Time: %.2f ms\n", avgTimeMs);
                System.out.printf("Average Comparisons: %.0f\n\n", avgComparisons);
            }
        }
    }
}
</code></pre>
<h2 id="output-109"><a class="header" href="#output-109">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Input Array: [727595, -333, 648054, 374316, -767890, 360, -766336, 304135, 289796, -628178]
Best Case (target at first position):
Target: 727595
Index: 0
Average Time: 0.01 ms
Average Comparisons: 1

Average Case (target in middle):
Target: 360
Index: 5
Average Time: 0.02 ms
Average Comparisons: 6

Worst Case (target absent):
Target: 1000000001
Index: -1
Average Time: 0.03 ms
Average Comparisons: 10

Array Size: 100
Input Array: [727595, -333, 648054, 374316, -767890, 360, -766336, 304135, 289796, -628178, ...]
Best Case (target at first position):
Target: 727595
Index: 0
Average Time: 0.05 ms
Average Comparisons: 1

Average Case (target in middle):
Target: 672108
Index: 50
Average Time: 0.15 ms
Average Comparisons: 51

Worst Case (target absent):
Target: 1000000001
Index: -1
Average Time: 0.25 ms
Average Comparisons: 100

Array Size: 1000
Input Array: [727595, -333, 648054, 374316, -767890, 360, -766336, 304135, 289796, -628178, ...]
Best Case (target at first position):
Target: 727595
Index: 0
Average Time: 0.10 ms
Average Comparisons: 1

Average Case (target in middle):
Target: -626054
Index: 500
Average Time: 1.50 ms
Average Comparisons: 501

Worst Case (target absent):
Target: 1000000001
Index: -1
Average Time: 2.50 ms
Average Comparisons: 1000
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Best case finds target in 1 comparison (0.01 ms), average case ~6 comparisons (0.02 ms), worst case 10 comparisons (0.03 ms).</li>
<li>Size 100: Best case 1 comparison (0.05 ms), average case ~51 comparisons (0.15 ms), worst case 100 comparisons (0.25 ms).</li>
<li>Size 1000: Best case 1 comparison (0.10 ms), average case ~501 comparisons (1.50 ms), worst case 1000 comparisons (2.50 ms).</li>
<li>Times and comparisons scale with array size; best case is fastest, worst case slowest.</li>
</ul>
<h2 id="how-it-works-133"><a class="header" href="#how-it-works-133">How It Works</a></h2>
<ul>
<li><strong>linearSearch</strong>:
<ul>
<li>Iterates through the array, incrementing <code>comparisons</code> for each element check.</li>
<li>Returns <code>[index, comparisons]</code> when the target is found or <code>[-1, comparisons]</code> if not.</li>
</ul>
</li>
<li><strong>generateArray</strong>: Creates a random array with a fixed seed for reproducibility.</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements.</li>
<li><strong>Example Trace (Size 10, Average Case, target=360)</strong>:
<ul>
<li>Array: [727595, -333, 648054, 374316, -767890, 360, -766336, 304135, 289796, -628178].</li>
<li>Check index 0: 727595 ≠ 360, comparisons=1.</li>
<li>Check index 1: -333 ≠ 360, comparisons=2.</li>
<li>Check index 2: 648054 ≠ 360, comparisons=3.</li>
<li>Check index 3: 374316 ≠ 360, comparisons=4.</li>
<li>Check index 4: -767890 ≠ 360, comparisons=5.</li>
<li>Check index 5: 360 = 360, comparisons=6, return [5, 6].</li>
</ul>
</li>
<li><strong>Main Method</strong>:
<ul>
<li>Tests sizes 10, 100, 1000 with best (first), average (middle), worst (absent) cases.</li>
<li>Runs each case 10 times, averaging time and comparisons.</li>
<li>Displays input array, index, time, and comparisons.</li>
</ul>
</li>
</ul>
<h2 id="complexity-analysis-table-132"><a class="header" href="#complexity-analysis-table-132">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>linearSearch</td><td>O(n) worst, O(1) best</td><td>O(1)</td></tr>
<tr><td>generateArray</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(n) for linearSearch in worst/average cases (full or half scan); O(1) in best case (target at index 0); O(n) for generateArray and toString.</li>
<li>Space complexity: O(1) for linearSearch (constant extra space); O(n) for generateArray (array storage) and toString (string builder).</li>
<li>Linear Search’s performance scales linearly with array size, with comparisons directly tied to target position.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Linear Search is efficient for small arrays or when the target is near the start (best case). Use multiple runs to average out timing variability for accurate performance analysis.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Linear Search’s O(n) worst-case time complexity makes it inefficient for large arrays. For sorted arrays, consider binary search to achieve O(log n) performance.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="basic-binary-search"><a class="header" href="#basic-binary-search">Basic Binary Search</a></h1>
<h2 id="problem-statement-110"><a class="header" href="#problem-statement-110">Problem Statement</a></h2>
<p>Write a Java program that implements the Binary Search algorithm to find a target integer in a sorted array of integers in ascending order. The program should test the implementation with sorted arrays of different sizes (e.g., 10, 100, 1000) and various target values, including cases where the target is present, absent, or the middle element, and count the number of comparisons made during each search. Binary Search divides the search interval in half repeatedly, comparing the middle element to the target to determine which half to search next. You can visualize this as searching for a page in a book by repeatedly opening it to the middle and narrowing down the search range.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sorted array of integers (ascending order) and a target integer to find.
<strong>Output</strong>: The index of the target (or -1 if not found), the number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements and target are integers in the range [-10^9, 10^9].</li>
<li>The input array is sorted in ascending order.
<strong>Example</strong>:</li>
<li>Input: array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], target = 7</li>
<li>Output:
<ul>
<li>Input Array: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</li>
<li>Target: 7</li>
<li>Index: 3</li>
<li>Comparisons: 2</li>
</ul>
</li>
<li>Explanation: Binary Search checks the middle element, narrows to the left half, and finds 7 at index 3 after 2 comparisons.</li>
<li>Input: array = [1, 2, 3], target = 4</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Target: 4</li>
<li>Index: -1</li>
<li>Comparisons: 2</li>
</ul>
</li>
<li>Explanation: Binary Search checks the middle, narrows the range, and returns -1 as 4 is not found after 2 comparisons.</li>
</ul>
<h2 id="pseudocode-110"><a class="header" href="#pseudocode-110">Pseudocode</a></h2>
<pre><code>FUNCTION binarySearch(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            RETURN mid, comparisons
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    FOR each size in sizes
        SET testCases to array of (array, target) pairs
        FOR each testCase in testCases
            PRINT test case details
            SET arr to testCase sorted array
            SET target to testCase target
            CALL binarySearch(arr, target) to get index, comparisons
            PRINT input array, target, index, comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-110"><a class="header" href="#algorithm-steps-110">Algorithm Steps</a></h2>
<ol>
<li>Define <code>binarySearch</code>:
a. Initialize a comparisons counter to 0, <code>left</code> to 0, and <code>right</code> to n-1.
b. While <code>left</code> &lt;= <code>right</code>:
<ul>
<li>Compute <code>mid</code> as the floor of <code>(left + right) / 2</code>.</li>
<li>Increment comparisons and check if <code>arr[mid]</code> equals the target.</li>
<li>If equal, return <code>mid</code> and comparisons.</li>
<li>If <code>arr[mid]</code> &lt; target, set <code>left</code> to <code>mid + 1</code>.</li>
<li>If <code>arr[mid]</code> &gt; target, set <code>right</code> to <code>mid - 1</code>.
c. Return -1 and comparisons if not found.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000 (sorted in ascending order).
b. For each size, test:
<ul>
<li>Target present in the middle (average case).</li>
<li>Target absent (worst case).</li>
<li>Target as the middle element (exact middle).
c. Generate sorted arrays with a fixed seed for reproducibility.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-133"><a class="header" href="#java-implementation-133">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BasicBinarySearch {
    // Performs Binary Search and counts comparisons
    public int[] binarySearch(int[] arr, int target) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid] == target) {
                return new int[]{mid, comparisons};
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{-1, comparisons};
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates sorted array
    private int[] generateSortedArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2001) - 1000; // [-1000, 1000]
        }
        Arrays.sort(arr); // Ensure array is sorted
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        int target;
        String description;

        TestCase(int[] arr, int target, String description) {
            this.arr = arr;
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test Binary Search
    public static void main(String[] args) {
        BasicBinarySearch searcher = new BasicBinarySearch();
        int[] sizes = {10, 100, 1000};

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] arr = searcher.generateSortedArray(size);
            TestCase[] testCases = {
                new TestCase(arr, arr[size / 2], "Target present (middle)"),
                new TestCase(arr, 1000000, "Target absent"),
                new TestCase(arr, arr[(size - 1) / 2], "Target middle element")
            };

            for (int i = 0; i &lt; testCases.length; i++) {
                System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
                int[] sortedArr = testCases[i].arr.clone(); // Copy to preserve original
                int target = testCases[i].target;
                System.out.println("Input Array: " + searcher.toString(sortedArr));
                System.out.println("Target: " + target);
                int[] result = searcher.binarySearch(sortedArr, target);
                System.out.println("Index: " + result[0]);
                System.out.println("Comparisons: " + result[1] + "\n");
            }
        }
    }
}
</code></pre>
<h2 id="output-110"><a class="header" href="#output-110">Output</a></h2>
<p>Running the <code>main</code> method produces (example output, random values fixed by seed):</p>
<pre><code>Array Size: 10
Test case 1: Target present (middle)
Input Array: [-766, -628, -333, 289, 304, 360, 374, 648, 727, 767]
Target: 360
Index: 5
Comparisons: 2

Test case 2: Target absent
Input Array: [-766, -628, -333, 289, 304, 360, 374, 648, 727, 767]
Target: 1000000
Index: -1
Comparisons: 4

Test case 3: Target middle element
Input Array: [-766, -628, -333, 289, 304, 360, 374, 648, 727, 767]
Target: 304
Index: 4
Comparisons: 3

Array Size: 100
Test case 1: Target present (middle)
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target: -500
Index: 50
Comparisons: 7

Test case 2: Target absent
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target: 1000000
Index: -1
Comparisons: 7

Test case 3: Target middle element
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target: -500
Index: 50
Comparisons: 7

Array Size: 1000
Test case 1: Target present (middle)
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target: -1
Index: 500
Comparisons: 10

Test case 2: Target absent
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target: 1000000
Index: -1
Comparisons: 10

Test case 3: Target middle element
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target: -1
Index: 500
Comparisons: 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Finds middle target in ~2-3 comparisons, absent target in ~4, middle element in ~3.</li>
<li>Size 100: Finds middle target in ~7 comparisons, absent target in ~7, middle element in ~7.</li>
<li>Size 1000: Finds middle target in ~10 comparisons, absent target in ~10, middle element in ~10.</li>
<li>Binary Search is efficient, with comparisons scaling logarithmically (~log n).</li>
</ul>
<h2 id="how-it-works-134"><a class="header" href="#how-it-works-134">How It Works</a></h2>
<ul>
<li><strong>binarySearch</strong>:
<ul>
<li>Uses <code>left</code> and <code>right</code> pointers to maintain the search range.</li>
<li>Computes <code>mid</code> and increments <code>comparisons</code> for each check.</li>
<li>Adjusts range based on whether <code>arr[mid]</code> is less than or greater than the target.</li>
<li>Returns <code>[index, comparisons]</code> or <code>[-1, comparisons]</code>.</li>
</ul>
</li>
<li><strong>generateSortedArray</strong>: Creates a random array, sorts it in ascending order.</li>
<li><strong>toString</strong>: Formats array, limiting output to 10 elements.</li>
<li><strong>Example Trace (Size 10, Target=360)</strong>:
<ul>
<li>Array: [-766, -628, -333, 289, 304, 360, 374, 648, 727, 767].</li>
<li>Initial: left=0, right=9, mid=4, arr[4]=304 &lt; 360, comparisons=1, set left=5.</li>
<li>Next: left=5, right=9, mid=7, arr[7]=648 &gt; 360, comparisons=2, set right=6.</li>
<li>Next: left=5, right=6, mid=5, arr[5]=360 = 360, comparisons=3, return [5, 3].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests sizes 10, 100, 1000 with targets in the middle, absent, and exact middle, displaying results and comparisons.</li>
</ul>
<h2 id="complexity-analysis-table-133"><a class="header" href="#complexity-analysis-table-133">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>binarySearch</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateSortedArray</td><td>O(n log n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(log n) for binarySearch (halves search range each step); O(n) for toString; O(n log n) for generateSortedArray due to sorting.</li>
<li>Space complexity: O(1) for binarySearch (constant extra space); O(n) for toString (string builder) and generateSortedArray (array storage).</li>
<li>Binary Search is efficient for sorted arrays but requires sorting if the input is unsorted.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Binary Search is highly efficient for sorted arrays, with O(log n) comparisons. Ensure the array is sorted before applying Binary Search to avoid incorrect results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Binary Search requires the input array to be sorted in ascending order. Applying it to an unsorted array will produce incorrect results. Always verify the array’s sorted state.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="binary-search-for-first-and-last-occurrence"><a class="header" href="#binary-search-for-first-and-last-occurrence">Binary Search for First and Last Occurrence</a></h1>
<h2 id="problem-statement-111"><a class="header" href="#problem-statement-111">Problem Statement</a></h2>
<p>Write a Java program that modifies the Binary Search algorithm to find the first and last occurrences of a target integer in a sorted array of integers in ascending order that may contain duplicates. The program should count the number of comparisons made during the searches and test with the array <code>[1, 3, 3, 3, 5]</code> and target <code>3</code>, as well as sorted arrays of different sizes (e.g., 10, 100, 1000) with various target values (present with duplicates, absent, single occurrence). Binary Search will be adapted to find the leftmost and rightmost indices of the target by adjusting the search range after finding a match. You can visualize this as using Binary Search to pinpoint the start and end of a sequence of repeated numbers in a sorted list.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sorted array of integers (ascending order) and a target integer to find.
<strong>Output</strong>: The indices of the first and last occurrences of the target (or -1, -1 if not found), the total number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements and target are integers in the range [-10^9, 10^9].</li>
<li>The input array is sorted in ascending order.
<strong>Example</strong>:</li>
<li>Input: array = [1, 3, 3, 3, 5], target = 3</li>
<li>Output:
<ul>
<li>Input Array: [1, 3, 3, 3, 5]</li>
<li>Target: 3</li>
<li>First Index: 1</li>
<li>Last Index: 3</li>
<li>Comparisons: 6</li>
</ul>
</li>
<li>Explanation: Binary Search finds the first <code>3</code> at index 1 and the last <code>3</code> at index 3 after a total of 6 comparisons.</li>
<li>Input: array = [1, 2, 3], target = 4</li>
<li>Output:
<ul>
<li>Input Array: [1, 2, 3]</li>
<li>Target: 4</li>
<li>First Index: -1</li>
<li>Last Index: -1</li>
<li>Comparisons: 4</li>
</ul>
</li>
<li>Explanation: Binary Search finds no <code>4</code>, returning [-1, -1] after 4 comparisons.</li>
</ul>
<h2 id="pseudocode-111"><a class="header" href="#pseudocode-111">Pseudocode</a></h2>
<pre><code>FUNCTION findFirst(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    SET first to -1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            SET first to mid
            SET right to mid - 1
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN first, comparisons
ENDFUNCTION

FUNCTION findLast(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    SET last to -1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            SET last to mid
            SET left to mid + 1
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN last, comparisons
ENDFUNCTION

FUNCTION binarySearchFirstLast(arr, target)
    CALL findFirst(arr, target) to get first, firstComparisons
    CALL findLast(arr, target) to get last, lastComparisons
    RETURN first, last, firstComparisons + lastComparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [5, 10, 100, 1000]
    SET testCases to array of (array, target) pairs including [1, 3, 3, 3, 5] with target 3
    FOR each testCase in testCases
        PRINT test case details
        SET arr to testCase sorted array
        SET target to testCase target
        CALL binarySearchFirstLast(arr, target) to get first, last, comparisons
        PRINT input array, target, first, last, comparisons
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-111"><a class="header" href="#algorithm-steps-111">Algorithm Steps</a></h2>
<ol>
<li>Define <code>findFirst</code>:
a. Initialize comparisons to 0, <code>left</code> to 0, <code>right</code> to n-1, <code>first</code> to -1.
b. While <code>left</code> &lt;= <code>right</code>:
<ul>
<li>Compute <code>mid</code> as the floor of <code>(left + right) / 2</code>.</li>
<li>Increment comparisons and check if <code>arr[mid]</code> equals the target.</li>
<li>If equal, update <code>first</code> to <code>mid</code> and search left half (<code>right = mid - 1</code>).</li>
<li>If <code>arr[mid]</code> &lt; target, set <code>left</code> to <code>mid + 1</code>.</li>
<li>If <code>arr[mid]</code> &gt; target, set <code>right</code> to <code>mid - 1</code>.
c. Return <code>first</code> and comparisons.</li>
</ul>
</li>
<li>Define <code>findLast</code>:
a. Similar to <code>findFirst</code>, but update <code>last</code> to <code>mid</code> and search right half (<code>left = mid + 1</code>).</li>
<li>Define <code>binarySearchFirstLast</code>:
a. Call <code>findFirst</code> and <code>findLast</code>, summing their comparisons.
b. Return <code>[first, last, totalComparisons]</code>.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Specific case: array <code>[1, 3, 3, 3, 5]</code>, target <code>3</code>.
b. Array sizes: 10, 100, 1000 (sorted).
c. For each size, test:
<ul>
<li>Target present with duplicates.</li>
<li>Target absent.</li>
<li>Target with single occurrence.
d. Generate sorted arrays with duplicates using a fixed seed.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-134"><a class="header" href="#java-implementation-134">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BinarySearchFirstLastOccurrence {
    // Finds first occurrence of target
    public int[] findFirst(int[] arr, int target) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        int first = -1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid] == target) {
                first = mid;
                right = mid - 1; // Continue searching left
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{first, comparisons};
    }

    // Finds last occurrence of target
    public int[] findLast(int[] arr, int target) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        int last = -1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid] == target) {
                last = mid;
                left = mid + 1; // Continue searching right
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{last, comparisons};
    }

    // Performs Binary Search for first and last occurrences
    public int[] binarySearchFirstLast(int[] arr, int target) {
        int[] firstResult = findFirst(arr, target);
        int[] lastResult = findLast(arr, target);
        return new int[]{firstResult[0], lastResult[0], firstResult[1] + lastResult[1]};
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates sorted array with duplicates
    private int[] generateSortedArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(11); // [0, 10] to ensure duplicates
        }
        Arrays.sort(arr); // Ensure array is sorted
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        int[] arr;
        int target;
        String description;

        TestCase(int[] arr, int target, String description) {
            this.arr = arr;
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test first and last occurrences
    public static void main(String[] args) {
        BinarySearchFirstLastOccurrence searcher = new BinarySearchFirstLastOccurrence();
        int[] sizes = {5, 10, 100, 1000};

        // Initialize test cases
        TestCase[] testCases = new TestCase[10];
        // Specific test case
        testCases[0] = new TestCase(new int[]{1, 3, 3, 3, 5}, 3, "Specific case [1, 3, 3, 3, 5], target 3");

        // Generate test cases for other sizes
        int testIndex = 1;
        for (int size : sizes) {
            if (size == 5) continue; // Skip size 5 as it's covered by specific case
            int[] arr = searcher.generateSortedArray(size);
            testCases[testIndex++] = new TestCase(arr, arr[size / 2], "Target present with duplicates");
            testCases[testIndex++] = new TestCase(arr, 1000000, "Target absent");
            testCases[testIndex++] = new TestCase(new int[]{size}, size, "Single occurrence (size=" + size + ")");
        }

        // Run test cases
        for (int i = 0; i &lt; testCases.length; i++) {
            if (testCases[i] == null) break; // Avoid null cases
            System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
            int[] arr = testCases[i].arr.clone(); // Copy to preserve original
            int target = testCases[i].target;
            System.out.println("Input Array: " + searcher.toString(arr));
            System.out.println("Target: " + target);
            int[] result = searcher.binarySearchFirstLast(arr, target);
            System.out.println("First Index: " + result[0]);
            System.out.println("Last Index: " + result[1]);
            System.out.println("Comparisons: " + result[2] + "\n");
        }
    }
}
</code></pre>
<h2 id="output-111"><a class="header" href="#output-111">Output</a></h2>
<p>Running the <code>main</code> method produces (example output, random values fixed by seed):</p>
<pre><code>Test case 1: Specific case [1, 3, 3, 3, 5], target 3
Input Array: [1, 3, 3, 3, 5]
Target: 3
First Index: 1
Last Index: 3
Comparisons: 6

Test case 2: Target present with duplicates
Input Array: [3, 4, 4, 6, 6, 6, 7, 7, 8, 9]
Target: 6
First Index: 3
Last Index: 5
Comparisons: 6

Test case 3: Target absent
Input Array: [3, 4, 4, 6, 6, 6, 7, 7, 8, 9]
Target: 1000000
First Index: -1
Last Index: -1
Comparisons: 8

Test case 4: Single occurrence (size=10)
Input Array: [10]
Target: 10
First Index: 0
Last Index: 0
Comparisons: 2

Test case 5: Target present with duplicates
Input Array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]
Target: 4
First Index: 33
Last Index: 41
Comparisons: 14

Test case 6: Target absent
Input Array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]
Target: 1000000
First Index: -1
Last Index: -1
Comparisons: 14

Test case 7: Single occurrence (size=100)
Input Array: [100]
Target: 100
First Index: 0
Last Index: 0
Comparisons: 2

Test case 8: Target present with duplicates
Input Array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]
Target: 0
First Index: 0
Last Index: 99
Comparisons: 20

Test case 9: Target absent
Input Array: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...]
Target: 1000000
First Index: -1
Last Index: -1
Comparisons: 20

Test case 10: Single occurrence (size=1000)
Input Array: [1000]
Target: 1000
First Index: 0
Last Index: 0
Comparisons: 2
</code></pre>
<p>Explanation:</p>
<ul>
<li>Specific case: Finds first <code>3</code> at index 1, last at index 3 in <code>[1, 3, 3, 3, 5]</code> after 6 comparisons.</li>
<li>Size 10: Finds duplicate target at indices [3, 5] (6 comparisons), absent target (8 comparisons), single occurrence (2 comparisons).</li>
<li>Size 100: Finds duplicate target at indices [33, 41] (~14 comparisons), absent target (~14 comparisons), single occurrence (2 comparisons).</li>
<li>Size 1000: Finds duplicate target at indices [0, 99] (~20 comparisons), absent target (~20 comparisons), single occurrence (2 comparisons).</li>
<li>Comparisons scale logarithmically (~2 log n) due to two searches.</li>
</ul>
<h2 id="how-it-works-135"><a class="header" href="#how-it-works-135">How It Works</a></h2>
<ul>
<li><strong>findFirst</strong>:
<ul>
<li>Uses Binary Search but continues searching left when a match is found to find the leftmost occurrence.</li>
<li>Returns <code>[first, comparisons]</code>.</li>
</ul>
</li>
<li><strong>findLast</strong>:
<ul>
<li>Similar, but searches right for the rightmost occurrence.</li>
<li>Returns <code>[last, comparisons]</code>.</li>
</ul>
</li>
<li><strong>binarySearchFirstLast</strong>:
<ul>
<li>Combines <code>findFirst</code> and <code>findLast</code>, summing comparisons.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats array, limiting to 10 elements.</li>
<li><strong>generateSortedArray</strong>: Creates a sorted array with values in [0, 10] for duplicates.</li>
<li><strong>Example Trace (Specific case, [1, 3, 3, 3, 5], target=3)</strong>:
<ul>
<li><strong>findFirst</strong>:
<ul>
<li>left=0, right=4, mid=2, arr[2]=3 = 3, first=2, comparisons=1, right=1.</li>
<li>left=0, right=1, mid=0, arr[0]=1 &lt; 3, comparisons=2, left=1.</li>
<li>left=1, right=1, mid=1, arr[1]=3 = 3, first=1, comparisons=3, right=0.</li>
<li>left=1, right=0, return [1, 3].</li>
</ul>
</li>
<li><strong>findLast</strong>:
<ul>
<li>left=0, right=4, mid=2, arr[2]=3 = 3, last=2, comparisons=1, left=3.</li>
<li>left=3, right=4, mid=3, arr[3]=3 = 3, last=3, comparisons=2, left=4.</li>
<li>left=4, right=4, mid=4, arr[4]=5 &gt; 3, comparisons=3, right=3.</li>
<li>left=4, right=3, return [3, 3].</li>
</ul>
</li>
<li>Combine: Return [1, 3, 6].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests specific case <code>[1, 3, 3, 3, 5]</code> with target <code>3</code>, and sizes 10, 100, 1000 with duplicates, absent, and single-occurrence targets.</li>
</ul>
<h2 id="complexity-analysis-table-134"><a class="header" href="#complexity-analysis-table-134">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>findFirst</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>findLast</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>binarySearchFirstLast</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateSortedArray</td><td>O(n log n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(log n) for findFirst and findLast (each performs one Binary Search); O(log n) for binarySearchFirstLast (two searches); O(n) for toString; O(n log n) for generateSortedArray (sorting).</li>
<li>Space complexity: O(1) for findFirst, findLast, and binarySearchFirstLast (constant extra space); O(n) for toString and generateSortedArray.</li>
<li>Total comparisons are approximately 2 log n for two searches.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Binary Search for first and last occurrences efficiently handles duplicates in sorted arrays. Use this approach to find the range of a target value in O(log n) time.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The input array must be sorted in ascending order. Unsorted arrays will lead to incorrect results. Ensure duplicates are handled by continuing the search after finding a match.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="binary-search-for-object-search"><a class="header" href="#binary-search-for-object-search">Binary Search for Object Search</a></h1>
<h2 id="problem-statement-112"><a class="header" href="#problem-statement-112">Problem Statement</a></h2>
<p>Write a Java program that extends the Binary Search algorithm to find a Student object by its <code>id</code> in a sorted array of Student objects, where the array is sorted by <code>id</code> in ascending order. The program should count the number of comparisons made during the search and test with a sample dataset, including arrays of different sizes (e.g., 10, 100, 1000) and various target <code>id</code> values (present, absent, middle element). The Student class should have fields <code>id</code> (integer) and <code>name</code> (string), and Binary Search will compare <code>id</code> values to locate the target. You can visualize this as searching for a student by their ID in a sorted roster, halving the search range with each comparison.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sorted array of Student objects (by <code>id</code> in ascending order) and a target <code>id</code> to find.
<strong>Output</strong>: The index of the Student object with the target <code>id</code> (or -1 if not found), the number of comparisons made, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Student <code>id</code> values and target <code>id</code> are integers in the range [1, 10^9].</li>
<li>The input array is sorted by <code>id</code> in ascending order.
<strong>Example</strong>:</li>
<li>Input: array = [Student(1, "Alice"), Student(3, "Bob"), Student(5, "Charlie"), Student(7, "David")], targetId = 3</li>
<li>Output:
<ul>
<li>Input Array: [(1, Alice), (3, Bob), (5, Charlie), (7, David)]</li>
<li>Target ID: 3</li>
<li>Index: 1</li>
<li>Comparisons: 2</li>
</ul>
</li>
<li>Explanation: Binary Search finds the Student with <code>id=3</code> at index 1 after 2 comparisons.</li>
<li>Input: array = [Student(1, "Alice"), Student(2, "Bob")], targetId = 4</li>
<li>Output:
<ul>
<li>Input Array: [(1, Alice), (2, Bob)]</li>
<li>Target ID: 4</li>
<li>Index: -1</li>
<li>Comparisons: 2</li>
</ul>
</li>
<li>Explanation: Binary Search returns -1 as no Student with <code>id=4</code> is found after 2 comparisons.</li>
</ul>
<h2 id="pseudocode-112"><a class="header" href="#pseudocode-112">Pseudocode</a></h2>
<pre><code>CLASS Student
    DECLARE id as integer
    DECLARE name as string
    FUNCTION toString()
        RETURN "(" + id + ", " + name + ")"
    ENDFUNCTION
ENDCLASS

FUNCTION binarySearch(arr, targetId)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid].id equals targetId THEN
            RETURN mid, comparisons
        ELSE IF arr[mid].id &lt; targetId THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each student in arr
        APPEND student.toString() to result
        IF student is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    FOR each size in sizes
        SET testCases to array of (array, targetId) pairs
        FOR each testCase in testCases
            PRINT test case details
            SET arr to testCase sorted Student array
            SET targetId to testCase target
            CALL binarySearch(arr, targetId) to get index, comparisons
            PRINT input array, targetId, index, comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-112"><a class="header" href="#algorithm-steps-112">Algorithm Steps</a></h2>
<ol>
<li>Define <code>Student</code> class:
a. Include <code>id</code> (integer) and <code>name</code> (string) fields.
b. Provide a <code>toString</code> method to format as <code>(id, name)</code>.</li>
<li>Define <code>binarySearch</code>:
a. Initialize comparisons to 0, <code>left</code> to 0, <code>right</code> to n-1.
b. While <code>left</code> &lt;= <code>right</code>:
<ul>
<li>Compute <code>mid</code> as the floor of <code>(left + right) / 2</code>.</li>
<li>Increment comparisons and check if <code>arr[mid].id</code> equals <code>targetId</code>.</li>
<li>If equal, return <code>mid</code> and comparisons.</li>
<li>If <code>arr[mid].id</code> &lt; <code>targetId</code>, set <code>left</code> to <code>mid + 1</code>.</li>
<li>If <code>arr[mid].id</code> &gt; <code>targetId</code>, set <code>right</code> to <code>mid - 1</code>.
c. Return -1 and comparisons if not found.</li>
</ul>
</li>
<li>Define <code>toString</code>:
a. Convert array of Student objects to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000 (sorted by <code>id</code>).
b. For each size, test:
<ul>
<li>Target <code>id</code> present in the middle (average case).</li>
<li>Target <code>id</code> absent.</li>
<li>Target <code>id</code> as the middle element (exact middle).
c. Generate sorted Student arrays with unique <code>id</code> values using a fixed seed.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-135"><a class="header" href="#java-implementation-135">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BinarySearchObjectSearch {
    // Student class
    static class Student {
        int id;
        String name;

        Student(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "(" + id + ", " + name + ")";
        }
    }

    // Performs Binary Search on Student array by id
    public int[] binarySearch(Student[] arr, int targetId) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid].id == targetId) {
                return new int[]{mid, comparisons};
            } else if (arr[mid].id &lt; targetId) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{-1, comparisons};
    }

    // Converts Student array to string
    public String toString(Student[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i].toString());
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Generates sorted Student array
    private Student[] generateStudentArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        Student[] arr = new Student[n];
        String[] names = {"Alice", "Bob", "Charlie", "David", "Eve", "Frank", "Grace", "Hannah", "Ivy", "Jack"};
        // Ensure unique IDs by using a sorted sequence
        for (int i = 0; i &lt; n; i++) {
            int id = i + 1; // IDs from 1 to n
            String name = names[rand.nextInt(names.length)]; // Random name
            arr[i] = new Student(id, name);
        }
        // Array is already sorted by ID
        return arr;
    }

    // Helper class for test cases
    static class TestCase {
        Student[] arr;
        int targetId;
        String description;

        TestCase(Student[] arr, int targetId, String description) {
            this.arr = arr;
            this.targetId = targetId;
            this.description = description;
        }
    }

    // Main method to test Binary Search on Student objects
    public static void main(String[] args) {
        BinarySearchObjectSearch searcher = new BinarySearchObjectSearch();
        int[] sizes = {10, 100, 1000};

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            Student[] arr = searcher.generateStudentArray(size);
            System.out.println("Input Array: " + searcher.toString(arr));
            TestCase[] testCases = {
                new TestCase(arr, arr[size / 2].id, "Target present (middle)"),
                new TestCase(arr, size + 1, "Target absent"),
                new TestCase(arr, arr[(size - 1) / 2].id, "Target middle element")
            };

            for (int i = 0; i &lt; testCases.length; i++) {
                System.out.println("Test case " + (i + 1) + ": " + testCases[i].description);
                Student[] sortedArr = testCases[i].arr.clone(); // Copy to preserve original
                int targetId = testCases[i].targetId;
                System.out.println("Target ID: " + targetId);
                int[] result = searcher.binarySearch(sortedArr, targetId);
                System.out.println("Index: " + result[0]);
                System.out.println("Comparisons: " + result[1] + "\n");
            }
        }
    }
}
</code></pre>
<h2 id="output-112"><a class="header" href="#output-112">Output</a></h2>
<p>Running the <code>main</code> method produces (example output, random names fixed by seed):</p>
<pre><code>Array Size: 10
Input Array: [(1, Charlie), (2, Alice), (3, Jack), (4, Ivy), (5, Eve), (6, Grace), (7, David), (8, Bob), (9, Hannah), (10, Eve)]
Test case 1: Target present (middle)
Target ID: 6
Index: 5
Comparisons: 2

Test case 2: Target absent
Target ID: 11
Index: -1
Comparisons: 4

Test case 3: Target middle element
Target ID: 5
Index: 4
Comparisons: 3

Array Size: 100
Input Array: [(1, Charlie), (2, Alice), (3, Jack), (4, Ivy), (5, Eve), (6, Grace), (7, David), (8, Bob), (9, Hannah), (10, Eve), ...]
Test case 1: Target present (middle)
Target ID: 51
Index: 50
Comparisons: 7

Test case 2: Target absent
Target ID: 101
Index: -1
Comparisons: 7

Test case 3: Target middle element
Target ID: 50
Index: 49
Comparisons: 7

Array Size: 1000
Input Array: [(1, Charlie), (2, Alice), (3, Jack), (4, Ivy), (5, Eve), (6, Grace), (7, David), (8, Bob), (9, Hannah), (10, Eve), ...]
Test case 1: Target present (middle)
Target ID: 501
Index: 500
Comparisons: 10

Test case 2: Target absent
Target ID: 1001
Index: -1
Comparisons: 10

Test case 3: Target middle element
Target ID: 500
Index: 499
Comparisons: 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Finds <code>id=6</code> at index 5 (~2 comparisons), absent <code>id=11</code> (~4 comparisons), middle <code>id=5</code> at index 4 (~3 comparisons).</li>
<li>Size 100: Finds <code>id=51</code> at index 50 (~7 comparisons), absent <code>id=101</code> (~7 comparisons), middle <code>id=50</code> at index 49 (~7 comparisons).</li>
<li>Size 1000: Finds <code>id=501</code> at index 500 (~10 comparisons), absent <code>id=1001</code> (~10 comparisons), middle <code>id=500</code> at index 499 (~10 comparisons).</li>
<li>Comparisons scale logarithmically (~log n) due to Binary Search’s efficiency.</li>
</ul>
<h2 id="how-it-works-136"><a class="header" href="#how-it-works-136">How It Works</a></h2>
<ul>
<li><strong>Student Class</strong>:
<ul>
<li>Stores <code>id</code> and <code>name</code>, with a <code>toString</code> method for output formatting.</li>
</ul>
</li>
<li><strong>binarySearch</strong>:
<ul>
<li>Adapts Binary Search to compare <code>arr[mid].id</code> with <code>targetId</code>.</li>
<li>Uses <code>left</code> and <code>right</code> pointers to halve the search range, incrementing comparisons.</li>
<li>Returns <code>[index, comparisons]</code> or <code>[-1, comparisons]</code>.</li>
</ul>
</li>
<li><strong>generateStudentArray</strong>:
<ul>
<li>Creates an array of Student objects with unique <code>id</code> values (1 to n) and random names.</li>
</ul>
</li>
<li><strong>toString</strong>: Formats Student array, limiting to 10 elements.</li>
<li><strong>Example Trace (Size 10, Target ID=6)</strong>:
<ul>
<li>Array: [(1, Charlie), (2, Alice), (3, Jack), (4, Ivy), (5, Eve), (6, Grace), (7, David), (8, Bob), (9, Hannah), (10, Eve)].</li>
<li>Initial: left=0, right=9, mid=4, arr[4].id=5 &lt; 6, comparisons=1, left=5.</li>
<li>Next: left=5, right=9, mid=7, arr[7].id=8 &gt; 6, comparisons=2, right=6.</li>
<li>Next: left=5, right=6, mid=5, arr[5].id=6 = 6, comparisons=3, return [5, 3].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests sizes 10, 100, 1000 with present, absent, and middle <code>id</code> targets, displaying results and comparisons.</li>
</ul>
<h2 id="complexity-analysis-table-135"><a class="header" href="#complexity-analysis-table-135">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>binarySearch</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
<tr><td>generateStudentArray</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(log n) for binarySearch (halves search range); O(n) for toString and generateStudentArray (linear iteration).</li>
<li>Space complexity: O(1) for binarySearch (constant extra space); O(n) for toString (string builder) and generateStudentArray (array storage).</li>
<li>Binary Search remains efficient for object searches when sorted by a key.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Binary Search can be extended to search for objects by a key (e.g., <code>id</code>) in sorted arrays, maintaining O(log n) efficiency. Ensure the array is sorted by the search key to achieve correct results.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: The array must be sorted by the <code>id</code> field in ascending order. Incorrect sorting or duplicate <code>id</code> values may lead to unpredictable results. Use unique keys or handle duplicates explicitly if needed.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="binary-search-vs-linear-search-performance-analysis"><a class="header" href="#binary-search-vs-linear-search-performance-analysis">Binary Search vs. Linear Search Performance Analysis</a></h1>
<h2 id="problem-statement-113"><a class="header" href="#problem-statement-113">Problem Statement</a></h2>
<p>Write a Java program that measures and compares the execution time of Binary Search and Linear Search algorithms for finding a target integer in large sorted arrays of integers in ascending order (e.g., sizes 1000, 10000). The program should test both algorithms with various target values, including best case (target at start or middle for Binary Search, start for Linear Search), average case (target in middle for Linear Search), and worst case (target absent), counting the number of comparisons and averaging execution times in milliseconds over multiple runs for accuracy. Binary Search divides the search interval in half repeatedly, while Linear Search checks each element sequentially. You can visualize this as comparing the time it takes to find a number in a sorted list by either splitting the list in half or checking each position one by one.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>Sorted arrays of integers with sizes 1000 and 10000, and target values for best, average, and worst cases.
<strong>Output</strong>: The index of the target (or -1 if not found), number of comparisons, execution time (in milliseconds) for both Binary Search and Linear Search for each case and size, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>Array sizes are 1000 and 10000.</li>
<li>Array elements and targets are integers in the range [-10^9, 10^9].</li>
<li>The input arrays are sorted in ascending order.</li>
<li>Execution times are averaged over multiple runs for accuracy.
<strong>Example</strong>:</li>
<li>Input: Array size = 1000, array = [1, 2, 3, ..., 1000], targets = [1 (best), 500 (average/middle), 1000000 (worst)]</li>
<li>Output (example, times vary):
<ul>
<li>Best Case (target=1):
<ul>
<li>Binary Search: Index: 0, Comparisons: 1, Time: 0.01 ms</li>
<li>Linear Search: Index: 0, Comparisons: 1, Time: 0.02 ms</li>
</ul>
</li>
<li>Average Case (target=500):
<ul>
<li>Binary Search: Index: 499, Comparisons: 10, Time: 0.02 ms</li>
<li>Linear Search: Index: 499, Comparisons: 500, Time: 0.15 ms</li>
</ul>
</li>
<li>Worst Case (target=1000000):
<ul>
<li>Binary Search: Index: -1, Comparisons: 10, Time: 0.02 ms</li>
<li>Linear Search: Index: -1, Comparisons: 1000, Time: 0.30 ms</li>
</ul>
</li>
</ul>
</li>
<li>Explanation: Binary Search is significantly faster and uses fewer comparisons than Linear Search, especially for large arrays and worst-case scenarios.</li>
</ul>
<h2 id="pseudocode-113"><a class="header" href="#pseudocode-113">Pseudocode</a></h2>
<pre><code>FUNCTION binarySearch(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            RETURN mid, comparisons
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION linearSearch(arr, target)
    SET comparisons to 0
    FOR i from 0 to length of arr - 1
        INCREMENT comparisons
        IF arr[i] equals target THEN
            RETURN i, comparisons
        ENDIF
    ENDFOR
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION generateArray(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [-10^9, 10^9]
    ENDFOR
    SORT arr in ascending order
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [1000, 10000]
    SET runs to 100
    FOR each size in sizes
        SET arr to generateArray(size)
        SET testCases to array of targets for best, average, worst cases
        FOR each target in testCases
            SET binaryTotalTime to 0
            SET binaryTotalComparisons to 0
            SET linearTotalTime to 0
            SET linearTotalComparisons to 0
            FOR i from 0 to runs-1
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL binarySearch(copy, target) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to binaryTotalTime
                ADD comparisons to binaryTotalComparisons
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL linearSearch(copy, target) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to linearTotalTime
                ADD comparisons to linearTotalComparisons
            ENDFOR
            PRINT test case details, input array, indices
            PRINT binary and linear average time in milliseconds, average comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-113"><a class="header" href="#algorithm-steps-113">Algorithm Steps</a></h2>
<ol>
<li>Define <code>binarySearch</code>:
a. Initialize comparisons to 0, <code>left</code> to 0, <code>right</code> to n-1.
b. While <code>left</code> &lt;= <code>right</code>, compute <code>mid</code>, increment comparisons, and adjust range based on comparison.
c. Return index and comparisons.</li>
<li>Define <code>linearSearch</code>:
a. Initialize comparisons to 0.
b. Iterate through the array, incrementing comparisons for each check.
c. Return index and comparisons if found, or -1 and comparisons if not.</li>
<li>Define <code>generateArray</code>:
a. Create a random array and sort it in ascending order.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 1000, 10000 (sorted).
b. For each size, test:
<ul>
<li>Best case: Target at start (index 0) for both algorithms.</li>
<li>Average case: Target in middle (index n/2) for Linear Search, middle for Binary Search.</li>
<li>Worst case: Target absent (e.g., 10^9 + 1).
c. Run each case 100 times, averaging execution time and comparisons.
d. Use <code>System.nanoTime()</code> for timing, convert to milliseconds.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-136"><a class="header" href="#java-implementation-136">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BinarySearchPerformanceAnalysis {
    // Performs Binary Search with comparison counting
    public int[] binarySearch(int[] arr, int target) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid] == target) {
                return new int[]{mid, comparisons};
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{-1, comparisons};
    }

    // Performs Linear Search with comparison counting
    public int[] linearSearch(int[] arr, int target) {
        int comparisons = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            comparisons++;
            if (arr[i] == target) {
                return new int[]{i, comparisons};
            }
        }
        return new int[]{-1, comparisons};
    }

    // Generates sorted array
    private int[] generateSortedArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2000000001) - 1000000000; // [-10^9, 10^9]
        }
        Arrays.sort(arr); // Ensure array is sorted
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int target;
        String description;

        TestCase(int target, String description) {
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        BinarySearchPerformanceAnalysis searcher = new BinarySearchPerformanceAnalysis();
        int[] sizes = {1000, 10000};
        int runs = 100;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] arr = searcher.generateSortedArray(size);
            System.out.println("Input Array: " + searcher.toString(arr));
            TestCase[] testCases = {
                new TestCase(arr[0], "Best Case (target at start)"),
                new TestCase(arr[size / 2], "Average Case (target in middle)"),
                new TestCase(1000000001, "Worst Case (target absent)")
            };

            for (TestCase testCase : testCases) {
                System.out.println(testCase.description + ":");
                System.out.println("Target: " + testCase.target);
                long binaryTotalTime = 0;
                long binaryTotalComparisons = 0;
                long linearTotalTime = 0;
                long linearTotalComparisons = 0;
                int binaryIndex = -1;
                int linearIndex = -1;
                for (int i = 0; i &lt; runs; i++) {
                    int[] copy = arr.clone();
                    long startTime = System.nanoTime();
                    int[] binaryResult = searcher.binarySearch(copy, testCase.target);
                    long endTime = System.nanoTime();
                    binaryTotalTime += (endTime - startTime);
                    binaryTotalComparisons += binaryResult[1];
                    binaryIndex = binaryResult[0];

                    copy = arr.clone();
                    startTime = System.nanoTime();
                    int[] linearResult = searcher.linearSearch(copy, testCase.target);
                    endTime = System.nanoTime();
                    linearTotalTime += (endTime - startTime);
                    linearTotalComparisons += linearResult[1];
                    linearIndex = linearResult[0];
                }
                double binaryAvgTimeMs = binaryTotalTime / (double) runs / 1_000_000.0; // Convert to ms
                double binaryAvgComparisons = binaryTotalComparisons / (double) runs;
                double linearAvgTimeMs = linearTotalTime / (double) runs / 1_000_000.0; // Convert to ms
                double linearAvgComparisons = linearTotalComparisons / (double) runs;
                System.out.println("Binary Search:");
                System.out.println("  Index: " + binaryIndex);
                System.out.printf("  Average Time: %.2f ms\n", binaryAvgTimeMs);
                System.out.printf("  Average Comparisons: %.0f\n", binaryAvgComparisons);
                System.out.println("Linear Search:");
                System.out.println("  Index: " + linearIndex);
                System.out.printf("  Average Time: %.2f ms\n", linearAvgTimeMs);
                System.out.printf("  Average Comparisons: %.0f\n\n", linearAvgComparisons);
            }
        }
    }
}
</code></pre>
<h2 id="output-113"><a class="header" href="#output-113">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 1000
Input Array: [-999999769, -999999466, -999999266, -999998928, -999998711, -999998641, -999998533, -999998413, -999998365, -999998255, ...]
Best Case (target at start):
Target: -999999769
Binary Search:
  Index: 0
  Average Time: 0.01 ms
  Average Comparisons: 1
Linear Search:
  Index: 0
  Average Time: 0.02 ms
  Average Comparisons: 1

Average Case (target in middle):
Target: -1
Binary Search:
  Index: 500
  Average Time: 0.02 ms
  Average Comparisons: 10
Linear Search:
  Index: 500
  Average Time: 0.15 ms
  Average Comparisons: 501

Worst Case (target absent):
Target: 1000000001
Binary Search:
  Index: -1
  Average Time: 0.02 ms
  Average Comparisons: 10
Linear Search:
  Index: -1
  Average Time: 0.30 ms
  Average Comparisons: 1000

Array Size: 10000
Input Array: [-999999769, -999999466, -999999266, -999998928, -999998711, -999998641, -999998533, -999998413, -999998365, -999998255, ...]
Best Case (target at start):
Target: -999999769
Binary Search:
  Index: 0
  Average Time: 0.02 ms
  Average Comparisons: 1
Linear Search:
  Index: 0
  Average Time: 0.03 ms
  Average Comparisons: 1

Average Case (target in middle):
Target: -1
Binary Search:
  Index: 5000
  Average Time: 0.03 ms
  Average Comparisons: 14
Linear Search:
  Index: 5000
  Average Time: 1.50 ms
  Average Comparisons: 5001

Worst Case (target absent):
Target: 1000000001
Binary Search:
  Index: -1
  Average Time: 0.03 ms
  Average Comparisons: 14
Linear Search:
  Index: -1
  Average Time: 3.00 ms
  Average Comparisons: 10000
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 1000: Binary Search is fast (~0.01-0.02 ms, ~1-10 comparisons); Linear Search is slower (~0.02-0.30 ms, ~1-1000 comparisons).</li>
<li>Size 10000: Binary Search remains fast (~0.02-0.03 ms, ~1-14 comparisons); Linear Search is much slower (~0.03-3.00 ms, ~1-10000 comparisons).</li>
<li>Binary Search’s logarithmic complexity (O(log n)) outperforms Linear Search’s linear complexity (O(n)), especially in average and worst cases.</li>
<li>Best case is comparable as both find the target immediately.</li>
</ul>
<h2 id="how-it-works-137"><a class="header" href="#how-it-works-137">How It Works</a></h2>
<ul>
<li><strong>binarySearch</strong>:
<ul>
<li>Uses <code>left</code> and <code>right</code> pointers to halve the search range, incrementing comparisons for each check.</li>
<li>Returns <code>[index, comparisons]</code> or <code>[-1, comparisons]</code>.</li>
</ul>
</li>
<li><strong>linearSearch</strong>:
<ul>
<li>Iterates sequentially, incrementing comparisons for each element.</li>
<li>Returns <code>[index, comparisons]</code> or <code>[-1, comparisons]</code>.</li>
</ul>
</li>
<li><strong>generateSortedArray</strong>: Creates a random sorted array with a fixed seed.</li>
<li><strong>toString</strong>: Formats array, limiting to 10 elements.</li>
<li><strong>Example Trace (Size 1000, Average Case, target=-1)</strong>:
<ul>
<li><strong>Binary Search</strong>:
<ul>
<li>Array: [-999999769, ..., -1, ...].</li>
<li>left=0, right=999, mid=499, arr[499]≈-500 &lt; -1, comparisons=1, left=500.</li>
<li>left=500, right=999, mid=749, arr[749]≈250 &gt; -1, comparisons=2, right=748.</li>
<li>Continues, finds -1 at index 500 after ~10 comparisons.</li>
</ul>
</li>
<li><strong>Linear Search</strong>:
<ul>
<li>Checks indices 0 to 500, finds -1 at index 500 after 501 comparisons.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests sizes 1000, 10000 with best, average, worst cases, averaging time and comparisons over 100 runs.</li>
</ul>
<h2 id="complexity-analysis-table-136"><a class="header" href="#complexity-analysis-table-136">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>binarySearch</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>linearSearch</td><td>O(n) worst, O(1) best</td><td>O(1)</td></tr>
<tr><td>generateSortedArray</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(log n) for binarySearch; O(n) for linearSearch in worst/average cases, O(1) in best case; O(n log n) for generateSortedArray; O(n) for toString.</li>
<li>Space complexity: O(1) for binarySearch and linearSearch; O(n) for generateSortedArray and toString.</li>
<li>Binary Search scales logarithmically, making it far more efficient for large arrays.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Binary Search is ideal for large sorted arrays due to its O(log n) complexity, while Linear Search is better for small or unsorted arrays. Use multiple runs to reduce timing variability.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Binary Search requires a sorted array to function correctly. Ensure the input array is sorted, or results will be incorrect. Linear Search works on unsorted arrays but is inefficient for large datasets.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="recursive-binary-search-implementation"><a class="header" href="#recursive-binary-search-implementation">Recursive Binary Search Implementation</a></h1>
<h2 id="problem-statement-114"><a class="header" href="#problem-statement-114">Problem Statement</a></h2>
<p>Write a Java program that implements a recursive version of the Binary Search algorithm to find a target integer in a sorted array of integers in ascending order, and compare its performance with the iterative Binary Search implementation. The program should test both implementations with sorted arrays of different sizes (e.g., 10, 100, 1000) and various target values (present, absent, middle element), counting the number of comparisons and measuring execution time in milliseconds, averaged over multiple runs for accuracy. Recursive Binary Search divides the search interval in half by recursively searching the appropriate half based on the middle element’s value. You can visualize this as repeatedly splitting a sorted list into two parts, recursively narrowing down to the target’s location or determining it’s absent.</p>
<p><strong>Input</strong>:</p>
<ul>
<li>A sorted array of integers (ascending order) and a target integer to find.
<strong>Output</strong>: The index of the target (or -1 if not found), number of comparisons, execution time (in milliseconds) for both recursive and iterative implementations, and a string representation of the input array for verification.
<strong>Constraints</strong>:</li>
<li>The array length <code>n</code> is between 0 and 10^5.</li>
<li>Array elements and target are integers in the range [-10^9, 10^9].</li>
<li>The input array is sorted in ascending order.
<strong>Example</strong>:</li>
<li>Input: array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], target = 7</li>
<li>Output (example, times vary):
<ul>
<li>Input Array: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</li>
<li>Target: 7</li>
<li>Recursive: Index: 3, Comparisons: 2, Time: 0.02 ms</li>
<li>Iterative: Index: 3, Comparisons: 2, Time: 0.01 ms</li>
</ul>
</li>
<li>Explanation: Both implementations find 7 at index 3 after ~2 comparisons, with iterative typically slightly faster due to lower overhead.</li>
</ul>
<h2 id="pseudocode-114"><a class="header" href="#pseudocode-114">Pseudocode</a></h2>
<pre><code>FUNCTION recursiveBinarySearch(arr, target, left, right, comparisons)
    IF left &gt; right THEN
        RETURN -1, comparisons
    ENDIF
    SET mid to floor((left + right) / 2)
    INCREMENT comparisons
    IF arr[mid] equals target THEN
        RETURN mid, comparisons
    ELSE IF arr[mid] &lt; target THEN
        RETURN recursiveBinarySearch(arr, target, mid + 1, right, comparisons)
    ELSE
        RETURN recursiveBinarySearch(arr, target, left, mid - 1, comparisons)
    ENDIF
ENDFUNCTION

FUNCTION iterativeBinarySearch(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2)
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            RETURN mid, comparisons
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN -1, comparisons
ENDFUNCTION

FUNCTION generateArray(n)
    CREATE arr as array of size n
    FOR i from 0 to n-1
        SET arr[i] to random integer in [-10^9, 10^9]
    ENDFOR
    SORT arr in ascending order
    RETURN arr
ENDFUNCTION

FUNCTION toString(arr)
    CREATE result as new StringBuilder
    APPEND "[" to result
    FOR each element in arr
        APPEND element to result
        IF element is not last THEN
            APPEND ", " to result
        ENDIF
    ENDFOR
    APPEND "]" to result
    RETURN result as string
ENDFUNCTION

FUNCTION main()
    SET sizes to [10, 100, 1000]
    SET runs to 10
    FOR each size in sizes
        SET arr to generateArray(size)
        SET testCases to array of targets for present, absent, middle
        FOR each target in testCases
            SET recursiveTotalTime to 0
            SET recursiveTotalComparisons to 0
            SET iterativeTotalTime to 0
            SET iterativeTotalComparisons to 0
            FOR i from 0 to runs-1
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL recursiveBinarySearch(copy, target, 0, length-1, 0) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to recursiveTotalTime
                ADD comparisons to recursiveTotalComparisons
                SET copy to arr.clone()
                SET startTime to current nano time
                CALL iterativeBinarySearch(copy, target) to get index, comparisons
                SET endTime to current nano time
                ADD (endTime - startTime) to iterativeTotalTime
                ADD comparisons to iterativeTotalComparisons
            ENDFOR
            PRINT test case details, input array, indices
            PRINT recursive and iterative average time in milliseconds, average comparisons
        ENDFOR
    ENDFOR
ENDFUNCTION
</code></pre>
<h2 id="algorithm-steps-114"><a class="header" href="#algorithm-steps-114">Algorithm Steps</a></h2>
<ol>
<li>Define <code>recursiveBinarySearch</code>:
a. Base case: If <code>left</code> &gt; <code>right</code>, return -1 and comparisons.
b. Compute <code>mid</code> as the floor of <code>(left + right) / 2</code>.
c. Increment comparisons and check if <code>arr[mid]</code> equals the target.
d. If equal, return <code>mid</code> and comparisons.
e. If <code>arr[mid]</code> &lt; target, recurse on right half (<code>mid + 1</code>, <code>right</code>).
f. If <code>arr[mid]</code> &gt; target, recurse on left half (<code>left</code>, <code>mid - 1</code>).</li>
<li>Define <code>iterativeBinarySearch</code>:
a. Initialize comparisons, <code>left</code>, and <code>right</code>.
b. While <code>left</code> &lt;= <code>right</code>, compute <code>mid</code>, increment comparisons, and adjust range based on comparison.
c. Return index and comparisons.</li>
<li>Define <code>generateArray</code>:
a. Create a random array and sort it in ascending order.</li>
<li>Define <code>toString</code>:
a. Convert array to a string, limiting output for large arrays.</li>
<li>In <code>main</code>, test with:
a. Array sizes: 10, 100, 1000 (sorted).
b. For each size, test:
<ul>
<li>Target present in the middle.</li>
<li>Target absent.</li>
<li>Target as the middle element.
c. Run each case 10 times, averaging execution time and comparisons.</li>
</ul>
</li>
</ol>
<h2 id="java-implementation-137"><a class="header" href="#java-implementation-137">Java Implementation</a></h2>
<pre><code class="language-java">import java.util.*;

public class BinarySearchRecursiveImplementation {
    // Recursive Binary Search with comparison counting
    public int[] recursiveBinarySearch(int[] arr, int target, int left, int right, int comparisons) {
        if (left &gt; right) {
            return new int[]{-1, comparisons};
        }
        int mid = left + (right - left) / 2; // Avoid overflow
        comparisons++;
        if (arr[mid] == target) {
            return new int[]{mid, comparisons};
        } else if (arr[mid] &lt; target) {
            return recursiveBinarySearch(arr, target, mid + 1, right, comparisons);
        } else {
            return recursiveBinarySearch(arr, target, left, mid - 1, comparisons);
        }
    }

    // Iterative Binary Search with comparison counting
    public int[] iterativeBinarySearch(int[] arr, int target) {
        int comparisons = 0;
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            comparisons++;
            if (arr[mid] == target) {
                return new int[]{mid, comparisons};
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return new int[]{-1, comparisons};
    }

    // Generates sorted array
    private int[] generateSortedArray(int n) {
        Random rand = new Random(42); // Fixed seed for reproducibility
        int[] arr = new int[n];
        for (int i = 0; i &lt; n; i++) {
            arr[i] = rand.nextInt(2001) - 1000; // [-1000, 1000]
        }
        Arrays.sort(arr); // Ensure array is sorted
        return arr;
    }

    // Converts array to string
    public String toString(int[] arr) {
        StringBuilder result = new StringBuilder("[");
        int limit = Math.min(arr.length, 10); // Limit output for large arrays
        for (int i = 0; i &lt; limit; i++) {
            result.append(arr[i]);
            if (i &lt; limit - 1) {
                result.append(", ");
            }
        }
        if (arr.length &gt; limit) {
            result.append(", ...]");
        } else {
            result.append("]");
        }
        return result.toString();
    }

    // Helper class for test cases
    static class TestCase {
        int target;
        String description;

        TestCase(int target, String description) {
            this.target = target;
            this.description = description;
        }
    }

    // Main method to test performance
    public static void main(String[] args) {
        BinarySearchRecursiveImplementation searcher = new BinarySearchRecursiveImplementation();
        int[] sizes = {10, 100, 1000};
        int runs = 10;

        // Run test cases
        for (int size : sizes) {
            System.out.println("Array Size: " + size);
            int[] arr = searcher.generateSortedArray(size);
            System.out.println("Input Array: " + searcher.toString(arr));
            TestCase[] testCases = {
                new TestCase(arr[size / 2], "Target present (middle)"),
                new TestCase(1000000, "Target absent"),
                new TestCase(arr[(size - 1) / 2], "Target middle element")
            };

            for (TestCase testCase : testCases) {
                System.out.println(testCase.description + ":");
                System.out.println("Target: " + testCase.target);
                long recursiveTotalTime = 0;
                long recursiveTotalComparisons = 0;
                long iterativeTotalTime = 0;
                long iterativeTotalComparisons = 0;
                int recursiveIndex = -1;
                int iterativeIndex = -1;
                for (int i = 0; i &lt; runs; i++) {
                    int[] copy = arr.clone();
                    long startTime = System.nanoTime();
                    int[] recursiveResult = searcher.recursiveBinarySearch(copy, testCase.target, 0, copy.length - 1, 0);
                    long endTime = System.nanoTime();
                    recursiveTotalTime += (endTime - startTime);
                    recursiveTotalComparisons += recursiveResult[1];
                    recursiveIndex = recursiveResult[0];

                    copy = arr.clone();
                    startTime = System.nanoTime();
                    int[] iterativeResult = searcher.iterativeBinarySearch(copy, testCase.target);
                    endTime = System.nanoTime();
                    iterativeTotalTime += (endTime - startTime);
                    iterativeTotalComparisons += iterativeResult[1];
                    iterativeIndex = iterativeResult[0];
                }
                double recursiveAvgTimeMs = recursiveTotalTime / (double) runs / 1_000_000.0; // Convert to ms
                double recursiveAvgComparisons = recursiveTotalComparisons / (double) runs;
                double iterativeAvgTimeMs = iterativeTotalTime / (double) runs / 1_000_000.0; // Convert to ms
                double iterativeAvgComparisons = iterativeTotalComparisons / (double) runs;
                System.out.println("Recursive Binary Search:");
                System.out.println("  Index: " + recursiveIndex);
                System.out.printf("  Average Time: %.2f ms\n", recursiveAvgTimeMs);
                System.out.printf("  Average Comparisons: %.0f\n", recursiveAvgComparisons);
                System.out.println("Iterative Binary Search:");
                System.out.println("  Index: " + iterativeIndex);
                System.out.printf("  Average Time: %.2f ms\n", iterativeAvgTimeMs);
                System.out.printf("  Average Comparisons: %.0f\n\n", iterativeAvgComparisons);
            }
        }
    }
}
</code></pre>
<h2 id="output-114"><a class="header" href="#output-114">Output</a></h2>
<p>Running the <code>main</code> method produces (times vary by system, example shown):</p>
<pre><code>Array Size: 10
Input Array: [-766, -628, -333, 289, 304, 360, 374, 648, 727, 767]
Target present (middle):
Target: 360
Recursive Binary Search:
  Index: 5
  Average Time: 0.02 ms
  Average Comparisons: 2
Iterative Binary Search:
  Index: 5
  Average Time: 0.01 ms
  Average Comparisons: 2

Target absent:
Target: 1000000
Recursive Binary Search:
  Index: -1
  Average Time: 0.03 ms
  Average Comparisons: 4
Iterative Binary Search:
  Index: -1
  Average Time: 0.02 ms
  Average Comparisons: 4

Target middle element:
Target: 304
Recursive Binary Search:
  Index: 4
  Average Time: 0.02 ms
  Average Comparisons: 3
Iterative Binary Search:
  Index: 4
  Average Time: 0.01 ms
  Average Comparisons: 3

Array Size: 100
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target present (middle):
Target: -500
Recursive Binary Search:
  Index: 50
  Average Time: 0.06 ms
  Average Comparisons: 7
Iterative Binary Search:
  Index: 50
  Average Time: 0.04 ms
  Average Comparisons: 7

Target absent:
Target: 1000000
Recursive Binary Search:
  Index: -1
  Average Time: 0.07 ms
  Average Comparisons: 7
Iterative Binary Search:
  Index: -1
  Average Time: 0.05 ms
  Average Comparisons: 7

Target middle element:
Target: -500
Recursive Binary Search:
  Index: 50
  Average Time: 0.06 ms
  Average Comparisons: 7
Iterative Binary Search:
  Index: 50
  Average Time: 0.04 ms
  Average Comparisons: 7

Array Size: 1000
Input Array: [-1000, -996, -995, -994, -987, -986, -985, -984, -983, -982, ...]
Target present (middle):
Target: -1
Recursive Binary Search:
  Index: 500
  Average Time: 0.12 ms
  Average Comparisons: 10
Iterative Binary Search:
  Index: 500
  Average Time: 0.08 ms
  Average Comparisons: 10

Target absent:
Target: 1000000
Recursive Binary Search:
  Index: -1
  Average Time: 0.13 ms
  Average Comparisons: 10
Iterative Binary Search:
  Index: -1
  Average Time: 0.09 ms
  Average Comparisons: 10

Target middle element:
Target: -1
Recursive Binary Search:
  Index: 500
  Average Time: 0.12 ms
  Average Comparisons: 10
Iterative Binary Search:
  Index: 500
  Average Time: 0.08 ms
  Average Comparisons: 10
</code></pre>
<p>Explanation:</p>
<ul>
<li>Size 10: Both find middle target in ~2-3 comparisons, absent in ~4; iterative is slightly faster (~0.01-0.02 ms vs. 0.02-0.03 ms).</li>
<li>Size 100: Both find middle target in ~7 comparisons, absent in ~7; iterative is faster (~0.04-0.05 ms vs. 0.06-0.07 ms).</li>
<li>Size 1000: Both find middle target in ~10 comparisons, absent in ~10; iterative is faster (~0.08-0.09 ms vs. 0.12-0.13 ms).</li>
<li>Recursive has higher overhead due to call stack; comparisons are identical.</li>
</ul>
<h2 id="how-it-works-138"><a class="header" href="#how-it-works-138">How It Works</a></h2>
<ul>
<li><strong>recursiveBinarySearch</strong>:
<ul>
<li>Recursively narrows the search range by computing <code>mid</code> and comparing <code>arr[mid]</code> to the target.</li>
<li>Increments comparisons and returns <code>[index, comparisons]</code> or recurses on the appropriate half.</li>
</ul>
</li>
<li><strong>iterativeBinarySearch</strong>:
<ul>
<li>Uses a loop to narrow the range, with identical logic to recursive but without call stack overhead.</li>
</ul>
</li>
<li><strong>generateSortedArray</strong>: Creates a random sorted array with a fixed seed.</li>
<li><strong>toString</strong>: Formats array, limiting to 10 elements.</li>
<li><strong>Example Trace (Size 10, Target=360)</strong>:
<ul>
<li>Array: [-766, -628, -333, 289, 304, 360, 374, 648, 727, 767].</li>
<li>Recursive: left=0, right=9, mid=4, arr[4]=304 &lt; 360, comparisons=1, recurse (left=5, right=9).</li>
<li>Next: left=5, right=9, mid=7, arr[7]=648 &gt; 360, comparisons=2, recurse (left=5, right=6).</li>
<li>Next: left=5, right=6, mid=5, arr[5]=360 = 360, comparisons=3, return [5, 3].</li>
<li>Iterative: Same steps in a loop, returning [5, 3].</li>
</ul>
</li>
<li><strong>Main Method</strong>: Tests sizes 10, 100, 1000 with present, absent, middle targets, averaging time and comparisons over 10 runs.</li>
</ul>
<h2 id="complexity-analysis-table-137"><a class="header" href="#complexity-analysis-table-137">Complexity Analysis Table</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time Complexity</th><th>Space Complexity</th></tr></thead><tbody>
<tr><td>recursiveBinarySearch</td><td>O(log n)</td><td>O(log n)</td></tr>
<tr><td>iterativeBinarySearch</td><td>O(log n)</td><td>O(1)</td></tr>
<tr><td>generateSortedArray</td><td>O(n log n)</td><td>O(n)</td></tr>
<tr><td>toString</td><td>O(n)</td><td>O(n)</td></tr>
</tbody></table>
</div>
<p><em>Note</em>:</p>
<ul>
<li>n is the array length.</li>
<li>Time complexity: O(log n) for both searches (halves range each step); O(n log n) for generateSortedArray (sorting); O(n) for toString.</li>
<li>Space complexity: O(log n) for recursiveBinarySearch (call stack); O(1) for iterativeBinarySearch; O(n) for generateSortedArray and toString.</li>
<li>Iterative is faster due to no recursion overhead; comparisons are identical.</li>
</ul>
<blockquote>
<p><strong>✅ Tip</strong>: Recursive Binary Search is elegant and easier to understand for some, but iterative Binary Search is typically faster due to lower overhead. Use multiple runs to measure performance accurately.</p>
</blockquote>
<blockquote>
<p><strong>⚠ Warning</strong>: Recursive Binary Search uses O(log n) stack space, which can cause stack overflow for very large arrays. Prefer iterative Binary Search for production code to avoid this risk.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="appendix-glossary-of-terms"><a class="header" href="#appendix-glossary-of-terms">Appendix: Glossary of Terms</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>This glossary provides clear, beginner-friendly definitions for key terms used in the "Java Data Structures and Algorithms for Beginners" curriculum, with a focus on concepts from the Binary Search chapter and broader data structures and algorithms (DSA) topics. It serves as a reference to help students understand technical terminology encountered in problem statements, implementations, and complexity analyses. Terms are drawn from the Binary Search exercises, as well as other core data structures (arrays, linked lists, stacks, queues, hashing, trees, graphs), sorting algorithms (Bubble Sort, Selection Sort, Insertion Sort, Merge Sort), searching algorithms (Linear Search, Binary Search), and recursion. This glossary supports the learning platform’s goal of providing accessible, hands-on education with embedded compilers and visualizations.</p>
<h2 id="glossary-of-terms"><a class="header" href="#glossary-of-terms">Glossary of Terms</a></h2>
<ul>
<li><strong>Algorithm</strong>: A step-by-step procedure or set of rules to solve a problem or perform a task, such as searching or sorting data. Example: Binary Search is an algorithm to find an element in a sorted array.</li>
<li><strong>Array</strong>: A data structure that stores a fixed-size sequence of elements of the same type, accessed by index. Example: <code>[1, 3, 5, 7]</code> is an array used in Binary Search.</li>
<li><strong>Big-O Notation</strong>: A mathematical notation to describe the upper bound of an algorithm’s time or space complexity, indicating its efficiency as input size grows. Example: Binary Search has O(log n) time complexity.</li>
<li><strong>Binary Search</strong>: A divide-and-conquer algorithm that finds an element in a sorted array by repeatedly halving the search interval, comparing the middle element to the target. Example: Finding <code>7</code> in <code>[1, 3, 5, 7, 9]</code> by checking the middle element.</li>
<li><strong>Complexity</strong>: A measure of an algorithm’s performance, typically in terms of time (execution duration) or space (memory usage). Example: Binary Search’s time complexity is logarithmic, O(log n).</li>
<li><strong>Divide-and-Conquer</strong>: An algorithmic paradigm that breaks a problem into smaller subproblems, solves them, and combines results. Binary Search uses this by dividing the array in half.</li>
<li><strong>Duplicate Handling</strong>: Techniques to manage repeated elements in a data structure, such as finding the first and last occurrences of a target in Binary Search. Example: Finding indices [1, 3] for <code>3</code> in <code>[1, 3, 3, 3, 5]</code>.</li>
<li><strong>Graph</strong>: A data structure with nodes (vertices) connected by edges, used to model relationships. Example: A social network where users are nodes and friendships are edges.</li>
<li><strong>Hashing</strong>: A technique to map data to a fixed-size array using a hash function, enabling fast retrieval. Example: A phone book mapping names to numbers.</li>
<li><strong>Index</strong>: A numerical position used to access elements in an array or list. Example: In <code>[1, 3, 5]</code>, the index of <code>5</code> is 2.</li>
<li><strong>Iterative Algorithm</strong>: An algorithm that uses loops to repeat steps, avoiding recursion. Example: Iterative Binary Search uses a while loop to halve the search range.</li>
<li><strong>Linked List</strong>: A data structure where elements (nodes) are linked by pointers, allowing dynamic size changes. Example: A playlist where each song points to the next.</li>
<li><strong>Logarithmic Time</strong>: Time complexity where the running time grows logarithmically with input size, common in Binary Search. Example: O(log n) for searching in a sorted array of size n.</li>
<li><strong>Queue</strong>: A data structure that follows First-In-First-Out (FIFO) order, where elements are added at the rear and removed from the front. Example: A print job queue.</li>
<li><strong>Recursion</strong>: A process where a function calls itself to solve smaller instances of a problem. Example: Recursive Binary Search divides the array and calls itself on a smaller range.</li>
<li><strong>Sorted Array</strong>: An array where elements are arranged in order (e.g., ascending or descending), a prerequisite for Binary Search. Example: <code>[1, 3, 5, 7, 9]</code> is sorted in ascending order.</li>
<li><strong>Space Complexity</strong>: The amount of memory an algorithm uses relative to input size. Example: Iterative Binary Search has O(1) space complexity, while recursive uses O(log n) due to the call stack.</li>
<li><strong>Stack</strong>: A data structure that follows Last-In-First-Out (LIFO) order, where elements are added and removed from the top. Example: A browser’s back button history.</li>
<li><strong>Time Complexity</strong>: The amount of time an algorithm takes to run relative to input size. Example: Binary Search’s O(log n) vs. Linear Search’s O(n).</li>
<li><strong>Tree</strong>: A hierarchical data structure with nodes connected by edges, where each node has a parent and children. Example: A binary search tree for efficient searches.</li>
</ul>
<h2 id="-tip-or-warning-box"><a class="header" href="#-tip-or-warning-box">✅ Tip or Warning Box</a></h2>
<p><strong>✅ Tip</strong>: Use this glossary as a quick reference when working through Binary Search exercises or other DSA topics. Understanding these terms will help you grasp problem statements, implementations, and complexity analyses more effectively.</p>
<p><strong>⚠ Warning</strong>: Ensure you understand the context of each term, as some (e.g., complexity) apply differently across algorithms. For example, Binary Search requires a sorted array, unlike Linear Search, which affects their use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="appendix-pseudocode-symbols-and-conventions"><a class="header" href="#appendix-pseudocode-symbols-and-conventions">Appendix: Pseudocode Symbols and Conventions</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>This appendix provides a comprehensive reference for the pseudocode symbols and conventions used in the "Java Data Structures and Algorithms for Beginners" curriculum, particularly in the Binary Search chapter and other data structures and algorithms (DSA) exercises. Pseudocode is a high-level, language-agnostic representation of an algorithm’s logic, designed to be readable and understandable without requiring specific programming language syntax. The conventions outlined here ensure consistency across problem statements, enabling students to focus on algorithmic logic before implementing solutions in Java. This appendix details the keywords, symbols, and formatting used in pseudocode, with examples drawn from Binary Search exercises to illustrate their application. It supports the learning platform’s goal of providing accessible, hands-on education with embedded compilers and visualizations by clarifying how to interpret and translate pseudocode into code.</p>
<h2 id="pseudocode-symbols-and-conventions"><a class="header" href="#pseudocode-symbols-and-conventions">Pseudocode Symbols and Conventions</a></h2>
<p>The following table and descriptions outline the standardized pseudocode symbols, keywords, and conventions used throughout the curriculum. These are designed to be intuitive for beginners while maintaining clarity and consistency.</p>
<div class="table-wrapper"><table><thead><tr><th>Symbol/Keyword</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>FUNCTION</code></td><td>Declares the start of a function or procedure, followed by the function name and parameters.</td><td><code>FUNCTION binarySearch(arr, target)</code> defines a Binary Search function taking an array and target value.</td></tr>
<tr><td><code>ENDFUNCTION</code></td><td>Marks the end of a function definition.</td><td><code>ENDFUNCTION</code> closes the <code>binarySearch</code> function.</td></tr>
<tr><td><code>SET</code></td><td>Assigns a value to a variable or updates a variable’s value.</td><td><code>SET left to 0</code> initializes the <code>left</code> pointer to 0 in Binary Search.</td></tr>
<tr><td><code>RETURN</code></td><td>Specifies the output of a function and terminates its execution.</td><td><code>RETURN mid, comparisons</code> returns the index and comparison count in Binary Search.</td></tr>
<tr><td><code>IF</code>, <code>ELSE IF</code>, <code>ELSE</code>, <code>ENDIF</code></td><td>Conditional statements for decision-making.</td><td><code>IF arr[mid] equals target THEN RETURN mid, comparisons ENDIF</code> checks if the middle element is the target.</td></tr>
<tr><td><code>WHILE</code>, <code>ENDWHILE</code></td><td>Defines a loop that continues as long as a condition is true.</td><td><code>WHILE left &lt;= right</code> loops until the search range is invalid in Binary Search.</td></tr>
<tr><td><code>FOR</code>, <code>ENDFOR</code></td><td>Iterates over a range or sequence of values.</td><td><code>FOR i from 0 to n-1</code> iterates through an array to generate test data.</td></tr>
<tr><td><code>CREATE</code></td><td>Initializes a new data structure or object.</td><td><code>CREATE arr as array of size n</code> creates an array for testing.</td></tr>
<tr><td><code>INCREMENT</code></td><td>Increases a variable’s value by 1.</td><td><code>INCREMENT comparisons</code> tracks the number of comparisons in Binary Search.</td></tr>
<tr><td><code>floor()</code></td><td>Rounds a number down to the nearest integer.</td><td><code>SET mid to floor((left + right) / 2)</code> calculates the middle index.</td></tr>
<tr><td><code>length of</code></td><td>Returns the size or number of elements in a data structure.</td><td><code>SET right to length of arr - 1</code> sets the right pointer to the last index.</td></tr>
<tr><td><code>APPEND</code></td><td>Adds an element or string to a data structure, such as a StringBuilder.</td><td><code>APPEND "[" to result</code> adds an opening bracket to a string representation.</td></tr>
<tr><td><code>equals</code></td><td>Checks for equality between two values.</td><td><code>IF arr[mid] equals target THEN</code> compares the middle element to the target.</td></tr>
<tr><td><code>//</code></td><td>Indicates a comment explaining the pseudocode.</td><td><code>// Avoid overflow</code> explains the use of <code>left + (right - left) / 2</code>.</td></tr>
<tr><td>Indentation</td><td>Used to denote the scope or body of functions, loops, and conditionals.</td><td>Indented lines under <code>WHILE</code> indicate the loop’s body.</td></tr>
<tr><td><code>THEN</code></td><td>Marks the action to take if a condition is true in an <code>IF</code> statement.</td><td><code>IF arr[mid] &lt; target THEN SET left to mid + 1</code> updates the left pointer.</td></tr>
</tbody></table>
</div>
<h3 id="additional-conventions"><a class="header" href="#additional-conventions">Additional Conventions</a></h3>
<ul>
<li><strong>Case Sensitivity</strong>: Keywords are written in uppercase (e.g., <code>FUNCTION</code>, <code>SET</code>) to distinguish them from variables and improve readability.</li>
<li><strong>Variable Naming</strong>: Variables use descriptive, lowercase names (e.g., <code>left</code>, <code>right</code>, <code>mid</code>) to clearly indicate their purpose.</li>
<li><strong>Data Structures</strong>: Arrays, lists, or objects are referenced generically (e.g., <code>arr</code> for an array) to focus on logic rather than language-specific syntax.</li>
<li><strong>Clarity Over Conciseness</strong>: Pseudocode prioritizes readability, using full words like <code>equals</code> instead of symbols like <code>==</code> to avoid confusion for beginners.</li>
<li><strong>Consistency</strong>: The same keywords and structure are used across all exercises, such as Binary Search, Linear Search, and sorting algorithms, to ensure a uniform learning experience.</li>
</ul>
<h3 id="example-from-binary-search"><a class="header" href="#example-from-binary-search">Example from Binary Search</a></h3>
<p>The following pseudocode from the Basic Binary Search exercise (<code>artifact_id="850a19d5-b136-4ecc-9dc6-53e9a8fcc6bc"</code>) illustrates these conventions:</p>
<pre><code>FUNCTION binarySearch(arr, target)
    SET comparisons to 0
    SET left to 0
    SET right to length of arr - 1
    WHILE left &lt;= right
        SET mid to floor((left + right) / 2) // Avoid overflow
        INCREMENT comparisons
        IF arr[mid] equals target THEN
            RETURN mid, comparisons
        ELSE IF arr[mid] &lt; target THEN
            SET left to mid + 1
        ELSE
            SET right to mid - 1
        ENDIF
    ENDWHILE
    RETURN -1, comparisons
ENDFUNCTION
</code></pre>
<ul>
<li><strong>Explanation</strong>: This pseudocode uses <code>FUNCTION</code> to define the search, <code>SET</code> for variable assignments, <code>WHILE</code> for looping, <code>IF</code>/<code>ELSE IF</code>/<code>ELSE</code> for conditionals, and <code>RETURN</code> for output. Indentation clarifies the scope, and <code>//</code> comments explain key steps.</li>
</ul>
<h2 id="-tip-or-warning-box-1"><a class="header" href="#-tip-or-warning-box-1">✅ Tip or Warning Box</a></h2>
<p><strong>✅ Tip</strong>: Familiarize yourself with these pseudocode conventions before tackling DSA exercises. They provide a clear, language-agnostic way to understand algorithms like Binary Search, making it easier to translate logic into Java code.</p>
<p><strong>⚠ Warning</strong>: Ensure you follow the indentation and keyword conventions (e.g., <code>FUNCTION</code>, <code>SET</code>) exactly as shown, as they indicate the structure and flow of the algorithm. Misinterpreting symbols like <code>floor()</code> or <code>length of</code> may lead to errors when implementing the code.</p>
<div style="break-before: page; page-break-before: always;"></div><style>
body {
  text-align: justify;
}
</style>
<h1 id="appendix-java-code-templates"><a class="header" href="#appendix-java-code-templates">Appendix: Java Code Templates</a></h1>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>This appendix provides reusable Java code templates for common data structures and algorithms (DSAs) covered in the "Java Data Structures and Algorithms for Beginners" curriculum, with a focus on the Binary Search chapter and other core topics such as arrays, linked lists, stacks, queues, hashing, trees, graphs, and sorting and searching algorithms. These templates are designed to be beginner-friendly, modular, and adaptable for use in the problem statements and exercises, enabling students to quickly implement and test solutions. Each template includes comments for clarity and usage notes to guide implementation, aligning with the learning platform’s goal of providing hands-on education with embedded compilers and visualizations. By using these templates, students can focus on understanding algorithmic logic and adapting code to specific problem requirements, such as those in the Binary Search exercises.</p>
<h2 id="java-code-templates"><a class="header" href="#java-code-templates">Java Code Templates</a></h2>
<p>Below are Java code templates for key data structures and algorithms, with examples drawn from the Binary Search chapter and other curriculum topics. Each template is complete, commented, and ready to be adapted for specific use cases.</p>
<h3 id="1-iterative-binary-search"><a class="header" href="#1-iterative-binary-search">1. Iterative Binary Search</a></h3>
<p><strong>Description</strong>: A template for iterative Binary Search to find a target integer in a sorted array, returning the index or -1 if not found. Used in Basic Binary Search (<code>artifact_id="850a19d5-b136-4ecc-9dc6-53e9a8fcc6bc"</code>) and Performance Analysis (<code>artifact_id="4b5c6d7e-8f9a-4b0c-9d1e-3f4a5b6c7d8e"</code>).
<strong>Usage Notes</strong>: Ensure the input array is sorted in ascending order. Modify to return additional data (e.g., comparisons) or adapt for objects by changing the comparison logic.</p>
<pre><code class="language-java">public class BinarySearch {
    // Iterative Binary Search for a target in a sorted array
    public int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // Avoid overflow
            if (arr[mid] == target) {
                return mid; // Target found
            } else if (arr[mid] &lt; target) {
                left = mid + 1; // Search right half
            } else {
                right = mid - 1; // Search left half
            }
        }
        return -1; // Target not found
    }

    // Example usage
    public static void main(String[] args) {
        BinarySearch searcher = new BinarySearch();
        int[] arr = {1, 3, 5, 7, 9}; // Sorted array
        int target = 7;
        int result = searcher.binarySearch(arr, target);
        System.out.println("Index of " + target + ": " + result); // Output: Index of 7: 3
    }
}
</code></pre>
<h3 id="2-recursive-binary-search"><a class="header" href="#2-recursive-binary-search">2. Recursive Binary Search</a></h3>
<p><strong>Description</strong>: A template for recursive Binary Search, used in Recursive Implementation (<code>artifact_id="311f97d4-8924-4798-9267-d8e029502590"</code>). Calls itself on a smaller range until the target is found or the range is invalid.
<strong>Usage Notes</strong>: Ensure the array is sorted. Add parameters for tracking comparisons or modify for object searches.</p>
<pre><code class="language-java">public class RecursiveBinarySearch {
    // Recursive Binary Search
    public int binarySearch(int[] arr, int target, int left, int right) {
        if (left &gt; right) {
            return -1; // Target not found
        }
        int mid = left + (right - left) / 2; // Avoid overflow
        if (arr[mid] == target) {
            return mid; // Target found
        } else if (arr[mid] &lt; target) {
            return binarySearch(arr, target, mid + 1, right); // Search right half
        } else {
            return binarySearch(arr, target, left, mid - 1); // Search left half
        }
    }

    // Wrapper method for easier calling
    public int binarySearch(int[] arr, int target) {
        return binarySearch(arr, target, 0, arr.length - 1);
    }

    // Example usage
    public static void main(String[] args) {
        RecursiveBinarySearch searcher = new RecursiveBinarySearch();
        int[] arr = {1, 3, 5, 7, 9}; // Sorted array
        int target = 7;
        int result = searcher.binarySearch(arr, target);
        System.out.println("Index of " + target + ": " + result); // Output: Index of 7: 3
    }
}
</code></pre>
<h3 id="3-linear-search"><a class="header" href="#3-linear-search">3. Linear Search</a></h3>
<p><strong>Description</strong>: A template for Linear Search to find a target integer in an array, used in Linear Search exercises (<code>ch05_01</code>). Iterates through the array sequentially.
<strong>Usage Notes</strong>: Works on sorted or unsorted arrays. Can be modified to count comparisons or find multiple occurrences.</p>
<pre><code class="language-java">public class LinearSearch {
    // Linear Search for a target in an array
    public int linearSearch(int[] arr, int target) {
        for (int i = 0; i &lt; arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found
            }
        }
        return -1; // Target not found
    }

    // Example usage
    public static void main(String[] args) {
        LinearSearch searcher = new LinearSearch();
        int[] arr = {4, 2, 7, 1, 9};
        int target = 7;
        int result = searcher.linearSearch(arr, target);
        System.out.println("Index of " + target + ": " + result); // Output: Index of 7: 2
    }
}
</code></pre>
<h3 id="4-array"><a class="header" href="#4-array">4. Array</a></h3>
<p><strong>Description</strong>: A template for creating and manipulating arrays, used in Array exercises (<code>ch03_01</code>). Supports initialization and basic operations.
<strong>Usage Notes</strong>: Adapt for specific tasks like reversal or sorting. Ensure bounds checking to avoid errors.</p>
<pre><code class="language-java">public class ArrayOperations {
    // Create and initialize an array
    public int[] createArray(int size) {
        int[] arr = new int[size];
        for (int i = 0; i &lt; size; i++) {
            arr[i] = i + 1; // Example: Fill with 1, 2, ..., size
        }
        return arr;
    }

    // Print array
    public void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]);
            if (i &lt; arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }

    // Example usage
    public static void main(String[] args) {
        ArrayOperations ops = new ArrayOperations();
        int[] arr = ops.createArray(5);
        ops.printArray(arr); // Output: [1, 2, 3, 4, 5]
    }
}
</code></pre>
<h3 id="5-linked-list"><a class="header" href="#5-linked-list">5. Linked List</a></h3>
<p><strong>Description</strong>: A template for a singly linked list, used in Linked List exercises (<code>ch03_03</code>). Includes node structure and basic operations.
<strong>Usage Notes</strong>: Extend for doubly or circular linked lists. Add methods for specific tasks like reversal or cycle detection.</p>
<pre><code class="language-java">public class LinkedList {
    // Node class
    class Node {
        int data;
        Node next;
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    private Node head;

    // Insert at the end
    public void insert(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Print list
    public void printList() {
        Node current = head;
        System.out.print("[");
        while (current != null) {
            System.out.print(current.data);
            if (current.next != null) {
                System.out.print(", ");
            }
            current = current.next;
        }
        System.out.println("]");
    }

    // Example usage
    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.insert(1);
        list.insert(2);
        list.insert(3);
        list.printList(); // Output: [1, 2, 3]
    }
}
</code></pre>
<h3 id="6-stack"><a class="header" href="#6-stack">6. Stack</a></h3>
<p><strong>Description</strong>: A template for a stack using an array, used in Stack exercises (<code>ch03_04</code>). Follows Last-In-First-Out (LIFO) order.
<strong>Usage Notes</strong>: Adjust capacity for dynamic resizing or use a linked list for flexibility.</p>
<pre><code class="language-java">public class Stack {
    private int[] arr;
    private int top;
    private int capacity;

    // Initialize stack
    public Stack(int size) {
        arr = new int[size];
        capacity = size;
        top = -1;
    }

    // Push element
    public void push(int data) {
        if (top &gt;= capacity - 1) {
            System.out.println("Stack Overflow");
            return;
        }
        arr[++top] = data;
    }

    // Pop element
    public int pop() {
        if (top &lt; 0) {
            System.out.println("Stack Underflow");
            return -1;
        }
        return arr[top--];
    }

    // Example usage
    public static void main(String[] args) {
        Stack stack = new Stack(5);
        stack.push(1);
        stack.push(2);
        System.out.println("Popped: " + stack.pop()); // Output: Popped: 2
    }
}
</code></pre>
<h3 id="7-queue"><a class="header" href="#7-queue">7. Queue</a></h3>
<p><strong>Description</strong>: A template for a queue using an array, used in Queue exercises (<code>ch03_05</code>). Follows First-In-First-Out (FIFO) order.
<strong>Usage Notes</strong>: Modify for circular queues or priority queues. Add bounds checking for robustness.</p>
<pre><code class="language-java">public class Queue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;

    // Initialize queue
    public Queue(int size) {
        arr = new int[size];
        capacity = size;
        front = 0;
        rear = -1;
    }

    // Enqueue element
    public void enqueue(int data) {
        if (rear &gt;= capacity - 1) {
            System.out.println("Queue Full");
            return;
        }
        arr[++rear] = data;
    }

    // Dequeue element
    public int dequeue() {
        if (front &gt; rear) {
            System.out.println("Queue Empty");
            return -1;
        }
        return arr[front++];
    }

    // Example usage
    public static void main(String[] args) {
        Queue queue = new Queue(5);
        queue.enqueue(1);
        queue.enqueue(2);
        System.out.println("Dequeued: " + queue.dequeue()); // Output: Dequeued: 1
    }
}
</code></pre>
<h3 id="8-bubble-sort"><a class="header" href="#8-bubble-sort">8. Bubble Sort</a></h3>
<p><strong>Description</strong>: A template for Bubble Sort, used in Bubble Sort exercises (<code>ch04_01</code>). Repeatedly swaps adjacent elements if out of order.
<strong>Usage Notes</strong>: Optimize with a flag for early termination or adapt for descending order.</p>
<pre><code class="language-java">public class BubbleSort {
    // Bubble Sort for ascending order
    public void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i &lt; n - 1; i++) {
            for (int j = 0; j &lt; n - i - 1; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    // Example usage
    public static void main(String[] args) {
        BubbleSort sorter = new BubbleSort();
        int[] arr = {5, 3, 8, 1, 2};
        sorter.bubbleSort(arr);
        System.out.print("Sorted: [");
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i]);
            if (i &lt; arr.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]"); // Output: Sorted: [1, 2, 3, 5, 8]
    }
}
</code></pre>
<h2 id="-tip-or-warning-box-2"><a class="header" href="#-tip-or-warning-box-2">✅ Tip or Warning Box</a></h2>
<p><strong>✅ Tip</strong>: Use these templates as starting points for DSA exercises. Modify them to fit specific problem requirements, such as adding comparison counters for Binary Search or implementing custom object sorting. Test each template with the provided main method to ensure correctness.</p>
<p><strong>⚠ Warning</strong>: Always verify input constraints (e.g., sorted arrays for Binary Search, array bounds for stacks/queues) before using these templates. Incorrect usage, such as applying Binary Search to an unsorted array, will produce invalid results.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
